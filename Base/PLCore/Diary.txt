>> 08.08.2011
[CO]
- "Frontend": Added virtual "OnRun()"-method. This method is called just before the frontend calls it's run-method in order to enter it's main-loop. Use this method for instance
  to pre-process command line arguments.
- "FrontendPixelLight" is now using the new "OnRun()"-method in order to fill the application context just like "CoreApplication::Run()" does
- "Frontend": Exposed the class to the RTTI
- "Class": Added "Create()"-method creating an object by using a given constructor name and typeless constructor parameters
- Implemented frontend arguments... I'am not really happy with the current solution because it just looks complicated. I tried some other approaches but this one was the best one.
  Maybe I find another, better solution later on - but for now it works and is quite flexible. I'am really happy that I introduced the "pl_module_application" & "pl_module_application_frontend"
  macros because they're hiding the complex frontend run call. Within the samples the frontend call is only done once within "45ScriptApplication" without this "standard use case"-macros.
[SW]
- "PLFrontendOS": added toggle fullscreen support and and setting window icon to linux X11 part
- "PLFrontendQt": added support for setting the application/window icon



>> 07.08.2011
[CO]
- Updated "PLFrontendQt::QPLRenderWindow". Drawing and updating states are now two distinct things for the frontend & application framework, so, "PLFrontendQt::QPLRenderWindow"
  has now only care about drawing.
- Moved the "PLCore::Timing"-update from "FrontendApplication::OnUpdate()" into the frontend implementations. "PLCore::Timing" can limit the update rate to a fixed one like
  60, meaning that the update process doesn't run more than 60 times per second. An application (the slave) shouldn't care about such a topic and the frontend (the master) should
  have control over this one as well. Please note that it is allowed that the logic update and draw update have different intervalls (but again, the application side doesn't care
  about this :).
- "Frontend": Added fullscreen mode support and implemented it for "PLFrontendOS::OSWindowWindows" (implementations for the other frontends will follow)
- "PLFrontendPLGui": Implemented fullscreen mode support
- "PLFrontendQt": Implemented fullscreen mode support
- "FrontendApplication::GetFrontend()" now returns a reference instead of a pointer. An "FrontendApplication"-instance is always running within a frontend, else the system becomes
  artificially complex. Therefore, the result of "GetFrontend()" must always be valid and there's no need for null pointer tests trashing the code.



>> 06.08.2011
[CO]
- Linux: Changed the type of "handle" from "int" to "unsigned long" (shouldn't really be a difference in the used bit length... even on 64 bit "long" is usually only 32 bit long...)
- Added "Core::ScanRuntimeDirectoryPlugins()" because the same stuff was done in "CoreApplication::OnInitPlugins()", "PLCore::Frontend::CreateInstance()", the sample "40ScriptHelloWorld"
  not using the application framework at all, "PLFrontendQt::Application::InitCore()" and so on.
- Added "Core::ScanRuntimeDirectoryData()", more stuff not only useful for "CoreApplication::OnInitData()"
- MS Windows: "PLFrontendOS" is now using the standard PixelLight icon for the main window of this frontend
- MS Windows: If a process has an own icon, "PLFrontendOS" is now using it instead of the standard PixelLight icon
- "PLFrontendQt": Removed unused "Application::ScanFSArchives()"-method
- Added "AbstractFrontend", same purpose as "AbstractLifecycle" => one and the same interface for the same task
- "AbstractFrontend": Added "OnUpdate()"-method. Drawing and updating states are now two distinct things for the frontend & application framework.



>> 05.08.2011
[CO]
- "Frontend": Added versions of the "Run()"-method using traditional C-arguments (char/wchar_t). Some frontends, like the Qt one, want to have the original C-arguments or someone
  may want to run a frontend by providing it with traditional C-arguments.
- "Frontend": Made a clear distinction between "Redraw()" and "Ping()"
- "Frontend": Added "RedrawAndPing()"-method first calling "Redraw()", then "Ping()"... probably an important use case... :D
PLFrontendQt:
- Implemented correct application lifecycle and "Ping()"-method (by the way, just noticed Qt's "QCoreApplication", so, "PLCore::CoreApplication" is probably really a decent name)
- Instead of performing an immediate hard-coded repainting of the frontend within "FrontendMainWindow::timerEvent()", Qt is now asked politly to update (and repaint) the widget.
  This way, the main window stays always responsive - but now I had "white flickering" due to some Qt overdraw. After using same settings as in Qt's QGLWidget, the "white flickering"
  had gone... but now there's "black flickering" from time to time. When debugging, it's clear that Qt still draws something into the window. After over a hour of research
  I wasn't able to figure out what's going on. The concept is ok, drawing only within Qt's "paintEvent()" and a redraw-timer only asks Qt politly to update (and repaint) the widget
  instead of directly draw (which wasn't working that well, messed up Qt's event processing). Time to stop working on this "detail" for now in order to finish the frontend work.
- ... I wasn't able to stop thinking about the "black flickering"-issue... and found a solution:
  -> Set "Qt::WA_OpaquePaintEvent"-attribute
  -> Overwrite "QPaintDevice::paintEngine()"-method and just return a null pointer
  ... the flickering is now gone and the whole main window is responding and behaving quite fine...



>> 04.08.2011
[CO]
- Renamed "ConsoleApplication" into "CoreApplication" so that one can guess the name of this class by just knowing the component name it's in
  (it's also the base/core class of the application framework, so "core" maybe more suitable then "console")
- "AbstractFrontendLifecycle" really solved some nasty design issues when it comes to application lifecyle control. Time that also "CoreApplication"
  is using this interface so that frontends can control the applications in a proper way (e.g. deactivating input control as soon as the application gets
  paused because it e.g. lost the focus). For this, renamed "AbstractFrontendLifecycle" into "AbstractLifecycle".
- Derived "CoreApplication" from "AbstractLifecycle". When possible, I try to avoid using multi-inheritance but in this case I see no other decent option -
  sadly C++ has no Java like "implements". :/
  -> Renamed "CoreApplication::Init()" into "CoreApplication::OnStart()", the "AbstractLifecycle" equivalent called as soon as something is started (not same as instanced)
  -> Renamed "CoreApplication::DeInit()" into "CoreApplication::OnStop()", the "AbstractLifecycle" equivalent called as soon as something is stopped (not same as destroyed)
- "FrontendPixelLight" is now calling all "AbstractLifecycle"-methods of it's petted application
- "Frontend": Added "Ping()"-method to give the frontend a chance to process OS messages. There are situations (like current load screen implementations) were an application
  may do some heavy work without letting the frontend a chance to process OS messages. In such situations, it may be wise to call this method from time to time to give the
  frontend a chance to do some message processing. Whenever possible, don't use this method, do heavy work within e.g. threads.
PLFrontendPLGui:
- Moved "ModTrapMouse", "PreviewWidget", "RenderWidget", "RenderWindow" and "WindowConnection" from "PLEngine" into "PLFrontendPLGui"
- Implemented correct application lifecycle and "Ping()"-method
PLFrontendOS:
- The application lifecycle is now handled within the OS dependent implementation (e.g. "OSWindowWindows") instead of within "Frontend"... I hope this way the order is
  always correct... hopefully... eventually... *g*
- When moving/sizing the window, the application will also be paused during this period (WM_EXITSIZEMOVE/WM_ENTERSIZEMOVE MS Windows events)... it's just annyoing when you move
  or size a window and the controlled scene camera is spinning around while you do so...



>> 03.08.2011
[CO]
PLFrontend:
- "PLFrontendNull", "PLFrontendOS", "PLFrontendPLGui", "PLFrontendQt" and "PLFrontendActiveX" (testing it within the MS Internet Explorer) are now up and running
  ("PLFrontendMozilla" is still broken)
- Added "PLFrontend::Frontend::Run()" to start an application inside a frontend. This is only required for executables and not if an application is running e.g. within
  a browser. When using it, it looks like this:
    int PLMain(const PLCore::String &sFilename, const PLCore::Array<PLCore::String> &lstArguments)
    {
        return PLFrontend::Frontend::Run("PLFrontendOS::Frontend", "Application", sFilename, lstArguments);
    }
- When the work on the frontend stuff is complete, PixelLight applications are usually "frontendless", meaning when compiling it as an executable, you as application developer
  choose the frontend to use (or not if you just don't care about GUI). Additionally, in the future it should be possible to just recompile the application as shared library in
  order to be able to embed it within other applications like a browser. To make this as easy as possible, I added the macro "pl_module_application_frontend" (yeah, too long
  name, again... but it's only required once within a project and therefore a speaking name is fine) and when using it, the main C++ file usually looks like this:
    #include <PLFrontend/FrontendMain.h>
    pl_module_application_frontend("50RendererTriangle", "Application", "PLFrontendPLGui::Frontend")
        pl_module_vendor("Copyright (C) 2002-2011 by The PixelLight Team")
        pl_module_license("GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version")
        pl_module_description("PixelLight triangle sample")
    pl_module_end
  ... should be quite handy to use ("pl_module" is usually already used, so not much additional work, it's even less work!). :D
  There's also a shorter macro:
    "pl_module_application("50RendererTriangle", "Application")
  Which will use the frontend "PLFrontendOS::Frontend" as default. This totally primitive frontend is sufficient for many applications.
PLFrontend<>PLCore
- Merged PLFrontend into PLCore... another new project which didn't make it long on it's own. :D
  Just like PLScript, PLFrontend was started as a separate project to see whether or not the idea/concept is working and then to see how it's integrating into the system as a whole.
  The PLFrontend concept turned out to be the key in making PixelLight really easy runnable within other applications like browsers. As such, it feels just right to put it directly
  into PLCore - it doesn't introduce new dependencies and is also not really a huge component.



>> 02.08.2011
[CO]
PLFrontend:
- Added "FrontendApplication" & "AbstractFrontendLifecycle" and started on the frontend design
PLFrontendPLGui:
- Moved "SNGui" from "PLEngine" to "PLFrontendPLGui" because it's using PLGui



>> 01.08.2011
PLFrontend:
[CO]
- Started the PLFrontend project (kind of "PLPlugin"-project successor)... now that scripting is working, it's finally time to attack another big design task.
  When we started the development of the PixelLight engine on 16 September 2002, we just had one single project: "PLEngine"
  This project just used a quite simple OS window to render stuff into it. Back then, the world was more simple regarding to required supported platforms.
  Providing support to be able to render into multiple OS windows was really a cool feature because most engines were just able to render into a single
  OS window. Over the years, the GUI stuff was moved into an own, platform independent, GUI library called PLGui. All other PixelLight projects were build
  on the top of it. PLGui is currently already within it's third (!) reincarnation.
  In the last past 9 years, the world has dramatically evolved regarding to the platforms one should really support and the current PixelLight design regarding
  to GUI handling does no longer really completely satisfies the changed needs. Now those are the requirements to be fulfilled:
  -> Be able to have absolutely no GUI at all, e.g. for server side applications or applications rendering just into a buffer *currently there's always a PLGui dependency*
  -> A quite primitive OS window for applications requiring no GUI handling, except for the OS window it's running in *PLGui is an overkill for this use case*
  -> "PLGui": PixelLight own GUI system (OS & ingame) perfectly integrated into the complete system, stuff like scripting doesn't need wrappers, it just works out of the box *currently used way*
  -> Be able to just use third party GUI systems like Qt for front-ends *currently there's always a PLGui dependency*
    -> The PixelLight editor will be Qt based because getting PLGui to the point were it's possible to write such an complex editor is just impossible with a team of two
       active spare-time developers (we already tried it years ago *PixelLab* and it was a total failure :/)
  -> Be able to embed an PixelLight application into another application, meaning another GUI system has the control and we're just a slave
    -> Be able to run in a web browser (e.g. by using "Java Web Start"/"JNLP" or/and by writing special browser plugins)
    -> Be able to run on mobile devices, e.g. Android based
    -> Be able to use ActiveX under MS Windows to embed 3D stuff into e.g. a MFC dialog (we already had to do this for a project some years ago)
    ... scripting is especially useful for the first two mentioned embed-points. This way, an application developer doesn't need to care about the target platform and is just
        writing some scripts...
  Ok, as you can see, a whole bunch of new requirements since the start of the PixelLight engine. In "Docs\Diagrams\PixelLight_PackageDiagram.png" I outlined how it will probably
  look when PLFrontend is up and running.
  Please note that the PLFrontend approach doesn't mean that I abandon the PLGui project, but having the whole system be dependent of a GUI system is not working any more with
  the changed requirements. Also, while the third reincarnation of Stefans PLGui is really cool and can be used for OS and ingame and has, by using the PL RTTI, automatic support
  for scripting and therefore integrates itself perfectly into the whole system... PLGui is still missing some features and fine-tuning. Sadly, such a GUI system is a huge task
  and currently, as already mentioned, there are only two active spare-time developers. Personally, I finally want to get PixelLight to the point were it's possible to create
  simple prototype applications in a matter of minutes by using e.g. a Lua script to load in a scene and adding some interaction - and then be able to run this on multiple
  platforms/targets. So, my focus is on that instead of taking over the development of Stefans PLGui (I already ruined the previous second reincarnation and don't want to repeat
  this experience). I really hope that in the future there's someone continuing the development of PLGui because especially the scripting-argument is a really cool argument for PLGui!
  (connecting e.g. libRocket or Qt to the PL RTTI and scripting system will be probably lot of work while it's no work at all with PLGui!)
  ... enough introduction and explanation why there's need for the PLFrontend project. Let's go to work...
- Added the (currently empty) frontend plugins
  - "PLFrontendNull": The usual dummy project doing nothing at all
  - "PLFrontendOS": Just a totally primitve OS window
  - "PLFrontendPLGui": PLGui connection
  - "PLFrontendQt": Qt connection (the new "PLQt")
  - "PLFrontendActiveX": ActiveX connection (the new "PLPluginActiveX")
  - "PLFrontendMozilla": Mozilla connection  (the new "PLPluginMozilla")
  ... while "PLFrontendNull", "PLFrontendOS", "PLFrontendActiveX" and "PLFrontendMozilla" are intended to be 100% loose dynamic plugins, "PLFrontendPLGui" and "PLFrontendQt" are
  of course also such plugins, but one is usually going to also use those libraries directly within an application (meaning linking aginst them).
- Copied the diaries of "PLPlugin", "PLPluginActiveX" and "PLPluginMozilla" into this diary because PLFrontend will be the successor of the "PLPlugin"-project... which is not limited
  to "PixelLight application as a plugin for e.g. a browser" but will also cover the "PixelLight application as executable" use case. Meaning, in the future it will be possible to just
  recompile a C++ PixelLight as shared library and then be able to use it in any available frontend.
- Using "PLPlugin::Plugin" as start point for the class "Frontend"
- Renamed "PLPluginActiveX" (still working, just tested it :) into "PLFrontendActiveX"
- Renamed "PLQt" into "PLFrontendQt"
- Renamed "PLPluginMozilla" into "PLFrontendMozilla", when testing it with Firefox 5.0 the browser didn't want to load it (sayed something about corrupt... before I did the changes...)...
  I'll check it later when PLFrontend is working as a whole...
- Removed "PLPlugin", it's been replaced by "PLFrontend"



>> 02.07.2011
[CO]
PLQt:
- Added empty project "PLQt". In the next steps, PLQt (https://sourceforge.net/projects/pixellight/) from Stephan Wezel will be integrated directly into the PixelLight
  Git repository and SDK because e.g. the editor will be Qt based. I currently use Qt 4.7.0 and I know that there's already a newer version available... but I already
  had Qt 4.7.0 compiled for VisualStudio 2010 (to avoid using VC 2008 within the PL SDK) a while ago and right now I don't want to spend time in recompiling Qt, again.
- Moved "QtStringAdapter" from PLGeneral into PLQt
- Integrated PLQt, I'am sure it's not yet final and that over time, there will be multiple simplifications



>> 31.07.2011
[CO]
- Exposed "ConsoleApplication::Exit()" to the RTTI



>> 30.07.2011
[CO]
- "PLScriptLua::RTTIObjectSignalMethodPointer::EventCallback": "TypeRef" was missing



>> 27.07.2011
[CO]
- Using PLCore to check whether or not "override" from C++0x (see e.g. http://www2.research.att.com/~bs/C++0xFAQ.html#override) will cause any problems
  -> By using "override", the compiler found the following: "Constructor" implemented the virtual method "GetDesc()" and a comment stated that it's a
     "DynFunc"-method. Ok, the name is a "DynFunc"-method, but the signature is "const FuncDesc *DynFunc::GetDesc() const" while the other signature is
     "const ConstructorDesc *Constructor::GetDesc()". "ConstructorDesc" is not derived from "DynFunc". To be fair, to the compiler would also have found it without "override"
     if "Constructor::GetDesc()" would have been declared as constant as well, but it wasn't. So, "override" really did the trick and exactly such errors are the reason
     why I'am so interested in this language feature in the first place. I'am sure that there are some more of such errors in the hundred thousends lines of code... :D
     If I'am not totally wrong and missed something, "Constructor::GetDesc()" is a dead method. Removed it.
  -> In the dungeon demo, I found at once an error using this new language feature: The "Application::LoadScene" signature had changed, but the dungeon demo wasn't updated...
     I'am starting to really like "override" :D
- PixelLight was already using "extern templates" which are part of C++0x (http://www2.research.att.com/~bs/C++0xFAQ.html#extern-templates)... added comments to avoid confusion...



>> 26.07.2011
[CO]
- "LoadableType::AddLoader()" fixed log messages ("[Info]: Loader 'PLAssimp::SceneLoader3DGameStudio': Format 'mdl' is already used by loader 'PLAssimp::SceneLoader3DGameStudio")
- "Loadable::Load()"/"Loadable::Save()": Moved the "IsDerivedFrom()" security check into "LoadableManager::RegisterClasses()"
- Renamed "LoadableType::GetLoader(uint32 nIndex)" into "LoadableType::GetLoaderByIndex(uint32 nIndex)"
- Renamed "LoadableType::GetLoader(const String &sExtension)" into "LoadableType::GetLoaderByExtension(const String &sExtension)"
- Renamed "LoadableManager::GetLoader(uint32 nIndex)" into "LoadableManager::GetLoaderByIndex(uint32 nIndex)"
- Renamed "LoadableManager::GetLoader(const String &sExtension)" into "LoadableManager::GetLoaderByExtension(const String &sExtension)"
- Renamed "LoadableManager::GetType(uint32 nIndex)" into "LoadableManager::GetTypeByIndex(uint32 nIndex)"
- Renamed "LoadableManager::GetType(const String &sName)" into "LoadableManager::GetTypeByName(const String &sName)"
- Added "LoadableType::GetLoaderForLoadingByFile()" which currently is using, as before, just the filename extension to find the proper loader
- "LoadableType::GetLoaderForLoadingByFile()": If there's no loader for the given file extension, the complete file extension is checked as well (file format extensions like
  "mesh.xml" can now be used as well)
- Added "System::GetSeparator()" returning the directory separator used by the operation system (e.g. '/' on Linux, '\' on Windows)... interesting that such a method was still
  missing...
- Added "File::CFileModeToAccessFlags" translating a given C file mode ("r", "r+", "w", "w+", "a", "a+", "t", "r+t" etc. used for e.g. "fopen") into access flags



>> 25.07.2011
[CO]
- "Url": "GetTitle()" and "GetExtension()": For a filename like "archive.tar.gz" the method "GetTitle()" returns "archive.tar" and "GetExtension()" returns "gz". While this is
  ok/standard for some use cases, there are also situations were "archive" as title and "tar.gz" as extension is desired/standard. I checked other libraries/frameworks like Qt
  in order to see how they deal with this topic. In Qt, they offer the following methods:
    "QFileInfo::baseName()"="archive"
    "QFileInfo::completeBaseName()"=archive.tar"
    "QFileInfo::suffix()"="gz"
    "QFileInfo::completeSuffix()"="tar.gz"
  This naming convention sounds reasonable and at least "suffix()" is handled the same way as PL's "GetExtension()".
  -> Added some more comments to avoid confusion (or at least reduce it) when dealing with filenames like "archive.tar.gz"
  -> Renamed "GetTitle()" into "GetCompleteTitle()" returning "archive.tar"
  -> Added "GetTitle()" returning "archive"
  -> Added "GetCompleteExtension()" returning "tar.gz" and also added "CutCompleteExtension()"



>> 21.07.2011
[CO]
- PLGeneral->PLCore - done



>> 19.07.2011
[CO]
- Merged PLGeneral (started before 25.11.2003) into PLCore (started: 05.02.2008) because both are completely fundamental and it's not that clear which project was for which
  components. When looking e.g. at the PixelLight component diagram one can see that every other project is already using PLCore and not even the most primitive sample within
  the SDK is using just PLGeneral. This may be a sign that this is in fact one component which was just splitted into two projects. A year ago or so, there were already
  discussions whether or not e.g. the log should be part of PLGeneral and PLCore. In the end, the log was moved into PLGeneral although the log formater classes are in fact
  loose dynamic plugins, but were now not able to be implemented in this way because the RTTI was introduced within PLCore. Of course, that's nothing dramatic, but on the other
  hand it would be cool to e.g. write a special log formater within a loose plugin and then select it within a configuration file. While modulation is a really useful thing,
  PixelLight now consists of 13 of primary modules and loose plugins and when looking at user feedback it looks like that some people have some issues with this. I'am not going to
  merge everything into a single "PixelLight"-project as seen in several engines out there. There was a reason for this individual modules: To make everything as flexible as
  possible which is especially nowadays really important due to the mass of available target platforms. But it seems to be reasonable to simplify PixelLight were ever possible
  to avoid comments like "PixelLight is a monster" in the future. This was one reason why I moved weeks ago the 100% dynamic plugin projects into the "Plugins"-directory so everyone
  can see at once that those are optional and nothing build in. The core of PixelLight is in fact slim and most features are just plugged-in! (which may be one of the reasons why
  there are people thinking that PixelLight is really complicated because they seem to be used to have everything thrown statically together in one huge blob)
  -> The PixelLight base now consists of 12 modules as well as 38 optional modules aka plugins aka extensions aka addons, this should still be more then enough modularisation.
  -> Due to the current examines at university, I'am pretty sure that I will need several days to update the rest of PixelLight...



>> 10.07.2011
[CO]
- Moved PLIRC and PLJabber from the PLNetwork directory into the PLPlugins directory because it's nothing the PixelLight core is
  using and in fact, until now it isn't used at all. So, this is definitively a plugin/extension/addon.
- Removed PLNetwork project. It has now been empty since "23.10.2009" and there are no signs that this will change in the near feature.
  The basic stuff like sockets were already within the PLGeneral project and even some more hight level constructs like server-client
  classes. Since the public release of PixelLight, there were several user questions asking why PLNetwork is empty, and why there's an empty
  project at all. So, to avoid this confused (but understandable) question in the future, PLNetwork is now gone. If there's really
  need for an individual network component in the future, the project can be added in no time.
-> Moved the entries of the PLNetwork diary into the PLGeneral diary



>> 03.07.2011
[CO]
PLCore:
- Within "Rtti.h", "__NT__" ("#define __NT__	PLCore::NullType") was defined... which usually stands for "Windows NT" in system headers. Until now, there were
  no problems with that, but today this changed when using Qt to compile something under Linux.
  Within the Qt header file "qglobal.h" there's the following line
    "#elif !defined(SAG_COM) && (defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__))"
  ... and now, when including a PixelLight header using the RTTI before a Qt header is included, Windows headers are included inside Qt. I thought about renaming
  "#define __NT__	PLCore::NullType" into "_PLNT_" or so, but on the other hand, maybe there's an OS header using "_PLNT_" or another definition as well? To avoid
  any further troubles in here, I just removed this definition.



>> 02.07.2011
[CO]
- Moved "QtStringAdapter" from PLGeneral into PLQt



>> 27.06.2011
[CO]
PLCore:
- "PLScriptLua::RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()": Added some quotation mark checks. If the string content is "Name="Bob"" the resulting parameter
  string will be "Param0="Name="Bob""" and the parser will have troubles with it and will take "Name=" instead of "Name="Bob"" for the value of "Param0". After this change,
  the resulting parameter string is now "Param0='Name="Bob"'".



>> 21.06.2011
[CO]
PLCore:
- When testing the Dungeon demo under Linux, I noticed that the "Object" RTTI methods (but only those?) were not exported correctly when using GCC. Found the "bug" within my
  change from "04.06.2011" when I removed the per instance cost of RTTI methods... the RTTI method instantiation was wrong. I still think that this is the right way because
  tons of those methods will come in the future!
  After a look into how Stefan did it with the RTTI constructors I was able to fix the issue, more or less. It looks like now, that more stuff is connected to the RTTI the
  template instantiation issue strikes back (we already had it multiple times under Linux). Interesting that everything runs that smoothly under MS Windows.
  Maybe it's better to do as many RTTI related definitions as possible in the cpp files instead of the header files? As far as I can see, for constructor and method definitions
  this wouldn't be problem - except that the RTTI stuff would be more scattered over two files (although there's already "pl_implement_class" in the cpp files...).   
  This would probably also make the life of the compiler a little bit easier... the more complex derived classes from derived classes get, the more work for the compiler
  (the slow down is really notable when compiling). Right now, I don't want to work too much on the RTTI - I already did way more changes as I wanted. It's not
  really my field and I'll have other stuff on my TODO-list (but I really had to do something about the most important issues to be able to go on with other parts in a decent way).
  So a kind of patchwork has do to the job for now: In important RTTI classes, I'll added a define around the constructor and method definitions so that they are only considered
  when compiling the project they are in. This solved my current template instantiation issue under Linux - for now.
  Ps. By the way, I just noticed that the Windows version of the Dungeon executable is after this change only 230 KiB instead of 395 KiB... I assume that this massive template
  instantiation within the header files really has a notable impact on everything. :/



>> 18.06.2011
[CO]
PLCore:
- Added "DynSignature"-interface and derived "DynEvent", "DynEventHandler", "DynFunc" and "DynParams" from this new interface. Previously, those interfaces had
  only a "GetSignature()"-method in order to request the signature description as string. With the introduction of script support there was a need to get concrete
  type ID information of return and parameters for proper exchange of data between script and C++. Of course, it would have been possible to just parse the already
  available signature-string, but this would have been a little bit uncomfortable.
- PLScriptLua: Added new static method "RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()" which returns the current Lua function parameters on the Lua
  stack as string. This was my motivation for the "DynSignature"-interface because this new method is used by "RTTIObjectMethodPointer" and "RTTIObjectSignalPointer"
  and type ID information is used internally.
- PLScriptLua: Solved another reference issue. Well, not directly an issue with references in general, more an issue about their usage in scripts with strings.
  Strings are somewhat of a special case, at least within their usage. It's possible that there's a RTTI method with a "Object*(const PLGeneral::String&)"-signature
  meaning that the parameter is a reference. Within scripts, strings are fundamental and therefore it should be possible to use such a RTTI method by writing for instance
    this:GetSceneNode():GetByName("Soldier")
  so that the script programmer doesn't need to care whether or not the required RTTI method parameter is in fact a reference instead of a string. Of course, a real
  reference a parameter should still also be possible as well. To solve this issue, whenever the script programmer provides a string, but a RTTI method is expecting
  a reference or a pointer, this given string is stored within a string-list on the heap during the function call. By doing so, the reference/pointer has a valid address.
  -> Some weeks ago, I was afraid that we can't keep the "const PLGeneral::String&"-concept and had to change it into "PLGeneral::String" in order to use such methods
     within scripts. But the solution within PLScriptLua solves this issue and the PixelLight interfaces don't need to be rewritten. The solution also introduces no
	 extreme runtime overhead because the string class is quite optimized internally and is using e.g. the "copy-on-write"-concept. So, those temporary strings on the
	 runtime stack don't really hurt much.
- "PLScriptLua::RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()": If a RTTI signature demands more parameters as the script programmer provided, we need to add
  the missing parameters because if there's a reference parameter it really needs a valid address
- "Script": Added namespace support for global variables. By using namespaces, one can e.g. define that all script variables an editor is able to show have to be
  within a "public"-Namespace (just an example, there's no such thing fixed build in within PLCore!). In this editor-example, the user is then able to get and set script
  variables just like RTTI attributes, but the other script variables which are e.g. within the global namespace are hidden.
  Currently, this namespace support is only implemented within PLScriptLua... the next scheduled PixelLight release is near and so I really have to work focused.
- "Script": Due to namespace support for global variables, I had to change the "GetGlobalVariables()"-signature. This method no longer returns a list of found global variables,
  instead a list to be filled up has to be provided as parameter.
- "Script": Added support for global script functions which are inside a namespace. Currently, this namespace support is only implemented within PLScriptLua.
- "pl_class_internal"-macro: Added "__pl_rtti_export(PLCORE_RTTI_EXPORT)" within the RTTI macro to make it possible to expose "Object"-methods to the RTTI
- "Object": Renamed "IsInstanceOf(const Class &cClass)" into "IsInstanceOfByReference(const Class &cClass)" to make it possible to expose the
  "IsInstanceOf(const PLGeneral::String &sClass)" method to the RTTI (this version of the method is the more often used one)
- "Object": Exposed several methods to the RTTI... this makes it for instance possible to construct the names of methods/attributes etc. to be called from inside a script
   dynamically inside the script...



>> 17.06.2011
[CO]
PLCore:
- "Script": Added support for "Object&"
- "DynEvent": "Connect()" and "Disconnect()" required a pointer as parameter, but there was no documentation whether or not a null pointer was allowed.
  When providing a null pointer, the implementation crashed because there was no test for a null pointer. Before I start adding pointless pointer
  checks, I just change the methods so their using references as parameters as done in other PixelLight parts. By the way, connecting event handlers
  looks now also the same as when doing the same in Lua scripts. *g*



>> 16.06.2011
[CO]
PLCore:
- There was an issue when using a reference type as RTTI method result... this was the reason why I hadn't yet exposed methods like
    SceneNode &GetSceneNode() const;
  to the RTTI. It took me several hours to wrap my head around the type traits Stefan wrote (no critics, the system is really genial... but the topic is just not really
  my expertice, I'am more the graphics programmer type :) and several more hours for attempts and experiments to get reference types as return values up and running.
  When I finally had an working solution, I reduced my number of code changes to the bare minimum in order to reduce the risk to introduce new bugs or to mess everything
  up. I really had to do a change in order to be able to continue exposing methods to the RTTI... the alternative to just forbid the usage of pointers wasn't a real
  solution for me.
  The problem was the following: The internal system stores within the parameters class the parameters, and also copies them around like
    cP.Return = (*this)(cP.Param0);
  as long as the type is no reference, everything is just fine. But as soon as there was a reference type hell broke loose because a when copying one reference into another,
  not the address of the referenced object is copied but instead the value. Within the system, this reference behaviour results in another behaviour as the desired one. My
  solution is the introduction of a "storage" type within the type definitions. Usually, meaning for 99% of all types, the storage type is identical to the real type. For
  reference types, the real type is a reference (as before) - but the storage type is a pointer. This way it's possible to internally copy around the parameter in the correct
  way. There are also the two new type methods "ConvertRealToStorage()" and "ConvertStorageToReal()" which are used to convert the types when necessary. I hope the compiler
  is clever enough to notice when this results in copying one variable into itself without any further change - in this case, this change would introduce no new additional work
  to be done. The example code from above now looks like this
    cP.Return = Type<R>::ConvertRealToStorage((*this)(Type<T0>::ConvertStorageToReal(cP.Param0)));
  and from the outside, as long as not accessing "Return", "Param0" etc. directly, the user will not notice that his reference is internally handled as pointer. With this change,
  it's now possible to expose methods with a reference type as result to the RTTI - meaning to also enable it's usage within scripts.
  ... the last days were really exhausting because due to university, I had to get into the topic and solve the issue at night and during lectures. But I really wanted to have this
  issue solved within the upcoming PixelLight 0.9.7 release because it's quite fundamental for scripting. Now that it's up and running, I think it was worth the effort. :D
- PLScriptLua: Added "TypeRef" support for method results
- ... now that I have GCC 4.6.1 installed, removed the following hack within Event.h
    // [HACK] This is currently necessary to avoid the following strange compiler error:
    //		    undefined reference to `vtable for PLCore::Functor<void, PLCore::Module const*, ...>
    #ifdef GCC
        static Functor<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> DummyFunctor;
    #endif
  in order to check whether or not this is still the case... made a fresh build without the hack and there were no more problems. :)
  So, I let the hack out... there's no point in supporting buggy old compilers. For example in GCC 4.5.2 the nullptr emulation was no longer working due to a GCC bug. So, if you
  encounter any compiler issues, just use an up-to-date compiler (if there's one :) instead of spending time to hack around compiler bugs.
- "Func.h": Removed debug-output in case of a signature mismatch. The "new" RTTI 2 is now working since over a year within PixelLight and does really a fantastic job. I assume it's
  about time to remove this scaffold (which, over the time caused some debug/release include issues).
- Minor "SignatureString::GetSignatureID()" implementation change to make the life of the string class a little bit more comfortable. I know, this doesn't really have a directly
  measurable impact... but when I see something that can be optimized without messing everything up (especially when it's within the core), I do it because in the end, all sums up...
- Removed
    typedef Func<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> _Func;
  etc. in e.g.
    FuncFunPtr<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> : public Func<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> {
  because it really looks like dead code (wasn't able to find any usage of it).



>> 14.06.2011
[CO]
PLCore:
- "ConsoleApplication": The "Init()"-method documentation stated that it's calling "OnInit()", and the "DeInit()"-method documentation stated that it's calling
  "OnDeInit()"... but those two methods are actually called by the "ConsoleApplication::Run()"-method. I had a look into this diary to see the intended behaviour
  and found the description within the "06.08.2010"-entry from Stefan Buschmann (I'am really glad that we're writing diaries :). The implementation is correct,
  but the documentation wasn't. Fixed that.
- "Script:" Added "IsGlobalFunction()" so one can check whether or not there's a certain global script function before calling it. Background: When calling a global
  script function, the script backend usually writes an error into the log when the given global script function wasn't found. I still think that this behaviour is
  useful. When using optional global script functions, it's a good idea to check whether there's such a global script function by using "IsGlobalFunction()".
- PLScriptBindings: Changed the default value of "UpdateFunction", containing the name of the script function to be called, from "Update" into "OnUpdate"
 (same name as in "PLEngine::ScriptApplication")
- "PLEngine::ScriptApplication" and "PLScriptBindings::SNMScript" have now both the script entry points "OnInit()", "OnUpdate()" and "OnDeInit()".
  The name of the optional script function called by C++ by one of these entry points is an RTTI atribute, meaning that e.g. a scipt can manipulate
  it's own entry points! Wow, the script-stuff is getting pretty flexible. *g*



>> 12.06.2011
[CO]
PLCore:
- Merged PLScript into PLCore. When starting PLScript on "25.04.2011" I had no real idea were the script voyage would end. Back then, I decided to
  create an own project for script support - this has proven to be useful when starting a new component. Now that the Lua backend of PLScript has
  nearly all features I wanted I start to play around with it a little more... and it's a little bit annoying to add PLScript to the VC project solutions.
  Right now, PLScript consists just of a handful of classes and it doesn't look as if a lot more script classes will come. The "magic" happens in the RTTI
  system and within the general PLCore infrastructure. Scripts exist to make the world a little bit less complex, so, it's probably a good idea to make using
  scripts within the PixelLight C++ API less complex as well by directly adding the scripting-feature into PLCore. The PLScript documentation will still be an
  own document because the PLCore documentation is already comprehensive and contains more advanced stuff which will probably shock many people which are just
  looking for e.g. "How to use Lua within PixelLight". *g*



>> 11.06.2011
[CO]
PLCore:
- PLScriptLua: A Lua script can now connect a RTTI signal with a Lua function



>> 10.06.2011
[CO]
PLCore:
- "DynParams": Added "GetReturnTypeID()", "GetNumOfParameters()" and "GetParameterTypeID()" in order to make it possible to get some more
  information about parameters if one has just access to the "DynParams" interface
- Added "FuncGenFunPtr" and "FuncGenMemPtr" using functions/methods with the signature "Signature<void, DynParams&, void*>". There are situations were it's not
  possible to, e.g. create a typed event handler because the types are unknown to compile time. Those two new functor implementations are using a generic
  function/method and pass the parameters by using "DynParams".
- "DynParams": Added "GetPointerToReturnValue()" and "GetPointerToParameterValue()" to make it possible to set a return value or to get a parameter if one has
  just access to the "DynParams" interface. It's of course no good idea to use generic void* pointers to access the data and whenever possible typed access should
  be used instead... but there are situations were it's really required to be generic because the types are not known to compile time.
  Here's an example of a generic function:
    void GenericFunction(DynParams &cDynParams, void *pUserData)
    {
        // Get the value of the first parameter
        String sMessage = (cDynParams.GetParameterTypeID(0) == TypeString) ? *((String*)cDynParams.GetPointerToParameterValue(0)) : "";

        // Set return value
        if (cDynParams.GetReturnTypeID() == TypeInt32)
            *((int*)cDynParams.GetPointerToReturnValue()) = 42;
    }
  This function can then be used in the following way:
    FuncGenFunPtr<int, String> cFunctor(&GenericFunction);
    int nResult = cFunctor("He ho!");
  As you can see, using a generic function is just like using any other functor, except that the target function has a generic signature. The user
  data pointer enables the user to pass on additional data... this is a quite common approach (although it also has to be used with precaution).
- "DynEvent": Added "CreateGenericEventHandler()" which creates a generic event handler which is compatible with the dynamic event. Sadly this is only
  possible for global functions and not for class methods because we don't have any class type information available. But for my use-case it will do the job.
  Here's an example of a generic function:
    void GenericFunction(DynParams &cDynParams, void *pUserData)
    {
        // Get the value of the first parameter
        String sMessage = (cDynParams.GetParameterTypeID(0) == TypeString) ? *((String*)cDynParams.GetPointerToParameterValue(0)) : "";
    }
  And here's an example of how the new "DynEvent::CreateGenericEventHandler()"-method can be used:
    Event<String> cMyEvent;
    DynEventHandler *pDynEventHandler = cMyEvent.CreateGenericEventHandler(&GenericFunction);
    if (pDynEventHandler) {
        cMyEvent.Connect(pDynEventHandler);
        cMyEvent("He ho!");
        delete pDynEventHandler;
    }
  ... this means that if one has just access to the "DynEvent" interface, it's now possible to create an event handler which is informed when the event
  is emitted.
- PLScriptLua: RTTI signals now have some build in methods. When writing e.g.
    object.MySignal.Connect(object.OnMyEvent)
  the RTTI slot "OnMyEvent" of our RTTI class instance "object" is connected with the RTTI signal "MySignal" of our RTTI class instance "object".
  To disconnect, just use "Disconnect" instead of "Connect".



>> 09.06.2011
[CO]
PLCore:
- Until now, the constructor of RTTI signals was demanding a pointer back to their owner object. When looking at the "pl_slot_<x>"-macros, one could
  see that this provided constructor parameter was not used and I have no glue why it's there - because signals are internally just events (as also stated
  within the documentation). If there's need to know where an event came from, this information has to be provided in the event definition. Events should be as
  lightweight as possible, so storing e.g. an additional pointer within the event instance would probably not be the best idea. 
- PLScript: Lua is now an recommended external dependency and will be the script backend which is within the official PixelLight SDK. The answer for "Why Lua
  and not Python, JavaScript or AngelScript?!" is quite simple: Right now, the Lua backend is the most advanced one because Lua and it's C-API is mostly
  intuitively to use and there are tons of useful information all over the net how to integrate Lua into a "game engine". Lua is also the most compact
  of all of those mentioned script languages - the Windows dll is only 124 KiB while v8 (used for JavaScript) is 2,354 KiB! The syntax of Lua is also
  good to read and something like OOP can be done without totally unreadable tricks as required for JavaScript (did some OOP experiments within "44ScriptOOP").
- PLScript: Added "ScriptManager::GetScriptLanguageExtension()" which returns the filename extension of a given script language
- PLScriptNull: The null backend has no load and runnable scripts -> removed the "null" and "NULL" formats



>> 06.06.2011
[CO]
PLCore:
- PLScriptLua: Something like "sceneNode:SetActive(true)" is now handled correctly, meaning the boolean value "true"



>> 05.06.2011
[CO]
- *breaking change* "ElementManager": Renamed "Get(uint32 nIndex)" into "GetByIndex(uint32 nIndex)" and "Get(const String &sName)" into
  "GetByName(const String &sName)". There were already situations were the compiler wasn't able to distinguish between these two methods
  and upcoming changes/features would cause even more problems.
PLCore:
- Exposed "ConsoleApplication" to the RTTI
- Until now, C++ methods exposed to the RTTI had to be non-constant. Due to the script support, RTTI methods will now be heavily used and it's not that
  comfortable to be forced to change a method signature just to be able to expose it to the RTTI. So, within the "__pl_method_meth"-macro I cast away the
  const within the method pointer using a good old C-style cast to be as flexible as possible in here. I don't think that this introduces any security risks
  because the RTTI method just points to the real C++ method, and in there the const is still there and the compiler will blame you as usual if a non mutable
  member attribute is changed within a constant method.
- *breaking change* "ResourceManager": Renamed "Get(uint32 nIndex)" into "GetByIndex(uint32 nIndex)" and "Get(const String &sName)" into
  "GetByName(const String &sName)" (same change as in "PLGeneral::ElementManager")
- PLScriptBindings: Added "ScriptBinding_PL"
- PLScript: Removed experimental "ScriptBindingScene" because it's no longer needed. Write e.g.
      PL.GetApplication():GetScene():GetByName("Soldier")
  within a Lua script to get the scene node "Soldier". Something like
    PL.GetApplication():GetScene():GetByName("MySubscene"):GetByName("Soldier")
  will work of course as well... WOW! Stefans RTTI is *really* powerful and most script bindings will come practically
  for free... I just added
      pl_method_1(GetByName, SceneNode*, PLGeneral::String, "Returns a scene node by using the given name, can be a null pointer", "")
  within the RTTI class interface of "PLScene::SceneContainer" in order to be able to access the C++ method from inside a script.
  To avoid issues when exposing C++ methods to the RTTI I'am afraid we need to change something like
     void SetFilename(const PLGeneral::String &sValue)
  into
     void SetFilename(PLGeneral::String sValue)
  because "const PLGeneral::String &" is of course a reference, and the RTTI is using it this way (which is correct!). This is becoming a problem
  when there's no real "PLGeneral::String" instance on the method calling side... which is true for scripting. Before I start to hack around, I probably
  just change it as seen above... there's no real need for passing in a string reference anyway because the string class internally just shares
  a string buffer and therefore "copying" one string into another is blazing fast.
  -> I'am sure the "PL.GetApplication()" way is the right one for PixelLight. It results in only a few global functions (they introduce script
     initialization costs!) and the rest is completely dynamic by just using RTTI class instances (they introduce no script initialization costs!).
	 Exposing new features to script languages only requires a single, simple line of C++ code, and this line is even not just there for scripting,
	 it's generic. So, there's no need for thousands of "script proxies"/"script wrappers" in order to expose C++ stuff to scripting languages as seen
	 in many other engines with script support.
  -> In the next few days I should really spend more time on university stuff, but then I probably will start exposing the most important C++ methods
     to the RTTI (exposing this stuff doesn't blow up the memory footprint of RTTI class instances). 
	 When I'am done with it, the Lua support should already be quite usable... as for the Python, JavaScript and AngelScript support ... well,
	 I first have to figure out how to access RTTI objects in a decent way using those script APIs. The strongly typed AngelScript already produced some
	 headaches. For now, it's important to me that at least one scripting language is usable, so I focus on this point.
- PLScript: Removed experimental "ScriptBindingSceneRendererTool" because it's no longer needed. Write e.g.
      PL.GetApplication():GetSceneRendererTool():SetPassAttribute("DeferredDOF", "Flags", "Inactive")
  within a Lua script.
- PLScriptBindings: Renamed "ScriptBindingLog" into "ScriptBinding_PL_Log", "ScriptBindingTiming" into "ScriptBinding_PL_Timing" and
  "ScriptBindingSystemConsole" into "ScriptBinding_PL_System_Console" so one can directly see the resulting script namespace (I'am not sure whether or
  not the current solution will stay this way)



>> 04.06.2011
[CO]
PLCore:
- Adding a RTTI class method came with the cost of 8 bytes (32 bit build) per RTTI class instance. While e.g. RTTI class attributes really require
  per RTTI class instance data, RTTI class methods don't need per RTTI class instance data... at least as long as such a method is not called. When
  calling a RTTI class method, the RTTI class instance is required, but only then.
  One may say: "8 bytes - who cares about a few bytes?", but considering that those 8 bytes are per method and per class instance this really sums up.
  Until now, RTTI class methods were not used that often within PixelLight, so, this wasn't a real problem. For the script support, those RTTI class
  methods play an important role and I'am quite sure that all over the place a lot of RTTI class methods will be added in order to use RTTI class
  instances e.g. within scripts. With this in mind, those 8 bytes really hurt.
  So, before I start to add a lot of RTTI class methods for script support, I stopped and had a look into how to reduce the RTTI class method per
  instance memory costs. RTTI class methods are now static, meaning they only introduce a memory cost for the RTTI class itself which is not critical
  because there's only one such class instance per class. :D
  When requesting a callable RTTI class method, an instance of such an object is created on the fly. In short, memory was traded for additional memory
  allocation/deallocation - but I really think it's ok and maybe there will be more internal optimisations later.
  -> This change means, that something like
       "cMyObject.MethodTest()" or "cMyObject.MethodTest.Call(PLCore::Params<void, int, float>(20, 1.1f))"
     for calling the method "Test" though it's RTTI wrapper is no longer possible. But that's not really a loss because in those situations it's possible
     to directly call the C++ method anyway.
  -> This change also means that within constructors, it's no longer required to initialize RTTI class methods by writing e.g. "MethodLoad(this)". This makes
     exposing methods to the RTTI easier because it's only required to add e.g.
       pl_method_2(Load, bool, Chunk&, PLGeneral::File&, "Load method", "")
     within the RTTI class definition in order to access the method "Load" though the RTTI.
  -> And the most important meaning of this change: Add as many RTTI class methods as you want, your RTTI class instance won't grow into the kilobytes through that. :D
- "Object::GetMethod()" returns now "DynFuncPtr" instead of "DynFunc*"
- "Object::GetMethods()" no longer returns a list instance, instead a list instance to be filled has to be provided as parameter.
  This change avoids unnecessary copying around. Because the RTTI stuff is fundamental, it really has to be as performant as possible...
  even if this means that the interface of "Class::GetMethods()" is not identical to "Object::GetMethods()".
- Stephan found a cleanup bug within my delayed shared library loading implementation... in the case that a class dummy can't be registered because there's
  already a class dummy or even the real class, no one destroyed the created dummy class instance. This is now handled within "ClassManager::RegisterClass()".
  Uff, simple principle, that many implementation bugs - not that I had expected it otherwise... but I really hope that was the last one.
- The type ID of "TypePtr" and "TypeRef" was set to -1 instead of an unique value
- PLScriptLua is now able to deal with RTTI class instances derived from "PLCore::Object" instead of just direct pointers
  to "PLCore::Object". The current solution is not really a good one, but for now it works. I hope I'am able to figure out
  a more waterproof solution.



>> 03.06.2011
[CO]
PLCore:
-> Stephan Wezel made a PLProject refactoring (see PLProject diary for details), delayed shared library loading is now also working under Linux
   because PLProject adds the class information into the plugin-file
- PLScriptBindings: Added "ScriptBindingSceneRendererTool"... The "making of" of the dungeon demo is now done via a
  Lua script. Still experimental, but the wires begin to tie up.



>> 02.06.2011
[CO]
PLCore:
-> After an university lecture etc. maraton of two weeks and some non script related PixelLight work, back to the script stuff. :)
- PLScript: "Script::SetGlobalVariable()" has now as parameter the more generic "PLCore::DynVar" instead of "PLGeneral::String"
- PLScript: Renamed "Script::GetGlobalVariableType()" into "Script::GetGlobalVariableTypeID()" so that it's similar to e.g. "PLCore::Var::GetTypeID()"
- PLScriptLua: "Script::SetGlobalVariable()" now also supports "PLCore::Object*" and is able to add new global variables
  (one can use e.g. "Script::IsGlobalVariable()" to check whether or not there's such a variable before setting one to avoid adding a new
  global variable if this is not desired)
- "PLScriptBindings::SNMScript" now adds the global variable "this" to the script so that it's able to access "this" RTTI class instance,
  meaning the script scene node modifier
- PLScriptV8 & PLScriptPython: "Script::SetGlobalVariable()" is now able to add new global variables



>> 29.05.2011
[CO]
- Added "Stopwatch::Stopwatch(bool bStartAtOnce)" to make it possible to use the stopwatch in a more compact way
- "StringBufferManager::ReleaseStringBuffer()": Activated the string buffer management under MS Windows because, especially when
  debugging, this adds a real performance boost like e.g. 2 sec instead of 20 sec to start an application in debug mode.
  (so, this string management is nothing optional - without it, it's just painful to debug more complex applications)
  Under Linux, I currently just get a segment fault when starting an application with enabled string buffer management - so it's deactivated
  under Linux for now because I don't have the time to do intensive debugging at the moment, but I really need to be able to do decend debugging
  under MS Windows...
- Ok, "StringBufferManager::ReleaseStringBuffer()" is now working under Linux as well... there was a really stupied bug which caused the UTF8
  string buffer to lie about it's type...
PLCore:
- Added parameters to the plugin relevant "ClassManager"-methods to make it possible to e.g. disable delayed shared library loading
- Added an option to "ConsoleApplication" to make it possible to configure whether or not it's allowed to perform delayed shared library loading to
  speed up the program start ("DelayedPluginLoading" within the configuration file)
- The "ClassManager"-destructor has to destroy the class implementation dummies, the real classes are destroyed automatically by the RTTI system
  (see "pl_class" -> "__pl_guard"). Stephan Wezel helped me in identifying those (hopefully) last bugs in the refactored "Class"-class and helped
  testing the stuff under Linux as well as fixing some details, a huge thank's for the motivating support. :D
-> It looks like the delayed shared library loading is really working quite fine and it's finally fun again to do debugging because the program start
   doesn't take half a minute. I hope I'am now able to focus back to complete the scripting stuff and fix some general bugs like the one described at
   http://dev.pixellight.org/forum/viewtopic.php?f=6&t=48&p=153#p153
   ... the time until the next planned PixelLight release is running, but it was really important to me to speed up the program start time in order
   to be able to debug in a resonable way.



>> 28.05.2011
[CO]
PLCore:
- Continued "Delayed shared library loading"-refactoring: Currently, "LoadableManager" forces many plugins to be loaded in order to register
  loader instances. To delay the plugin loading, "Loader" is now just a proxy and "LoaderImpl" the real loader implementation. This way, the available
  loader implementations are registered correctly, but the actual loader implementations which require to load in the shared library are only
  created when really required.
- The RTTI interface for "Object" was defined as
    pl_class_internal(Object, "PLCore", "", "Object base class")
  and the result was that the base class of "Object" was "" instead of <no base class>, meaning an empty string. I changed it to
    pl_class_internal(Object, "PLCore", , "Object base class")
  ... although it looks somewhat strange, it's correct this way.
- "ClassImpl::GetBaseClass()" is no longer calling "InitClass()" to enhance the chance that a RTTI class is never initialized



>> 26.05.2011
[CO]
PLCore:
- Started "Class" refactoring... There are now a lot of PixelLight plugins within the Git repository and by default, they are all loaded within
  "ConsoleApplication::OnInitPlugins()" so that it's possible to create RTTI class instances. While this behaviour is quite comfortable
  because plugins can be used automatically by just throwing the loose plugins into a scanned directory, it's also quite slow at program start.
  (although there are already several internal optimizations in place like delayed RTTI class initialization!)
  Usually only a few plugins are really used during runtime, but in order to be able to create RTTI class instances it's required that the system
  knows which RTTI classes are actually available. Currently, this requires to load in the shared library which may cause the loading of other
  shared libraries. (domino effect) Due to the increasing number of loose PixelLight plugins, the program start time starts to get annoying long
  - especially in debug mode. My plan was to focus on the script implementation, but I'am not able to try out and debug stuff in reasonable time
  because each program start takes several seconds, even if there's actually not happening much in an application. Of course, it would be possible
  to just "deactivate" plugins, but such hacking around would cost time as well and would be error prone. So, it's probably time to add another
  RTTI initialization speed up optimization: Delayed shared library loading
  This was actually planned for several years, but there were always more important things to do - like getting the RTTI to the point were it's
  really cool and powerful. Stefan accomplished that. The "new" RTTI system is now several months in use and works really well, so, it's now probably
  really time to implement this delayed shared library loading thingy to speed up the program start when there are a lot of optional loose plugins
  available. (which is now the case)
  The delayed shared library loading should be transparent to the user, meaning that it should happen automatically on the fly so that the user don't
  need to care about it. So, as the first refactoring step I applied the bridge design pattern to "Class" and moved the previous implementation
  into the implementor "ClassReal". The RTTI system still creates automatically class instances, but they are now derived from "ClassReal" instead
  of "Class" which is now just a class implementation wrapper. Looks like everything is still working as before. This change makes it possible to
  secretly change the internal class implementation... the next step is to add class metadata into the "plugin" file and when loading a plugin,
  this metadata is used to create dummy class instances without actually loading the shared libraries the RTTI classes are implemented in. The real
  RTTI class instance is only created by loading in the shared library when really required, e.g. when an instance of the RTTI class has to be created.
  In this case, the internal class implementation is changed - but the "Class" instance the user is working with will be still the same. This should
  speed up the program start.
- Added "pl_module_delayed()"-macro and the plugin file option "Delayed" which is "true" by default
- Renamed "ClassManager::LoadPluginLibrary()" into "ClassManager::LoadModule()" and made it public
- Add RTTI class metadata within the XML plugin file
- Wow, already done! Delayed shared library loading is working! The startup time of e.g. "01Application" is now better.
  (it's of course only faster when not all available plugins are used)
-> I'll do some more testing before I upload this change (although the next two days I'am quite busy with university, again :/)



>> 24.05.2011
[CO]
- The "DynLib" implementations were not unloading the dynamic OS library automatically. I thought about this issue to figure out whether
  it's acutally a "feature", but this really looks like an adverse behaviour because e.g. something like "File" is closing the opened file
  automatically.
PLCore:
- "ClassManager": Moved plugin file format version 1 loading code from "LoadPlugin()" into a separate method "LoadPluginV1()"
- "ClassManager": Moved plugin library loading code from "LoadPluginV1()" into a separate method "LoadPluginLibrary()"
- "ClassManager": There was a memory leak during plugin library loading: The ownership of the created instance of the dynamic
  library was given to the created "Module" instance, but "Module" never destroyed the given instance of the dynamic library.
- "ClassManager": No one was destroying the module instances, so this is now done within the "ClassManager"-destructor
- Made the "Module" constructor and destructor private because only the class manager is responsible for managing the modules
- The "Module" destructor was virtual, but there's no reason for that



>> 22.05.2011
[CO]
PLCore:
- PLScript: Woho, the demo "Scripts.scene" comes to live... "ScriptsScene.lua" is already up and running and is manipulating a scene
  node by using a Lua script. It's still everything experimental to see what's possible and how it may work as a whole
  system.
- Added PLScriptBindings plugin which exposes certain parts of PixelLight to script languages. This means that the script bindings
  are a 100% loose plugin and are not within the core. First I thought about adding some basic script bindings directly into PLScript and
  other script bindings into the PLEngine project which brings together the individual components to an easy usable framework. But
  this way the standard PixelLight script bindings would be scattered over multiple projects and there would also be the risk that the
  completly optional script support may accidentally grow into the core over the time. This way, it will probably also easier for other
  people to contribute to the script bindings part.



>> 21.05.2011
[CO]
PLCore:
- "TypeObjectPtr" & "TypePtr" & "TypeRef": "ConvertFromVar()" is now using "GetUIntPtr()" instead of "GetInt()" (this was a [TODO] point)
- PLScript: Worked on "PLCore::Object*" support



>> 19.05.2011
[CO]
PLCore:
- DynEvent: Added "void Emit(const PLGeneral::String &sParams)" and "void Emit(const PLGeneral::XmlElement &cElement)" to make it possible to emit
  events when one just has a DynEvent pointer
- Added "GetNumOfParameters()" and "GetParameterTypeID()" to "DynEvent" to make it possible to request some more information about the dynamic function
- Warning, breaking event change: I had to change "void Emit(_T0 t0, _T1 t1)" into "void operator ()(_T0 t0, _T1 t1)" etc. because when not doing so, the compiler
  failed to see the difference between e.g. "Emit(String)" and "Emit(String)", ok, maybe there isn't one. This issue has to do with the
  "void Emit(const PLGeneral::String &sParams)" change above - but those non typed call methods are really required. I don't wanted to rename those methods
  into e.g. "void EmitString(const PLGeneral::String &sParams)" because it felt unnatural to me and by the way, "DynEvent" is quite similar to "DynFunc" -
  at least within the usage. Whenever possible I try to avoid such breaking changes, but sometimes they are required to avoid that stuff gets uggly.
  So, to call e.g. an event named "MyEvent" call "MyEvent()" (if you have ever used boost, you are already familiar with this way :) instead of "MyEvent.Emit()".
- PLScriptLua: Calling RTTI object methods within Lua scripts is working... currently only slow progress because the university is using most of my available
  time. But I still try to get the script support up and running until the next scheduled PixelLight release. :D
- PLScriptLua: Calling RTTI object signals within Lua scripts is working



>> 17.05.2011
[CO]
PLCore:
- PLScript: Added "Script::PushArgument(PLCore::Object *pObject)" and an experimental Lua implementation to get an idea how to access RTTI objects
  directly within scripts *work in progress*



>> 16.05.2011
[CO]
- Removed "long" methods within the "String" and "Tokenizer" classes to avoid compiler issues with 64 bit data types
  (a compiler may actually define a 64 bit data type as long, and then there's no way to distinguish long from long *g*)



>> 13.05.2011
[CO]
- "String": Added "int64"-support
PLCore:
- "PLCoreDefinitions.h": Added "TypeInvalid"
- PLScript: "Script:" Added support for global variables. At first I thought about adding "GetGlobalVariable()" & "SetGlobalVariable()" versions
  for the supported primitive data types - but this would result in a total copy'n'past overkill within the internal implementations. Those
  string methods should do the job (the internal implementations try to don't change the script variable type).
- PLScript: Renamed "Script::AddDynamicFunction()" into "Script::AddGlobalFunction()" and "Script::RemoveAllDynamicFunctions()" into "Script::RemoveAllGlobalFunctions()"



>> 12.05.2011
[CO]
PLCore:
- Added "GetNumOfParameters()" and "GetParameterTypeID()" to "DynFunc" to make it possible to request some more information about the dynamic function
- Added "PLScriptLua::Script::LuaStackDump()" which writes the current Lua stack content into the log



>> 11.05.2011
[CO]
PLCore:
- PLScript: The "ScriptManager" creates now instances of all found "ScriptBinding" classes
- PLScript: Added "Script::AddBindings()" to bind all available "ScriptBinding" instances at once
- PLScript: By default, "ScriptManager::Create()" and "ScriptManager::CreateFromFile()" binds all available "ScriptBinding" instances at once



>> 08.05.2011
[CO]
- A while ago, Stephan reported me an issue with double slashes within filenames - finally I found some time to have a look into it.
  Something like "PLGeneral::File("e:\\1//Test.jpg").Exists()" failes. Because I wasn't sure whether or not this behaviour is "correct"
  (the filename looks kinda messy) I first tested the same with boost by writing "boost::filesystem::exists("e:\\1//Test.jpg")" and with
  Qt by writing "QFile("e:\\1//Test.jpg").exists()" and "QUrl("e:\\1//Test.jpg").isValid()". For boost and Qt a filename like
  "e:\\1//Test.jpg" is totally fine.  	
  Next I tried to find a description which behaviour is "correct". As usual, found first information at Wikipedia:
    "http://en.wikipedia.org/wiki/URL_normalization" (from 2011-05-08)
      "Removing duplicate slashes Paths which include two adjacent slashes should be converted to one. Example:
       http://www.example.com/foo//bar.html  http://www.example.com/foo/bar.html "
  I wasn't able to find this in standards like RFC 3986 (http://tools.ietf.org/html/rfc3986#section-6) - but I was searching only a few
  minutes. After this research I "assume" that removing duplicate slashes is fine, at least this way there's within PixelLight the same
  behaviour as in boost or Qt.
  -> Made a minor change within the "Url::SetValue()" implementation.
PLCore:
- PLScript: The AngelScript add on source codes are now within "External\Optional\AngelScript\add_on" directory instead within the to download external package.
  CMake told me that it wasn't able to find those add on source codes... because it was checking BEFORE downloading and extracting the external package. Maybe
  it's possible to change the CMake script... but that's somewhat too dangerous for me and usually really time consuming to get it right.



>> 07.05.2011
[CO]
PLCore:
- Implemented "PLScriptPython::Script::AddDynamicFunction()" namespace by using Python dictionaries... probably not the best solution but for
  now I just want to have it up and running to get an idea of concepts multiple scripting languages are sharing. Maybe I'll replace "namespace"
  later by "module".
- Implemented "PLScriptV8::Script::AddDynamicFunction()" namespace by using V8 object template
- Implemented "PLScriptAngelScript::Script::AddDynamicFunction()" namespace. It looks like that AngelScript (2.20.2) has currently no support
  for namespaces... so right now I'am doing an ugly hack: e.g. "PL.Timing.GetTimeDifference()" is written within scripts as "PL_Timing_GetTimeDifference()". :/
-> Ok, the namespace support for global functions is now implemented within all script backends... although I'am really not happy with the current
   AngelScript solution (e.g. "PL_Timing_GetTimeDifference()" instead of "PL.Timing.GetTimeDifference()") and Python solution
   e.g. "PL[Timing][GetTimeDifference]()" instead of "PL.Timing.GetTimeDifference()"). It's really time consuming to do the research into multiple script
   API's at the same time and on those two issues I already spend several hours without a decent solution. So, if there's someone who knows a better solution...
-> Right now my candidates for the "recommended PixelLight script language" are JavaScript and Lua. Lua is quite compact while JavaScript is a web-standard which
   could be somewhat beneficial for PixelLight, especially regarding to the browser plugin. AngelScript looks somethat unfinished although I like the API in
   general. Python is just a monster. *g*
- PLScript: "Script": Added string versions of "PushArgument()" and "GetReturn()". Adding support for this within PLScriptAngelScript was some hard work because unlike
  JavaScript (V8), Python and Lua, within AngelScript strings are just "add_on" and not everything is documented as detailed as I wished for and I wasn't able
  to find real help via google as well. So I had to guess, review the AngelScript source codes and perform some debugging... I really hope that I didn't miss
  anything...



>> 06.05.2011
[CO]
PLCore:
- PLScript: Added "ScriptBinding" which is actually a blank RTTI class. RTTI classes which are only used for "script binding" should be
  derived from this class. This doesn't mean that it will be impossible to bind any other RTTI class instance to a script - but usually
  it's useful to have such an abstract base class...
- PLScript: "Script::AddDynamicFunction()": Added namespace as last optional parameter (backend implementations will follow)
- PLScript: Added "Script::AddBinding()" which adds a script binding to connect the given RTTI class instance with this script (currently only RTTI
  methods are used)
- Implemented "PLScriptLua::Script::AddDynamicFunction()" namespace by using Lua tables



>> 02.05.2011
[CO]
PLCore:
- "DynFunc": Added "GetReturnTypeID()" to make it possible to figure out the return type (e.g. "TypeNull" for "void()" or "TypeInt" for "int()")
  of a dynamic function
- Python backend: Implemented "AddDynamicFunction()" and "RemoveAllDynamicFunctions()"
- V8 (JavaScript) backend: Implemented "AddDynamicFunction()" and "RemoveAllDynamicFunctions()"
-> The Lua, Python, AngelScript and JavaScript backends are now equal in the implemented behaviour. It's possible to call script functions
   from the C++ side, and it's also possible to call C++ functions from the script side. I'am quite sure that this isn't everything one
   requires when working with script engines, but it's a start. I have to take a break for a couple of days due to university stuff, then
   I continue working on PLScript.



>> 01.05.2011
[CO]
PLCore:
- AngelScript backend: Implemented "AddDynamicFunction()" and "RemoveAllDynamicFunctions()"
- Python backend: Calling Python functions is working



>> 30.04.2011
[CO]
- "String": Added pointer constructor "String(void *pValue)"
PLCore:
- "Functor"-Templates: Added "Clone()"-Implementation
- "DynFunc": Added protected copy constructor and copy operator to avoid misuse, made the default constructor protected as well to avoid confusion
- "DynFunc": Added "PLGeneral::String" and "PLGeneral::XmlElement" parameter versions of "CallWithReturn()". When using
  "DynFunc::Call(const PLGeneral::String &sParams)" or "DynFunc::Call(const PLGeneral::XmlElement &sParams)" there's absolutely no chance to get any
  function return values because there's no type information. Currently I'am using "DynFunc::Call(const PLGeneral::String &sParams)" within the work
  in progress PLScript to let a script call a given C++ function/method and really need at least a string representation of the result which I can give
  back to the script API. I really hope that those "CallWithReturn()" template methods don't backfire... right now it appears that there are no side
  effects during template instantiation. I could have added the string return directly into the already existing methods, but I wasn't comfortable
  with that.
- PLScript: Added script support for functors/functoids so that it's possible to call C++ functions or member methods from inside scripts...
  as well as other script functions because the functors are hiding this detail.
  The method "Script::AddDynamicFunction()" is used to register functors while "Script::RemoveAllDynamicFunctions()" can be used to remove
  all registerd functors. The Lua implementation is already working. Please note that this is still highly experimental and I don't know
  whether or not the script interfaces are completly changed later.



>> 29.04.2011
[CO]
- Added "File::GetContentAsString()"
PLCore:
- Moved "OpenFile()" from "Loader" into "LoadableManager" because it's kind of universal
- Moved "LoadStringFromFile()" from "PLRenderer::EffectPass" into "LoadableManager" because it's kind of universal
- "SignatureString": "PLGeneral::String GetSignatureID()" constructed internally the signature string on every call. But during runtime, this
  must only be done once and then the signature can just be reused. So, the internal signature string is now static to enhance performance. I
  double-checked the change, used the debugger a few times on it to see and think through the performed steps and tested the existing PixelLight
  projects as well. It looks like that this change has no side effects.
- PLScript: Added "GetScriptLanguage()", "GetSourceCode()" and "SetSourceCode()" to "Script" (similar to "PLRenderer::Shader")
- PLScript: Added "FuncScriptPtr" which is a version of "PLCore::FuncFunPtr"/"PLCore::FuncMemPtr" for script functions. This means that script functions
  can be called in the same way as all other functions/methods (e.g. RTTI methods) can be called. This template is using
  the "Script" methods "BeginCall()", "PushArgument()", "EndCall()" and "GetReturn()" to call script functions. Calling Lua and AngelScript
  functions is already implemented and working. Those mentioned script function calling methods are currently public although it's not recommended
  to call them without using "FuncScriptPtr", but currently I see no change to hide those methods from the user. But this is just my first attempt to
  get things up and running... next stop: Implementing the same for Python and JavaScript. (calling C/C++ methods from scripts will follow as well)
- PLScript: Calling JavaScript functions is working... although the implementation is currently somewhat poor... having some issues getting into the V8-API...



>> 28.04.2011
[CO]
- "FileWindows::GetSize()" is now using the MS Windows API functions "_filelength" and "_fileno"
PLCore:
- PLScript: As requested within the PixelLight forum at: http://dev.pixellight.org/forum/viewtopic.php?f=3&t=45
  ... I'll also added a script backend for AngelScript (like the others, just a skeleton right now!). Ok, four script languages should really
  be enough to get a good script interface.



>> 26.04.2011
[CO]
PLCore:
- PLScript: Compiled 32 bit versions of Lua, Python and V8 (JavaScript engine) for Windows and Linux. Configurated everything so that the script
  projects can be compiled and are able to run.
  Next stop: Concrete script implementations :D



>> 25.04.2011
[CO]
PLCore:
- Started the PLScript project. As usual there's a null backend and I'll implement backends for Lua, JavaScript and Python in parallel.



>> 19.04.2011
[CO]
- Removed "_DEBUG" preprocessor tests within the String and String Buffer class



>> 15.04.2011
[CO]
- Premier: First entry within the tracker ("Bugs"-category) at http://sourceforge.net/tracker/?group_id=507544
  -> Bugfix (ID: 3286541): "PLGeneral::XmlElement::GetLastAttribute()" was returning the first instead of the last attribute



>> 10.04.2011
[CO]
PLCore:
- "ConsoleApplication::OnInitData()" is now using English as the default language instead of the current system locale, this makes things more predictable



>> 08.04.2011
[CO]
PLCore:
- Added "ResourceManager::EventResourceRemoved"-event which is called when a resource is going to be removed



>> 09.03.2011
[CO]
- Url-class: Nearly over a year ago, a client reported that a client reported (jap :) that UNC (Uniform Naming Convention aka Universal
  Naming Convention) support was not working. At this time, I never had heard of UNC before and there was not really time to look into it
  in more detail - so, a hack on the client side had to do the job. Today, why ever, I was really curious what's the issue with UNC.
  After looking what exactly UNC is all about (I usually don't have to do anything with network related stuff), I made some experiments
  (also with "QUrl" from Qt) and figured out, that the only problem seemed to be within the "Url::SetValue()"-method while parsing the
  given URL. After spending some hours to get into regular expressions again and looking for pitfalls that may occur, I added UNC parsing
  support to the Url-class. Now, the following works for me
    System::GetInstance()->SetCurrentDir("\\\\COFENBERG-PC\\Users\\COfenberg\\UNC_Test");
  As well as
    File cFile("\\\\COFENBERG-PC\\Users\\COfenberg\\UNC_Test\\Test.txt");
    if (cFile.Open(File::FileRead|File::FileText)) {
        String sText = cFile.GetS();	// -> sText = "Hello" :D
    }
  I don't know whether or not my change within "Url::SetValue()" is perfect... in general, I wanted to keep the required implementation change 
  as compact as possible.



>> 02.03.2011
[CO]
- As noticed by a PixelLight user, the data type returned by "System::GetMicroseconds()" was "uint32" which is critical for the stored data
  and "unsigned long" is commonly used instead. So, methods like "System::GetMicroseconds()" are now using "uint64" instead of "uint32".
  It's really cool to get feedback on how to improve PixelLight, keep up providing feedback! :D



>> 26.02.2011
[CO]
- StringBufferASCII is now using "memcpy" instead of "strncpy" because "memcpy" is usually slightly faster as "strncpy"
  (checked usual implementations of those functions). Within this class, it's guaranteed that the values are correct, so there's no security
  risk in using "memcpy". I know, the difference is not really measurable, but I always try to squish out everything possible out of such
  basic implementations.
- StringBufferUnicode is now using "memcpy" instead of "wcsncpy"
- Added some more String constructors to make it easier and "more intiutive" to create a string out of a number
- Had a look into "sprintf" (a variation is used within "String::Format()") and "itoa" (non-standard extension to the standard C). In certain
  situations, "sprintf" has no chance to come near to the performance of "itoa" - which is obvious because "sprintf" is more universal and powerful.
  The following example took 880 ms
    for (int i=0; i<100000; i++)
        String sMyString = String::Format("The number %d is fantastic!", 42);
  while the following example took 129 ms
    for (int i=0; i<100000; i++)
        String sMyString = String("The number ") + 42 + " is fantastic!";
  after using "itoa" in the internal String implementation. I think there's a notable performance difference in the second version which is worth to
  talk about. :D



>> 25.02.2011
[CO]
PLCore:
- "ConsoleApplication": Moved "Write some general information into the log"-step from "OnInit()" to "OnInitLog()". It was a little bit
  confusing that initial information like "Log-system started" was written somewhere at the end of the initialization phase.



>> 22.02.2011
[CO]
PLCore:
- "ConsoleApplication::OnInitPlugins()": The PixelLight runtime directory is now also scanned non-recursively for plugins. This is quite useful
  for projects which can be used completely dynamically, but can also be used in other C++ projects to access certain features. This behaviour is
  also symmetric to the application directory scan.



>> 17.02.2011
[CO]
- Program entry point within "Main.h": Removed "setlocale(LC_ALL, "");" because I don't think that it's a good idea to use "setlocale".
  This is up to the user and the user is also responsible for the consequences when changing the current locale...
- String internals: Sadly, the current set locale is of course also an issue on all operation systems. It would be fantastic if we never
  ever would come into contact with "setlocale" at all, but sadly, the user can and possibly WILL change the current set locale and then
  hell breaks lose because e.g. "42.21" will be written as "42,21" and possibility written e.g. into a XML file... on another side "42,21"
  is read from the same XML file and boom, invalid floating point number due to the use of another locale. To be honest, I really hate this
  topic but sadly, I can't just completely ignore it forever.
  Today I was remembered, again, why we decided to wrap EVERYTHING within PixelLight so more complex projects can use a consistent framework...
  Just an example: MSVC has some cool string functions like "_sprintf_l", on Linux there are some similar functions allowing you to directly
  provide the locale to use as a parameter (other systems like Android OS, don't offer such stuff, of course!), instead of using an ugly global
  setting. But sadly, there's no standard for that. So I backup the current set locale by using "strdup" before changing it (evil dynamic memory
  management, but currently I see no other simple solution)... but wait, now VC tells me the following:
    "warning C4996: 'strdup': The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strdup. See online help for details."
  Cool, the VC compiler tells me "Do NOT use POSIX, it's evil!". Because I don't like dozens of "#ifdefs" either, I just
  suppressed this stupid warning. Low level C/C++, one just must love it! *gruml*
  Sadly I'am afraid that the locale changes from today are no real solution, and something like a locale class is required... but for now, I
  just have enough of this topic...



>> 01.01.2011
[CO]
- Renamed the method "Mutex::Lock()" with a timeout as parameter into "Mutex::TryLock()" so one can see that it's really wise to
  check whether or not a lock was actually received
- Added "PLGeneral::MutexGuard" helper class using the really cool "Scoped Locking"-idiom which can make the code more compact while
  also increasing the maintainability
- Renamed the method "Semaphore::Lock()" with a timeout as parameter into "Semaphore::TryLock()" so one can see that it's really wise to
  check whether or not a lock was actually received...



>> 29.12.2010
[CO]
- Removed "String::Unknown"-definition, it was only used once internally and less variations are usually the better choice
- Removed "String::UTF8"-definition
- Removed "utf8" data type
- "String": Refactoring of the UTF8 support, in fact reduced the support to the two methods "GetUTF8()" and "SetUTF8()"
- "QtStringAdapter" is now using UTF8 instead of wchar_t to avoid the need to recompile Qt or PixelLight with other compiler settings



>> 18.12.2010
[CO]
- "PLGeneralWindows.h": If "_MSC_VER" (VisualStudio) or "_WCHAR_T_DEFINED" is not defined, "wctype.h" will be included for
  "wchar_t". Now PLGeneral can be used within for example QtCreator at once.
- Added a static adapter class within PLGeneral for mapping Qt strings to PixelLight strings and vice versa



>> 17.12.2010
[CO]
- Added unicode support to "FileLinux", "FileSearchLinux", "ConsoleLinux", "DynLibLinux", "SystemLinux", "FileStdStream", "Log",
  "ConsoleWindows" and "Process"



>> 12.12.2010
[CO]
PLCore:
- Loadable-System: At the PixelLight mailing list (pixellight@lists.pixellight.org), a discussion about case-sensitive file-extensions
  came up. In general, while for instance UNIX like systems have case-sensitive file systems, MS Windows does not. At the
  beginning of the development of PixelLight, we made the design decision that PixelLight should be case-sensitive in general
  to avoid porting problems across multiple-platforms. Naturally, for MS Windows only users, this leads to confusion when
  they try to load in, for example an image named "MyImage.JPG", and nothing happens although the jpg file format is supported.
  The reason behind this is, that the file extension is used to figure out which loadable implementation is responsible for
  loading the concrete data. In this case, "jpg" tells the (plugin based) system to use "PLGraphics::ImageLoaderJPG" to load
  in the data. The extension string test is case-sensitive, and as such, "JPG" is unknown to the system.
  Ideas came up to add an option to make the extension case handling configurable, or to make file extensions in general case-insensitive.
  I did some research on the topic to see how other developers handle this situation or think about this - as expected, there are a lot
  of different opinions about "what's best".
  I thought about the issue, and I see the point that this can be a problem using a lot of content - to be honest, from time to time
  I have some "problems" with this as well. For example, "The Compressonator" (http://ati.amd.com/developer/compressonator.html) from ATI (ok,
  AMD nowadays *g*) always wants to write "DDS" instead of "dds" as file extension.
  In my opinion, I still think that it's no good idea to weaken the "PixelLight is in general case-sensitive" design decision and adding a huge
  comment that this is the one and only place within PixelLight were it's handled by using strategy A instead of strategy B. I really think that, on
  the long term, this will cause more problems than solving them.
  Fortunately, the loadable system already supports multiple aliases for one and the same file format. For example "PLGraphics::ImageLoaderJPG"
  can be addressed by using "jpg", "jpeg", "jpe", "jif", "jfif" or "jfi" as jpg file extension. So, why not add "JPG", "JPEG", "JPE", "JIF", "JFIF"
  and "JFI" as well? Of course, something like "JpG" will still not be recognized, but I can't remember a program using this case convention... and
  as a computer scientist, I love orderliness and don't really want to support spelling chaos intentionally. I saw that some other developers are
  using this solution as well, and I think it's a good compromise - it doesn't weaken a general system design decision by adding an exception, but
  it allows to use for example "JPG" instead of just "jpg", too.




/*********************************************************\
 *  The entries below are in German only
\*********************************************************/



>> 06.12.2010
[CO]
PLCore:
- DynEvent um "GetNumOfConnects()"-Methode erweitert, bei z.B. Profiling ist es hin und wieder interessant zu
  erfahren wie viele Connections gerade vorhanden sind



>> 04.12.2010
[CO]
- Beim ber die Codes "schweifen" (hin und wieder passiert mir soetwas unbeabsichtigt *g*) vielen mir in der String Klasse ein
  paar Stellen wie z.B. "if (pszFormat && strlen(pszFormat))" auf. Sinn ist hier eigentlich nur rauszufinden ob direkt das erste
  Zeichen im String eine terminierende Null ist - die String lnge braucht man hier gar nicht. nderte diese Stellen daher in
  "if (pszFormat && pszFormat[0] != '\0')" - spart einen Funktionsaufruf und ndert die komplexitt hier von n zu 1 da nicht mehr
  im String nach '\0' gesucht werden muss. Interessant das mir das noch nicht vorher ins Auge gestochen ist. *g*



>> 29.11.2010
[CO]
- "Stopwatch::Stop()"-Bugfix: Wenn die Stopuhr gerade nicht luft, und man "Stop()" aufruft sollte natrlich "0" als gemessene
  Zeit zurckgegeben werden...
-> Die im Tagebucheintrag vom "30.10.2010" angesprochenen String Optimierungen angepackt...
- StringBuffer: "Append()" hinzugefgt, wenn immer mglich wird in der String-Implementation nun "Append()" verwendet da dessen
  Implementation einfacher gehalten ist (wodurch Optimierungen und bessere Performance leichter zu realisieren sind)
- StringBuffer um "m_nMaxLength"-Variable erweitert, damit ist es nun mglich, dass ein String Buffer intern grer ist als der
  tatschlich gespeicherte String. Hintergrund ist, das Speichermanagement teuer ist und derzeit die String Klasse fr ein paar
  Dinge performancemig leider unbrauchbar ist. Da wir meist nur ASCII nutzen, konzentriere ich mich erstmal auf Optimierungen
  fr ASCII Strings - aufgrund des Umfangs der String Klasse, wird es sicherlich nen bischn dauern bis alles etwas flotter geht.
  Oft werden mehrere Strings konkateniert, hier zeigte die String Klasse performance mig deutliche schwchen. Sinnfreies aber
  einfaches Beispiel:
    String sString;
    for (int i=0; i<100000; i++)
      sString += 'a';
  Vor dem Beginn der Performance optimierungen dauerte das im Release Modus unglaubliche 2995 ms. Nach dem einbauen von "Append()"
  noch 2757 ms, und sobald bei "Append()" intern Speicher fr zuknfige Zeichen reserviert und dann genutzt wurde nur noch
  47 ms. Das zeigt denke ich, dass es Sinnvoll ist diese Optimierung weiterzuverfolgen da es doch schon ein deutlicher Unterschied ist -
  gerade bei groen Datenmengen! (der Code wird dadurch aber leider nicht einfacher oder gar weniger :/)
- StringBufferManager hinzugefgt. Zuknftig sollten StringBuffer-Instanzen nur noch hierber erfragt, und sobald nicht mehr bentigt
  hierhin zurckgegeben werden. Sobald man einen StringBuffer bentigt, fragt man einfach den StringBufferManager nach einer StringBuffer
  Instanz die eine bestimmte String lnge halten kann... es obliegt dann dem StringBufferManager zu entscheiden ob man einen Buffer
  mit GENAU der lnge zurckbekommt, oder einen Buffer der *mehr* halten kann. Es ist ebenfalls dem StringBufferManager berlassen ob
  er gerade nicht bentigte StringBuffer Instanzen buffert statt sofort zu lschen, um dann diese wiederverwenden zu knnen um dynamisches
  Speicher anlegen/freigeben zu reduzieren. Durch den StringBufferManager wurde hier und da die Implementation der String Klasse etwas einfacher. :D
  Die StringBuffer-Klasse hat eine statische Instanz von StringBufferManager und StringBufferManager speichert gerade nicht bentigte
  StringBuffer Instanzen zwischen - das ist momentan eher noch Experimentiell und sicherlich definitiv nicht optimal (u.a. weil die statische initialisierungs
  und deinitialisierungs Reihenfolge ja nicht festgelegt werden kann), luft aber bereits halbwechs ordentlich und reduziert das dynamische anlegen
  und freigeben von Speicher zur Laufzeit.
-> Uff, das waren nun fast 14 Stunden am Stck mit Strings jonglieren, aber ich denke es ist schonmal besser als vorher, vorallem wurde die Implementation
   an einigen Stellen deutlich berschauberer. Das mit Strings intern mehr Speicher geben + StringBufferManager wollte ich nun schon seit Jahren mal
   ausprobieren... und da mir wiedermal aufviel wie laaaam die String Klasse stellenweise ist/war, hatte ich mich nun endlich einfach mal drangesetzt und
   es durchgezogen. Ich merke hier bei mir nun eine allgemeine leichte Performance verbesserung... wie gehofft. :D
   Morgen mal noch etwas weitertesten, aber bisher siehts so aus als ob sich durch das interne String-Refactoring (das Interface nach Auen hin hat sich
   nicht verndert!) keine total blen Bugs eingeschlichen htten die sofort alles zum Crashen bringen.



>> 14.11.2010
[SB]
- String::Format(): Hier gab es einen Bug, da nicht darauf geachtet wurde, dass laut Dokumentation die Funktion
  _vscprintf (und alle anderen Funktionen dieser Art) das Handle fr die Argumentenliste "zerstrt". Daher muss
  nach dem Aufruf von _vscprintf die Argumentenliste beendet und dann wieder neu geffnet werden. Unter 32 Bit Linux
  sowie unter Windows gab es hier niemals irgendwelche Probleme, aber unter 64 Bit Linux strzte das ganze hier auf
  mysterise Art und Weise ab. Wre schon nett, wenn solche Dinge dann vielleicht nicht nur irgendwo in der Doku versteckt
  wren, sondern auch verlsslich abstrzen wrden, damit sowas nicht vllig unentdeckt bleiben kann ;-)
  Zu diesem Fehler: http://bytes.com/topic/c/answers/572931-segmentation-fault-vsnprintf-lib64-tls-libc-so-6-a



>> 04.11.2010
[SB]
- XmlAttribute: Die Funktion sscanf_s ist eine Microsoft-Erweiterung und daher
  unter anderen Systemen nicht vorhanden. Habe das daher erstmal in sscanf()
  umgewandelt, vielleicht knnte man hier natrlich auch eine von unseren
  bereits vorhandenen Varianten verwenden, um Strings in Zahlen zu konvertieren?
  Die String-Klasse hat soetwas ja schon, alleine schon daher wrde ich daher
  empfehlen, in Zukunft mglichst auf low-level String-Funktionen zu verzichten.



>> 30.10.2010
[CO]
- Wie mit Stefan besprochen: TinyXML Abhngigkeit entfernt. Das hatten wir nun bereits seit etlichen Jahren angedacht... TinyXML ist zwar
  wirklich super, aber unsere eigenen Ansprche verndern sich ber die Zeit so das immer mehr nderungen in TinyXML ntig wurden um es in
  PL noch richtig nutzen zu knnen. Die XML Wrapper Schicht an sich war auch noch nie sooo toll da diese Overhead hinzufgte. Nachdem Stefan
  nun probleme beim Einladen groer XML Dateien hatte, entschlossen wir uns dazu, die TinyXML Abhngigkeit nun zu entfernen um mehr Kontrolle
  ber die XML Implementation zu haben und z.B. einfacher Problemen nachgehen zu knnen. Der Kern des XML Parsers basiert auf TinyXML damit ich
  nicht ganz bei 0 anfangen musste und auf einen ber viele Jahre hinweg ausgereiften XML Parser aufbauen kann, ich denke das die Implementation
  auf Dauer allerdings immer weiter von TinyXML abdriften wird.
  Das war nun zwar ca. 2 Tage Arbeiten an Grundlagen-Klassen, aber ich denke es hat sich gelohnt da unsere grundliegenste Komponente nun von
  einer externen lib weniger Abhngt was das Cross-Compiling etwas einfacher macht. Die erzeugte PLGeneral dll ist bei mir um 10 KB kleiner geworden
  da weniger Redundanter Code vorhanden ist (mehrere String Klassen etc. da jede lib das nochmal selbst implementiert).
  -> Weis noch nicht ob Unicode XML Dateien schon korrekt funktionieren, da msste man etwas testen und gegebenenfalls ausbessern
  -> Das XML Laden (XmlDocument::Load) ist im Augenblick etwas langsamer als vorher da unsere String Klasse bei z.B. "sMyString +=" immer einen internen
     neuen String erzeugt... hier sollte man wohl demnchst kleinere Optimierungen machen so das der interne String immer etwas mehr Speicher belegt
     als eigentlich ntig ist, was dann aber ein performanteres anhngen von weiteren Zeichen oder kurzen Strings ermglicht.
  -> Am XML Interface hat sich zwar nicht wirklich was groartig verndert, unter der Haupe gabs allerdings einiges an nderungen... darum wre es gut
     wenn jemand das nochmal kritisch durchgeht (auch z.B. die Copy-Operatoren) und testet.



>> 24.10.2010
[SB]
- Time: Wenn man Zeiten als String abspeichert, mchte man diese manchmal auch gerne wieder einlesen. Da das Format
  hier ja sehr strikt ist, drfte dies auch ohne weiteres mglich sein, daher habe ich FromString() so implementiert,
  dass es die von ToString() ausgegebenen Time-Strings parsen kann und somit Zeiten auch als Strings bergeben
  werden knnen.



>> 11.10.2010
[CO]
- String: < und > Operatoren fr ASCII waren fehlerhaft Implementiert. StringBuffer::IsLessThan() und StringBuffer::IsGreaterThan()
  wurden, warum auch immer, mit einer String lnge von 0 aufgerufen... interessant das dies bisher noch nicht aufgefallen war, und das
  obwohl die String-Tests die umfangreichsten aller Tests sind. :/ (ok, die ASCII, UTF8 und Unicode kombinationsmglichkeiten machen
  es nicht einfacher das mglichst Wasserdicht zu testen)



>> 20.09.2010
[SB]
- HttpServer: Methoden zum Senden von Daten nach HttpServerConnection verschoben, wo sie auch hingehren.
  Eine Server-Klasse sollten eigentlich nur Connections verwalten, die eigentliche Kommunikation
  zwischen zwei Hosts passiert aber immer in einer Connection, daher sollte die Funktionalitt dieser
  Kommunikation auch dort definiert werden. Dies macht auch die Verwendung und den Zugriff auf eine Connection
  einfacher, ansonsten gibt es immer Probleme mit der Sichtbarkeit und der Vererbung von der Server-Klasse.



>> 16.09.2010
[CO]
- "PLGeneralWindows.h" um MinGW Support erweitert



>> 22.08.2010
[CO]
- Huch, die "FileWindows::CopyTo"-Implementation war fehlerhaft, die Windows Funktion "CopyFile" erwartet als zweiten Parameter,
  die Ziel URL inklusive Dateiname, bergeben wurde allerdings URL ohne Dateiname...
- "FileLinux::CopyTo" war noch nicht implementiert... selbst nach lngeren Suchen konnte ich allerdings keine c-Funktion fr Dateien
  kopieren finden, per Hand eine neue Datei erzeugen und dann die Daten selbst umkopieren war mir etwas zu doof...
  die jetztige Implementation ber "system" ist allerdings genauso doof :/ (aber wenigstens lufts)



>> 16.08.2010
[SB]
PLCore:
- ConsoleApplication: Basispfad fr Daten, die direkt im Runtime-Verzeichnis liegen, korrigiert.
  Das mit den Paketen ist ja schn und gut, aber es ist super unpraktisch, damit zu arbeiten, wenn man z.B. gerade
  an den darin enthaltenen Daten selbst arbeiten will, da man dann stndig alles entpacken und wieder packen msste.
  Darum sollte es zumindest die Mglichkeit geben, die Daten aus einem Zip-File einfach an Ort und Stelle zu entpacken,
  und danach sollte noch alles so laufen wie mit dem Zip-File. Da aber die Zip-Files selber im Unterverzeichnis "Data"
  liegen, musste dieses natrlich noch dem Runtime-Pfad hinzugefgt werden, damit das klappt.



>> 15.08.2010
[SB]
PLCore:
- Core: Unter Linux wird nun die Umgebungsvariable PL_RUNTIME ausgelesen.
  Wenn diese gesetzt ist, wird das darin enthaltene Verzeichnis als
  PixelLight-Runtime verwendet, ansonsten wird in /usr/ und /usr/local gesucht.
  Um dies mglichst einfach zu machen, gibt es ausserdem das Script profile,
  welches dieses Verzeichnis ausgehend vom aktuellen Verzeichnis setzt.
  Natrlich kann man auch in seiner .profile oder .bashrc-Datei im
  Homeverzeichnis diese Variable automatisch beim Systemstart setzen lassen,
  damit man dies nicht immer wieder per Hand ausfhren muss.
  Somit ist es nun wieder mglich, einfach so aus den Sourcen heraus zu
  arbeiten, ohne immer mittels "make install" das SDK im System installieren
  zu mssen.



>> 12.08.2010
[SB]
PLCore:
- Core: Unter Linux wird nun erst geschaut, ob "/usr/local/share/pixellight/Runtime" existiert, wenn ja, wird dieses
  als Runtime-Directory verwendet, ansonsten wird angenommen, dass ein global installiertes Runtime im Pfad
  "/usr/share/pixellight/Runtime" zu finden ist. Bei mir hat das damit schonmal geklappt, dass die Plugins aus
  diesem lokalen Runtime verwendet wurden, die konnten dann aber nicht geladen werden, weil wohl die automatisch
  geladenen dynamischen Bibliotheken, welche sich entsprechend in /usr/local/lib/ befinden, nicht automatisch
  geladen werden konnten. Dies lsst sich aber durch ausfhren des Befehls "ldconfig /usr/local/lib" beheben.
  Momentan besteht dann noch das Problem, dass jetzt die dynamischen Abhngigkeiten wie Cg, Newton oder OpenAL
  natrlich nicht gefunden werden knnen.



>> 07.08.2010
[SB]
PLCore:
- ConsoleApplication: OnDeInit() wird wie OnInit() nun auerhalb aufgerufen, damit es sicher als letztes aufgerufen wird.



>> 09.08.2010
[CO]
- "UTF8Tools::GetNumOfStringBytes" um "nCount" erweitert
- "StringBufferUTF8::LastIndexOf(const char szString[]..." war fehlerhaft implementiert, daher erstmal eine funktionierende
  Lsung eingebaut, die allerdings sicherlich nicht die Effizienteste ist
- "StringBufferUTF8::GetSubstring" implementiert
-> Nun geht "Url(sFilename).GetExtension()" wenn "sFilename" ein UTF8-String ist
- "String::Compare" & "String::CompareNoCase" & "String::Insert" um UTF8 Support erweitert
- "FileWindows::Open(" um Unicode-Support erweitert
- UTF8Tools Warnungen beseitigt wo ich halbwechs sicher bin das die Beseitigung keine Seiteneffekte hat



>> 06.08.2010
[SB]
PLCore:
- ConsoleApplication: OnInit(), also die fr die eigentliche Applikation bestimmte lokale Init-Methode, wird nun
  nicht mehr im Rahmen von Init() aufgerufen, sondern ist fest in der Run-Methode verdrahtet. Hintergrund ist,
  dass diese Methode als aller letztes aufgerufen werden muss, damit sie einen Sinn ergibt, alle Basisklassen
  mssen also die Chance haben, sich vorher komplett inizialisiert zu haben. Das wrde aber heien, dass niemand
  einfach Init() von der Basisklasse aufrufen kann, sondern immer alles neu implementieren msste, damit die
  Reihenfolge stimmt. Darum musste OnInit() verschoben werden, damit dies nicht mehr ntig ist.



>> 05.08.2010
[CO]
PLCore:
- LoadableManager ist kein Loadable mehr, Kopie der alten Version liegt im Archive (Removed_LoadableFromLoadablaManager_05082010)



>> 05.08.2010
[SB]
PLCore:
- ConsoleApplication: LastCrashed und Speichern/Laden von LoadableManager-Pfaden entfernt.



>> 04.08.2010
[SB]
- System: GetDataDirName() hinzugefgt. Diese Methode wandelt den bergebenen Namen fr das Unterverzeichnis im
  User-Data-Dir in ein fr das OS typisches Format um. Aus "PixelLight" wird dann unter Linux ".pixellight", unter
  Windows wird der Name nicht verndert und bleibt bei "PixelLight".
PLCore:
- ConsoleApplication: Behandlung von Log- und Config-Dateien implementiert. Die Schwierigkeit hierbei ist es,
  gleichzeitig ein vernnftiges Standardverhalten zu implementieren, und es trotzdem dem Applikationsprogrammierer
  mglichst einfach zu machen, spter alles abzundern oder ganz auszuschalten, ohne dass er dafr groe Teile
  komplett neu schreiben muss. Es gibt daher fr das meiste jetzt Optionen in ConsoleApplication, die verwendet
  werden knnen, um Standardeinstellungen abzundern:
  - MultiUser: Gibt an, ob Config und Log im User-Verzeichnis gespeichert werden sollen
  - AppDataSubdir: Gibt das Unterverzeichnis im DataDir an (wenn leergelassen, wird es in Run() auf der Applikationsnamen gesetzt)
  - LogName: Dateiname fr Log (wenn leergelassen, wird Applikationsname mit '.log' verwendet)
  - ConfigName: Dateiname fr Config (wenn leergelassen, wird Applikationsname mit '.cfg' verwendet)
  Hierber kann man also ziemlich einfach z.B. den Dateinamen von Log oder Config abndern, ohne gleich die
  gesamte Main-Methode neuschreiben zu mssen. Wenn z.B. LogName oder ConfigName auf "" gesetzt werden, heit das,
  dass diese Datei berhaupt nicht verwendet werden soll. Zustzlich gibt es auch noch die Kommandozeilen-Optionen,
  die in jedem Fall vorrang haben (will jemand auch das nicht, sollte er die Option im Konstruktor entfernen).
- ConsoleApplication: Es wird nun alles bereits im Konstruktor gesetzt, damit es mglichst einfach wird, das Verhalten
  zu verndern, indem man einfach im Konstruktor alles so setzt, wie man das haben will. Der einzige dadurch notwendig
  gewordene Hack besteht darin, dass beim Spteren Aufruf von SetName() auch noch automatisch die Dateinamen fr Log
  und Config angepasst werden, falls diese so aussehen, als wren sie noch auf ihren Default-Wert gesetzt.
- ConsoleApplication: Wenn die Konfigurationsdatei nicht geladen werden konnte, wird jetzt in einem zweiten Schritt
  dennoch der Dateiname gesetzt, damit eine neu erzeugte Config spter gespeichert werden kann. Hierbei wird es wieder
  erst mit dem User-Data-Dir versucht, dann mit dem Applikationsverzeichnis. Wenn der ConfigName auf "" steht, wird
  gar keine Config verwendet. Ein auf der Kommandzeile bergebener Pfad hat immer Vorrang, und wenn er nicht
  existiert oder fehlerhaft ist, so werden trotzdem keine Standardpfade mehr versucht. Analog zur Config auch die
  Log-Methode angepasst, nur dass hier kein Dateiname gesetzt wird, wenn das Log nicht zu ffnen ging (ergibt hier
  keinen Sinn).
- ConsoleApplication: Option 'UseRuntime' hinzugefgt, die bestimmt, ob automatisch nach einer installierten
  PixelLight-Runtime gesucht werden soll, von der dann die Plugins und Datenpakete verwendet werden. Wie bisher
  kann das auch ber die Config-Option eingestellt werden, wenn diese gefunden wird, wird diese Flag entsprechend
  gesetzt.
- ConsoleApplication: Weitere virtuelle Methoden eingebaut, um dem Programmierer mglichst viele Mglichkeiten zu
  geben, das Standardverhalten der Applikation abzundern:
  - OnInitCmdLine() wird nach dem Parsen der Kommandozeile aufgerufen und ist dafr da, die gesetzen Optionen abzufragen
  - OnInitPlugins() wird nach dem Laden der Config aufgerufen und ist zum Laden der Plugins da
  - OnInitData() wird nach OnInitPlugins() aufgerufen und ist zum Setzen der Datenpfade da
- Methode ScanPackages() aus GuiApplication direkt nach LoadableManager verschoben. Da diese Funktion recht universell
  ist und sicherlich auch ausserhalb des Application-Frameworks verwendet werden kann, sollte sie auch gleich im
  LoadableManager vorliegen, auf dem sie ja auch operiert. Name und Kommentar analog zu ClassManager::ScanPlugins()
  angepasst.
- Core: Der Runtime-Pfad unter Linux ist nun erstmal festgelegt auf "/usr/share/pixellight/Runtime". Spter knnte
  man hier vielleicht noch anhand der aktuell verwendeten Bibliothek oder deren Version unterscheiden... (knnten
  ja theoretisch mal mehrere Runtimes gleichzeitig installiert sein)
- Folgende Config-Items von EngineGeneralConfig nach CoreConfigGroup verschoben, da sie universell fr alle
  Applikationen wichtig sind: UsePixelLightRuntime, FirstRun, LastCrashedMessage, LastCrashed, Language.
  Dabei LoadLibsFromRuntime in UsePixelLightRuntime umbenannt, da es hier nicht nur um die Libs geht (wobei man hier
  genauer von Plugins sprechen sollte), sondern gleichzeitig auch um die Daten im Runtime-Verzeichnis.
- Alles wichtige von GuiApplication nach ConsoleApplication verschoben.



>> 03.08.2010
[SB]
- System: GetCurrentDir() gibt das aktuelle Verzeichnis nun im Native-Format zurck statt wie bisher im URL-Format.
- System: Zustzlich zu GetUserHomeDir() gibt es nun auch noch GetUserDataDir(). Hier wird das Verzeichnis zurckgegeben,
  in das die Konfiguration der Applikation geschrieben werden soll. Unter Linux sind Home- und Data-Dir identisch,
  unter Windows wird hier der Ordner "Anwendungsdaten" im Home-Verzeichnis zurckgegeben.
PLCore:
- Application berarbeitet. Statt "About" gibt es nun "Version", welches man bei den meisten Applikationen als
  Kommandozeilenoption finden kann (-a fr about eher nicht). Die eigentliche Funktionalitt wurde von Run()
  in die virtuellen Methoden Init(), Main() und DeInit() verschoben, da es ansonsten fr abgeleitete Klassen
  nicht mglich ist, das Verhalten der Applikation zu modifizieren (z.B. wenn berhaupt kein Log geffnet oder
  die Kommandozeile nicht geparsed werden soll - das ist in der bisherigen Lsung nicht zu verhindern).
  Die Idee dabei ist, dass in den drei Methoden Init(), Main() und DeInit() das eigentliche Gerst fr die
  Ausfhrung der Applikation implementiert wird, dies wird also von der jeweilige Basisklasse (z.B. Application,
  GuiApplication oder SceneApplication) entsprechend modifiziert. Konkrete Programm-Applikationen dagegen sollten
  diese Methoden dagegen mglichst nicht mehr verndern mssen, sondern statt dessen nur einzelne Schritte verndern,
  welche in zustzlichen virtuellen Methoden bereitgestellt werden (z.B. OnRun(), OnInitLog() etc.). Diese
  Methoden werden von den Basisapplikationen aus aufgerufen. Nur wenn man wirklich grundlegend die Arbeitsweise
  der Applikation ndern will, muss man dann Main() etc. anpassen.
- Neue Application-Klasse in ConsoleApplication umbenannt. Diese nderung wollte ich sowieso machen, damit man nicht
  mehr stndig das Problem mit gleichen Namen hat, da wir die Klassen in konkreten Programm ja auch immer "Application"
  nennen, und das daher immer in Konflikt gert. Ausserdem wird es so leichter, die Klassen nach und nach umzustellen,
  da erstmal beides nebeneinander existieren kann.
- ConsoleApplication: Option m_bMultiUser hinzugefgt, mit der bestimmt wird, ob das Multi-User-Environment des Systems
  verwendet werden soll, oder nicht. In dem Falle wird immer zuerst versucht, z.B. Config oder Log-Dateien im
  entsprechenden User-Verzeichnis abzulegen, erst dann wird als Fallback z.B. das Application- oder das aktuelle
  Verzeichnis verwendet. Diese Option ist standardmig eingeschaltet und sollte wohl nur noch in Sonderfllen
  ausgeschaltet werden, da alle aktuellen Systeme mittlerweile darauf ausgelegt sind.



>> 02.08.2010
[SB]
- SystemLinux: GetProgramName() implementiert, so dass nun genauso wie unter Windows der absolute Pfad zur Bin-Datei
  zurckgegeben wird, gleichgltig von wo das Programm aufgerufen wurde. Der in args[0] bergebene Pfad ist leider
  relativ zur aktuellen Position und hilft daher nicht wirklich weiter, wenn es darum geht, den Pfad zu extrahieren
  um dann z.B. relativ dazu Datenpfade herausfinden zu knnen. Mittels der PID kann aber der absolute Pfad einer
  Applikation relativ leicht abgefragt werden. Dafr wurde nun SetProgramName() entfernt, da dies nur eine Notlsung
  war, damit den Wert aus arg[0] bergeben zu knnen.
- SystemLinux: GetUserHomeDir() scheint richtig zu funktionieren, daher eingebaut und TODO entfernt.
- System: GetProgramName() in GetExecutableFilename() umbenannt, da dies wesentlich eindeutiger ist.
- Log: ConsoleOutputActive in Verbose umbenannt. "Keep it simple" darf ruhig auch mal auf Namen angewendet werden :-)
- Log: Kommentare etwas berarbeitet.
PLCore:
- ApplicationContext hinzugefgt. Damit die Application-Klasse mglichst bersichtlich bleibt, sollten hier nicht
  so viele Daten und Methoden auf einem Haufen sein, denn das macht es immer gleich um einiges schwerer, den
  Aufbau einer Klasse zu verstehen. Die Laufzeit-Informationen der Klasse, also z.B. die wichtigen Verzeichnisse
  sowie die bergebenen Parameter, wurden daher in die neue Context-Klasse verschoben. Die Daten, die dagegen die
  Applikation selber bestimmen (wie z.B. Name und Titel) bleiben aber in der Klasse selbst.
- Application: Name hinzugefgt. Bisher gab es nur den Titel, der Name einer Applikation sollte aber auch noch
  gesetzt werden, da dieser meist krzer ist als der ausgeschriebene Titel. Wenn kein Name angegeben wird, so wird
  der Name aus dem Dateinamen der Applikation extrahiert (z.B. "TestApp.exe" -> "TestApp").



>> 01.08.2010
[SB]
- Eigene Versionsnummer von PLGeneral entfernt.
[SB]
PLCore:
- Config-Klassen in eigenes Verzeichnis "Config" verschoben. Bitte die Application-Verzeichnisse nicht immer mit
  zustzlichen Klassen belasten, insbesondere, wenn diese ganz locker auch fr sich selber stehen knnen.
- Timer-Klassen entfernt, da veraltet und zur Zeit sowieso nicht mehr verwendet. In PLGui liegen ja schon Timer-Klassen
  bereit, wenn man das also mal braucht, msste man sich nur noch einmal vernnftig berlegen, wie man darauf ausserhalb
  von PLGui am besten zugreifen knnte.



>> 24.07.2010
[SB]
- ConsoleLinux: Wenn Dateibefehle verwendet werden, um auf die Konsole zu schreiben, sollte der Dateipuffer immer geleert werden, damit die
  Ausgabe sofort erfolgt. Habe daher hier fflush(stdout) hinzugefgt.



>> 17.07.2010
[CO]
- "XmlNode::GetNextSiblingElement" & "XmlNode::GetFirstChildElement": Rckgabetyp sollte XmlElement und nicht XmlNode sein
PLCore:
- XML basierendes Chunk PixelLight Dateiformat hinzugefgt, Dateiendung ist "xchunk" statt "chunk" fr Binre Dateien



>> 15.07.2010
[CO]
- Bugfix in verschiedenen Projekten: Verwendung von XmlNode GetFirstChild/IterateChildren war Fehlerhaft da oft auf XmlElement
  gecasted wurde ohne vorher zu prfen ob es berhaupt XmlElement ist, im Falle von XmlComment bekam man so dann einen Crash
PLCore:
- Nachdem ich die letzten Stunden damit verbrachte die Projekte und Daten entsprechend anzupassen... Suchpfade wie besprochen
  aus dem Loadable Manager entfernt. Zuknftig muss man also z.B. "Data/Textures/MyTexture.dds" statt "MyTexture.dds" schreiben.



>> 07.07.2010
[CO]
- "String::GetUInt32()": Statt "atol" wird nun "strtoul" verwendet da sich scheinbar das Verhalten von "atol"
  unter Linux/Windows unterscheidet und z.B. unter Linux das umwandeln in uint32 nicht klappte wenn die Zahlen
  zu gro waren



>> 06.07.2010
[SB]
- Bug in FileLinux::IsFile() behoben.



>> 08.06.2010
[CO]
PLCore:
- LoadableManager::OnClassLoaded: Hier darf die Klasse wirklich nur in eine Liste eingetragen werden, da man noch nichtmal
  davon ausgehen kann das "IsDerivedFrom" immer funktioniert da z.B. eine bentigte Basisklasse erst etwas spter registriert
  werden knnte... das war bei mir unter Linux natrlich gerade der Fall, und dann war einfach der Loadable Type "Scene"
  unbekannt und es konnten keine Szenen eingeladen werden.



>> 02.06.2010
[SB]
PLCore:
- Bei der Verwendung von Enums im RTTI wird nun nicht mehr stur der Basistypus verwendet, da dies dazu fhren wrde,
  dass z.B. bei Methoden auch die Signatur so verndert wird, dass berall der Basistypus erwartet wird (Bsp.: Wird eine
  Methode, oder ein Event z.B. mit der Signatur(void, EnumType<EEnum>) angemeldet, so wrde fr die tatschliche Methode
  die Signatur (void, int) erwartet). Das ist verwirrend, daher wurde die Behandlung von Enums nun so verndert, dass
  jetzt berall der tatschliche Enum-Typus verwendet wird.
- Neuer Typ-Wrapper EnumTypePlain<> eingebaut, der fr direkte Enum-Typen verwendet wird, also solche, die nicht am
  RTTI angemeldet wurden. Wenn man nun bspw. Type<EEnum> schreibt, wird intern Type< EnumTypePlain<EEnum> > verwendet,
  welches es ermglicht, dieses als Typus im RTTI zu verwenden (dann hat man natrlich z.B. keine Umwandlung in Strings
  unter Verwendung der Enum-Namen, kann aber ansonsten diesen Typus wie gewohnt verwenden).
- RTTI-Makros fr Enums angepasst: Normale enums werden nun ohne den Basistypus deklariert, also z.B. pl_enum(EEnum)
  statt pl_enum(EEnum, int). Nur in dem speziellen Fall, dass "unechte" Enums z.B. mit floats erzeugt werden sollen,
  muss auch der Basistyp mit angegeben werden, hierfr kann nun das Makro pl_enum_direct() verwendet werden.
  Es ist zu beachten, dass der Name in enums nun nicht mehr vllig frei gewhlt werden kann, sondern immer der angegebene
  Typus unter dem exakten Namen auch existieren muss (also entweder ein echtes enum oder z.B. eine leere Klasse). Damit
  sind einige beabsichtigte oder unbeabsichtige Unstimmigkeiten, die es bisher gab (z.B. Enum hie EFlag wurde aber
  als EStyle angemeldet) nicht mehr mglich.



>> 01.06.2010
[SB]
PLCore:
- RTTI: Bei der Verwendung von Enums z.B. in Events kam es bislang noch zu Fehlermeldungen durch den Compiler.
  Der Grund dafr war, dass noch nicht berall konsequent die tatschlichen Typen verwendet wurden, welche von
  Type::_Type ermittelt werden (bei Var<T> war dies schon der Fall, aber bei allen Functoid- und Event-Typen noch nicht).
  Wenn bspw. ein Enum verwendet wird, ist der Typus ja EnumType<T> - dies ist aber nur ein Pseudo-Typus, der nicht wirklich
  verwendet werden darf (EnumType<T> als Parameter in einer Funktion ergibt keinen Sinn). Daher wird in Type::_Type der
  Typus auf den jeweiligen tatschlichen Typus gemappt, dieser Typus muss dann verwendet werden.
  Als Faustregel kann festgehalten werden: In Template-Parametern sollte immer der Eingabetyp unverndert weitergereicht
  werden, erst wenn es zur Verwendung kommt (z.B. als Variable oder als Funktionsparameter), muss dann der jeweilige
  korrekte Typ verwendet werden.



>> 30.05.2010
[SB]
PLCore:
- RTTI: Beim Einbinden von RTTI-Klassen in andere Projekte, kam es zu dem Problem, dass diese Klassen dann mehrfach
  am System angemeldet wurden, weil die entsprechenden Template-Klassen vom Compiler dann mehrfach instanziiert werden
  (in jedem Projekt, in dem die Klassen eingebunden werden, also nicht nur in dem Projekt, das sie exportiert).
  Aufgrund der RTTI-Makros ist es leider nicht einfach mglich, diese Templates dann zu exportieren, darum wurden die
  RTTI-Makros nun so erweitert, dass man wie bei DLL-Exports eine Definition dafr verwendet, um festzustellen, ob die
  jeweilige Klasse gerade importiert oder exportiert wird. Fr solche Projekte, die niemals in andere Projekte eingebunden
  werden (z.B. reine Plugins, die nur dynamisch ber das Plugin-System eingeladen werden, oder Applikation, die gar nicht
  in andere Projekte eingeladen werden), kann das Makro pl_rtti_export verwendet werden. Alle anderen Bibliotheken sollten
  im Header-Datei hnlich zu PLXXX_API ein Makro definieren, das jeweils auf 1 oder 0 gesetzt wird fr Import oder Export.
  Die Projekte wurden entsprechend umgestellt.



>> 27.05.2010
[SB]
PLCore:
- Workaround fr Linux bzw. GCC eingebaut, da es leider sonst folgenden, ziemlich dubiosen Linker-Fehler gibt:
    ../../../PLBase/PLCore/libPLCoreStat.a(ClassManager.cpp.o):
    In function `PLCore::Event<PLCore::Module const*, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType>::Emit(PLCore::Module const*) const':
    ClassManager.cpp:(.text._ZNK6PLCore5EventIPKNS_6ModuleENS_8NullTypeES4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_E4EmitES3_[PLCore::Event<PLCore::Module const*, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType>::Emit(PLCore::Module const*) const]+0x1a):
    undefined reference to `vtable for PLCore::Functor<void, PLCore::Module const*, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType>'
  Dieser Fehler ist wirklich sehr eigenartig, weshalb ich annehme, dass es sich um einen Fehler im Compiler handeln knnte:
    - Der Fehler tritt z.B. mit Event<Module*>, Event<int> und allen anderen Typen auf
    - Der Fehler tritt *nicht* mit Event<Class*> auf, den Grund hierfr konnte ich aber nicht finden
    - Der Fehler tritt auf, sobald der Operator () vom Functor aufgerufen werden soll
    - Sobald der entsprechende Functor<T> in der Klasse Event oder in einer Methode instanziiert wird, verschwindet der
      Fehler. Es muss aber eine richtige Instanz sein, eine Typendeklaration, ein Zeiger oder eine Referenz reichen hier
      nicht aus, was wirklich eigenartig ist
    - Wenn statt des Functor()-Aufrufes eine neue Methode im EventHandler eingebaut wird, die wiederum Functor()
      aufruft, tritt der Fehler ebenso auf und kann ebenso behoben werden, indem dann in der neuen Methode innerhalb von
      EventHandler der Functor instanziiert wird. Komischer Weise reicht hier aber eine Instanziierung innerhalb der Klasse
      dann nicht mehr aus (zumal hier ja der Functor auch bereits instanziiert wird!).
  Es scheint also so, als ob unter bestimmten Voraussetzungen die Template-Klasse vom Compiler nicht richtig instanziiert
  wird, weshalb es dann zu dieser wenig hilfreichen Fehlermeldung kommt (diese Fehlermeldung wird normaler Weise darauf
  zurckgefhrt, wenn z.B. eine virtuelle Methode, meist z.B. ein virtueller Destruktor, nicht implementiert wurde. Dies
  scheint mir hier aber nicht der Grund zu sein, zumal hier der Zusammenhang mit Templates besteht. Darum und aufgrund
  der unlogisch wirkenden Verhaltensweisen des Fehlers, halte ich einen Compiler-Bug fr mglich).
  -> Als Workaround wird nun der Functor in der Emit-Methode einmal statisch instanziiert. Habe dafr im CMake-Projekt
  auch gleiche eine neue Prprozessor-Definition eingefgt, die mitteilt, wenn der GCC zum Compilieren verwendet wird
  (ifdef LINUX wre hier eigentlich falsch, darum lieber ifdef GCC, zumal man theoretisch auch den GCC fr Windows
  verwenden kann).
- CMake-Projekt so angepasst, dass PLCoreStat nur noch von PLGeneralStat abhngig ist, und nicht mehr wie bisher von
  PLGeneral.
- ClassManager::GetClasses() gibt nun keine Liste mehr zurck, sondern fllt eine bergeben Liste, um unntige Kopier-
  operationen zu vermeiden.



>> 27.05.2010
[CO]
- Log liegt wieder in PLGeneral. Diesmal allerdings in einem eigenen "Log" Verzeichnis und nicht ans RTTI angeschlossen.
  "LogFormaterConsole" entfernt, das Log kann auf Wunsch nun direkt in die Standard OS Konsole schreiben.
PLCore:
- Log liegt wieder in PLGeneral
- "Application::Run": Hier wird nun das Log anhand von Kommandozeilen Parametern initialisiert, ich denke es ist das beste das
  direkt hier zu machen statt z.B. erst in "PLGui::GuiApplication"
- "Application::OnPrintVersion()" in "Application::OnPrintAbout()" umbenannt damit es keine Konflikte mit "v" als Kommendozeilen
  Parameter fr "Verbose" gibt (uh, "v" scheint nen Standard-Parameter zu sein http://de.wikipedia.org/wiki/Verbose :)



>> 25.05.2010
[SB]
- String::GetUInt64(): _wtoi64 gibt es leider unter Linux nicht. Habe da nun statt dessen wcstoumax() verwendet,
  welches hoffentlich die richtige Funktion dafr ist. Leider gibt es die wiederum unter Windows nicht, jedenfalls
  konnte ich das nicht finden, obwohl es eigentlich zum ISO-Standard gehren sollte, und musste darum hier leider
  eine Fallunterscheidung einbauen.



>> 24.05.2010
[CO]
- Bugfix: "ElementManager<AType>::SetElementName": Umbenannte Elemente sollten nur in m_mapElements eingefgt werden, wenn
  diese kurz zurvor ausgetragen wurden
PLCore:
- Bugfix: "ResourceManager<AType>::SetResourceName": Umbenannte Elemente sollten nur in m_mapResources eingefgt werden, wenn
  diese kurz zurvor ausgetragen wurden



>> 23.05.2010
[CO]
- Da der Typ "handle" als "unsigned int" definiert ist, ist es unter 64 Bit bersetzt, 64 Bit statt 32 Bit gro.
  "INVALID_HANDLE" wird daher nun 32/64 Bit abhngig definiert. (scheinbar nur fr Windows ntig)



>> 22.05.2010
[CO]
- String Klasse um Operatoren fr uint32 und uint64 erweitert. Unter Windows nutzte ich dafr die Erweiterungen "I32"
  und "I64", unter Linux einfach nur "u" und "llu" - habe im Code fr Linux als Kommentar alternativen eingefgt die
  man eventuell noch testen knnte.
PLCore:
- "Type<T*>", "Type<T&>" und "Type<Object*>": ConvertToString/ConvertFromString arbeitet nun mit uint32/uint64.
  ber die Definition "X64_ARCHITECTURE" wird bei uns festgelegt das es 64 Bit ist, "X64" war mir dann Namenskonflikt
  mig doch etwas zu Riskant. :D



>> 21.05.2010
[SB]
PLCore:
- TypeInfo: Neben IsEnumType() gibt es nun ebenfalls IsFlagType(), um Flags von Enums unterscheiden zu knnen.
  Im Falle von Flags gibt IsEnumType() nun dort auch 'false' zurck - das scheint mir ein wenig logischer, natrlich
  muss man hier aber wissen, dass auch bei IsFlagType() == 'true' die Methoden zum Auslesen der Enums natrlich
  funktionieren. Mann knnte das auch anders herum machen, so dass IsEnumType() in beiden Fllen 'true' zurckgibt, dann
  wrde man "Flag" sozusagen als Sonderfall von "Enum" ansehen. Momentan habe ich es aber wie oben beschrieben gelst.
- Class: ClassName (Name mit Namespace) wird nun noch gesondert als String gespeichert, damit beim Zugriff darauf nicht
  immer dynamisch neue Strings zusammengestellt werden mssen.
- Log, LoadableManager und Localization: Template-Instanz so verndert, dass es sich auch mit gcc compilieren lsst.
  Bei so einer expliziten Instanziierung von Templates ist zu beachten, dass es nicht erlaubt ist, diese innerhalb
  eines fremden Namespaces vorzunehmen. Da Singleton zum namespace PLGeneral gehrt, muss also eine Spezialisierung
  innerhalb von PLGeneral oder ausserhalb aller Namespaces vorgenommen werden, aber *nicht* z.B. innerhalb von PLCore.
  Wie so oft geht dies zwar unter VC, unter z.B. dem gcc aber nicht, daher sollte hier in Zukunft darauf geachtet werden,
  Template-Instanziierungen immer ausserhalb fremder Namespaces vorzunehmen.



>> 20.05.2010
[CO]
- Das alte RTTI aus PLGeneral entfernt... manohman, das waren 2 verdammt heftige Wochen. Im groen und ganzen luft nun alles
  wieder, natrlich steht nun noch weiteres Bugfixing an bis alles wieder so rund luft wie vor der groen Umstellung. Interessant
  ist, dass es am Ende nun wirklich 2 Wochen Arbeit waren, so wie am Anfang pi*daumen geschtzt. *g*
PLCore:
- LoadableManager: Neue Klassen werden erst dann, wenn diese bentigt werden korrekt Eingetragen. Trgt man sofort bei
  erhalten des ClassManager::EventClassLoaded Ereignisses ein, so kann es sein das eine Klasse noch nicht vollstndig
  initialisiert ist und dann die Loader Registierung nicht klappt.
- LoadableType speichert nun ebenfalls die RTTI Klasse von der alle Loader Implementationen dieses Types abgeleitet sein
  mssen. Diese Klasse wird z.B. in Loadable verwendet um zu sehen ob der Loader Typ, der ber eine Dateiendung ermittelt
  wurde, wirklich zum Loadable Typ passt der gerade eingeladen werden soll... sonst knnte man einem Mesh sagen es solle
  sich doch bitte aus diesem Bild hier laden - klar, probieren kann ich es als Benutzer immer noch, das System grinst mich
  in dem Fall aber nur dmlich an. *g*



>> 19.05.2010
[CO]
PLCore:
- Loadable System von "PLGeneral::Parameters" befreit. Gestern Abend schwierte mir im Kopf eine Loader-Lsung herum die mit
  RTTI Methoden arbeitet, heute in aller frh setzte ich das mal um und passte entsprechend alle Loader an. Das Ergebnis
  gefllt mir sogar... Die einzelnen Loader-Basis Klassen wie z.B. "ConfigLoader" sind nun superschlank, ja praktisch leer.
  Die konkreten Loader-Implementationen wie z.B. "ConfigLoaderPL" sind nun ebenfalls etwas schlanker da dort keine Dynamischen
  Parameter mehr geparst werden. Es gibt nun einfach ffentliche Load/Save Methoden, die man also auch ganz ohne RTTI nutzen kann.
  Ebenfalls kann es LoadParams/SaveParams Methoden geben - wenn ein Format noch besondere Optionen anbietet, wie z.B. welche
  Kompression beim Speichern verwendet werden soll. Wenn man es ganz wild treiben will, kann man die Methoden Namen auch frei
  whlen, beim Resourcen-Laden muss man dann allerdings die Methoden Namen angeben. Es stehen nun also deutlich mehr Nutzungsmglichkeiten
  zur Verfgung und die Implementationen sind schlanker geworden + man kann in den RTTI Methoden Kommentaren nachlesen was es
  fr weitere besondere Format abhngige Parameter gibt und was die machen.



>> 17.05.2010
[CO]
- PixelLight ist nun soweit auf das neue RTTI umgestellt, nun folgen nur noch Aufrumarbeiten & Bugfixing
- "Log" von PLGeneral nach PLCore verschoben
PLCore:
- "Log" von PLGeneral nach PLCore verschoben



>> 16.05.2010
[SB]
PLCore:
- ClassManager: GetClasses() kann nun auch nur Klassen aus einem bestimmten Modul zurckgeben. Damit ist diese Methode
  nun immer mehr zur zentralen Such-Funktion fr Klassen geworden, was ich auch ganz sinnvoll finde. Kommentare an
  anderen Stellen eingefgt, um auf diese zentrale Suchfunktion hinzuweisen.



>> 16.05.2010
[CO]
PLCore:
- PLCore::Object::IsInstanceOf in der Art erweitert das ebenfalls "true" zurckgegeben wird wenn die beiden zu testenden
  Klassen identisch sind



>> 15.05.2010
[SB]
PLCore:
- RTTI: Ein mit ModifyAttr berschriebenes Attribut setzt nun den Default-Value in Abhngigkeit vom Storage-Type
  des Basis-Attributes. Wenn das Basis-Attribut also den GetSet-Storage gesetzt hat, wird auch im berschriebenen
  Attribut der Default-Wert *nicht* mehr gesetzt, so dass es nicht mehr zu Problemen im Konstruktor kommen sollte.
  Ist dagegen DirectValue als Basis-Storage gesetzt, so wird der Default-Wert gesetzt, da es hier keine Probleme gibt.
  Ich habe es zwar noch nicht ausprobiert, aber das ganze sollte auch ber beliebig viele Ebenen funktionieren,
  da der StorageType der Basisklasse hier jeweils durchgereicht wird :-)
- Constructor: IsDefaultConstructor() eingebaut
- Class: HasConstructor() und HasDefaultConstructor() eingebaut
- Class: IsDerivedFrom() gibt nun bei der eigenen Klasse "false" zurck, damit der Name exakt stimmt
- ClassManager: GetDerivedClasses() akzeptiert nun mehrere Parameter, mit denen man bestimmten kann, ob die Basisklasse
  selbst mit aufgefhrt werden soll, ob rekursiv oder nicht rekursiv gesucht wird, sowie ob abstrakte Klassen, also solche
  ohne Konstrukturen, mit aufgefhrt werden sollen oder nicht.
- Class und ClassManager: Das Auflisten der abgeleiteten Klassen wurde noch einmal grndlich berarbeitet. Es ist nun die
  von Christian eingebaute Lsung, die nur auf den Namen operiert, verwendet worden, da mir aufgefallen ist, dass das
  InitClass()-Schema in Bezug auf abgeleitete Klassen ja gar nicht richtig funktionieren kann. Denn wenn die Klasse
  initialisiert wird, trgt sie sich zwar in die Liste ihrer Basisklasse ein, aber damit kann man ja noch nicht sicherstellen,
  dass die eigenen abgeleiteten Klassen bereits initialisiert wurden. Die Liste an abgeleiteten Klassen bleibt also leer,
  da man die entsprechenden Klassen vorher initialisieren msste, womit sich die Katze in den Schwanz beit ;-)
  Darum wurde die Liste von abgeleiteten Klassen nun aus Class entfernt, statt dessen wird die Suchmethode aus
  ClassManager verwendet, um an die Liste von abgeleiteten Klassen zu kommen, wenn diese abgefragt wird.
- ClassManager: GetDerivedClasses() in GetClasses() umbenannt.



>> 14.05.2010
[SB]
PLCore:
- NullType nach TypeTraits.h verschoben
- InvalidType in TypeTraits.h hinzugefgt. Dies ist ein Template, das alle nicht untersttzten Typen reprsentiert
- TypeTraits: Einige Templates hinzugefgt, um den Typus eines, h, Typus festzustellen:
  - IsConvertible, mit dem man feststellen kann, ob zwei Typen ineinander konvertierbar sind.
  - IsEnum, mit dem man feststellen kann, ob es sich bei einem Typen um ein enum handelt
  - TypeClassification, welches Informationen ber den Typus in Form von bools in einer Klasse speichert
  - CheckType, welches den geeigneten Typus fr nicht-standard-Typen auswhlt (z.B. <int> fr enums)
  - IsBaseClass, welches ermittelt, ob eine Klasse eine Basisklasse einer anderen Klasse ist
  - CheckBaseClass, welches einen Compiler-Fehler hervorruft, wenn eine Klasse nicht von einer Basisklasse abgeleitet ist
- Type und DefaultValue: Es werden nun die neuen Templates verwendet, um neben den Standardtypen weitere, nicht-standard-Typen
  zu untersttzen. So werden nun z.B. auch enums untersttzt, in diesem Falle wird der Typus einfach wie ein int behandelt.
  So etwas wie Event<EEnum> sollte daher nun verwendet werden knnen.
- RTTI: Es wird nun ein Compilerfehler erzeugt, wenn im RTTI-Makro nicht angegebene Klasse nicht von der angegebenen
  Basisklasse abgeleitet wurde. Damit werden nun Fehler leichter entdeckt, z.B. wenn die Klasse selbst als Basisklasse
  angegeben wurde etc. Was allerdings noch nicht entdeckt werden wrde, wre z.B., wenn zwar eine korrekte Basisklasse
  angegeben wurde, dazwischen aber noch weitere Klassen sind (z.B. A->B->C, und es wird angegeben, C sei von A abgeleitet!).



>> 11.05.2010
[CO]
PLCore:
- Bis auf SceneNode und SceneNodeModifier ist nun alles auf das neue PLCore2 umgestellt, also Klassenmig Halbzeit :D
- Wie in einer EMail besprochen: "type_flag" in "pl_flag_type", "type_enum" in "pl_enum_type" und "ret_type" in "pl_ret_type" umbenannt



>> 08.05.2010
[SB]
PLCore:
- TypeTraits.h hinzugefgt: Hier wird es einige generelle templates geben, um Abfragen auf Typen zur Compile-Time
  zu ermglichen.
- Rtti.h: Es waren noch einige nderungen notwendig, damit das Projekt wieder mit gcc zu compilieren ist. Die
  erzeugten Storage-Templates fr ein Attribut sind so geschrieben, dass sie nur valide sind, wenn der entsprechende
  Storage-Type auch wirklich ausgewhlt wurde (es gibt z.B. keine Methoden GetMyVar()/SetMyVar(), wenn MyVar nicht
  mit dem Storage-Typus GetSet deklariert wurde). Im template-code wurde jedoch fr jedes Attribut das entsprechende
  Template verwendet, wenn auch nur als Typus fr andere Templates, wo es spter verworfen wurde. Fr den gcc reicht
  dies jedoch aus, um das Template zu spezialisieren, was natrlich zu einem Fehler fhrt. Aus diesem Grunde wird
  nun das template SpecializeIfEqual<> verwendet, welches eine Template-Class nur dann spezialisiert, wenn eine
  bestimmte Bedingung erfllt ist. Damit lsst sich PLCore2 nun auch unter Linux wieder compilieren.
- IntegralType nach TypeTraits.h verschoben
- Traits.h entfernt



>> 07.05.2010
[CO]
- "Chunk" und "Localization" samt dazugehrigen Klassen von PLGeneral nach PLCore verschoben da hier RTTI Funktionalitt
  bentigt wird die zuknftig erst ab PLCore zur Verfgung steht. Habe das erstmal in einem "Tools"-Unterordner gelassen.
- "Loader"/"Loadable" von PLGeneral nach PLCore verschoben
- "Resource" von PLGeneral nach PLCore verschoben
PLCore:
- "Chunk" und "Localization" samt dazugehrigen Klassen von PLGeneral nach PLCore verschoben da hier RTTI Funktionalitt
  bentigt wird die zuknftig erst ab PLCore zur Verfgung steht. Habe das erstmal in einem "Tools"-Unterordner gelassen.
- "Loader"/"Loadable" von PLGeneral nach PLCore verschoben
- "Resource" von PLGeneral nach PLCore verschoben
- Wie schon bei PLGeneral, hat nun auch PLCore eine statische Version da z.B. PLProject und der 3ds Max Exporter nun PLCore
  bentigen, aber nicht von einer dll abhngig sein sollten. Hoffentlich hab ich "CMakeLists.txt" korrekt erweitert, naja
  werds sptestens beim nchsten PL SDK bersetzen merken. *g*



>> 06.05.2010
[CO]
PLCore:
- Umstellung von PixelLight auf PLCore2 begonnen
- "Core", "ThreadTimer", "Timer", "TimerImpl", "TimerWindows", "Config", "ConfigLoader", "ConfigLoaderPL", "CoreConfigGroup"
  vom alten PLCore ins neue kopiert damit sich die Umstellarbeiten auf das neue RTTI Konzentrieren knnen.
- Params um Copy-Constructor und Copy-Operator erweitert da ansonnsten an einigen Stellen der VisualStudio Team Edition Compiler
  Warnungen ausgab, whrend der *normale* VisualStudio Compiler nix sagte



>> 05.05.2010 (PLCore2)
[SB]
- RTTI: pl_enum_end() in pl_enum_end gendert
- RTTI: Fehler in pl_enum() behoben - wenn der Wert 0 definiert war, funktionierte die Umwandlung von Name->Wert nicht
  mehr, da hier eine Abfrage fehlte.
- RTTI: Die Behandlung von Flags und Enums musste noch einmal grndlich berarbeitet werden, da es bspw. so nicht
  mglich war, Enums in einer Klasse zu definieren und in der gleichen Klasse auch gleich zu verwenden. Daher habe
  ich die interne Verwaltung von Enums nun so verndert, dass das enum nicht mehr durch eine Spezialisierung
  von PLCore2::EnumType<> definiert wird, sondern statt dessen eine einfache Klasse erzeugt wird, die dann als
  Template-Parameter weitergereicht wird. Das vereinfacht vieles und bedeutet letztlich fr die Anwendung:
  - pl_enum() kann nun prinzipiell berall verwendet werden. Auch in Namespaces, und auch in Klassen :-)
  - pl_enum_value_namespace() wurde deswegen wieder entfernt, da es nicht mehr bentigt wird
  - pl_enum_value_direct() wurde hinzugefgt, dies kann verwendet werden, wenn der zu definierende Enum-Typ kein echter
    C++-Enum-Typ ist - letztlich kann dies verwendet werden, um beliebige Definitionen zu machen. Anwendungsfall sollte
    vor allem sein, wenn man enum definieren will, die nicht den Datentyp 'int' haben (z.B. float)
  - berall, wo man auf ein enum zugreifen will, muss man nun zwanglufig auch das Makro type_enum() verwenden,
    da dies jetzt nicht mehr nur ein PLCore2::EnumType< > um den Namen legt, sondern auch den Namen so verndert,
    dass auf die erzeugte RTTI-Enum-Klasse verwiesen wird.
  - Fr den direkten Zugriff auf RTTI-Enums ist jetzt die Klasse PLCore2::EnumType< > zustndig. Wie eben erwhnt muss
    hier immer type_enum() verwendet werden, um also z.B. die Anzahl an Elementen eines enums abzufragen, benutzt man
    also: type_enum(EnumName)::GetNumOfEnumValues();
- Bespiele fr Enums erweitert: U.a. Verwendung von Enums in Klassen und Definition von float-enums.
- RTTI: Die Basisklasse muss in pl_class() nun ohne Anfhrungszeichen angegeben werden.
- VarAccess und VarStorage noch einmal grndlich berarbeitet und ein wenig berschaubarer gemacht. Der zugrunde
  liegende Storage-Typ (z.B. StorageDirectValue oder StorageGetSet) wird nun so weit wie mglich mitgereicht,
  damit dann an letzter Stelle das jeweilige Template anhand der Klasse entscheiden kann, was zu tun ist. Auch
  der StorageChoose wurde entsprechend umgendert.
- Neben StorageDirectValue und StorageGetSet gibt es nun noch einen weiteren Storage-Typ: StorageModifyAttr.
  Dieser Typus kann verwendet werden, um Variablen in abgeleiteten Klassen zu berschreiben, und dabei in die gleiche
  Variable zu schreiben. Es wird also eigentlich die Variable der Basisklasse verwendet, jedoch im RTTI die Daten aus
  der abgeleiteten Klasse verwendet (z.B. Default-Value, Enum etc.). Wenn dies verwendet werden soll, muss daher der
  Typus der Variablen in der Basisklasse und in der abgeleiteten Klasse identisch sein. Wenn statt dessen StorageDirectValue
  verwendet wird, ist es zwar auch mglich, Variablen zu berschreiben und dabei den Typus zu ndern, dies sind dann
  jedoch in Wirklichkeit zwei Variablen, die nur den gleichen Namen haben.
- Beispiel fr das berschreiben von Variablen hinzugefgt.
- RTTI: Auf vielfachen Wunsch einer einzelnen Person kann nun bei Enums zu jedem Wert auch noch eine Beschreibung
  mit angegeben werden. Diese kann bei statischem Zugriff ber EnumType<T>::GetEnumDescription(sName), oder bei
  dynamischem Zugriff ber DynTypeInfo::GetEnumDescription(sName) abgefragt werden.
- Var: Methode Default() hinzugefgt. Die Methode gibt direkt den Default-Wert zurck, benutzt also direkt den
  jeweiligen Datentyp. Wie bei Get() und Set() ist diese Methode nur vorhanden, wenn man direkten Zugriff auf die
  Variable hat. ber DynVar gibt es die Methode GetDefault(), welche den Default-Value als String zurckgibt (ist
  nicht anders mglich, da hier der tatschliche Datentyp noch nicht bekannt ist).



>> 04.05.2010 (PLCore2)
[SB]
- Var: Es kann jetzt auch der Default-Konstruktor verwendet werden.
- RTTI: 'pl_enum'-Makro erweitert, so dass die dadurch erzeugte EnumType-Klasse ein wenig mehr Komfort bietet.
- RTTI: 'pl_enum_base' eingebaut. Mit diesem Makro knnen bei der Deklaration eines Enum-Typs alle Werte eines anderen
  Enums bernommen werden, hiermit knnen also Datentypen "erweitert" werden.
- RTTI: Neben 'pl_enum_value' gibt es nun auch 'pl_enum_value_namespace', das verwendet werden kann, wenn der enum-Typ
  innerhalb eines Names (oder auch einer Klasse) liegt. RTTI-Enums mssen immer im globalen Scope deklariert werden,
  also auch ausserhalb von namespaces, hiermit knnen jedoch dann auch solche Enums angemeldet werden, die selbst
  innerhalb eines namespaces liegen.
- Neue Klassen DynTypeInfo und TypeInfo erstellt. Diese sind im Gegensatz zu den Type<>-Klassen nicht statisch, sondern
  haben ein virtuelles Interface und knnen daher dynamisch (polymorph) verwendet werden. Dies wird wohl so aussehen,
  dass man von einer Variable per GetTypeInfo() eine Referenz auf ein solches TypeInfo-Objekt zurckbekommt, und
  davon dann noch einmal die wichtigsten Typen-Informationen abfragen kann. Hier noch einmal die ganzen Konvertierungs-
  funktionen einzubauen, scheint mir nicht sinnvoll, zumal man dies auch direkt innerhalb von Var machen kann, und
  es ausserdem hier schwierig wird, da der tatschliche Typ ja nicht bekannt ist. Deshalb kann man hier erstmal nur
  noch einmal Typ-ID und Namen abfragen.
- Var: GetType() hinzugefgt, welche eine statische Instanz von TypeInfo<T> fr den jeweiligen Daten zurckgibt.
- DynTypeInfo: Es kann nun neben dem eigentlichen Datentyp auch abgefragt werden, ob es sich um einen Enum-Datentyp
  handelt (Enum und Flag ist auf dieser Ebene das gleiche). Falls ja, kann abgefragt werden, welche Enum-Werte es gibt,
  hier bekommt man dann eine Liste von Namen zurck. Es ist leider nicht mglich, hier auch gleich die Werte fr
  die Enum-Namen abzufragen, aus dem Grunde, dass hierfr ja der Datentyp bekannt sein msste. Um das zu erreichen,
  muss man also entweder Zugriff auf den jeweiligen Header haben und EnumType<ENUM> verwenden, oder den Umweg ber
  eine Variable gehen, da man ja nun die Namen kennt, die man setzen kann.
- DynTypeInfo: Methode GetEnumValue() hinzugefgt, mit der man nun doch auf den Wert eines Enum-Names zugreifen kann,
  allerdings nur als String (s.o., der Typus ist hier nicht bekannt). Das sollte jedoch helfen, um z.B. in einem Dialog
  neben dem Enum-Namen auch dessen Wert anzeigen zu knnen.
- Object: Umbenennung der Methoden, um mehrere oder alle Attribute eines Objektes gleichzeitig setzen oder auslesen
  zu knnen in SetValues()/GetValues() und SetValuesXml()/GetValuesXml(). Auch wenn man hier letztlich auf Attribute
  zugreift, sind diese Methoden mehr als reine zugriffsmethoden auf Attribute und stellen den Kern des RTTI dar. Daher
  sollten diese Methoden von den anderen Attribut-Methoden getrennt sein und zudem einen mglichst einfachen und gut
  zu merkenden Namen haben :-)
- Object: Methoden SetAttributeDefault() und SetDefaultValues() hinzugefgt. Diese Methoden setzen einen bzw. alle
  Attribute auf ihren jeweiligen Default-Wert.



>> 29.04.2010 (PLCore2)
[SB]
- Klassen knnen nun noch zustzliche Properties haben, also Key/Value-Pairs, die an einer *Klasse* (!) dranhngen
  und zur Laufzeit abgefragt werden knnen. Dies dient dazu, zustzliche Infos zu einer Klasse bereitzuhalten, bspw.
  knnen Loader so bekannt geben, welche Dateitypen sie untersttzen oder eine Klasse kann beliebige andere Infos
  ber sich preisgeben. Properties knnen in abgeleiteten Klassen berschrieben werden. Definiert werden Properties
  ber das neue Makro pl_property. Leider mssen alle Properties innerhalb von pl_properties und pl_properties_end
  eingeklammert werden - anders war das mit den RTTI-Makros leider nicht zu lsen, ohne dass es unntig kompliziert
  geworden wre.
- RTTI: Analog zu 'pl_properties' und 'pl_properties_end' heit es nun 'pl_class_end' anstelle von 'pl_class_end()',
  da es so einfach irgendwie netter aussieht.



>> 24.04.2010 (PLCore2)
[CO]
- Im "pl_module"-Makro "Unknown" Initialisierungen eingebaut da ansonnsten durch "ClassManager::RegisterModule" die
  Module Initialisierungen komplett berschrieben werden und am Ende wieder leere Strings vorhanden waren :/



>> 23.04.2010 (PLCore2)
[CO]
- Params: "DefaultValue<x>::Default();" eingefgt + Rckgabewert im Konstruktor initialisiert



>> 23.04.2010 (PLCore2)
[SB]
- DynFunc, Func: Call(DynParams &cParams) erwartet ein Params-Objekt, welches nicht const ist. Unter Windows wird dies
  scheinbar auch akzeptiert, wenn man z.B. Call(Params<int, int>(10)) aufruft - zwar geht hier natrlich z.B. der
  Rckgabewert verloren, aber der Aufruf findet dennoch statt, und theoretisch kann man das auf dem Stack befindliche
  Params-Objekt wohl auch manipulieren, auch wenn man davon natrlich im Nachhinein nichts mehr hat, weil man es nicht
  wieder auslesen kann :-) Unter Linux mit dem aktuellen gcc klappt dies allerdings nicht, hier wird ein so bergebener
  Parameter wohl grundstzlich als const angesehen. Aus diesem Grund musste ich leider zustzlich noch eine zweite
  Methode hinzufgen: Call(const DynParams &cParams). Die macht natrlich das gleiche wie im nicht-const Fall, mit
  dem Unterschied, dass hier keine Rckgabewerte geschrieben werden. Deswegen musste diese Methode nicht nur in DynFunc,
  sondern auch in allen 34 Spezialisierungen von Func<T> implementiert werden :-( Sollte jemandem hier eine einfachere
  Lsung einfallen, bitte Bescheid sagen...
- DynEvent, Event: Gleiche Problematik wie bei DynFunc, Func. Da Events jedoch niemals einen Rckgabewert haben knnen,
  reicht es hier aus, wenn die Parameter immer als const bergeben werden. Emit(DynParams&) wurde also berall zu
  Emit(const DynParams&) gemacht.
- Constructor: Auch hier die gleiche Problematik. berall wo ntig wurde daher Create(DynParams&) in Create(const DynParams&)
  gendert. Auch an allen anderen Stellen, z.B. Object und Class, wurden nun wenn ntig zweite Varianten der jeweiligen
  Methoden hinzugefgt, damit man berall Parameter sowohl const als auch nicht-const bergeben kann.
- Func: Bei den nderungen gab es noch einige kleinere Fehler, wo einfach von const nach non-const gecastet wurde, was
  hier definitiv nicht erwnscht ist. Nun habe ich hoffentlich alles erwischt (bitte nochmal drber schauen!)
- Constructor: Hier gab es sogar ein noch greres Problem, weil zwar der Aufruf im Prinzip nur ein const-Parameters
  bentigt, jedoch der Rckgabewert in diesem Fall ja intern verwendet wird. Ich habe das nun so gelst, dass an einen
  Constructor immer const-Parameters bergeben werden, diese intern aber kopiert werden und somit ein non-const
  Parameters-Objekt entsteht, welches an den Functoid weitergegeben wird. Dort ist dann der Rckgabewert, also der Zeiger
  auf das neu erstellte Object, als Return-Value gespeichert, welches dann wiederum zurckgegeben werden kann. Nach
  meinen bisherigen Tests scheint das auch zu funktionieren, besonders schn ist die Lsung natrlich nicht.
- ClassManager und Class: Methode GetModule() eingebaut.
- ClassManager: Es wird nun bei duplizierten Klassennamen (Konflikten zwischen zwei Klassen gleichen Namens und
  Namespaces) eine Warnung ins Log geschrieben.
- Module: Name, Beschreibung usw. werden nun alle mit "Unknown" initialisiert. Sollte ein Projekt also nicht die Makros
  nutzen, um Infos ber das Modul zu setzen, wird dieses in der Liste und z.B. im Log als "Unknown" auftauchen
- RTTI: Makro pl_current_module_id() hinzugefgt als Shortcut, um die ID des aktuellen Modules abzufragen.
- RTTI: Slots werden nun, genauso wie Methoden, beim Anmelden am RTTI umbenannt. Fr den Slot "OnMyEvent" wird also
  jetzt ein Objekt namens 'SlotOnMyEvent' angelegt, dafr wird der aufgerufenen Methode kein automatisches "On" mehr
  vornangestellt. Dies ist nun konsistent mit den Methoden, man gibt also einfach auch beim Slot den Namen der Methode
  an, die aufgerufen werden soll, und erhlt ein Feld mit 'Slot' davor. Als Konvention fr uns wrde ich vorschlagen,
  dass alle Slots immer der Konvention "On[EventName]" folgen sollten.



>> 22.04.2010 (PLCore2)
[SB]
- Functor: Einige Fehler in den partiellen Spezialisierungen behoben (R statt void)
- DefaultValue: Fehlende Datentypen nachgetragen.
- Class, Object, RTTI: Wie Christian richtig anmerkte, war die Verwendung von Event/Signal und EventHandler/Slot noch
  nicht konsequent umgesetzt. Habe das nun behoben, es sollte nun also vllig analog sein zu Attributes und Methods.
- DynEvent: virtual void Emit(DynParams&) war nicht als const deklariert - in den abgeleiteten Klassen aber schon, wodurch
  die virtuelle Funktion nicht korrekt berschrieben wurde (sondern das natrlich als neue Funktion galt).
- Class: GetAttribute(), GetMethod() etc. geben nun const-Zeiger auf die jeweiligen Descriptoren zurck. Zwar geschehen
  dann zwischenzeitlich const-casts, da man letztlich von dem Descriptor ja auch wieder auf das jeweilige Member-Objekt
  kommen kann, aber ich denke, das ist hier ok. Das mit const ist nicht immer so ganz sauber hinzubekommen, frchte ich.



>> 21.04.2010 (PLCore2)
[SB]
- Fehler behoben, die beim bersetzen mit gcc unter Linux aufgedeckt wurden.
- PLCore2 lsst sich nun unter Linux bersetzen.



>> 15.04.2010 (PLCore2)
[SB]
- Class: Die Namen etc. mssen nun direkt im Konstruktor bergeben werden, da ansonsten die Klasse bereits
  angemeldet wird, bevor ihre Daten gesetzt wurden, der Name ist also leer. Makros etc. entsprechend angepasst.
- Func: Einige Warnungen behoben
- Object: Wir nun auch beim RTTI angemeldet



>> 14.04.2010 (PLCore2)
[SB]
- RTTI-Makros: Probleme behoben, die auftraten, sobald das RTTI ber mehr als eine Bibliothek hinweg verwendet wurde.
  Dies fhrte zu unaufgelsten externen Referenzen, diese Probleme wurden nun durch leichte nderungen im RTTI behoben
  (hoffentlich auch fr andere Compiler zu gebrauchen).
- RTTI-Makros: Die Basisklasse kann nun auch mit angegeben werden (*hust*)
- Basisklasse Config erstellt (noch leer).
- Basisklasse Application erstellt (noch leer).



>> 13.04.2010 (PLCore2)
[SB]
- Klasse Module erstellt, welche die Informationen ber ein Modul speichert. Fr jedes Module (Applikation/Bibliothek) wird
  automatisch eine Instanz von Module erstellt und beim ClassManager angemeldet. Ein Module beinhaltet dann bspw. auch eine
  Liste aller Klassen, die zu diesem Modul gehren.
- Funktionalitt zum Laden und Verwalten von Plugins hinzugefgt.
- Type-Wrapper fr Pointer-Typen hinzugefgt.
- ClassManager: Events hinzugefgt fr das Anmelden/Abmelden von Klassen und Modulen. Dies kann z.B. verwendet, wenn eine
  Komponente darber informiert werden muss, wenn es neue Klassen von einer bestimmten Basisklasse gibt etc.
- RTTI: Eine Makros hinzugefgt, die zwar nicht notwendig sind, aber die Definitionen besser zu lesen machen.
  ret_type() markiert einen Rckgabewert und sollte fr die Deklaration von Methoden verwendet werden, um den Rckgabetyp
  von den Argument-Typen zu unterscheiden. type_enum() und type_flag() sind Wrapper-Makros, die anstelle der ansonsten
  recht langen und unbersichtlichen Templates verwendet werden sollten.
- Weitere statische Datentypen zum RTTI hinzugefgt: double, int8, int16, int32, uint8, uint16, uint32



>> 12.04.2010 (PLCore2)
[SB]
- Klassen-Template ModuleID hinzugefgt, welches dafr zustndig ist, jedem Modul (z.B. eine Applikation oder Bibliothek)
  eine eindeutige Modul-ID zu beschaffen.
- ModuleMain.h hinzugefgt. Dieser Header sollte genau einmal in einem Projekt eingebunden werden und die darin enthaltenen
  Makros verwendet werden, um das Modul zu beschreiben (Name, Beschreibung etc.).
- Makros und Klassen fr die Deklaration und Registrierung von Modulen hinzugefgt.



>> 11.04.2010 (PLCore2)
[SB]
- Einige Fehler in Type<EnumType> behoben.
- Type<FlagType> implementiert (Flag-Types sind wie Enums, erlauben aber die Kombination von Werten).
- EnumTypes kann jetzt auch bei der Deklaration von Attributen verwendet werden (hier gab es noch kleinere Fehler, die
  das bisher verhinderten).
- Object, Class: Methoden hinzugefgt, um den Typus von Objekten abzufragen und z.B. zu erfragen, ob eine Klasse von
  einer anderen abgeleitet ist oder ein Objekt von einem bestimmten Typus ist.



>> 10.04.2010 (PLCore2)
[SB]
- Klasse ParamParser erstellt und implementiert. Diese Helfer-Klasse kann verwendet werden, um Parameter-Strings
  zu parsen, wie z.B. "Param0=\"Hello\" Param1=10". Die Klasse bietet dann ein einfaches Interface, um ber die
  gefundenen Parameter sowie ihrer Werte zu iterieren und diese auszulesen. Da diese Funktionalitt an sehr verschiedenen
  Stellen bentigt wird, sollte es hier eine wiederverwendbare Klasse geben :-)
- Params: Statische Funktion FromString hinzugefgt, welche ein Params-Objekt mit den im String angegebenen Parametern
  erzeugt und zurckgibt. Damit ist es mglich, bspw. eine Funktion mit den Parametern als String aufzurufen:
    cFunc.Call(Params<int, float>::FromString("Param0=10 Param1='1.5'")); // Parameter names are not important
- DynFunc, Func: Neue virtuelle Methode Call(const String&) hinzugefgt, die es erlaubt, eine Methoden mit einem
  Parameter-String aufzurufen, ohne im Vorfeld die Signatur der Funktion kennen zu mssen.
- Klasse ParamParserXml erstellt und implementiert. Diese arbeitet analog zu ParamParser, lies die Parameter aber
  im XML-Format ein, z.B.:
    <?xml version=\"1.0\" ?>
    <Call Param0=\"1\" Param1=\"2.5\"/>
- Params: Statisch Funktion FromXML hinzugefgt (analog zu FromString).
- DynFunc, Func: Neue virtuelle Methode Call(const XmlElement&) hinzugefgt (analog zu String&).
- Var, Type: Werte knnen nun auch gesetzt werden, indem ein Pointer auf eine andere dynamische Variable gegeben wird,
  anstelle eines statischen Typs (quivalent zu Func, wo DynParam bergeben werden kann). Neben z.B. pVar->SetInt()
  gibt es nun also auch pVar->SetVar(pVar2).
- Objekt: Interface um einige Komfort-Funktionen erweitert, z.B. SetAttribute(), CallMethod() etc (Abkrzungen fr
  den lngeren Weg :-))
- Objekt: Methoden hinzugefgt, um alle Variablen zu laden oder zu speichern (per String oder XML).



>> 08.04.2010 (PLCore2)
[SB]
- Neue Klasse MemberDesc erstellt. Dies ist die Basisklasse fr alle Member einer Klasse wie z.B. Attribute, Method etc.
  Dies erleichtert es beispielsweise, ber alle Member einer Klasse zu iterieren, ohne fr jeden Member-Typus eine eigene
  Schleife schreiben zu mssen.
- Class: Methodik implementiert, um Member von Klassen in abgeleiteten Klassen zu vererben, die (hoffentlich) sowohl
  simpel als auch mchtig ist. Zunchst werden alle Member einer Klasse ber Selbst-Initialisierung nur bei der Klasse
  selbst registriert und dort in einer Liste "eigener Member" gespeichert. Da hier das Static-Initialization-Dilemma
  einsetzt, die Reihenfolge in der sich die Member registrieren also nicht vorhergesehen werden kann, muss damit gerechnet
  werden, dass spter noch weitere Member der eigenen Klasse oder einer Basisklasse hinzukommen knnen. Um dieses Problem
  zu lsen, gilt die Klasse zunchst so lange als nicht initialisiert, bis versucht wird, auf die Member der Klasse
  zuzugreifen. Erst dann wird die Klasse initialisiert, was dazu fhrt, dass sie alle ihre Member aufzhlt und internen
  Listen von Attributen, Methoden etc. aufbaut, welche dann fr den Zugriff auf die Member verwendet werden. Dabei werden
  auch die Member der Basisklassen mit aufgezhlt, wodurch auch die Reihenfolge der Member die richtig ist. Wenn nun spter
  noch Member zu einer Klasse hinzugefgt werden, die bereits initialisiert wurde, fhrt dies dazu, dass diese Klasse sofort
  wieder de-initialisiert wird und dann wieder als nicht initialisiert gilt, bis ein Zugriff auf die Klasse erfolgt, der
  wieder zu einer Initialisierung fhrt (wodurch dann auch wieder alle Member korrekt aufgelistet werden). Auf diese Weise
  sollte sichergestellt sein, dass immer alle Member bekannt sind, auch wenn diese sich erst spter angemeldet haben. Auch
  ist zu hoffen, dass eine Klasse nicht zu hufig initialisiert und wieder de-initialisiert werden muss, da dies eigentlich
  nur dann passieren kann, wenn eine Klasse zu frh initialisiert wird (auf das RTTI sollte also mglichst erst ab der
  Main-Funktion zugegriffen werden). Zudem fhrt dieses System dazu, dass Klassen, auf die berhaupt gar nicht zugegriffen
  wird im Laufe des Programmes, auch niemals ihre Member initialisieren mssen, was ein zustzlicher Gewinn ist :-)
- Class, Object: Methoden fr den Zugriff auf alle Member hinzugefgt (sowohl Listen aller Member sowie einzelne Member).



>> 07.04.2010 (PLCore2)
[SB]
- Klasse FuncDesc hinzugefgt, welche einen Descriptor fr Funktionen und Methoden innerhalb einer Klasse darstellt.
- RTTI-Makros fr die Deklarations von Methoden hinzugefgt.
- Klasse EventDesc hinzugefgt, welche einen Descriptor fr Events und Signals innerhalb einer Klasse darstellt.
- Klasse EventHandlerDesc hinzugefgt, welche einen Descriptor fr EventHandler und Slots innerhalb einer Klasse darstellt.
- RTTI-Makros fr Events und EventHandlers hinzugefgt. 
- Klasse Constructor wurde in FuncConstructor umbenannt, da dies auch nur ein spezieller Funtoid ist, der ein Objekt
  erzeugt.
- Neue Klassen Constructor und ConstructorDesc implementiert, welche sich analog zu Attributen und Methoden um die Deklaration
  von Konstruktoren in Klassen kmmern. Constructor kann hier allerdings nicht komplett Analog zu den anderen genannten
  Klassen sein, da im Gegensatz zu Attributen und Methoden ein Constructor bei Class und nicht bei Object angesiedelt sein
  muss (ein Konstruktor wird von einer *Klasse* aufgerufen und gibt ein Objekt zurck, ein Constructor auf ein schon
  bestehendes Objekt anzuwenden, ergibt dagegen keinen Sinn). Daher unterscheidet sich die Klasse ConstructorDesc hier etwas
  von den anderen Konstruktoren, indem sie z.B. nicht nur den Konstruktor beschreibt (Name etc.), sondern gleichzeitig
  auch die Instanz des eigentlichen Konstruktor-Functoids beinhaltet. 
  so speichert bspw.
- RTTI-Makros fr Konstruktoren hinzugefgt.
- Methoden hinzugefgt, um Instanzen von Klassen zu erzeugen:
  - ConstructorDesc stellt die Methode Create() zu verfgung, welche den jeweiligen Konstruktor aufruft
  - Class hat drei weitere Create()-Methoden, mit denen alle Konstruktoren einer Klasse aufgerufen werden knnen.
    Hier kann entweder der Default-Konstruktor aufgerufen werden, oder es wird entweder per Namen oder per Signatur nach
    einem bestimmten Konstruktor gesucht.



>> 06.04.2010 (PLCore2)
[SB]
- Event und EventHandler implementiert. Ein Event-Handler verhlt sich zunchst einmal genau so wie ein Funktor, stellt
  aber zustzliche Funktionalitt bereit, die es erlaubt, Events und EventHandler miteinander zu verknpfen. Wenn ein
  Event ausgelst wird, werden automatisch alle angemeldeten EventHandler aufgerufen. Events und EventHandler wissen
  ber gegenseitige Verbindungen bescheid, so dass Verbindungen automatisch entfernt werden, wenn eine der beiden Seiten
  beispielsweise gelscht wurde.
- Klassen Event und EventHandler so verndert, dass hier immer der Rckgabetypus void festgelegt ist. Whrend bei generellen
  Functoiden und Functoren ein beliebiger Rckgabetypus verwendet werden kann, ergibt dies bei Events nicht so richtig
  viel Sinn. Was soll beispielsweise ein Event zurckgeben, wenn mehrere EventHandler aufgerufen wurden und jeder davon
  einen anderen Rckgabewert zurckgeliefert hat? Der Einfachheit halber haben daher nun alle Events und EventHandler den
  Rckgabetyp void.
- Kommentierung fr RTTI-Makros erweitert.



>> 05.04.2010 (PLCore2)
[SB]
- Statische Funktions-Pointer (FuncFuncPtr) und Memberfunktions-Pointer (FuncMemPtr) als Ableitung von Func implementiert.
  Diese Funktions-Pointer, welche die Basis fr Functoren sind, verhalten sich also genau so wie andere Functoide, tragen
  intern aber einen Zeigen auf eine Funktion mit sich herum :-)
- Functor implementiert. Ein Funktor ist ein spezieller Typus eines Functoids, der einen Zeiger auf eine andere
  Funktion beinhaltet. Wenn der Functor aufgerufen wird, ruft er die jeweils gespeicherte Funktion auf, stellt damit
  also eine Art generischen Funktionspointer dar.
- Func: Virtuelle Methode Clone() hinzugefgt, die bentigt wird, wenn eine Kopie eines Functoids angefertig werden soll.
  Dies wird von Functor verwendet, wenn eine Funktion einem Functor zugewiesen oder ein Functor kopiert werden soll.
- Basisklasse Constructor von ClassConstructor entfernt, statt dessen ClassConstructor in Constructor umbenannt.



>> 04.04.2010 (PLCore2)
[SB]
- Attributen mssen nun immer mit einen Zeiger auf das Object initialisiert werden. Das wre zwar eigentlich nur fr
  die Attribute notwendig, welche Get/Set-Methoden verwenden, aber dann wre das ganze inkonsistent, weil manche Attribute
  initialisiert werden mssten, andere aber nicht. Es scheint mir daher sinnvoller, dies bei allen Attributen einheitlich
  zu gestalten, zumal man manchmal auch aus anderen Grnden den Zeiger auf das Object gebrauchen kann.
- Variablen: Alle Klassen noch einmal durchgesehen und die Dokumentation berarbeitet.
- Functor: Basisklasse DynFunc erstellt, diese Klasse steht allgemein fr alle typisierten Funktionen bzw. Funktionsobjekte.
- Functor: Basisklasse DynParams erstellt, diese Klasse stellt die Basis fr typisierte Parameter dar.
- "Functor" in "Func" umbenannt und alle Klassen und Ordner angepasst.
- Funktions-Objekte (Functoide) und Konstruktoren implementiert.



>> 29.03.2010 (PLCore2)
[SB]
- Type: Es werden nun keine Funktions-Templates, sondern statt dessen normale Funktionen mit festgelegten Namen verwendet.
  Jeder Typ muss hier die Umwandlungs-Funktionen fr alle bekannten statischen Typen zur Verfgung stellen (ConvertToInt(),
  ConvertFromInt() etc.). Dies ist notwendig, da es ansonsten nicht mglich wre, Standardtypen wie z.B. int in nicht-standard
  Typen umzuwandeln, da es ja bspw. kein Type<int>::ConvertToMyType() gibt. 
- Klasse Types entfernt, welche zuvor verwendet wurde, um zwischen Type-ID und Type-Name umzuwandeln. Leider sind diesem
  Mapping natrlich die nicht-standard Typen unbekannt, weshalb das ganze System nicht sehr sinnvoll ist. Statt dessen hat
  nun jeder Typus die entsprechenden Methoden GetTypeID() und GetTypeName() zur Verfgung zu stellen.
- Klasse Attribute in Var umbenannt.
- Klasse TypedVarDesc entfernt, da diese nicht wirklich notwendig ist zwischen VarDesc und VarDesc_VARNAME.
- Enumerations zum RTTI Typensystem hinzugefgt.



>> 28.03.2010 (PLCore2)
[SB]
- Tools: Klasse CompileError erstellt. Dies ist ein Template, das verwendet werden kann, um Compiler-Fehler zu erzeugen.
  Hierbei gibt es zwei Versionen, das eine Mal wird der Fehler in jedem Fall erzeugt, das andere Mal hngt dies noch
  von einer Kondition ab (es wird nur dann ein Fehler generiert, wenn eine bestimmte Aussage zutrifft).



>> 27.03.2010 (PLCore2)
[SB]
- Die Helferklassen fr Access und Storage wurden umbenannt und in eigene Header-Dateien verschoben: TypedAttrAccess.h and TypedAttrStorage.h
- Template Signatur erstellt (dieses stellt den 'Typus' von Funktionen dar)
- Basisklasse fr Functoide und Konstruktoren erstellt (noch lange nicht einsatzbereit)



>> 26.03.2010 (PLCore2)
[SB]
- Klassen, in denen keine Attribute definiert wurden, werden nun auch korrekt am System angemeldet.
- Attribute knnen nun Default-Werte haben.
- Attribute knnen nun als read/write oder read-only definiert werden.
- Attribute haben nun Zuweisungs- und Conversion-Operatoren. Man kann daher nun z.B. direkt
  'AttrInt = 3' oder 'int nValue = AttrInt' schreiben.
- Helferklassen eingebaut, um den Storage-Type eine Attributes festzulegen:
  - StorageDirectValue speichert den Wert eines Attributes direkt innerhalb einer privaten Variable.
  - StorageGetSet ruft zum Setzen oder Abfragen des Wertes die jeweilige Get- oder Set-Methode des Objektes
    auf, hier wird der Wert also nur indirekt gesetzt und keine eigene Variable instanziiert.
  Bis jetzt ist nur StorageDirectValue implementiert.
- Externer Storage-Type wurde implementiert. Hierfr muss eine externe Klasse angegeben werden, welche die
  notwendigen Get()/Set()-Methoden fr das jeweilige Attribut zur Verfgung stellt. Diese Klasse wird dann
  vom Attribut verwendet, um auf den Inhalt der Variablen zuzugreifen, die eigentliche Speicherung der Daten
  kann innerhalb dieser Klasse also beliebig implementiert werden.



>> 25.03.2010 (PLCore2)
[SB]
- RTTI makros fr Klassen und Attribute erstellt.
- Attr: GetDesc() wurde nun als virtuelle Funktion innerhalb der Basisklasse implementiert, somit ist es nun immer
  mglich, an den Descriptor zu gelangen, sobald man einen Zeiger auf ein Attribut hat.
- Class: Namespace und Description hinzugefgt.
- ClassManager hinzugefgt.



>> 24.03.2010 (PLCore2)
[SB]
- Erste einfache template-basierte RTTI Funktionalitt implementiert. Es ist bereits mglich, Attribute von Klassen
  zu definieren und auf diese zuzugreifen. Alles ist komplett template-basiert, bisher wurden noch keinerlei Makros
  verwendet (natrlich werden spter auch wieder Makros zur Verfgung gestellt, um die Verwendung der Templates
  hinter einfacheren Konstrukten zu verstecken, aber die eigentlich Funktionalitt wird hoffentlich nur auf
  Templates basieren und keine Makro-Tricks mehr beinhalten wie z.B. Pointer-Arithmetik zum Ausrechnen von
  Speicheradressen o..).
- Auflisten und Abfragen von Attribute-Descriptoren (bei der Klasse) und Attributen (beim Objekt) wurde implementiert.



>> 23.03.2010 (PLCore2)
[SB]
- Mit neuem System angefangen, daher erst einmal wieder in einem separaten Projekt (PLCore2), damit das alte PLCore
  zunchst einmal parallel erhalten bleiben kann, ohne dass es Konflikte gibt.
- Mit neuem RTTI begonnen, welches dieses Mal zum Groteil auf C++ templates basieren soll:
  - Type eingebaut als statischen Wrapper fr die C++ Datentypen
  - Types ist eine statische Helfer-Klasse, die es bspw. erlaubt, Type-IDs in Strings umzuwandeln u..
  - TypedAttr ist ein Class-Template fr typisierte Attribute (also Variablen, die direkt einen Wert besitzen)
  - Attribute ist eine virtuelle Basisklasse fr Attribute



>> 21.03.2010
[SB]
- HttpClient: Fehler bei der HTTP-Authentification behoben: Benutzername und Passwort wurden falsch bermittelt, wodurch
  eine Anmeldung natrlich nicht mglich war. Ausserdem wird nun auch das HTTP-Verb "DELETE" untersttzt.



>> 14.03.2010
[CO]
- "Config", "ConfigLoader" und "ConfigLoaderPL" nach PLCore ins Application-Verzeichnis verschoben (siehe PLCore-Tagebuch
  fr mehr Informationen)
PLCore:
- "Config", "ConfigLoader" und "ConfigLoaderPL" von PLGeneral nach PLCore ins Application-Verzeichnis verschoben. Zuknftig
  sind "Konfigurationen" ausschlielich in Verbindung mit Application-Instanzen zu sehen. Ich konnte keinen Grund finden,
  wieso z.B. die Renderer-Klasse ein Konfigurations-Objekt haben sollte - dafr kann man genauso gut einfache Funktionen
  und oder das RTTI nutzen! "Konfiguration" sind eigentlich ja nur dann Interessant wenn man als Anwendungs-Programmierer Einstellungen
  "von Auen" ber eine Text-Datei einstellbar haben will, oder Programm-Einstellungen wegspeichern und wiederherstellen will.
  Was es jedoch an relevanten Programm-Einstellungen gibt, weis eigentlich nur ein Anwendungs-Programmierer. Man kann schlecht
  *alles* was die einzelnen Komponenten an Variablen haben wegspeichern, das wrde auch gar keinen Sinn machen. Als Anwendungs-Programmierer
  kann das sogar total lstig und unerwnscht werden wenn die "Engine" von sich aus Dateien rausschreibt - denn es kann sehr wohl
  auch mal Anwendungen geben die sich rein passiv zu verhalten haben, also nur von einer Festplatte lesen sollen, aber nix schreiben
  oder gar neue Dateien anlegen.
  Das Application-Framework bring natrlich wieder so Konfigurations-Objekte rein, aber das ist ja alles als Vereinfachung gedacht so
  das man sich nicht mehr um alles kmmern muss. Dies ist allerdings nicht fest in *PL verwurschtelt*, sondern man kann auch gut ohne
  diese Framework arbeiten und hat dann volle Kontrolle.
- "Config" ist kein Singleton mehr
- "Application" besitzt nun eine "Config"-Instanz. Das Konfigurations-System als solches ist also momentan noch so wie gehabt, nur das
  es kein Singleton mehr ist, sondern jede Application-Instanz eine eigene Konfigurations-Instanz besitzt. Des Weiteren nutzen nur noch
  Application-Instanzen Konfiguration und nicht mehr alle mglichen PixelLight-Komponenten. Dies stellt daher denke ich schonmal
  eine Verbesserung da.



>> 22.01.2010
[SB]
PLCore:
- Application::GetApplication(): Export in DLL hinzugefgt.



>> 19.01.2010
[SB]
- ThreadLinux: Wie es aussieht, ist die Thread-Implementation unter Linux noch so gut wie unbrauchbar. Leider kenne ich
  mich mit dem Threading ja auch so gut wie nicht aus, und msste mich da nun enorm einarbeiten, um das irgendwie brauchbar
  zu machen. Die schlimmsten Fehler habe ich nun aber erstmal korrigiert bzw. umgangen:
  - pthread_kill(m_nThreadID, SIGKILL) ist *nicht* geeignet, um einen Thread zu beenden. Das Signal beendet immer den
    gesamten Prozess, auch wenn es an einen bestimmten Thread eines Prozesses gesendet wird. Daher wurde nun bei uns jedes
    Mal das gesamte Programm beendet, wenn nur ein Thread oder z.B. ein Timer beendet werden sollte. Zum Beenden eines
    Threads verwende ich nun pthread_cancel(). Diese Fehler hat natrlich dazu gefhrt, dass das Programm stndig "abstrzte",
    nun macht das alles schon einen deutlich stabileren Eindruck unter Linux :-)
  - Es gibt keinen timed-join Befehl in pthreads, also einen Befehl der bis zu einem bestimmten Timeout darauf wartet, dass
    ein Thread beendet wurde. Statt dessen hatte ich hier bisher einfach join verwendet, also ohne Timeout zu warten, was dann
    aber zu einem Einfrieren der Applikation fhrt, wenn sich ein Thread nicht freiwillig beendet. Daher lasse ich diese
    Funktion nun erst einmal komplett fehlschlagen, damit das zumindest nicht mehr passieren kann, hier msste dann eine
    timed-join Operation implementiert werden, wofr ich auch schon ein Beispiel gefunden habe.



>> 30.11.2009
[SB]
- Neue und umfangreiche HTTP-Implementation erstellt. Dies umfasst sowohl einen HTTP-Client, als auch einen minimalen
  Http-Server. Der Client ist um einiges umfangreicher als die alte HttpHandle-Klasse und kann HTTP/1.0 sowie HTTP/1.1.
  Damit ist auch die "Download fortsetzen"-Funktion mglich, bzw. das auslesen beliebiger Teile einer Datei, sofern der
  Server das zulsst, was die Verwendung der File-Klassen und Seek() einfacher und vor allem deutlich schneller machen
  sollte. Auch ist die Klasse ansonsten umfangreicher, z.B. werden alle HTTP-Fehlercodes verstanden und knnen entsprechend
  abgefragt werden etc. Daneben gibt es noch einen sehr minimalistischen HTTP-Server, der dazu verwendet werden kann, aus
  einem Programm heraus z.B. eine kleine Weboberflche zur Verfgung zu stellen. Die Server-Klasse ist dabei eine reine
  Basisklasse, die HTTP-Anfragen entgegennimmt und weiterleitet, von sich aus aber erstmal nur eine statische Seite
  anzeigt. Die eigentliche Funktionalitt muss also in der abgeleiteten Klasse implementiert werden, z.B. was fr
  Seiten auf welche URLs hin generiert werden sollen. Auch ist dies kein HTTP-Server in dem Sinne, dass er Dateien von
  der Festplatte lesen und auf HTTP bereitstellen wrde, da der Anwendungsfall eher auf dynamisch generierte Web-Applikationen
  abzielt (z.B. als Weboberflche fr einen Spiele-Server). Allerdings wre es recht einfach, dies in einer abgeleiteten
  Klasse zu implementieren :-)



>> 29.11.2009
[SB]
- Time: Die Monate werden nun von 1 an gezhlt, statt wie bisher von 0. Es ist einfach vllig unintuitiv, wenn nur die
  Monate ungewohnt bei 0 anfangen, der Rest aber wie gewohnt von 1 an gezhlt wird. Habe das nun daher verndert und hoffe,
  dass ich alle Verwendungen in PL entsprechend korrekt angepasst habe (-1 entfernt wo ntig und +1 hinzugefgt wo ntig).
  Allerdings wurde die Time-Klasse zum Glck bisher nicht so hufig verwendet, es drften also wohl nicht allzu viele
  mgliche Fehlerstellen jetzt vorhanden sein.



>> 25.10.2009
[SB]
- Base64-Funktion nach Tools verschoben, da man diese Funktion spter noch einmal brauchen knnte.



>> 24.10.2009
[SB]
- Connection: Mir ist gerade aufgefallen, dass es nicht unbedingt immer erwnscht ist, dass eine Connection automatisch alle
  Daten ausliest, die man ihr zuschicken will. Beispielsweise bei einem HTTP-Client wrde man wohl erst den Header lesen,
  und dann entscheiden, ob man die Daten ausliest oder nicht (knnten ja auch groe Dateien sein). Aus diesem Grund kann
  nun per Option eingestellt werden, ob eine Connection automatisch alles liest, was ihr geschickt wird, oder ob dies
  manuell aufgerufen werden muss. Dafr die Option EReceiveMode sowie die Methoden Receive() und ReadLine() eingebaut.
  ReadLine liest Text-Daten vom Stream und gibt diese Zeilenweise zurck. Dabei wird das EOL-Zeichen nicht automatisch gelscht,
  da dies in manchen Kontexten wichtig ist, dies muss daher ebenfalls manuell geschehen. Ebenso wird nun beim Senden von
  Strings (Send()) nicht mehr automatisch CRLF angehngt, da dies auch nicht immer erwnscht ist. Fr Zeilenenden ist nun
  also die jeweilige Anwendung selbst verantwortlich.
- Buffer: Einige Fehler behoben. Beim zeilenweisen Auslesen werden nun sowohl CRLF als auch nur LF als Zeilenenden akzeptiert.
  Zustzliche Methode GetData() eingebaut, damit man auch auf den Inhalt des Buffers zugreifen kann.



>> 23.10.2009
[SB]
- Network: Habe die Basisklassen aus PLNetwork nach PLGeneral verschoben und noch einmal grndlich berarbeitet.
  Es scheint mir sinnvoll, diese Basisklassen bereits in PLGeneral zu haben, denn mit Sockets alleine zu arbeiten
  ist ziemlich mhsam und nicht sinnvoll, deswegen sollten immer diese Basisklassen verwendet werden, wenn es darum
  geht, Netzwerkfunktionalitt einzubauen. Daher ergab die Trennung hier nicht viel Sinn, und eine weitere Bibliothek
  zu verwenden stellt immer eine zustzliche Hrde dar, daher ist es besser, diese Klassen gleich in PLGeneral verfgbar
  zu haben. Die Netzwerk-Basisklassen bieten selber nur ein minimales Framework um Socket herum an, und durch die
  berarbeitung wurde auch alles noch einmal deutlich schlanker und eleganter, so dass letztlich nur 5 zustzliche
  Klassen herausgekommen sind, die PLGeneral daher auch nicht unntig aufblhen sollten :-)
PLNetwork:
- Netzwerk-Basisklassen nach PLGeneral verschoben. Dieses Projekt ist damit zwar erstmal leer, bleibt jedoch erhalten,
  da ich mir sicher bin, das man dafr spter noch Verwendung haben wird. Beispielsweise knnten hier Basisklassen
  fr typische Netzwerk-Komponenten erstellt werden (z.B. Messenger, Chat, ...), welche dann von spezialisierten Backends
  wie PLIRC oder PLJabber implementiert werden. Auch wird es natrlich Basisklassen fr die Netzwerksynchronisation brauchen,
  welche spter die Grundlage fr die tatschliche Netzwerkfunktionalitt in der Engine bieten wird. Daher ist es denke
  ich sinnvoll, dieses Projekt gleich beizubehalten, wenn es auch derzeit nicht genutzt wird.



>> 22.10.2009
[SB]
- String: Neue Methode RemoveLineEndings() eingebaut, die Markierungen fr das Zeilenende ("\r" oder "\r\n") am
  Endes des Strings lscht. Das ist insbesondere dann wichtig, wenn in einem Netzwerkprotokoll die Zeilenenden
  entscheidend sind und daher Strings nicht gleich "bereinigt" werden sollten.
PLNetwork:
- Buffer: Option m_bRemoveDelimiters hinzugefgt. Damit kann festgelegt werden, ob die Zeilenenden in einem
  Protokoll automatisch entfernt werden sollen, oder in den zurckgegebenen Strings drin bleiben sollen. In manchen
  Protokollen ist es wichtig, dass diese Zeichen nicht entfernt werden, da z.B. eine Leerzeile eine besondere
  Bedeutung hat. Wenn die Zeilenenden aber entfernt werden, knnte nicht mehr zwischen eine leeren Zeile ("\r\n") und
  einem leeren String ("") unterschieden werden, der zurckgegeben wird um anzuzeigen, dass noch keine weitere Zeile
  gelesen wurde.



>> 20.10.2009
[SB]
- Time: Neue Methode GetDaysPerMonth() spendiert, um die Anzahl an Tagen in einem Monat abzufragen.



>> 18.10.2009
[SB]
- Habe meine alte Klasse 'HMLTParser' vom letzten Jahr wieder ausgegraben und reaktiviert :-) Diese Klasse hatte ich
  geschrieben, damit man eine HTML-Datei parsen und als Ergebnis einen XML-Syntaxbaum herausbekommen kann. Zwar hatte
  ich dann die gesamte HTML-Anwendungsidee verworfen und in dem Zusammenhang auch den Parser wieder gelscht, aber
  da ich nun wieder einmal merke, wie praktisch es ab und zu wre, HTML-Dateien einlesen zu knnen, habe ich die
  Klasse nun wiederhergestellt und noch ein wenig erweitert sowie ein paar Fehler behoben. Der Parser selbst sollte
  nun relativ robust sein, allerdings besteht natrlich immer noch keine Garantie dafr, dass er in der Lage ist, eine
  beliebige HTML-Seite fehlerfrei einzulesen. Dafr ist der HTML-Syntax viel zu unbersichtlich und es gibt zu viele Arten
  von Erweiterungen ber eingebettete Scripte etc. Nun werden allerdings Kommentare und einige andere Tags von vornherein
  ignoriert, daher drften einiger Maen wohlformatierte Seiten jetzt eigentlich problemlos eingelesen werden knnen. Also
  falls man mal in irgendeinem Zusammenhang HTML-Seiten einlesen bzw. parsen muss, gibt es dafr nun eine Klasse, die man
  als Basis dafr verwenden kann.



>> 16.10.2009
[SB]
- FileObject und Url: Methoden fr den Zugriff auf URLs berarbeitet. GetUrl_() in GetUrl() umbenannt, da denke ich die
  Verwendung und Bedeutung dieser Methode inzwischen klar festgelegt ist. In FileObject alle "Abkrzungen" entfernt,
  um direkt auf den Dateinamen zuzugreifen, es muss nun also immer GetUrl() verwendet werden und von dort aus weitere
  Methoden, um die URL als String zu erhalten. Ich bin mittlerweile ein Freund davon, keine unntigen doppelten Funktionen
  irgendwo einzubauen, sondern lieber klar nur eine Mglichkeit zur Verfgung zu stellen. Das sieht zwar manchmal nicht so
  hbsch aus, ist dafr aber verstndlicher und leichter nachzuvollziehen. Schlielich GetWindow(), GetLinux() etc. wieder
  in GetWindowsPath(), GetLinuxPath() etc. umbenannt, denn der Name sollte schon irgendwie darauf hindeuten, was dort
  zurckgegeben wird (auch wenn "Path" nicht ganz korrekt ist, aber hier fehlt es halt an einem eindeutigen berbegriff fr
  Pfade, URLs etc.).



>> 03.09.2009
[CO]
PLCore:
- "Event::Emit()": Der Zeiger auf den nchsten Event Handler wird nun auf dem Stack zwischengespeichert bevor der Functor
  aufgerufen wird... da man damit rechnen muss das innerhalb des Functors der aktuelle Event Handler gelscht wird sollte
  man diesen dann nach dem Functor nicht mehr nutzen. Damit ist es nun mglich in Functoren soweit problemlos Event Handler
  whrend eines Emits zu lschen - neue hinzufgen wird natrlich je nach Situation immer noch fr Anomalien sorgen.
  (aber wohl weniger wahrscheinlich welche die in Crashs resultieren :)



>> 26.08.2009
[CO]
PLCore:
- "TimerWindows::TimerFunction()": Ich hatte hier gerade das Problem das ein "einmalig Feuern Timer" mehrmals feuerte...
  kann mir das noch nicht richtig erklren, aber wenn ich in der Callback Funktion hier ZUERST den Timer stoppe und dann
  das Event abgebe geht das hier momentan. Seltsam seltsam...



>> 06.08.2009
[CO]
- "uint32" wird nun mit "__int32" definiert, das gleiche gilt fr alle hnlichen Typen
- "HashFunction" & "CompareFunction" um 64 Bit Datentypen erweitert... ansonnsten gibts Probleme wenn man in einer
  HashMap als Schlssel z.B. "UINT_PTR" unter 64 Bit nutzen will, dann weis der Compiler nicht was er nehmen soll



>> 02.08.2009
[CO]
- "RegEx": Neue Funktion: "WildcardToRegEx()": Wandelt einen gebenen String mit Wildcard in einen String mit Regulren
  Ausdruck um
- "Map": "GetKeyIterator()", "GetConstKeyIterator()", "GetEndKeyIterator()" & "GetConstEndKeyIterator()" hinzugefgt
  damit man bei "Map" ebenfalls durch die Schlssel iterieren kann
- "HashMapKeyIterator" & "SimpleMapKeyIterator" hinzugefgt



>> 20.06.2009
[SB]
PLCore:
- CMakeFiles.txt: TimerWindows darf aber bitteschn auch nur unter Windows eingebunden werden :-)



>> 17.06.2009
[CO]
PLCore:
- "Timer", "TimerImpl", "TimerWindows" und "ThreadTimer" von PLGui3 hierhin kopiert, aber in PLGui3 noch genauso drinnen
  gelassen. Habe die Klassen erstmal in den Grundordner gelegt da mir kein brauchbarer Name fr einen Unterordner einfiel
  - da kommen ja noch einige Klassen bei Zeiten hinzu und dann findet sich sicherlich ne nette Gruppe der sich der Timer
  anschlieen kann. :D
  Da "ThreadTimer::Run()" in einem Thread luft kann der Timer allerdings zu jeder Zeit feuern... etwas das sicherlich
  schnell Problematisch werden kann. Eventuell wre ne art von "TimerManager"/"TimerScheduler" Klasse nett ber die
  man die Timer Synchronisieren kann... also quasi in der Art "So Leute, wer bereit ist - FEEEUER!". *g*
  Was beim Threaded Timer auch noch ein Problem ist, ist das "Stoppen" da die genutzte "Sleep()" nicht unterbrochen
  wird und der Timer erstmal ablaufen muss.
- "ThreadTimer::StartTimer()" und "ThreadTimer::StopTimer()": Der Thread wird hier gestartet und "abgewrgt", damit
  wird der Timer bei stop sofort angehalten. Damit verhlt es sich wie "TimerWindows". Ich hatte mir zuerst die
  Windows Funktion "QueueUserAPC()" angeschaut aber irgendwie wurde das zuviel des guten.



>> 03.06.2009
[CO]
PLCore:
- "Application": Neue Funktion "IsRunning()" gibt zurck ob die Anwendung gerade luft



>> 10.05.2009
[CO]
- "ZipHandle::ReadCurrentFileInfo()": Autsch, hier hatten wir ein bles Speicherleck wenn "m_cCurFile.m_nSizeFilename"
  0 war... denn hier muss noch ein Zeichen fr \0 angehngt werden. Die String Klasse bernimmt dann die Kontrolle
  ber den Speicher, bekommt aber die Original Speicherlnge ohne +1 und denkt sich dann "hopala, leerer String!"
  und bernimmt dann natrlich nicht die Speicherkontrolle da der Speicher ja scheinbar leer ist. Und dann mllt
  sich der Speicher langsam mit Herrenlosen frhlich frei herumschwirrenden 1 Bytes voll.
- "ClassManager::LoadPlugin()" sollte auch mehrmals aufgerufen werden knnen ohne das es bereits vorhandene
  Module erneut hinzufgt, baute daher einen entsprechenden Test ein.



>> 07.05.2009
[CO]
- "BinaryHeap", "BinominalHeap" und "FibonacciHeap" hatten Fehler so das der Compiler einem kryptische Fehler nur
   so um die Ohren schlug wenn man versuchte den "Comparer" durch einen eigenen zu ersetzen



>> 01.05.2009
[CO]
- "Bitset"-Konstruktor: Beseitigte eine Inkonsistenz zu "Array" und "Resize()": Die Standardeinstellungen von
  "bAdded" und "bInit" sind nun identisch. "Bitset" wird bis jetzt zum Glck sehr selten eingesetzt so das es
  nur wenige Stellen waren die einer Prfung bedurften. (nderung dieser Art sind ja immer sehr heikel :/)
- "Bitset" um superkomplexe "Reset()"-Funktion die es ebenfalls auch in "Array" gibt erweitert... setzt einfach
  die aktuelle Anzahl an Elementen auf null so das es einem "Clear()" gleichkommt, aber deutlich schneller ist da
  der angelegte Speicher erhalten bleibt. (hin und wieder sehr praktisch soetwas :)



>> 26.04.2009
[CO]
- "SystemWindows::GetOS()" erkennt nun auch Windows 7



>> 22.04.2009
[CO]
- nderte einige Methoden der String-Klasse minimal so das die heute von Stefan festgestellten unschnheiten beseitigt sind



>> 22.04.2009
[SB]
- RegEx: Workaround eingebaut, da String::Copy() mit der Lnge 0 den gesamten String zurckgibt anstelle der leeren Strings ("").
  Ich denke dies sollten wir dringend berarbeiten, denn dieses Verhalten ergibt zwar Sinn, wenn man 0 nur als Defaultwert,
  sprich als "nicht angegeben" betrachtet, verhindert aber, dass man den Wert 0 als tatschliche Lnge eines Substrings angeben
  kann. Und dies fhrt zu einem sehr ungewhnlichen Verhalten, denn wenn ich z.B. alle Prefixes alles Strings mit sowas wie
  for (int i=3; i>=0; i--) sPrefix = sString.GetSubstring(0, i); abfrage, wrde ich wohl eher ["abc", "ab", "a", ""] erwarten
  als ["abc", "ab", "a", "abc"] (siehe Test99).



>> 22.04.2009
[CO]
- "File": Neue Funktion: "GetMemoryBuffer()": Falls die Datei "im Speicher liegt" kann man sich hiermit direkt einen Zeiger auf
  den Speicher geben lassen. Ist zwar irgendwie "unschn" aber "praktisch" da man dadurch in einigen Fllen die Performance
  in Anwendungen verbessern kann... denn wenn man "weis" das eine Datei bereits komplett im Speicher liegt und man die Datei im
  Speicher braucht um diese mit anderen Funktionen weiterzuverarbeiten - dann muss man nun nicht mehr einen "Zwischenbuffer"
  erzeugen, die ganze Datei "einlesen", Arbeit erledigen und "Zwischenbuffer" wieder freigeben... sondern man nutzt direkt
  den bereits die bereits im Speicher liegende Datei. :D



>> 16.04.2009
[SB]
PLPlugin:
- Fehlende Abhngigkeiten in der CMakeLists.txt hinzugefgt.



>> 15.04.2009
[CO]
- Spendierte der "File"-Klasse einen weiteren Konstruktor dem man einen Buffer bergeben kann... was hin und wieder
  ziemlich praktisch ist da "Dateien" dann nicht zwanghaft direkt von der Festplatte kommen mssen.
- "Base::SetVars()": In meinem Regulren Ausdruck war noch ein bser Fehler drinnen so das beim Wert ' am Ende stehen konnte...
  generell hab ich hier noch etwas Probleme mit " und ' richtig erkennen und habe das momentan etwas umstndlich gelst -
  Stefan... falls du ne Idee hast wie man das alles zusammen in einem netten Ausdruck vereinen knnte... :D



>> 12.04.2009
[SB]
- System: Exit() hinzugefgt, um die Applikation sofort beenden zu knnen. Dies ist natrlich nur ein Wrapper fr die jeweilige Systemfunktion.
PLCore:
- Application: Neue Methode OnKill() hinzugefgt, die aufgerufen wird, wenn das Betriebssystem versucht, die Applikation zu beenden. Standardmig ist
  diese Methode so implementiert, dass sie sofort Exit() aufruft und die Applikation damit zwangsweise beendet. Durch berschreiben dieser Methode kann
  aber z.B. dafr gesorgt werden, dass erst einmal die aktuelle Aufgabe zu Ende gebracht wird und sich die Applikation hinterher ordentlich beendet.
- Application: Unter Linux wird nun das Signal SIGTERM aufgefangen und dann die Methode OnKill() aufgerufen.
- Application: Zugriffsmethoden fr die Versions-Variable hinzugefgt.
- Application: Einen statischen Pointer auf die aktuelle Application-Instanz hinzugefgt. Wenn es anders geht, sollte dies zwar nicht unbedingt verwendet
  werden, aber solange man darauf achtet, immer nur *eine* Application zur Zeit zu haben, bietet dies nun eine sehr einfach Methode, um schnell an diese
  wichtige Application-Instanz und damit auf alle anderen Dinge darin heranzukommen :-)



>> 11.04.2009
[SB]
- CommandLine erweitert, um mglichst viele der blichen Kommandozeilen-Optionen abzudecken. Ich hoffe mal, mit dieser
  aufgebohrten Klasse kommt man weit genug und kann auch komplizierte Kommandozeilen-Optionen definieren, damit man da
  mglichst nicht stndig wieder einen eigenen Parser schreiben muss. Es gbe natrlich noch viel mehr Mglichkeiten, aber
  alles abzudecken wre wirklich zu kompliziert und daher nicht mehr sinnvoll. Auch ist zu beachten, dass diese Klasse nun
  zwar vieles erlaubt, aber nicht alles auch auf Plausibilitt prft (z.B. beim Festlegen von bentigten und optionalen
  Parametern). Hier muss der Programmierer also noch selber darauf achten, dass er nicht unsinnige oder wiedersprchliche
  Angaben macht. Die nderungen im Detail:
  - Es gibt nun drei Typen von Optionen: Flags, Parameter und Argumente.
  - Ein Flag besteht nur aus einer Option (z.B. '-a' oder '--optiona') ohne weiterem Argument dahinter und
    kann einen kurzen sowie einen langen Namen haben.
  - Ein Parameter besteht aus einer Option und einem Argument dahinter (z.B. '-n <name>' oder '--name <name>').
    Die Mglichkeit, dass dieses Argument optional ist, besteht *nicht* (ich finde aber auch nicht, dass man das braucht).
  - Ein Argument wird ohne ohne Option davor angegeben (z.B. "app.exe <name>"). Hierbei werden die registrierten Argumente
    der Reihe nach durchgezhlt, das erste angegebene Argument entspricht dem ersten in der Liste usw. Alle weiteren
    bergebenen Argumente werden in einer zustzlichen Liste gespeichert und knnen ber GetAdditionalArgument() abgefragt
	werden.
  - Alle Optionen knnen nun einen logischen Namen bekommen, z.B. "Name" fr "-n" oder "--name". Das macht das Abfragen
    der Optionen einfacher und erlaubt es auch, die Flags spter zu verndern aber den logischen Namen dabei beizubehalten,
    wodurch man weniger im Code ndern muss. Bei Parametern wird dieser Logische Name auch in der Hilfe mit angezeigt
    (z.B. --name <name>).
  - Optionen knnen nun zustzlich noch als "Required" definiert werden. In diesem Fall wird es als Fehler gewertet, wenn
    die jeweilige Option beim Starten des Programmes nicht angegeben wurde, weshalb dann das Programm nicht gestartet und
	statt dessen der Hilfetext ausgegeben wird.   
  - CommandLine::ShowHelp() an die nderungen angepasst und erweitert. Alle Parameter werden geordnet angezeigt, unterteilt
    in Argumente und Optionen. Habe mich dabei an mglichst bliche Darstellungen gehalten, z.B. steht <arg> fr ein
    bentigtes Argument, [arg] fr ein optionales. Am Anfang wird eine kurze Zusammenfassung (Synopsis) ausgegeben, hierbei
    wird auch der Dateiname des Programmes mit ausgegeben.
PLCore:
- Application: An nderungen von CommandLine angepasst.



>> 10.04.2009
[CO]
- "Loader::OpenFile()"-Implementation etwas gendert so das weniger "File::IsFile()" aufrufe gemacht werden
 (langsam da Datei zugriff)
- "RegEx" etwas optimiert: "m_lstGroups" ist nun ein "Array", dadurch kann man von der schnellen "Reset"-Methode
  profitieren
- "Base::SetVars()" arbeitet nun mit Regulren Ausdrcken statt mit dem Tokenizer... und ist laut meinen intensiven
  Benchmarks die ich momentan betreibe sogar deutlich flotter. ("246 ms" statt "356 ms" Ladezeit in einem Projekt
  mit grerer Szene :)
  "static RegEx ..." mag zwar nicht Thread-Safe sein, aber das ist PixelLight in seiner Gesammtheit derzeit ohnehin
  nicht und das Beschleunigt die Sache. (ohne "static" beim Projekt von oben "280 ms"... und hier kommts wirklich
  knadenlos auf jede Millisekunde an :/)



>> 08.04.2009
[CO]
- Da das RTTI so grundliegend ist und sehr intensiv genutzt wird machte ich ein paar vorsichtige Optimierungen um
  soviel Performance wie mglich rauszuholen. (muss leider sein :/) Die nderungen hab ich einige male durchdacht
  und genau geprft damit ich blos nix klaput mache... Stefan, bitte zur Sicherheit auch nochmal berfliegen.
- "ClassManager::RegisterClass()": Das langsame durchgehen der 'm_lstClasses'-Liste ob die Klasse schon
   Registriert ist kann man sich sparen, 'm_mapClasses'-Test reicht vllig... + der Listen-Test brachte in
   meinen Tests immer das gleiche Ergebniss (nicht in Liste)
- "Class::HasBaseClass()": Hier braucht man keine Klassen-Namen vergleichen sondern kann direkt Klassen-Zeiger
   vergleichen, in der "String"-Variante wird der Test direkt Implementiert um einen Funktionsaufruf zu sparen
- "Base::IsInstanceOf()": Hier braucht man keine Klassen-Namen vergleichen sondern kann direkt Klassen-Zeiger
   vergleichen, in der "String"-Variante wird der Test direkt Implementiert um einen Funktionsaufruf zu sparen



>> 05.04.2009
[CO]
- "Tokenizer::StreamIsString()" nach "BufferedReader::IsString()" verschoben, dadurch kann man ein internes
  'GetSubstring()' nur fr String vergleichen vermeiden (... performance...)
- "Tokenizer::StreamRead()": "m_nPosition++" aus der Schleife gezogen und zu "m_nPosition += nCount" gemacht
- "Tokenizer": "EndOfLine"-Definition fr "\n" hinzugefgt damit man statt 'm_sEndTag = "\n"' einfach
  "m_sEndTag = EndOfLine" schreiben kann was um einiges Effizienter ist da keine dynamische Speicherbehandlung :D
- "String": Das zuweisen von "char" oder "wchar_t", sprich einzelnen Zeichen optimiert so das wenn die Situation
  es zulsst man keine dynamische Speicherbehandlung braucht
- "String": "GetChar()", "GetWideChar()", "GetInt()", "GetLong()", "GetFloat()" und "GetDouble()" Implementation
  berarbeitet damit so effizient wie mglich (keine xxx Funktionsaufrufe etc.)
- "StringBufferUnicode" & "StringBufferUnicode" & "StringBufferUTF8": Entfernte die "GetString()"-Methode da im
  grunde nur ein Umweg (= balast) in einem String-System das 'sehr eng verdrahtet' ist



>> 27.03.2009
[CO]
- "Bitset": Neue Funktion: "GetNumOfSetBits()": Gibt die Anzahl der auf "true" gesetzten Bits zurck



>> 25.03.2009
[CO]
- "Loader::OpenFile()" muss es natrlich auch erlaubt sein Dateien beim Speichern neu zu erzeugen, hm, merkwrdig das dies
  bis jetzt noch nicht aufgefallen war...
- "Loader::OpenFile()" sollte natrlich auch ohne eingetragene "Basis Pfade" funktionieren, tat es aber bis jetzt nicht



>> 11.02.2009
[CO]
- Bitset: 'GetNumOfIntegers()' & 'GetIntegers()' hinzugefgt damit man an die interne Datenreprsentation rankommt...
  was hin und wieder hilfreich sein kann...



>> 06.02.2009
[CO]
- 'DynLib': Neue Funktion 'GetAbsPath()' -> Gib den absoluten Pfad der geladenen Dynamischen Bibliothek zurck



>> 30.01.2009
[CO]
- 'Singleton': 'DestroyInstance()'-Funktion hinzugefgt mit der man manuell die Zerstrung der Singleton-Instanz
  'befehlen' kann. Da das Singleton normalerweise erst 'gaanz am Ende automatisch' zerstrt wird kann es zu
  problemen kommen wenn man eine Anwendung schreibt die in eine andere Eingebettet ist... + so kann man nie die
  von VC angebotenen Speicherleck Tests nutzen da dann immer angemeckert wird es gbe ein Speicherleck da die
  Singletons erst nach dem Test freigegeben werden. Auf dauer sollten wir versuchen soweit mglich komplett auf
  Singletons zu verzichten... (einfach weil man nicht wirklich Kontrolle ber erzeugung und lschung hat :/)



>> 26.01.2009
[SB]
- ChunkLoaderPL: Fehler behoben, wodurch sich das Projekt unter Linux nicht mehr bersetzen lie.
  Statische Member einer Klasse mssen *immer* in einer .cpp Datei definiert werden, da diese als
  Symbol exportiert werden. Nur im Header einfgen reicht nicht aus, da dann ein "undefined external
  symbol"-Fehler ausgelst wird, wenn von ausserhalb der Projektes versucht wird, auf dieses Symbol
  zuzugreifen. Also bitte bei statischen Members immer eine Definition in einer .cpp Datei hinzufgen
  (einzige Ausnahme sind Templates, da der Compiler das hier automatisch macht), oder statt dessen enums
  verwenden.



>> 25.01.2009
[CO]
- 'GetHexValue()' aus einem von Stefans Projekten nach 'ParseTools::ParseHexValue()' verschoben da man das durchaus fters mal brauchen kann



>> 22.01.2009
[CO]
- 'Chunk'-Klasse hinzugefgt die z.b. zum speichern von Keyframes genutzt werden kann



>> 14.01.2009
[SB]
- FileLinux: Die Klammerung war hier falsch, weshalb Verzeichnisse nicht mehr richtig erkannt wurden. Darum funktionierte PLProject nicht
  mehr richtig. Habe hier gleich die Fehlermeldungen ein wenig erweitert. Keine Ahnung, warum das noch nicht frher aufgefallen ist ...



>> 01.01.2009
[CO]
- 'Timing::CheckUpdate()': Hier kann man nun optional einen Parameter bergeben der im Falle eines FPS Limits zurckgibt wie lange man noch
  warten muss bis es Zeit fr das nchste Update ist. So kann man direkt diesen Wert fr 'Sleep' nutzen anstatt '1'.
- 'Timing::Update()': FPS Limit wird nun auch ausgefhrt wenn gerade 'freezed' aktiv ist



>> 03.12.2008
[SB]
PLCore:
- Neue Config-Klasse fr PLCore hinzugefgt und erst einmal nur die Einstellung "LoadLibsFromRuntime" aus PLEngine hierher verschoben.
  Ansonsten hat man das Problem, dass eine Applikation, die noch nicht von PLEngine abhngig ist, auch diese Option nicht kennt und daher
  nicht die Plugins im PL-Runtime sucht. Daher muss diese Einstellung so frh wie mglich kommen, damit ist das Problem erstmal behoben.
  Jetzt mssen wir mglichst schnell die ganze Config-Problematik nochmal sauber angehen, ansonsten haben wir bald ein echtes Problem ...
PLPlugin:
- BasicSceneApplet entfernt. Dies wre eine totale Verkomplizierung, wenn man hier nochmal eine extra Ableitungshierarchie
  aufmacht. Und damit knnte dann immer noch nicht eine Applikation zwischen Plugin und Exe 'geteilt' werden.
- Statt dessen hat PluginPixelLight nun direkt einen Zeiger auf eine Applikation, die dann eingebettet wird. Dank der
  nderungen am Application-Framework kann nun generell jede Applikation (ab GuiApplication) in fremde Fenster eingebettet
  werden, dies wird hier nun einfach verwendet. Es wird eine Application wie gewohnt instanziiert, dann wird aber nicht
  Run() aufgerufen, sondern die Applikation in das Plugin-Window eingebettet. Als Test habe ich die Teapot-Application
  verwendet, die Application kann aber jetzt ganz einfach ausgetauscht werden.



>> 03.12.2008
[CO]
PLCore:
- "64 Bit 'Bugfix': Core::GetRuntimeDirectory()" vom "25.08.2008" rckgngig gemacht da Windows das
  'normalerweise' Automatisch macht.
  Im 3ds Max Scene Exporter muss der alte Hack drinnen bleiben da man auf einem 64 Bit OS ein 32 Bit PL SDK
  Installieren kann... und dann ein 64 Bit 3ds Max nutzt, das sucht dann nach dem Registry Eintrag um automatisch
  feststellen zu knnen wo der PLSceneViewer liegt - und findet das dann natrlich nicht da es in einem
  "Magischen" 'Wow6432Node'-Unterordner abgelegt wurde. :D
PLPlugin:
- 64 Bit VC Projekt Einstellungen hinzugefgt
PLPluginMozilla:
- 64 Bit VC Projekt Einstellungen hinzugefgt



>> 29.11.2008
[CO]
- Var: 'GetFlagsFromString()' & 'GetStringFromFlags()' public gemacht da man diese Funktionalitt auch von auen brauchen kann
- Da wir berall 'PL_VAR_FLAGS' als 'uint32' handhaben stellte ich die paar Stellen die 'int' nutzten hier auch auf 'uint32' um... macht nicht
  wirklich einen unterschied da beides 32 Bit, aber so ists konsequent. :D



>> 16.10.2008
[CO]
PLPlugin:
- Projekt ist wieder bersetzbar, aber noch nicht wirklich wieder lauffhig. 'PL::Init()' etc. gibts nun nicht mehr, habe erstmal
  BasicSceneApplet angelegt - eine Klasse von 'BasicSceneApplication' abgeleitet die als 'Applet' fungieren soll.



>> 29.09.2008
[SB]
PLCore:
- Application: Verwaltung von Kommandozeilen-Optionen durch eine Instanz von CommandLine hinzugefgt. Es werden ausserdem gleich
  einige Standardoptionen hinzugefgt: "--version" zeigt Programmname und Version an, "--help" zeigt alle zur Verfgung stehenden
  Optionen an. Das Verhalten dieser Kommandos kann wie blich ber virtuelle Funktionen berschrieben werden.
  Ich mchte es hier dem Programmierer so einfach wie mglich machen und ausserdem dafr sorgen, dass PL-Applikationen
  gleich so viel Komfort wie mglich bieten. Oftmals stt man auf Programme, wo alles gut gemacht ist, aber dann fehlen solche
  Standarddinge wie "--version" oder Kommandozeilenoptionen berhaupt. Bei PL ist das nun gleich standardmig drin, es sei denn
  ein Programmierer baut dies bewusst wieder aus, was natrlich auch mglich sein sollte (CommandLine.Clear()). 



>> 28.09.2008
[SB]
- CmdLineParser durch die neu implementierten Klassen CommandLine und CommandLineOption ersetzt. Das Prinzip bleibt zwar
  das gleiche, die Schnittstelle von CommandLine entspricht jedoch mehr unserem blichen PL-Style als dies bei CmdLineParser
  der Fall war. So knnen bspw. die einzelnen Optionen ber die Methoden AddOption und AddFlag hinzugefgt werden, anstatt wie
  bisher alles in einen recht kryptischen String zu packen, der erst einmal geparsed werden musste. Optionen, die sowohl einen
  kurzen als auch einen langen Namen haben, gehren nun auch direkt zusammen. Zustzlich wird noch eine Beschreibung zu jeder
  Option gespeichert, was dazu benutzt wird, um automatisch einen Hilfetext auszugeben, in dem alle vorhandenen Optionen
  aufgezhlt werden. In Verbindung mit dem Application-Framework knnen damit nun sehr einfach Kommandozeilenoptionen
  verwaltet werden, was ingesamt einen sehr guten Eindruck machen sollte, wenn jede PL-Applikation solche Standardfunktionen
  schon bietet, ohne das der Programmierer sich gro darum kmmern muss. 
PLCore:
- Application: Der Executable-Dateiname und die Argumente werden jetzt nicht mehr im Constructor sondern bei Run bergeben.
  Alle Projekte wurden entsprechend angepasst. Da bei dieser Reihenfolge ChangeIntoAppDirectory() nicht mehr vernnftig von
  Aussen aufgerufen werden kann, habe ich dies nun erstmal in GuiApplication::OnInit() eingebaut. Dies sollte auf jeden Fall
  von der Application selbst entschieden werden, und nicht von Aussen aufgerufen werden.



>> 05.09.2008
[CO]
PLCore:
- Application: "GetName()" in "GetTitle()" umbenannt
- Application: "GetFilename()" in "GetExecutableFilename()" umbenannt
- Application: "OnHelp()" in "OnPrintHelp()" umbenannt
- Application: "OnVersion()" in "OnPrintVersion()" umbenannt
- Application: GetExitCode(), SetExitCode(), IsShutDown(), ShutDown(), OnShutDown() in PLGui::Application verschoben
- Application: Neue Funktion: GetStartupDirectory(), gib das aktuelle Verzeichniss zurck das beim aufruf des Applikation
  Verzeichnisses eingestellt war
- Application: 'OnInit()' in 'GuiApplication' verschoben
- Application: 'Title' muss nun ber 'SetTitle()' gesetzt werden und kann nicht mehr direkt im Konstruktor bergeben werden



>> 25.08.2008
[CO]
PLCore:
- 64 Bit 'Bugfix': Core::GetRuntimeDirectory(): Macht ein 32 Bit Programm bei einem 64 Bit OS in der Registry herum, so landen dessen
  Eintrge in einem 'Wow6432Node'-Unterordner. Also statt 'SOFTWARE\\PixelLight\\PixelLight-SDK' dann
  'SOFTWARE\\Wow6432Node\\PixelLight\\PixelLight-SDK' ... nicht das es zu einfach wird. *g*



>> 24.08.2008
[CO]
- System: GetPlatform() gibt wieder 'Win32' oder 'Win64' zurck statt 'Windows' da hier eine feinere Unterscheidung z.B. beim Plugins laden
  hilfreich ist. Unter Linux wird derzeit wie gehabt 'Linux' zurckgegeben, ob wir hier dann auch 32/64 Bit unterscheidungen brauchen mssen
  wir uns spter mal genauer anschaun.



>> 23.08.2008
[CO]
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da fr 32 Bit als auch fr 64 Bit
PLNetwork:
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da fr 32 Bit als auch fr 64 Bit
PLCore:
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da fr 32 Bit als auch fr 64 Bit



>> 22.08.2008
[CO]
- Der 64 Bit Support von PLGeneral funktioniert nun. CMake Dateien schau ich mir als nchstes an + ein paar Dinge msste man
  wohl umbenennen damit es 'Sauber' ist. 'SystemWin32' z.B. zu 'SystemWindows' da es fr 'Win32' und 'Win64' nutzbar ist. :D



>> 21.08.2008
[CO]
- Fing an mich mit 64-Bit Support auseinander zu setzen. 'WIN64' wird zustzlich als Precompiler Definition hinzugefgt.
  Bei zumindestens schonmal einer Stelle, und zwar in SystemWin32::GetCPUMhz() muss man nun mit 'WIN64' eine Fallunterscheidung machen.



>> 20.08.2008
[SB]
- HTMLParser wieder entfernt, da mir das alles nicht robust genug ist. Um Texte anzuzeigen, wird nun ein eigenes
  XML-Format verwendet, da muss man nicht die ganzen HTML-Probleme mit sich herumschleppen und das war auch relativ
  schnell und einfach implementiert. Fr "echtes" HTML kann man dann evtl. spter auf vernnftige Bibliotheken setzen.



>> 12.08.2008
[CO]
- Ich entschloss mich dazu die "SimpleList"-Implementation noch ein Stck radikaler zu machen... und hier auch keine virtuellen Funktionen
  einzusetzen so das nochmal 4 Byte fr die Virtuelle-Tabelle wegfallen. Eine leere "SimpleList" Instanz ist nun also nur noch 4 Byte gro.
  "Iterable" und "Container" Funktionen sind wie gehabt da und lassen sich genauso nutzen, auch sind weiterhin Funktionen drinnen die
  Daten von "Container" bernehmen knnen - nur kann man "SimpleList" nicht mehr auf "Container" oder gar "Iterable" casten. Da Sinn
  und Zweck dieser Implementation jedoch ist "so Speichereffizient wie irgend mglich sein", kann man das denke ich rechtfertigen
  das diese Klasse etwas aus der "Container"-Reihe tanzt.
- Die internen Daten von "SimpleList" sind nun von auen Zugreifbar fr maximale Optimierungs mglichkeiten. Das ist zwar sehr unschn
  und Riskant - aber diese Klasse sollte man eh nur nutzen wenn man genau weis was man will und warum. Die Vorteile berwiegen hier
  wie man in PLCore::Event sehen kann die Nachteile finde ich.
PLCore:
- Dadurch das "SimpleList" von PLGeneral nun keine Virtuelle-Tabelle mehr besitzt wurden Event und EventHandler Instanzen noch
  kompakter. Vorher:
    Event        = 12 Byte
    EventHandler = 20 Byte
  nun
    Event        = 8 Byte
    EventHandler = 12 Byte
  ... ich denke NOCH weiter runter mit dem Speicherverbrauch ohne coole Funktionalitt einben zu mssen knnen wir nicht mehr.
  Event ist nun dank "SimpleList" also nur noch halb so 'gro' wie vorher, EventHandler sogar nur noch ein drittel so gro. :D
- Entfernte 'm_nNumOfHandlers' im Event, dadurch ist ein Event nun nur noch 4 Byte gro - mal schaun ob man da noch irgendwo
  reduzieren kann... *g*
  Das entfernen wurde mglich da ich Zugriff auf die internen "SimpleList" Daten nun public machte - so kann man 'sehr Performant'
  ber die Daten iterieren - genau das was man hier ssseeeeehr oft macht, und daher wre das ber einen Iterator gehen der intern
  Dynamsich erzeugt werden muss nicht zumutbar gewesen.



>> 11.08.2008
[CO]
- Bugfix: Directory::CreateRecursive(): Hier muss auf jedenfall noch 'GetRoot()' (zur Sicherheit fgte ich auch noch 'GetProtocol()' ein)
  beim Pfad vorne eingefgt werden - sonst kann es schnell zu Problemen kommen wenn ein absoluter Pfad bergeben wurde. Viel mir
  gerade im 3ds Max Scene Exporter auf als 'neben' den gewnschten Verzeichnissen auch noch 'sollten nicht da sein'-Verzeichnisse
  erzeugt wurden.



>> 10.08.2008
[CO]
- "SimpleList" angelegt. Da "List" einige Daten speichert um diverse Operationen zu beschleunigen, aber in ein paar Situationen
  man diese Operationen nicht braucht und lieber eine 'super Speicherschonende' Liste htte gibts nun "SimpleList". Startpunkt
  war "List" das ich schrittweise Umformte:
  - 'm_nNumOfElements' raus
  - 'm_pLastElement' raus
  - 'ListElement::pPreviousElement' raus
  -> dadurch ist SimpleList 8 Byte wenn leer im gegensatz zu "List" 16 Byte leer.
PLCore:
- Event und EventHandler Klassen von "List" auf das neue "SimpleList" umgestellt. Vorher
    Event        = 16 Byte
    EventHandler = 36 Byte
  jetzt
    Event        = 8 Byte (+ 4, siehe unten)
    EventHandler = 20 Byte
  -> nderte an ein paar Stellen die Verwendung der Liste damit mglichst keine 'ineffizienten' Operatoren genutzt werden.
  Spendierte Event 'm_nNumOfHandlers' das 'GetNumOfElements()' aufrufe bei SimpleList vermeitet - denn diese Operation ist nun
  langsam. Es lohnt denke ich hier aber 4 Byte fr bessere Performance zu investieren, denn 'GetNumOfElements()' wre sonst
  'sehr huftig' aufgerufen worden. Event ist nun also 12 Byte, aber immer noch 4 Byte kleiner als vorher (davon knnen wir uns
  ein Eis kaufen gehen *g*)... und bei jedem EventHandler den man einhngt spart man nochmal durch die schlankere "SimpleList"
  Implemenation. Lohnt sich also denke ich.



>> 09.08.2008
[CO]
- "PLGeneralStat.vcproj": Gib seine Objekt-Dateien nun in ein eigenes Build-Verzeichniss aus. Ich hatte in letzter Zeit stndig
  Linker fehler beim bersetzen - jetzt weis ich auch warum. :D
- MODULE_LICENSE() hinzugefgt fr die Angabe der Lizenz. Mir war es wichtig das diese Information allerdings auch direkt im Modul
  Abrufbar ist - z.B. damit man ber ein Plugin-GUI dann das dort auch bequem sehen kann.
- In Funktionen wie z.B. "ModuleID<T>::SetModuleName()" war der 'berlaufschutz' nicht korrekt Implementiert, so msste das nun
  korrekt sein



>> 09.08.2008
[SB]
PLCore:
- Events: Mittels ConnectBind() knnen nun auch EventHandler an Events eines anderen Typs gebunden werden, wobei die
  Parameter analog zu bind() gebunden werden. Intern wird hier einfach ein EventHandler vom richtigen Typ erzeugt und
  mit dem Event verbunden. Damit dieser dynamisch erzeugte EventHandler auch wieder gelscht wird, brauchte es leider
  eine Klasse mit virtuellem Destruktor, die in eine Liste beim EventHandler eingetragen wird. Dies wird aber nur dann
  bentigt, wenn wirklich mal ein Event 'umgebogen' wird, im Normalfall bleibt die Liste leer. Ich hoffe, dass dies so
  am besten ist und damit bereinstimmt, wie Events und Handlers grtenteils benutzt werden. Sollte sich herausstellen,
  dass man die meiste Zeit ConnectBind benutzt, sollte man sich vielleicht eine andere Lsung berlegen, die 'teurer' ist
  fr den Normalfall, dafr aber 'billiger' fr den Bind-Fall. Bitte beachten, dass die Functors und Events zur Zeit noch
  getestet werden, einiges ist noch nicht so stabil wie es sein soll (z.B. wenn man mal die falsche Anzahl Parameter bergibt).
  Das berarbeite ich gerade nochmal, die Funktionalitt sollte aber so bleiben wie sie ist.



>> 08.08.2008
[CO]
- Loadable::Reload(): Funktionierte unter umstnden nicht korrekt da direkt eine Referenz auf einen 'internen' String bergeben
  wurde der whrend des Ladevorgangs verndert werden kann - und schon klappte das Neuladen nicht mehr. (altbekanntes "Problem" :)



>> 06.08.2008
[CO]
PLCore:
- 'ShutDown()' und 'IsShutDown()' Methoden in die 'Application'-Klasse eingebaut. Dies ist identisch zu dem was in
  der alten 'PLEngine::PL'-Klasse ist und das wie ich finde schon immer sehr gut funktionierte. Fgte desweiteren
  eine virtuelle 'OnShutDown'-Methode hinzu die innerhalb 'ShuwDown()' aufgerufen wird.
- 'Application'-Klasse: "OnRun()" Implementationen geben im 'normalfall' "GetExitCode()" zurck, nur im Fehlerfall was
  eigenes wie z.B. "-1" - so kann ein User der nur die Application Klassen nutzt ber "SetExitCode()" einen Error Code
  setzen der zurckgegeben werden soll



>> 03.08.2008
[CO]
PLCore:
- 'Application'-Klasse um 'Name' erweitert, dies ist recht ntzlich da man dann z.B. direkt anhand dieses Namens z.B.
  den Standard-Titel eines Fensters setzen kann.
- 'Base'-Verzeichniss mit alter Event und Functor Implementation gelscht



>> 02.08.2008
[SB]
PLCore:
- Bind-Funktionalitt fr Funktoren hinzugefgt. Damit ist es mglich, Parameter eines Funktors zu binden, also
  auf einen festen Wert zu setzen und damit die Signatur einer Funktion zu verndern. Diese Implementation erlaubt
  es auch, Eingabeparameter und gebundene Werte frei festzulegen und damit die Reihenfolge, Anzahl und Art
  der Parameter des neu erzeugten Funktors fast beliebig bestimmen zu knnen. Ergebnis der Bind-Funktion ist
  ein Funktor, dessen Signatur durch die verwendeten Parameter komplett festgelegt ist und der daher selbst
  wieder typensicher ist.

  Anwendung:
    Beispielsweise kann man auf diese Weise einen weiteren Parameter hinzufgen, um z.B. bei Events noch
    einen Zeiger auf das Objekt mitzuliefern, das dieses Event erzeugte (z.B. Window* oder SceneNode*).
    Durch die Verwendung von bind wird ein Funktor erzeugt, der wieder kompatibel zum Event des jeweiligen Objektes
    ist.

  Verwendung:
    bind(f, t0, t1, ...)
    - f: Eingabe-Funktor, der letztlich mit genderten Parametern aufgerufen wird
    - t0: Wert fr Parameter 0
    - t1: Wert fr Parameter 1
	- etc.

    Anstelle von echten Werten fr Parameter knnen Platzhalter verwendet werden, um die Parameter
    des erzeugten Funktors durchzureichen:
	- _0: Platzhalter fr Parameter 0
	- _1: Platzhalter fr Parameter 1
	- etc.

  Beispiele:
	// Define a test functor of type void(int, float)
	Functor<void, int, float> f(Function);

	// Call directly
	f(1234, 0.25f);

	// Bind first parameter -> getting functor of type void(float)
	bind(f, 1234, _0)(0.25f);

	// Bind second parameter -> getting functor of type void(int)
	bind(f, _0, 0.25f)(1234);

	// Bind both parameters -> getting functor of type void()
	bind(f, 1234, 0.25f)();

	// Exchange parameters -> getting functor of type void(float, int)
	bind(f, _1, _0)(0.25f, 1234);

	// Just to show the resulting functor's type
	Functor<void, float> f2 = bind(f, 100, _0);
	f2(0.1f);



>> 29.07.2008
[SB]
PLCore:
- FunctorTools hinzugefgt und Funktionen erstellt, um einen Funktor zu erzeugen. Das dient vor allem der
  bersichtlichkeit, damit man nicht stndig die ganzen Template-Parameter schreiben muss, gerade wenn man
  spter mit bind etc. die Funktoren noch ineinander schachteln muss. Ich habe mich dabei an die blichen
  Benennungen gehalten, die man in den meisten anderen Signal/Slot Implementationen findet: ptr_fun()
  erzeugt einen Funktor fr eine statische Funktion, mem_fun() erzeugt einen Funktor fr eine Memberfunktion.
- 'Types' in 'Traits' umbenannt, was eine bliche Bezeichnung fr solche Typendefinitions-Klassen ist. Die Klasse
  heisst nun FunctorTraits und wurde ausserdem in eine eigene Headerdatei ausgelagert, die allerdings "Traits.h" heit.
  Zustzlich wurde auch noch Functor selbst in die Klasse aufgenommen, damit man alle bentigten Datentypen dort beisammen hat.
- Analog zum Functor auch bei den Events Types in Traits umbenannt.
- Weitere Klassen umbenannt:
    FuncImpl   -> FunctorImpl (Dateiname ist trotzdem "Impl.h" und nicht "FunctorImpl.h", damit alle Impl's beisammen stehen)
    FuncTyped  -> ImplTyped
    FuncPtr    -> ImplFunPtr
    FuncMemPtr -> ImplMemPtr
  sowie
    FunctorTools -> Tools



>> 28.07.2008
[SB]
PLCore:
- Functor und Events nochmal berarbeitet und bersichtlicher gestaltet (mehrere Dateien).
- Beide Klassen sind nun erstmal so einfach wie mglich gestaltet, dass heit mglichst wenig Ableitungen und
  dadurch auch weniger virtuelle Destruktoren. Mal schauen, ob es fr das neue RTTI notwendig ist, diese Klassen doch
  noch einmal aufzubohren (und dadurch evtl. doch wieder einiges virtuell machen zu mssen), ich fnde es aber schn,
  wenn die Klassen so bleiben knnten, wie sie jetzt sind.
- ManagedEventHandler entfernt, da mir das nie wirklich gefallen hat (leicht unsicher, falls das falsch benutzt worden wre).
  EventHandler sollten lieber als direktes Attribut einer Klasse instanziiert werden statt ber new, und falls es doch
  jemand dynamisch braucht, muss er eben selber dafr sorgen, dass die erzeugten Objekte auch wieder gelscht werden.
- Sowohl Functor als auch EventHandler haben nun wieder einen Default Konstruktor. Es ist zwar schn, wenn es keine Probleme
  gab ohne Default-Konstruktor, jedoch nimmt uns das die Mglichkeit, Funktoren oder EventHandler beispielsweise in einer
  Liste zu speichern oder in anderen Situationen, wo es notwendig ist, zunchst einmal das Objekt ber den Default-Konstruktor
  zu initialisieren und den wirklichen Wert erst spter zuzuweisen. Da beide Klassen so gestaltet sind, dass es problemlos
  mglich ist, zunchst einmal ein leeres Objekt zu erzeugen und erst spter einen Zeiger auf eine wirkliche Funktion zu setzen,
  sollten wir uns diese Mglichkeit nicht unntig verbauen. Abgesehen davon hat das Entfernen des Default-Konstruktors
  von EventHandler das Problem nicht wirklich gelst, weil das eigentliche Problem im Functor lag und nicht im EventHandler,
  ein leerer Functor htte daher immernoch zum Crash gefhrt. Das wurde nun behoben, da ein leerer Functor jetzt eine Null-Funktion
  aufruft, anstatt wie bisher einfach abzustrzen :-)
- Ein EventHandler kann nun auch auf mehrere Events hren, womit es grtenteils wirklich unntig sein sollte, EventHandler dynamisch
  zu erzeugen. Christian: Bitte nochmal genau meine Implementation durchschauen, da bei so etwas leicht Fehler passieren (NxM Beziehung,
  beide Objekte mssen sich im Destruktor aus der Liste des jeweils anderen Objektes austragen, das wird leicht ganz schn kniffelig).



>> 23.07.2008
[CO]
- Neue System-Funktion: 'GetUserHomeDir()' liefert das 'Home Directory' des aktuellen Benutzers zurck - dort kann/sollte
  man dann immer Dinge wie Konfigurationen, Screenshots etc. speichern so das dort wo das eigentliche Programm gespeichert
  ist NICHTS dynamisches gespeichert wird. Das ist unter Unix scheinbar so gngig + unter Vista wird da wie es aussieht
  auch Wert drauf gelegt... jedenfalls muss man dort dann erst Verzeichnissattibute ndern bevor Logs etc. im Programm
  Verzeichniss geschrieben werden knnen...
  -> PLGeneral ist dadurch nun auch von 'Userenv.lib' Abhngig, das sollte aber kein Problem sein. Man htte sicherlich
     auch irgendwie in der Registry herumfummeln knnen, was aber nicht ganz so prall sein soll - dann lieber gleich
     Funktionen die das OS dafr bereitstellt nutzen. :D
  -> Linux Implementation 'msste so passen', aber da ich es nicht testen konnte ist es Auskommentiert.



>> 21.07.2008
[SB]
- HTMLParser implementiert. Diese Klasse liest eine HTML-Datei ein und erzeugt daraus ein XML-Dokument. Besonders robust ist
  der Parser sicherlich nicht, allerdings habe ich versucht, viele typische Fehler in HTML-Dateien (z.B. falsch geschlossene Tags
  oder gemischter HTML und XML-Syntax) zu bercksichtigen, so dass die Datei dennoch eingelesen werden kann. Die Klasse ist
  aber ein reiner Parser und beinhaltet keinerlei HTML-Semantik (was heit, dass semantische Regeln, wie z.B. <li> kann nur in
  Listen vorkommen oder <tr> nur in Tabellen, nicht berprft werden knnen). 



>> 18.07.2008
[CO]
- ClassManager::LoadPlugin(): Um Format Versions Informationen erweitert ('plugin'-Dateien)



>> 10.07.2008
[CO]
- ConfigLoaderPL & LocalizationLoaderPL: Um Format Versions Informationen erweitert



>> 09.07.2008
[CO]
- LoadableManagerLoaderPL: Um Format Versions Informationen erweitert. So wird es Zuknftig dann in all unseren XML Formaten gehandhabt.
- Loader: Ein paar 'Standard Strings' hinzugefgt



>> 08.07.2008
[SB]
- Statische Version von PLGeneral hinzugefgt. Ich denke, PLGeneral und evtl. spter noch PLGui sollten erstmal als statische
  Bibliotheken ausreichen, damit man kleine Tools auch ohne Abhngigkeit von der PixelLight-Runtime schreiben kann (gerade
  auch wichtig fr unsere internen Tools).



>> 04.07.2008
[CO]
PLCore:
- EventHandler: Standard Konstruktor entfernt da es ansonnsten einen Crash gibt wenn man einen nicht Initialisierten
  EventHandler nutzt - eine Situation die es auf jedenfall zu vermeiden gilt. Habe bei mir diesen Konstruktor schon seit
  Wochen auskommentiert und es gab keine Probleme.



>> 29.06.2008
[SB]
PLPluginMozilla:
- PLPluginMozilla implementiert.
- Anbindung an unsere abstrakte Plugin-Klasse vorgenommen und PixelLight-Plugin erfolgreich im
  Mozilla ausgefhrt.



>> 28.06.2008
[SB]
PLPlugin:
- Projekt gestartet. PLPlugin stellt eine Schnittstelle zur Verfgung, um PixelLight als Plugin in andere
  Umgebungen/Applikationen einzubinden. Also PixelLight als Plugin fr z.B. Browser, nicht Plugins fr PixelLight :-)
  Dazu wird eine abstrakte Plugin-Klasse bereitgestellt, die von konkreten Wrappern fr verschiedene Plugin-Schnittstellen
  angesprochen wird. Von dieser Plugin-Klasse werden dann konkrete Plugins abgeleitet, z.B. das standard PixelLight-Plugin,
  das wir letztlich im Browser oder sonstwo sehen wollen.
- Basisklasse Plugin implementiert, die das abstrakte Plugin-Interface darstellt.
- Basisklasse PluginImpl implementiert, die nach dem Backend-Prinzip das Interface
  fr konkrete Backends bereitstellt.
- PluginOpenGL als Testplugin implementiert, in dem eine minimale OpenGL Szene angezeigt wird.
- PluginPixelLight erstellt fr das standard PixelLight-Plugin. 
- Das Triangle-Sample genommen und als vorlufiges PixelLight-Plugin implementiert :-)
PLPluginActiveX:
- PLPluginActiveX implementiert. Diese konkrete Implementation von PluginImpl
  stellt das ActiveX Backend fr unsere eigene Plugin-Klasse dar.
- Den Wrapper auf die Verwendung unseres abstrakten Plugin-Interfaces umgestellt.
- Den OpenGL-Test hier entfernt und dafr als PluginOpenGL in PLPlugin implementiert.
- Das PixelLight-Plugin luft nun zum ersten Mal korrekt im Browserfenster :-)



>> 24.06.2008
[SB]
PLPluginActiveX:
- Projekt gestartet. PLPluginActiveX ist ein Container und Wrapper fr ActiveX, ber den das PLPlugin-Interface unter
  ActiveX verwendet werden kann.
- ActiveX control erstellt und an unsere Projektstruktur angepasst. Einstellungen
  gefunden, die zur Einbindung von OpenGL erforderlich sind.
- Kleines OpenGL Testplugin implementiert.



>> 22.06.2008
[CO]
- System Klasse um 'GetCurrentThread()' erweitert - das nutzen wir in verschiedenen Vorlesungen des fteren mal und kann ganz hilfreich sein.
  Rauszufinden wie man diese Funktion intern realisieren kann war allerdings etwas - knifflig. Leider scheint es weder bei Windows
  noch bei Linux mglich zu sein an die Funktions Parameter zu kommen die man einem Thread beim erzeugen gegeben hat. Daher muss man
  das leider etwas umstndlicher anpacken um an die PixelLight Thread Instanz des aktuellen Threads zu kommen:
  - Unter Windows lsst sich das mit 'Thread Local Storage' (TLS) realsieren, bis auf die unschne Globale Variable ganz ok wrd ich sagen
  - Unter Linux kann man dafr denke ich 'pthread_getspecific()' nutzen (fand das zuerst, und schaute dann obs unter Windows etwas
    hnliches gibt :)
  Ich habe das direkt mal in 'PLPhysics::WorldThread' ausprobiert, klappt ganz wunderbar. :D
  Sobald die Linux Variante Implementiert ist wrde ich gerne 'System::Sleep()' wieder nach 'Thread::Sleep()' verschieben da es fr mich
  einfach dorthin gehrt und man es in 'neuen Sprachen' wie Java oder C# ebenfalls in der Thread Klasse findet was ich sehr nett finde. Zwar
  ist 'System::GetInstance()->Sleep(100)' 'kompakter' zu schreiben als 'System::GetInstance()->GetCurrentThread()->Sleep(100)', aber irgendwie
  ist das einfach eine Thread Verwaltungs Funktion die fr mich nix in der 'allgemeinen System'-Klasse zu suchen hat, auch wenn man diese auf
  dem aktuell laufenden Thread ausfhrt. Bei Zeiten wrde ich dann auch noch gerne eine 'Thread::Yield()'-Funktion hinzufgen damit wir die
  meisten gngigen Thread Funktionen haben.
- Threads knnen nun auch einen von Menschen lesbaren Namen haben, gerade beim Debugging oder Thread Experimenten ist das sehr hilfreich
- Neue System Funktion: 'Yield()' -> veranlasst im Normallfall den aktuellen Thread den Prozessor aus der Hand zu geben, ebenfalls eine gngige
  Funktion. Habe das erstmal in die System Klasse eingebaut da dort auch die 'Sleep()'-Funktion ist. Hier mssten wir uns wie gesagt nochmals
  berlegen ob wir das wirklich in der System Klasse lassen wollen oder nicht lieber in die Thread Klasse schieben damit die Thread Dinge
  beisammen sind... auch wenn diese Funktionen auf den 'aktuell laufenden Thread' arbeiten und nicht auf die Thread Instanz was ein klein wenig
  verwirrt, aber das ist auch bei Java und C# so. (im aktuellen Semester habe ich wie gesagt sehr viele Vorlesungen die sich mit Threads in
  verschiedensten Sprachen befassen :) Wir mssen uns das nicht sofort nochmal anguckn ob wir das in der System Klasse haben wollen oder das so
  machen wie es mittlerweile viele API's handhaben und das den "Umstieg auf PixelLight" etwas einfacher machen knnte. :)



>> 21.06.2008
[SB]
PLCore:
- Neue Klasse Core hinzugefgt, die statische Funktionen bereitstellt, um Informationen ber die gesamte
  PixelLight-Installation abzufragen (z.B. Installationspfad, Versionsnummer etc.). GetRuntimeDirectory
  wurde von PLEngine hierher verschoben, und berall, wo der Installationspfad abgefragt wurde, wird nun
  diese Funktion verwendet (sowas sollte wenn mglich immer zentral an einer Stelle sein und nich dupliziert
  werden).
- Die Informationen ber das aktuelle SDK werden nun aus der Datei PixelLight.h genommen, die im Verzeichnis
  /PixelLight zu finden ist (siehe PLSDK)



>> 01.06.2008
[SB]
- RTTI: Es war immer noch ein Fehler beim Registrieren von Klassen vorhanden. Wenn die Liste der auf ihre Basisklassen
  wartenden Klassen durchgegangen wird, mu die Suche neugestartet werden, damit alle abgeleiteten Klassen auch initialisiert
  werden knnen. Hier war ein saublder fehler drin, wodurch die Klassen meistens nicht initialisiert wurden.
  Aus irgend einem Grund ist die Reihenfolge der Initialisierungen unter VC anscheinend ziemlich optimal, so dass dieser
  Fehler da nicht wirklich aufgefallen ist - solange die Klassen in der richtigen Reihenfolge initialisiert werden
  (z.B. erst SceneNode, dann SceneContainer, dann SCPhysics) funktioniert ja alles korrekt. Beim bersetzen mittels
  CMake ist die Reihenfolge, in der compiliert und gelinkt wird, jedoch eine andere, deswegen fiel der Bug hier ins Gewicht
  und beim Ausfhren konnten Klassen nicht gefunden werden, da diese nicht richtig am RTTI angemeldet wurden.
  Ich habe jetzt keine Probleme mehr feststellen knnen, auch wenn ich mit CMake das bersetzen starte, funktionieren hinterher
  alle Samples korrekt und das dubiose Problem, dass z.B. "SceneNode" nicht gefunden wird, ist nicht mehr vorhanden. Ich hoffe
  mal, dass dies auch meine Probleme unter Linux lst (dort wurden die Loader nicht gefunden, drfte ziemlich sicher das
  gleiche Problem gewesen sein). 
- RTTI: Da es sehr bld ist, das RTTI zu debuggen, wenn es aus irgend einem Grund nicht richtig funktioniert, und man hier
  auch nicht einfach ins Log schreiben kann, da dies ebenfalls schon ein funktionierendes RTTI voraussetzt, habe ich ein neues
  Makro eingebaut, um das RTTI zu debuggen. Normaler Weise ist das deaktiviert, wenn man es aber aktiviert, werden RTTI-Aktivitten
  mit einfachen stdio-Methoden in einer festgelegten Datei (C:\rtti.txt) geloggt. Das drfte es etwas vereinfachen, Problemen
  mit dem RTTI auf die Schliche zu kommen.



>> 22.05.2008
[CO]
- 'Informer' und 'Listener' Templates entfernt da wir zuknftig wie von Stefan vorgeschlagen auf das 'Event'-Konzept setzen das ich mittlerweile
  auch sehr nett finde. Diese zwei Templates wurden nur von 'SceneNode' und 'SceneQuery' innerhalb von 'PLEngine' verwendet, hier werden nun
  'Events' genutzt.



>> 16.05.2008
[CO]
- Wie besprochen liegen System Konsolen Funktionen nun in einer eigenen Klasse die man ber 'System::GerInstance().GetConsole()' bekommt
- XML-Klassen: Interessant. Mir viel gerade als ich Stefans nderungen durchschaute zum ersten mal das 'XmlDocument::SetTabSize()' beim speichern
  berhaupt keine Auswirkung hat da intern immer direkt "    " geschrieben wird. Als ich in den TinyXML Codes nachschaute sah ich das die
  das ebenfalls vergessen haben... oder es warum auch immer gewollt ist. Bei uns ist das jedenfalls nicht gewollt da ich keinen Grund finden
  kann warum die 'XmlDocument::SetTabSize()'-Einstellung ignoriert werden sollte. Darum ging ich die Funktionen die speichern nochmal durch
  und korrigierte das + nutzte '' anstatt "" wo nur ein Zeichen genutzt wird. (die String Klasse kann damit etwas Effizienter arbeiten :)
- XmlNode::GetDocument(): Auch hier war noch ein fieser Bug drinnen. Wow, Respekt, dieses Kerlchen hat sich aber ziemlich lange tapfer im
  Code halten knnen. *g*



>> 17.04.2008
[CO]
- SystemWin32::GetCurrentDir(): Gab das Verzeichniss 'Native' zurck. Da in der Dokumentation nix steht und in Programmen normalerweise
  wenn immer mglich nicht mit 'Native' gearbeitet werden sollte nderte ich das. Dies merkte ich durch 'LoadableType::GetRelativeFilePath()'
  das nicht mehr korrekt ging da alle Basis-Pfade im LoadableManager ein Protokoll vorne haben, aber das von 'System::GetCurrentDir()'
  keines hatte was hier nicht wirklich hilfreich ist. :D
- 'LoadableType::GetRelativeFilePath()': Da 'SystemWin32::GetCurrentDir() & CO' am Ende keinen Slash haben musste hier nun an einer Stelle
  '+1' eingefgt werden. Nun arbeitet diese Funktion wieder korrekt.



>> 05.04.2008
[SB]
- PLMain so umgendert, dass man nun immer den Dateinamen und die Parameter bergeben bekommt. Das wird so auch
  an die Application-Klasse weitergegeben, so ist das einheitlich und man braucht sich nicht mehr zu fragen, ob
  Parameter[0] jetzt der Dateiname ist oder der erste Parameter. Damit dies unter allen System vernnftig funktioniert,
  waren noch ein paar Anpassungen ntig. Man knnte nun berlegen, die Funktion GetProgramName() aus System herauszunehmen,
  damit man das nicht doppelt hat. Natrlich knnte man das dann nur noch nutzen, wenn man auch die Application-Klasse
  nutzt (was man allerdings tun sollte, da es nur Vorteile bringt).
PLCore:
- Mit der Arbeit am Application-Framework begonnen. Die Klasse Application ist die Basisklasse und wrappt
  die Hauptfunktion des Programmes. Alles weitere wird durch Spezialisierungen in anderen Projekten (z.B. PLGui)
  hinzugefgt.



>> 05.04.2008
[CO]
- ThreadLinux: Speichert intern das vom Benutzer gesetzte 'PriorityClass' und 'Priority' damit sich das rein von den Rckgabewerten
  her wie unter Windows verhlt. Linux selbst hat eine Funktion Namens 'pthread_setschedparam' zum setzen der Thread Prioritt - allerdings
  ist 'SCHED_OTHER' als Default-Strategie gesetzt und in dem Fall sind keine Thread Prioritten zulssig da dies komplett der Kernel
  bernimmt. Damit hat sich das mit den Thread Prioritten unter Linux also erledigt.



>> 05.03.2008
[SB]
- Mute die Verwendung des Null-Objektes noch etwas verndern: In (Standard-)C++ ist es nicht erlaubt, statische Member
  ber Objekte anzusprechen. So etwas wie m_lstObjects->Null geht also nicht, es mu List<Object>::Null heien. Leider
  scheint Visual C++ immer noch nicht standardkonform zu sein, da es hier keinerlei Fehler oder Warnungen gab. Fr den
  gcc dagegen ist m_lstObjects->Null ganz einfach unbekannt. Habe alles angepat und hoffe, dass es nun so unter beiden
  Compilern funktioniert.



>> 05.03.2008
[CO]
- Wie besprochen geben nun die Container Referenzen statt Zeiger zurck... die Klassen waren schnell verndert, das hatte
  ich gestern bereits fertig -  alle Projekte entsprechend anzupassen war allerdings 'etwas' mehr Aufwand der sich allerdings
  definitiv gelohnt hat. Stellen wo Zeiger genutzt werden mssten unproblematisch sein da soetwas wie 'if (!...)' oder nur
  'if (...)' weiterhin klappt. Sollte allerdings in den Containern ohne Zeiger gespeichert sein, so knnen diese Abfragen
  teils immer noch bersetzt werden - aber das was abgefragt wird ist dann nicht mehr ob das zurck bekommene Element gltig
  ist, sondern dann wird direkt der Wert dieses Elements getestet. Bei soetwas wie 'int' gespeichert meckert das dann natrlich
  der Compiler nicht an - das kann ganz bse nach hinten losgehen. Eine solche Stelle fand ich bereits, aber um 'alle' zu finden
  mssen wir berall wo Container genutzt werden ohne Zeiger nochmal suchen und durchschauen. :/
  Bin schon schwer gespannt was ich so alles bersehen habe... entweder findet es Stefan oder die Zeit. *g*



>> 03.03.2008
[SB]
- Neuer PLGeneral-Datentyp 'handle'. Es ist irgendwie bld, stndig auf uint32 casten zu mssen oder gleich
  void-Pointer zu bergeben, wenn es um System-Handles geht. Meistens sind diese auf einem System immer vom
  gleichen Datentyp, bei Windows wird HANDLE (DWORD) verwendet, bei Linux ist es meistens int. Daher definiere
  ich das nun in einem PLGeneral-Datentyp 'handle', der fr alle Systemhandles verwendet werden soll. Ebenfalls
  wird auch INVALID_HANDLE je nach System fr ungltige Handles definiert. Dieser Datentyp sollte nicht hufig
  Verwendung finden, aber manchmal braucht man eben auch die Mglichkeit, ber unsere Datentypen wieder an
  System-Handles heranzukommen. Das knnen wir nun ber diesen Datentyp machen, anstatt das vllig undefiniert
  zu lassen oder fr verschiedene Situationen unterschiedliche Datentypen zu definieren (wie frher MODULE_HANDLE).
- FileStdStream erweitert: Es kann nun entweder ein beliebiger Stream-Pointer bergeben werden (FILE*),
  oder ein File-Handle des jeweiligen Systems (int unter Linux, HANDLE unter Windows). Falls ein File-Handle
  bergeben wird, mu hinterher die Datei noch geffnet werden, wobei die bekannten Flags (Read/Write/Text/etc.)
  verwendet werden knnen. Im Falle eines FILE*-Pointers mssen die Access-Flags, die verwendet wurden um die Datei
  zu ffnen, mit bergeben werden. Somit ist es mglich, eine beliebige bereits geffnete oder sonstwie zurckgegebene
  Datei trotzdem ber unseren File-Wrapper anzusprechen. Die Standard-Streams (in/out/err) sind da nur ein Beispiel,
  es knnen jetzt aber auch beliebige andere Dateien oder Pipes so verwendet werden.
- Statt void* wird nun FILE* bergeben, da dieser Datentyp feststeht und sich auch nicht je nach System unterscheidet.

  Da dadurch jetzt leider schon in File <stdio.h> bentigt wird, habe ich die FILE-Vordefinition in eine eigene
  Headerdatei ausgelagert, wo nach Windows und Linux unterschieden wird. Damit wird <stdio.h> wirklich nur da
  eingebunden, wo es unbedingt ntig ist, ohne die Includes berall mit #ifdef's zu verunstalten :-)
- File: Konstruktoren zum ffnen schon vorhanderer Streams/FileHandles via FileStdStream eingebaut bzw.
  ffentlich gemacht.
- File: IsOpen() hinzugefgt
- berall Writeable durch Writable ersetzt. Es scheint zwar beides richtig zu sein, aber writable ist mir irgendwie
  gelufiger - und in meinem Dictionary ist diese Variante fettgedruckt :-)
- Neue Klasse Pipe eingebaut, ber die System-Pipes (named und unnamed) erstellt und angesprochen werden knnen.
- Neue Klasse Process eingebaut, die benutzt werden kann, um externe Prozesse zu starten. Dabei kann die
  Ein- und Ausgabe umgeleitet werden und hinterher ber unsere File-Klasse ausgelesen/geschrieben werden. Das ist
  eine Funktionalitt, die man immer mal wieder braucht, und die mit OS-Funktionen ein absoluter Krampf ist. Darum
  mchte ich gerne PLGeneral soweit vollstndig haben, dass man alles sowas schn einfach und komfortabel damit machen
  kann :-)



>> 02.03.2008
[CO]
- nderte in den Container-Klassen 'AType' zu 'ValueType' damit das hier berall gleich geschrieben ist und somit
  Doxygen bei z.B. dem Iterator eine 'komplette' Klassenhierarchie zeigt und nicht nur die 'Container' Klassen
- Bugfix: Directory::CreateRecursive(): Trotz meiner bei der Implementation merkwrdigerweise erfolgreichen Tests
  (eventuell nicht sonderliche pralle Test Situation erzeugt :) war die Implementation noch nicht ganz ok... Stefan
  hatte ja schon die korrekte Funktionsweise angezweifelt, so 'msste' es nun aber klappen.



>> 29.02.2008
[CO]
- "ConstIterator" hinzugefgt, bin mir allerdings nicht sicher ob das den 'Todo'-Punkt
  "Const_Iterator (currently we can't return some lists)" korrekt behandelt. Hoffentlich geht das so halbwechs,
  whre heftig wenn wir nochmal komplette Iterator Implementationen fr 'const' schreiben mssten. :/
  Wenn das passt, wre es sicherlich ne gute Idee bei 'Iterable::GetIterator()' und 'Iterable::GetEndIterator()'
  das 'const' hinten heraus zunehmen + die mglichkeit einen Iterator einem ConstIterator zuzuweisen.
  (anderst herum natrlich nicht *g*)



>> 28.02.2008
[CO]
Alle Projekte:
- Nahm wie besprochen berall dort wo 'inline' genutzt wird die Export Makros heraus. (siehe Eintrag 24.02.2008
  von Stefan) Damit man an diesen Stellen sehen kann das es absicht ist das hier kein Export Makro ist habe ich
  dort dann jeweils 'inline' reingeschrieben. (ist also nix 'funktionales', sondern als Hilfe/Gedchtnisssttze
  gedacht)
PLGeneral:
- 'SubString' und 'Sub-String' in 'Substring' umbenannt da man diese Schreibweise heute am hufigsten antrifft
- String::String(const utf8 *pnValue) muss natrlich raus da der Compiler hier nicht zwischen den zwei entsprechenden
  Konstruktoren unterscheiden kann (dank Default Einstellungen sieht das dann fr ihn gleich aus :)
- String: "String operator +(utf8 nValue) const;" macht natrlich nicht wirklich viel Sinn da dies eigentlich immer
  ein 'Array von utf8' ist, nahm es heraus. Das gleiche bei "String::operator +=(utf8 nValue)" und
  "friend String operator +(utf8 nValue, const String &sString)" und "GetUTF8Char()" und "Replace(utf8 nOld, utf8 nNew)".
  "SetCharacter()" mit UTF8 braucht natrlich einen Zeiger.
- Bugfix: "String(const utf8 *pszString, bool bCopy, uint32 nLength, uint32 nNumOfBytes)": "UTF8Tools::GetNumOfCharacters()"
  sollte man natrlich auch die Anzahl der Bytes mitgeben...
- "Functions.cpp": "HashFunction::Hash(const String &sKey)": Hier sollten Fallunterscheidungen fr die verschiedenen
  Formate gemacht werden... das knnte allerdings schnell zu problemen fhren wenn man Formate mischt und sich dann
  wundert wieso man 'bei doch eigentlich scheinbar gleichem String' unterschiedliche Schlssel bekommt. Das sollte
  man sich also dann eventuell nochmal genauer anschaun.
- RegEx: 'Mode' zu etwas universelleren Flags gemacht in denen 'Match' und 'Encoding' gespeichert wird, so braucht
  man fr 'Encoding' keine weiteren Parameter. Setzt man kein spezielles 'Encoding'-Flag, so wird das interne
  String Format (ASCII oder UTF8) des bergebenen Ausdrucks verwendet. 'Subject' bei 'Match()' wird in dieses
  interne RegEx Format 'gezwngt'. 'Meistens' macht man sich ber 'Encoding' keine Gedanken und nutzt nur ASCII,
  in dem Fall kann man das auch hier wie gehabt als Benutzer ignorieren. :D
  UTF8 Support in RegEx Implementation eingebaut, allerdings funktioniert das noch nicht richtig da u.a.
  "UTF8Tools::Unescape()" noch Probleme mit soetwas wie "\\s*(\\w+)\\s*" hat was es dann zu z.B. "s*(w+)s*" umformt +
  einige entsprechenden Funktionen in der String-Klasse noch nicht richtig Implementiert sind. Aber der Anfang wre
  gemacht, taste wir uns also mal voran bis das alles korrekt auch mit UTF8 luft...



>> 27.02.2008
[SB]
- Linux-Implementationen der Konsolen- und Memoryfunktionen getestet und wo ntig angepasst. Die Datei /proc/meminfo
  sieht bei mir vllig anders aus als offenbar in dem Beispiel, da sollte man sich also offenbar nicht drauf verlassen,
  dass der x-te Wert das und das bedeutet. Deswegen Parse ich nun nach den entsprechenden Strings. Worauf ich mich allerdings
  verlasse ist, dass der Wert immer in Kilobyte angegeben ist - hoffe, das ist auch so, ansonsten msste man auch noch nach
  "kB|MB|B" parsen.
- System::ConsolePrint hinzugefgt, damit alle Konsolenfunktionen beisammen sind und man nicht nur, um eine kleine
  Konsolenausgabe ttigen zu knnen, auch noch File einbinden muss. So wird die Funktion auch gefunden, ansonsten wrde
  man sich wohl wundern, dass zwar alle mglichen Konsolenfunktionen in System zu finden sind, nur ein simples Print fehlt.



>> 27.02.2008
[CO]
- Bugfix: "XmlBase::XmlBase(void *pData)", "((XmlBase*)m_pData)"... autsch, das sollte natrlich
  "((TiXmlBase*)m_pData)" heien, muss irgendwann einmal durcheinander gekommen sein... gab natrlich ein
  Speicherleck + ein Test wie 'GetFirstChild() == GetLastChild()' um zu sehen obs nur ein Kind gibt ging natrlich
  nicht da jedesmal ein anderer PL XML Knoten zurckgegeben wurde.
- Iteratoren: berarbeitete die Implementation nochmal so das Iteratoren beliebig 'kopiert' werden knnen. Intern
  wird hnlich wie bei bei den Strings gearbeitet - Implementationen werden gemeinsam genutzt so lange das mglich
  ist und erst wenn sich etwas ndert muss 'geklont' werden. Ansonnsten htte man einen ziemlichen Overhead in der
  'Standard Anwendung' z.B. "Iterator<int> cIterator = lstMyList.GetIterator()" da intern dann mehrmals dynamisch
  Speicher angelegt und wieder freigegeben werden msste.
- Neue Funktion: System::SetConsoleCursorPosition(): Wie von Stefan gewnscht eine Funktion zum setzen des
  Konsolen Cursors. Fgte auch 'GetConsoleCursorPosition()' hinzu damit das vollstndig ist.
  Die Linux Implementationen von 'ClearConsoleScreen() & SetConsoleCursorPosition()' msste man noch testen - hab
  hier mal den Weg ber ANSI Sequenzen gewhlt, diese Lsung findet man im Internet recht hufig. Fr
  'GetConsoleCursorPosition()' konnte ich auch nach lngerem Suchen keine einfache akzeptable Lsung finden.
- SystemWin32: 'GetComputerName()' und 'GetUserName()' ermitteln den ntigen Speicher nun automatisch passend.
  'GetProgramName()' hat leider weiterhin eine 'feste' gre die ich allerdings von '1024' auf 'MAX_PATH' setzte
  da ich fr 'GetModuleFileName()' nix finden konnte das einem zurck gibt wieviel Speicher man denn nun eigentlich
  wirklich braucht.
- System-Klasse um einige Funktionen erweitert ber die man Informationen ber den Speicher bekommen kann. Dies drfte
  praktisch fr Resource Manager sein da diese solche Informationen nutzen knnen um rauszufinden wann es sinnvoll
  ist etwas lnger nicht mehr genutzte Resourcen ber Bord zu werfen. Diese Funktionen 'knnte' man auch in
  'MemoryManager' halten, allerdings passt es doch am Ende etwas besser in die 'System'-Klasse. Habe in der
  'MemoryManager'-Klasse allerdings ein kleines Kommentar eingefgt falls jemand dort zuerst nach diesen Funktionen
  suchen sollte. Die Windows Implementation ist 'sehr' einfach, bei der Linux Implementation ist es ein 'wenig'
  mehr (wie irgendwie fast immer...) aber immer noch im bereich des ertrglichen. Den Linux Code msste man noch
  testen ob das so korrekt luft.
  Da es recht viele Funktionen fr Speicher Informationen sind berlegte ich zuerst ob man diese Informationen nicht
  besser gesammelt in einer Struktur speichert, entschloss mich dann aber dagegen da es ber Funktionen irgendwie
  'schner' zu nutzen ist.



>> 26.02.2008
[CO]
- CmdLineParser::CmdArrayToString(): "int argc, const char **argv"-Parameter zu "const Array<String> &lstArray"
  gemacht... das ist universeller so herum. Ansonnsten htte man etwas fr 'wchar_t' und 'utf8' hinzufgen mssen...
  "#include <string.h>" hinterherwink *g*



>> 24.02.2008
[SB]
- Seit den letzten nderungen lie sich die Engine bei mir unter Windows nicht mehr compilieren, da es beim
  Linken unresolved references auf Tools::FloatToUInt32 und Tools::UInt32ToFloat gab. Das Problem konnte
  durch das Entfernen von PLGENERAL_API vor diesen Funktionen behoben werden. Ich nehme an, dass das
  deswegen erst jetzt auftritt, weil in PLGeneral nun der Header selbst nicht mehr eingebunden wird und
  der Compiler diese Funktionen daher nicht mehr sieht und somit auch nicht compilieren und exportieren kann.
  Da die Funktionen als inline deklariert sind, sollte hier aber sowieso nichts export werden, sondern erst
  beim Einbinden durch den Compiler an die entsprechende Stelle eingesetzt werden. Damit da nichts durcheinander
  kommt (und das inline dadurch nutzlos wird), sollte bei Inline-Funktionen also knftig kein Export-Makro
  mehr verwendet werden.



>> 23.02.2008
[CO]
- PLMain(): 'MODULE_HANDLE hModule' ersatzlos heraus genommen da wir selbst es noch nirgends verwendet haben
  und ich im Augenblick auch nicht wsste wofr wir das noch brauchen - zumal es dies unter Linux scheinbar
  erst gar nicht gibt. Sollte ein Windows Nutzer es mal fr etwas spezielles brauchen, muss er einfach die
  entsprechende Windows Funktion nutzen um an den Module/Instanz-Handle zu kommen... in dem Fall macht er dann
  eh etwas Platform spezifisches. :D
  "PLGeneralLinuxIncludes.h" knnte man nun herausnehmen da komplett leer.
- Habe in PLMain() 'lstArgs' zu 'lstArguments' gemacht, 'args' ist zwar 'gelufig'... aber das muss hier nicht
  sein diese zwanghafte Abkrzung. Wird eh nur selten genutzt und daher ist "Schreibaufwand" kein Argument,
  lesbarkeit aber schon. :D
- ParseIntegerArray(), ParseFloatArray(), ParseDoubleArray(), GetFlagsFromString() und GetStringFromFlags() von
  der 'Tools'-Klasse in eine neue 'ParseTools'-Klasse verschoben die sich im 'String'-Ordner befindet
- 'Tools::FlipRB3()'-Funktion in 'PLGraphics::Color3' verschoben + dieses Funktion heit dort nun 'SwapRB'
- 'Tools::FlipRB4()'-Funktion in 'PLGraphics::Color4' verschoben + dieses Funktion heit dort nun 'SwapRB'
- Ein paar Copy-Operators und Copy-Constructors hinzugefgt
- Ein paar Copy-Operators und Copy-Constructors entfernt da unntig, sprich, die automatische erzeugten sind
  vllig ausreichend. Klassen: Version, Time



>> 18.02.2008
[CO]
- Directory::CreateRecursive() Implementation nochmal berarbeitet so das nur Url-Funktionen genutzt werden



>> 17.02.2008
[SB]
- PLGeneral lt sich nun wieder unter Linux bersetzen. Und manchmal frage ich mich wirklich, wozu ich
  Dinge dokumentiere ...
  Aus FileWin32.h:
    // Hmmmpf, not nice. But better than to include <stdio.h>, and as it must only work on Windows, it might be ok :-)
    struct _iobuf;
   typedef struct _iobuf FILE;
  Hier habe ich doch explizit geschrieben, dass dieser Hack *nur unter Windows* funktionieren wird. Deswegen steht
  da auch "as it must only work on Windows". Und darum war auch im Linux-Header entsprechend <stdio.h> eingebunden,
  weil das da nunmal leider nicht so geht (evtl. kann man es dort anders vordefinieren, aber da die Header da zig
  if's und defines enthalten, wird dies wohl auf jedem System anders aussehen). Und nun wird einfach dieser Kommentar
  kopiert, "Windows" durch "Linux" ersetzt und geglaubt, so ginge das.
  Entschuldigung, aber sowas verstehe ich einfach nicht. Kann man nicht bitte mal vor dem ndern davon ausgehen, dass
  andere Programmierer (ich, in diesem Falle) sich auch etwas *dabei denken*, was sie schreiben, und es somit wohl einen
  *Grund* hat, wenn die Forward-Declaration zwar im Windows-Header drin ist, aber im Linux Header nicht? Und wenn man dann
  trotzdem meint, dass das alles Quatsch ist und man das ndern muss, dann *muss* man das bitte auch unter Linux bersetzen
  und dort ausprobieren, und nicht einfach davon ausgehen, dass das schon gehen wird (insbesondere dann, wenn ich im Kommentar
  extra darauf hingewiesen habe, dass dies so nur unter Windows geht).
- Var.cpp: Habe ebenfalls die nderung mit PLGeneralLinuxWrapper.h wieder rckgngig machen mssen, da es eben
  '_atoi64' unter Linux leider nicht gibt. Wo die Information herkommen soll, dass es diese Funktion unter Linux
  nun auch in stdlib.h geben 'msste', ist mir schleierhaft, eine Suche per Google gibt jedenfalls nur zig mal die
  Information, dass es das unter Linux eben nicht gibt. Vielleicht knnten wir das nun einfach mal so lassen, und
  nicht in einem halben Jahr wieder behaupten, dass es nun gehen msste, ohne auszutesten, dass das auch wirklich so ist.



>> 17.02.2008
[CO]
- LogFormaterConsole: Nutzt wieder 'printf' direkt anstatt 'File::StandardOutput' da es ansonnsten dank der statischen
  De-initialisierungs Reihenfolge in PLSampleChat einen Crash beim beenden geben kann :/
PLNetwork:
- Copy-Operators und Copy-Constructors hinzugefgt



>> 16.02.2008
[CO]
- File: ESeek andere Werte vergeben damit diese mit SEEK_CUR, SEEK_END, SEEK_SET aus 'stdio.h' zusammenpassen, das ist sicherlich
  eine gute Sache... in z.B. 'PLSoundFMOD/SoundManagerFMOD.cpp' musste man extra 'stdio.h' einbinden 'nur' um an diese Definitionen
  zu kommen was ich irgendwie dmlich fand. ("Mit Kanonen auf Spatzen schieen")
- Var.cpp: Nahm den speziellen Linux Include '#include "PLGeneral/PLGeneralLinuxWrapper.h"' heraus, auch dort 'msste' '_atoi64'
  in 'stdlib.h' definiert sein
- System: Neue Funktion: GetConsoleCharacter(): Liest ein einziges Zeichen von der Konsole, fr die Linux Fassung musste ich mal
  wieder Code 'aus dem Internet' nehmen... das so einfache Dinge so kompliert und nicht Plattform unabhngig sein mssen. *gruml*
  Wie blich wieder ausfhrlich dazu geschrieben woher das kommt.
- System: Neue Funktion: ClearConsoleScreen(): 'Lscht' den Inhalt der Konsole, ebenfalls etwas sehr praktisches... aber auch wieder
  etwas das obwohl so Grundliegend, nicht wirklich so einfach ist daher auch hier wieder 'gefundener Code' sammt woher er kommt...
- FileHttp genauso wie die anderen File Implementationen alles private gemacht da man da von auen nicht mehr rankommen knnen sollte
  (es sprichts nichts dagegen, oder?)
- SystemWin32::GetEnvironmentVariable(): Nahm das [TODO] heraus und erweiterte das Kommentar 'etwas' damit man nachvollziehen kann
  warum das so 'merkwrdig' aussieht... das ist eine reine Optimierung. (nicht Performance 'kritisch', aber wenns mglich ist...)
  Wrde man nur "GetEnvironmentVariableW(sName.GetUnicode(), NULL, 0)" schreiben, msste 'sName' intern zwanghaft in Unicode
  konvertiert werden auch wenn das berhaupt nicht ntig ist da ASCII gegeben ist und eine solche Umgebungs Variable nicht
  existiert, existiert diese muss dann natrlich konvertiert werden da wir nicht vorher feststellen knnen ob fr den Wert
  ASCII reicht oder nicht. (wrd ich also gerne so lassen auch wenns 'Erbsenzhlerei' ist, das zeigt das man da mit liebe
  frs Detail rangeht :)
- Directory::CreateRecursive() Implementiert. Weis nicht ob das mit "System::GetInstance()->GetCurrentDir()" so prall ist, wsste
  aber im Augenblick nicht wie man das anderst machen sollte, auf jedenfall funktioniert es recht gut.
- 'Directory.h': "PLGeneral/File/FileSearch.h" durch 'Forward declaration' ersetzt. Ich erwhne es da ich mir gerade nicht sicher
  bin ob das so absicht war oder nicht. (Regel sollte sein 'Forward declaration' wo geht, das hlt die Compile dauer + das neu
  Compilieren bei Header nderungen schn niedrig was die Produktivitt steigert, bei der Sache bin ich wirklich stark hinterher
  da es sich wirklich auszahlt *g*)



>> 15.02.2008
[CO]
- Klassen im 'Container'-Ordner nochmal durchgeschaut (hauptschlich nur Zeilen umbrche)
- Heap & Map und Implementierungen um Copy-Operator und Copy-Constructor erweitert, auch wenn diese erstmal nicht Implementiert
  und daher private sind. Diese Operationen sind nicht ganz ohne... man knnte zwar einen Iterator nutzen, aber dann htte man
  nur 'Werte' aber ohne die dazu gehrenden 'Schlssel' - da muss ich mir noch etwas Einfallen lassen.
  Aber so ist's schonmal besser als berhaupt nix drinnen zu haben... dadurch viel sofort ein Bug im 'FileAccess' Copy-Constructor
  auf der bereits eifrig den nicht vorhandenen HashMap Copy-Constructor nutzte. :/
- SimpleMap: Speziellen Copy-Operator hinzugefgt, im grunde wrde der automatische reichen wie beim automatischen Copy-Constructor,
  aber der Rckgabewert sollte hier ein universelles 'Map' sein
- HashMap: Speziellen Copy-Constructor und Copy-Operator hinzugefgt, wird bereits von 'FileAccess' verwendet
- File: "Standard Stream"-Dateien, nchster Anlauf nach Stefans Idee - klappt denke ich so recht gut und ist berschaubar.
  Habe dies als File Implementation Namens 'FileStdStream' realisiert damit das sauber Implementiert ist und es nicht zu viele
  Sonderflle gibt die man stndig Abfragen muss.
- System: GetTime(), GetMilliseconds() und GetMicroseconds() Funktionen runter zu Sleep() verschoben damit Funktionen mit gleichen
  oder zumindestens sehr hnlichen Jobs 'rumlich' beisammen sind
- System: Neue Funktion: IsConsoleKeyHit(): '_kbhit()' Funktion die bei Konsolen Anwendungen recht praktisch sein kann. PLSoundTest
  nutzt diese Funktion bereits. Dort wurde bisher 'im Internet gefundener' Code direkt verwendet - forschte etwas nach woher dieser
  Code stammte und es stellte sich heraus das dieser Code auf flipcode (es ruhe in Frieden) verffentlicht wurde und recht bekannt
  ist. Fgte beim Linux Port ausfhrliche Copyright Informationen hinzu. (nutzen 'msste' man es knnen)



>> 14.02.2008
[CO]
- SystemLinux::GetCurrentDir(): Ist nun nicht mehr auf 'MAXPATHLEN' beschrnkt sondern ist Dynamisch
- Ging die System und XML Klassen nochmal ganz genau durch und fgte wo ntig Copy-Constructor und Copy-Operator
  hinzu. In z.B. 'DynLibLinux' ist dies jedoch nicht wirklich ntig da der User da nicht rankommt. (oder sollen wir
  hier dann trotzdem soetwas hinzufgen?)
  Schaute auch das jede Anweisung in einer eigenen Zeile steht - das machts einfacher wenn man mal einen Break-Point
  setzen will auch wenn das die Anzahl der Zeilen etwas aufblht, die Vorteile berwiegen.
- File-Klassen nochmal genau durchgeschaut
- FileSearchImpl: 'm_pSearch' herausgenommen (bin mir zu 99% sicher das dies noch ein alter berbleibsel war :)
- FileSearch: Copy-Operator hinzugefgt... hier erwhne ich es da es etwas umfangreicher ist, auch im Copy-Constructor
  nderte ich eine kleinigkeit. (sah etwas merkwrdig aus, funktionell natrlich kein Unterschied)
- FileObject: Destruktor virtuell gemacht
- FileAccess: 'NullEntry' zu einer ffentlichen Klassenvariable gemacht damit man von auen testen kann ob das als Ergebniss
  zurck kam + FileAccess braucht weniger Speicher (das erste Argument war ausschlag geben *g*)
- SocketAddress: "SocketAddress::SocketAddress(const String &sHost, uint32 nPort)" auskommentieren Code entfernt, schien mir
  wirklich 'tot' zu sein (sprich Nutzlos :)
- 'CmdLineParser' vom 'Tools'- in den 'String'-Ordner verschoben da es dort viel besser reinpasst, ist ja nur ein einfaches
  String Parsing. (also wrde ich wohl auch genau in diesem Ordner danach suchen :)
  Wollte auch zuerst die 'Localization'-Klassen in den 'String'-Ordner verschieben da diese ebenfalls 'nur' dazu da sind um
  einen String von einer Sprache in eine andere zu bringen... aber da diese Klassen bereits das Loadable-System nutzen das
  zuknftig wie es aussieht in PLCore liegen wird, wird das Localization-System wohl auch mit in PLCore wandern mssen. Bei
  Zeiten sollten wir mal fr das Localization-System ein Loader Plugin schreiben das die Sprachen/bersetzungen aus einer
  Datenbank ausliest. *g*
PLNetwork:
- 'SocketAddress' und 'Socket' heraus genommen da diese mittlerweile in PLGeneral liegen. (oder gabs einen speziellen Grund wieso
  das auch dort noch lag?) Wenn ich das richtig sehe gibts kein 'Socket::Create()' mehr und das wird inter automatisch erzeugt,
  darum entfernte ich die entsprechenden Funktions aufrufe.



>> 13.02.2008
[CO]
- File: Um "Standard Stream"-Dateien erweitert... das bot sich direkt an das "Dinge auf Konsole ausgeben"  hierber zu
  realisieren anstatt seperate Funktionen z.B. in die System-Klasse zu stecken. (knnten wir natrlich immer noch, aber ich denke
  das ist erstmal unntig) Intern ist das sowieso so realisiert + damit kommen andere Dinge wie man im Punkt unten sehen kann
  'for free'... hat also durchaus seine Vorzge. *g*
  Erweiterte dafr "EAccess" in der File Klasse damit das ohne groe nderungen ins Interface passt. In "File::Open()",
  "FileWin32::Open()" und "FileWin32::Linux()" musste etwas Code eingefgt werden - Stefan, schau dir das bitte genau an, nicht
  das diese nderung berhaupt nicht ins Konzept passt und alles durcheinander bringt. Hatte mir schon berlegt ob eine extra
  "StandardStream"-Datei Implementation angebracht wre... aber irgendwie war mir das dann mit Kanonen auf Spatzen geschossen.
- "Print()"-Funktion aus den XML Klassen genommen da sich dies nun ber eine "Standard Stream"-Datei realisieren lsst.
  In der PLBaseTest Funktion "XmlTest::Test()" kann man sehen wie das Schreiben 'in die Konsole' darber zu realisieren ist.
- XmlDocument: "LoadFile()" und "SaveFile()" Funktionen in "Load()" und "Save()" umbenannt damit das konsistent zu den anderen
  Funktionen ist.



>> 12.02.2008
[CO]
- Iteratoren wie besprochen umgeschrieben so das diese problemlos immer auf dem Stack liegen knnen damit man kein 'delete' mehr
  nutzen muss was man ja leider schnell mal vergisst. Alle Projekte entsprechend angepasst und darauf geachtet das die Iteratoren
  immer im kleinst mglichen Bereich genutzt werden damit so wenig wie mglich schief gehen kann. Dafr habe ich hier und da auch
  extra Blcke hinzugefgt was ich allerdings nicht 'schlimm' finde da es fr mehr 'Sicherheit' sorgt, (Thematik vernderung der
  Datenstruktur auf die der Iterator gerade arbeitet) das ersetzt praktisch das 'delete'. :)
  Im Iterator Copy-Constructor ist momentan noch ein kleiner Hack drinnen der den konstanten Parameter auf nicht Konstant umbiegt
  damit dort die Iterator Implementation zurck gesetzt werden kann - macht man den Parameter nicht Konstant erhlt man tonnenweise
  Compiler Warnungen... momentan weis ich noch nicht wie man das anderst lsen knnte. (bei nicht konstant kann man ein Temporres
  Objekt ndern das der Compiler nicht mag da Seiteneffekte mglich)
  Aber die Bedienung der Iteratoren ist so nun auf jedenfall 'deutlich' Eleganter und weniger Speicherleck anfllig. :D



>> 09.02.2008
[CO]
Gelaber:
- Nachdem ich gestern meine letzte Prfung im total berfllten 3'ten Semester geschrieben habe kann ich nun
  ENDLICH wieder mehr an PL machen. Am 17.03.2008 gehts dann weiter mit dem 4'ten Semester das hoffentlich nicht
  mehr so heftig wird wie das aktuelle. Bis dahin nur noch PL und daher wieder mehr Tagebuch Eintrge meinerseits. :D
Alle Projekte:
- Auf Visual Studio 2008 umgestellt damit man 'relativ problemlos' auch unter Vista arbeiten kann ohne erstmal
  die Entwicklungsumgebung mit x Vista-Patches vollzudrhnen die dann doch nicht gehen (zumindestens bei mir nicht)
- In den 'sln'-Dateien hat sich nix gro gendert, nur die Versionsnummer:
      Microsoft Visual Studio Solution File, Format Version 9.00
      # Visual Studio 2005
  wurde zu
      Microsoft Visual Studio Solution File, Format Version 10.00
      # Visual Studio 2008
  In den 'vcproj'-Dateien hat sich zum Glck auch nicht wirklich viel verndert. In "<VisualStudioProject"
      Version="8,00" wurde zu Version="9,00"
  und
      TargetFrameworkVersion="131072"
  kam neu hinzu.
-     <Tool
          Name="VCWebDeploymentTool"
      />
  Wurde automatisch entfernt da "Web deployment to the local IIS server is no longer supported", fr was auch
  immer das gut war, nicht mehr untersttzt wird - wir werden es sicher nicht vermissen. *g*
- Bei "<Tool Name="VCLinkerTool"" gibts zwei neue Optionen die automatisch hinzugefgt wurden:
      RandomizedBaseAddress="1"
      DataExecutionPrevention="0"
- "Data Execution Prevention (DEP)" auf "Image is compatible with DEP (/NXCOMPAT)" gestellt, das ist eine gute Sache
  und sollte bei uns keine Probleme geben (konnte jedenfalls keine feststellen)
- Folgende Warnung erschien nun fters mal:
      "Command line warning D9035 : option 'Wp64' has been deprecated and will be removed in a future release"
  Da diese Meldung leider wie es aussieht nicht Deaktivierbar ist und das 'etwas' strrend ist deaktivierte
  ich "/Wp64 (Detect 64-Bit Portability Issues)". 64 Bit Compilieren ist momentan bei uns kein Thema... und falls
  man das doch mal ausprobieren will muss sich einer von uns erstmal ein 64 Bit Windows Installieren (zum Testen)
  + den 64 Bit VC Compiler. (sehe momentan aber keinen Grund das zu tun, gibt wichtigeres momentan :)
- Ging die Projekt-Abhngigkeiten (Menu bar -> Project -> Project Build Order... -> Dependencies)
  nochmal durch und korrigierte wo ntig. Damit geht das komplett bersetzen wieder beim ersten mal sauber durch
  ohne das Fehlermeldungen kommen das z.B. 'PLGeneral.lib' nicht gefunden werden konnte da z.B. PLNetwork vorher
  'fertig wurde' mit dem bersetzen. (Multi-Threading sei dank *g*)
- "LINK : warning LNK4224: /OPT:NOWIN98 is no longer supported;  ignored" -> "Optimize for Windows98"
  auf Default gesetzt... das Untersttzen wir eh nicht. (selbst MS hat mittlerweie den Support dafr
  fallen gelassen)
PLGeneral:
- "LIBCMT,MSVCRT" zu den zu ignorierenden Bibliotheken hinzugefgt um Linker Warnungen zu beseitigen
- "PLGeneralWin32Includes.h": WINVER und _WIN32_WINNT werden, falls bereits Definiert, 'undefiniert' - ansonnsten
  bekam ich hier unter Vista mit VC 2008 Warnungen
- TinyXML: Neuste Version 2.5.3 (intern steht bereits 2.5.4) aus dem Repository genommen und mit VC 2005 bersetzt.
  "TiXmlBase::PutString()" wurde mittlerweile in "TiXmlBase::EncodeString()" umbenannt und ffentlich gemacht - darum
  haben wir nun nur noch 3 anstatt 4 eigene nderungen in TinyXML. :D
  Fr Linux und VC7 msste man das noch bersetzen.
PLNetwork:
- Warnung "warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead.
  To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details." beseitigt indem ich 'strncpy'
  durch 'MemoryManager::Copy' ersetzte - da wird nicht lange gezgert *g*



>> 05.02.2008
[SB]
PLCore:
- Auf Basis der Funktoren ein Event-System im Signal/Slot bzw. Event/Delegate Stil erstellt.
  Das ganze funktioniert so:
    void TestEvent(int nParam) { /* do something here */ }
  Event<int> cEvent;
  EventHandler<int> cHandler1(TestEvent);
  cEvent.Connect(&cHandler1);
  cEvent.Emit(1);
  Dabei ist zu beachten, dass ein EventHandler natrlich ein ganz normales Objekt ist, das dementsprechend verwaltet werden mu.
  Wenn man also z.B. ein EventHandler per new erzeugt, mu man diesen auch wieder lschen. Um das zu vereinfachen, gibt es
  die Basisklasse EventObserver und die spezialisierte Klasse ManagedEventHandler. Wann immer ein ManagedEventHandler fr eine
  Memberfunktion einer Klasse erzeugt wird, die von EventObserver abgeleitet ist, kmmert sich diese automatisch um das sptere
  Lschen des Handlers:
    class Test : public EventObserver {
      Test() {
        // Diese Instanz wird automatisch spter gelscht
        g_pMainWindow.OnAlienEvent.Connect(new ManagedEventHandler<int>(&Test::OnAlien, this));
    }
    void OnAlien(int nParam) {
    }
  }
- Projekt PLCore begonnen und zunchst Functor und Event dorthin verschoben.



>> 04.02.2008
[SB]
WOW. Mit den C++ Templates kann man echt viele tolle Dinge machen - man mu nur aufpassen, auf dem Weg dahin
nicht Amok zu laufen ;-)
- Habe meinen ersten Test von Funktionsobjekten entfernt und durch eine neue Implementation ersetzt. Es ist jetzt
  nicht mehr ntig, die Anzahl der Parameter beim Template mit anzugeben - das merkt das Template nun von selbst.
  Auch kann man jetzt die Klasse Functor direkt verwenden, und der einfach einen beliebigen gltigen Zeiger
  auf eine Funktion hineingeben - egal ob statisch oder Memberfunktion einer Klasse. Beispiel:
  Functor<int, int> cFunc(TestFunction);
  Functor<int, int> cFunc(&Class::TestMethod, &cObject);
  int nRes = cFunc(10);
  Dank vieler verrckter Template-Tricks mte das ganze Typensicher sein - man kann die Klasse also nicht austricksen
  und z.B. einen Zeiger auf ein Objekt falschen Typs hineingeben oder aus einem int(int) ein int(float) machen.
  Es war jetzt auch nicht mehr ntig, noch Makros zu verwenden - das ganze geht komplett nur mit Templates. Allerdings
  steht zur Zeit noch der Test aus, ob auch alle Compiler die wir verwenden das ganze mgen (VC8 mag es jedenfalls).
  Da der ganze Template-Mechanismus beim Compilieren abluft braucht brigens auch keine Angst zu entstehen, dass das
  ganze ein zu groer Overhead wre und daher die Performance beeintrchtigen knnte. Die ganzen Hilfsklassen sind nur
  dafr da, damit der Compiler die richtigen Typen zur richtigen Zeit findet, da sie aber weder Daten beinhalten noch
  jemals Instanzen davon erzeugt werden, bleibt davon zur Laufzeit nichts mehr brig :-) Das ganze reduziert sich
  dann auf das Dereferenzieren zweier Pointer :-) 



>> 22.01.2008
[CO]
Alle Projekte:
- berall den Style der Konstruktor Initialisierer-Liste wie vor geraumer Zeit besprochen angepasst



>> 22.01.2008
[CO]
- ClassManager::LoadPlugin(): Hier hatte sich ein Fehler eingeschlichen so das manche Plugins nicht gefunden
  werden konnten. Man kann innerhalb der '.plugin'-Datei auch absolute dll-Pfade nutzen, z.b. zu Testzwecken -
  ansonnsten sind die dll's IMMER relativ zum Verzeichniss in dem sich die '.plugin'-Datei befindet.



>> 19.01.2008
[CO]
- Fgte wie von Stefan gewnscht eine 'Set'-Funktion zur 'Map'-Klasse + deren Implementationen hinzu. Lies die 'Add'
  und 'Remove' Funktionen jedoch drinnen da ich finde das diese durchaus ihre Existenzberechtigung haben. (sonst htten
  wir wohl schon vvviiiiel frher die 'Set'-Funktion eingebaut :)
  Z.B. kann man ber 'Add' mehrmals den gleichen Schlssel einfgen, das verhlt sich im Grunde dann wie ein 'Stack' +
  'Replace' ersetzt wirklich nur einen Wert wenn dieser bereits in der Map war, ansonnsten wird nix gemacht.
- PLMain: Unicode-Support fr die Kommandozeilen-Parameter hinzugefgt, fr Linux knnte ich nix spezielles finden...



>> 18.01.2008
[CO]
Alle Projekte:
- berall "Predefinitions" durch "Forward declarations" ersetzt
- Ein paar unntige Includes entfernt ("Include-Sparsamkeit" ist mir extrem wichtig :)
- "uint32 HashFunction::Hash(const char szKey[])" und "uint32 HashFunction::Hash(const String &sKey)":
  Variable 'g' in die Schleife gezogen + die Zuweisung in der Abfrage entfernt
- Alle 'doxyfile'-Dateien an die 'Doc'-Ordner verschiebung angepasst
- "Config/" in Dateinamen beim Laden/Speichern von Konfigurationen entfernt, das regelt das Loadable System
  intern selbst wo diese Dateien standardmig landen
PLGeneral:
- Bugfix: Fand gerade den Grund dafr das es z.B. beim laden der Szene 'PhysicsPlayground.scene' Crashte:
  "FileWin32::Open()": Hier konnte es eine Situation geben in der 'szMode' nicht Initialisiert wurde. In dieser
  kombination muss 'ungltig' zurck gegeben werden. ("FileLinux" natrlich das gleiche)
    (!(nAccess & File::FileWrite) && !(nAccess & File::FileCreate) && !(nAccess & File::FileAppend))
- Bugfix: "FileWin32::Open()": Bei folgender Kombination klappte das noch nicht wie erwartet:
    (nAccess & File::FileWrite) && !(nAccess & File::FileCreate) && !(nAccess & File::FileAppend)
  Wenn man nicht "FileRead" gesetzt hatte gab die Funktion 'ungltig' zurck obwohl eine Datei bereits
  existierte in die man htte schreiben knnen. Daher wird hier nun erstmal geprft ob die Datei bereits
  vorhanden ist, wenn ja kann man den "w"-Modus nutzen, ansonnsten wird 'ungltig' zurckgegeben.
  ("FileLinux" natrlich das gleiche)
- "File::Open(uint32 nAccess = 0)" zu "File::Open(uint32 nAccess)" gemacht da '0' eine ungltige Flag-Kombination ist
- Loader::OpenFile(): Muss Dateien auch korrekt erzeugen knnen beim Speichern, das msste so nun hoffentlich
  passen... nach den oberen nderungen konnte ich keine Probleme mehr feststellen
- LoadableManagerLoaderPL: 'FileSystemSettings' entfernt und 'BaseDirectories' nach 'LoadableManagerSettings'
  verschoben
- "Loader::OpenFile()": Kennt nun 'nur' noch Basis Verzeichnisse, also kein '-1 = das aktuelle Verzeichniss'... dies
  war hchst Problematisch da dies nicht mit den 'Prioritten' der Basis Verzeichnisse zusammen passte. War etwas im
  aktuellen Verzeichniss, also standardmig wo das Programm selbst liegt, wurde diese Datei 'immer' genommen, auch
  wenn man z.B. im Falle des Scene Viewers dem Verzeichniss in dem die aktuelle Szene liegt die hchste Prioritt geben
  wollte damit 'zuallererst' geschaut wird ob die gesuchte Datei dort liegt.
- LoadableManager: "", also ein leerer String ist nun ebenfalls ein gltiger Basis-Pfad und steht fr das
  'aktuelle Verzeichniss'
- LoadableManager:SetBaseDirPriority(): Bei den URL-Umstellungen hatte sich hier ein kleiner Fehler eingeschlichen
  so das die Prioritten nicht korrekt gendert wurden



>> 14.01.2008
[SB]
- Beim Lesen aus Archiven mit dem Flag FileMemBuf gab es Probleme, weil die Zeilenenden auch dann konvertiert wurden,
  wenn die Datei als Binary geffnet wurde. Nachdem ich dieses Problem behoben hatte, scheinen auch wieder alle Daten
  richtig geladen zu werden :-)
- Habe das Flag FileBinary komplett gelscht, da dieses nur Probleme machte. Generell werden Dateien im Binrmodus geffnet,
  wenn dies nicht gewnscht ist, muss FileText angegeben werden.
- Registry-Klasse in einen eigenen Ordner verschoben.
- Url::Collapse: Hier gab es einige Probleme, wenn ein ".." am Ende des Pfades stand. Diese sind nun hoffentlich behoben ...
- nderungen aus dem Rewrite-Branch in den Trunk bertragen. Gab so weit ich sehen kann keinerlei Probleme - die einzige
  Datei mit einem Conflict war "Diary.txt" :-))



>> 13.01.2008
[CO]
- Ein paar Mini-nderungen an der "Registry"-Klasse



>> 12.01.2008
[SB]
- Wrapper fr die Registry hinzugefgt. Ich mchte einfach *nirgendwo* mehr direkt auf die Windows-API zugreifen mssen,
  da das immer total nervt und meist extrem unbersichtlich ist. Auch mu man dann ja meist wieder direkt mit irgendwelchen
  String-Buffern hantieren, Speicher allozieren etc. *brrr*. Die Klasse Registry bietet also Zugriff auf die Windows-Registry
  und wrappt einfach die API-Funktionen in eine hbsche Klasse. Spter knnte man das evtl. noch erweitern, um auch auf andere
  Registry-Systeme zugreifen zu knnen (z.B. Gnome hat ja auch so etwas). Allerdings wrden dann natrlich auch die ganzen Pfade
  darin vollkommen anders aussehen, das mu man also mal sehen, ob das berhaupt sinnvoll wre. In jedem Fall kann man nun auch
  ber die Registry-Klasse abfragen, ob berhaupt eine Registry auf dem System vorhanden ist, falls nein kann man dann auf andere
  Methoden zurckgreifen und sich so ein #ifdef sparen :-)



>> 11.01.2008
[SB]
- Einige kleinere Fehler in RegEx behoben.



>> 10.01.2008
[SB]
- Neue Toolklasse Version eingebaut. Diese speichert die Versionsnummer eines Projektes und kann diese z.B. als
  String ausgeben. Auch knnen Versionsnummern miteinander verglichen werden. Dies soll spter verwendet werden,
  um die Versionen der einzelnen Komponenten zu verwalten.



>> 21.12.2007
[SB]
- Neue Klasse RegEx zum Parsen regulrer Ausdrcke eingebaut. Diese sollten wir verwenden, um uns ansonsten schnell
  kompliziert werdende Parsing-Aufgaben zu erleichtern. Ich denke, dass wir damit an manchen Stellen das Parsen
  von Text deutlich vereinfachen knnen, z.B. fr Vektoren, Listen usw. (a b c) . Der Tokenizer ist zwar recht leistungsfhig,
  aber selbst damit ist es immer noch sehr aufwendig, so etwas zu parsen, und die entsprechenden Stellen werden meist
  sehr gro und sind schwer zu lesen. Regulre Ausdrcke drften hier weiterhelfen und sind sowieso an vielen Stellen sehr
  ntzlich :-) Das ganze benutzt den Perl-Syntax fr regulre Ausdrcke und darf noch krftig erweitert werden, im Moment
  knnen nur einfache Vergleiche ausgefhrt werden. Die Klasse ist ein Wrapper fr die PCRE Library (Perl Compatible
  Regular Expressions), die unter einer BSD-Lizenz steht.
- SearchFilterRegEx: Neuer Suchfilter zum Suchen mit regulren Ausdrcken.



>> 15.12.2007
[CO]
- Loadable System nderung vom 08.12.2007 im Main-Branch wieder rckgngig gemacht da nicht alles wieder ging wie vorher
  und Stefan das im seperaten Branch komplett berarbeitet. So haben wir zumindestens wieder eine voll lauffhige Version.



>> 09.12.2007
[SB]
- Einige Unklarheiten beseitig, die beim Umstellen auf das neue FS deutlich wurden.
- Url: Die Methoden zum Zurckgeben der URL etwas umsortiert und umbenannt, damit deren Verwendung verstndlicher wird.
  Man sollte eigentlich immer Url::GetNative() verwenden, denn dies gibt den Pfad im nativen Format zurck, sofern dies
  ein lokaler Pfad ist, ansonsten als URL, wenn es sich z.B. um http:// handelt. Das scheint mir der natrlichste Weg zu
  sein, weil der Pfad fr den User "normal" angezeigt wird, und nur dann z.B. ein Protokoll hinzugefgt wird, wenn das
  auch wirklich ntig ist. GetUrl() dagegen gibt in jedem Fall file:// heraus, was man aber normaler Weise nicht haben
  mchte und auch nicht braucht. Als Faustregel wrde ich daher sagen:
  - Zur bergabe von URLs (z.B. zum Laden/Speichern): GetUrl()
  - Zur Ausgabe von URLs an den Benutzer: GetNative()
- Url: Zugriff auf die einzelnen Teile einer Url etwas verndert und Funktionen fr die hufigsten Zugriffsformen
  hinzugefgt (z.B. nur Pfad oder Dateiname ohne Endung) 
- FileObject, File, Directory: GetUrl() gibt *immer* eine URL ohne "/" am Ende zurck. Dies ist wichtig zu wissen, denn
  dann kann man z.B. ohne Bedenken cDir.GetUrl() + "/filename.txt" schreiben, ohne noch selbst auf "/" testen zu mssen.
  Einzige Besonderheit: Beim Mounten von ZIP-Dateien mu das "/" angegeben werden, damit das FS berhaupt wei, dass diese
  ZIP-Datei als Verzeichnis angesprochen werden soll und nicht einfach die Datei geffnet werden soll. Das ndert aber nichts
  an der Regel, dass GetUrl() auch in diesem Fall ohne "/" zurckgegeben wird!
- FileObject: Erweiterte die Funktionen zum Zugriff auf die URL, damit man die hufig bentigten Funktionen direkt zur
  Hand hat und nicht stndig Url's dafr erzeugen muss. Die Funktionen sind analog zur Url-Klasse und wrappen diese:
  GetUrl() gibt nun das Url-Objekt zurck, damit dieses nicht unntig neu erzeugt werden mu
  GetPathUrl() gibt die Url als String zurck
  GetPathNative() gibt den Native-Path als String zurck
  GetPathWindows() gibt den Windows-Path als String zurck
  GetPathUnix() gibt den Unix-Path als String zurck
  GetFilename() gibt nur den Dateinamen zurck
- Threads etwas umgebaut und GetMainThread() in System eingebaut.
- File: FileBinary und FileText vertauscht, damit ist FileBinary nun wieder der Standard.
- Die Engine auf das neue FS umgestellt. Dabei sind mir einige Stellen aufgefallen, die noch deutlich berarbeitet werden
  sollten, z.B. werden noch viel zu Oft irgendwelche Dateipfade auseinandergebrselt, hier sollte zumindest versucht werden,
  das mglichst transparent nur an einer Stelle zu tun. Manche Dateitypen suchen dann wieder selbst die Basispfade durch
  oder geben einen festen Pfad vor (z.B. "data/sounds"), das sollte auf jeden Fall raus. Viele Dinge habe ich nur blind
  umstellen knnen und frchte, dass das nicht mehr richtig funktionieren wird. Dies war aber schlecht anders mglich, da
  mir teilweise die Funktionsweise der entsprechenden Funktion nicht wirklich klar wurde und ein komplettes Neuschreiben
  on-the-fly zu aufwendig wre.
- Es lt sich nun wieder alles compilieren, allerdings funktionieren die Loader noch nicht wieder richtig, weshalb viele
  Dateien noch nicht gefunden werden knnen. Als nchstes werde ich daher die fr spter geplanten Arbeiten vorziehen und
  das Config- und das Loader-System berarbeiten. Es drfte sinnvoller sein, dies nun gleich neu zu machen, als erstmal
  das alte wieder mhselig zum Laufen zu bringen um es dann hinterher doch noch neu zu schreiben.



>> 08.12.2007
[SB]
- PLGeneral/System berarbeitet: Globale Manager entfernt, direkte Instanzen der Klassen sind jetzt mglich und
  Impl-Klassen nach dem gleichen Pattern wie in File berarbeitet.
- Folgendes Pattern fr Implementationsklassen soll nun berall mglichst identisch verwendet werden:
  - Eine plattformunabhngige Klasse besitzt einen Zeiger auf eine (versteckte) Implementationsklasse
  - Diese wird im Konstruktor (oder evtl. erst spter, wie in FileObject) erzeugt, aber innerhalb dieser Klasse
  - Die Implementationsklasse besitzt keinen Zeiger zurck auf die plattformunabhngige Klasse!
  - Das gesamte Interface der Implementationsklasse sollte protected sein, auch die virtuellen Funktionen.
  - Mittels friend darf die plattformunabhngige Klasse darauf zugreifen.
  - Konkrete Implementation werden abgeleitet, auch diese mit protected-interface.



>> 08.12.2007
[CO]
- Base Path Dinge von FileSystem in LoadableManager verschoben. Ist noch nicht wirklich Prall realsiert, sollte so aber
  erstmal reichen. Nachdem das berarbeitet FS drinnen ist sollte man sich das hier nochmal anschaun.



>> 05.12.2007
[SB]
- Map: Auf die Values einer Map kann nun auch nicht-const zugegriffen werden. Dies ist ntzlich, wenn es sich um abstrakte
  Datentypen (z.B. Klassen) handelt, von denen man nur ein Attribut ndern mchte und nicht das gesamte Objekt per
  Replace austauschen mchte. 
- SearchFilter implementiert. Beim Auflisten von Dateien wird ber die Klasse SearchFilter getestet, ob der gefundene
  Dateiname dem Filter entspricht. Als Standard wird ein WildCard-Filter verwendet, es knnen aber auch individuelle
  Filter implementiert werden.
- GetCurrentDirectory und SetCurrentDirectory in PLGeneral::System implementiert.



>> 04.12.2007
[SB]
- HttpHandle und ZipHandle: Beide Klassen besitzen nun nur noch einen leeren Konstruktor und ffnen zunchst keine
  Datei bzw. Verbindung. Dafr gibt es nun jeweils eine Funktion Open(). 
- Habe mal etwas mit den Ideen herumgespielt, wie man beim FS den Zugriff auf z.B. passwortgeschtzte Inhalte
  realisieren knnte. Die bisherige Methode, Open(Name, Passwort) gefllt mir aus folgenden Grnden nicht:
  - Die Signatur von Open wird um einen Parameter erweitert, den vermutlich die meisten User zunchst nicht verstehen
  - Es wird nur von einem Passwort ausgegangen, in vielen Fllen kann es aber noch mehr Parameter geben
    (Username/Passwort, Crypto-Keys u.v.m.)
  - Wenn man z.B. eine Datei "http://www.pixellight.org/test.zip/dir/test.txt" laden mchte, kann man an verschiedenen Stellen
    einen Zugriffsschutz haben, z.B. einmal fr den http-server (username/passwort), und dann noch einmal fr die Zip-Datei.
    Mit dieser Lsung ist es aber nicht mglich, mehrere Passwrter zu bergeben, ausserdem vermittelt Open(Name, Passwort)
    in diesem Falle den Eindruck, dass das Passwort fr test.txt bentigt wird, was aber gar nicht der Fall ist.
  Es sollte also die Mglichkeit geben, mehrere Authentifizierungsdaten gleichzeitig anzugeben, falls die Dateisysteme wie
  im obigen Beispiel verschachtelt sind. Ausserdem wre es nett, noch weitere Daten bergeben zu knnen, z.B. dass bestimmte
  Zugriffsflags verwendet / nicht verwendet werden sollen (z.B.: Zip-File nicht memory-buffered ffnen), oder weitere
  unbestimmte Informationen (annotation like).
- FileAccess implementiert, dies soll so funktionieren wie oben angegeben. Kleines Beispiel:
  FileAccess sAccess;
  sAccess["www.pixel-light.de"].SetAuth("username", "password");                // Username und Passwort fr HTTP
  sAccess["http://www.pixellight.org/test.zip"].SetPassword("password");        // Passwort fr die ZIP-Datei
  sAccess["http://www.pixellight.org/test.zip"].SetFlags(File_::FileMemBuf, 0); // ZIP-Datei ohne FileMemBuf ffnen
  File cFile("http://www.pixellight.org/test.zip/dir/test.txt", sAccess);
  Etwas problematisch ist es zur Zeit noch die Frage, welcher Name fr welche Zugriffsoptionen verwendet werden soll.
  FileZip sucht nach dem exakten Namen der Zip-Datei, also z.B. "http://www.pixellight.org/test.zip",
  FileHttp sucht dagegen nach der Domain, also z.B. "http://www.pixel-light.de". Gerade im Falle von HTTP ist das schwierig,
  da man ja nicht genau weiss, wo auf dem Server der Passwortschutz eingerichtet ist.
- FileAccess um bCaseSensitive erweitert. Dies wird von FileZip ausgelesen, somit kann man bestimmen, ob eine Zip-Datei
  case-sensitive behandelt werden soll oder nicht. Standardwert ist jetzt 'true', da wir dies anderswo auch meist so behandeln!
- Ebenfalls prft FileZip nun, ob ein Wert fr FileMemBuf angegeben wurde. Ist dies der Fall, wird dieses Flag bernommen,
  damit kann also das automatische Buffern von Zip-Dateien ausgeschaltet werden. Das Prinzip der Flags in FileAccess funktioniert
  so: Alle Flags, die in FlagsMask angegeben werden, gelten als "gesetzt" (egal ob 1 oder 0). Deren Wert wird dann in FlagsValue
  bestimmt. Beispiel: (Mask = Read | MemBuf, Value = Read) bedeutet, dass Read = 1 gewnscht ist und MemBuf = 0. Alle anderen
  Werte sind nicht weiter bestimmt. Allerdings sind die ganzen Angaben in FileAccess nur "Wnsche", die bercksichtigt werden
  knnen aber nicht mssen. Im Moment wird also nur bei Zip-Dateien auf MemBuf geachtet, alle anderen Flags werden ignoriert.
  Man kann dies also nciht nutzen, um z.B. eine Zip-Datei auch zum Schreiben zu ffnen oder hnliches.
- Mir ist aufgefallen, dass man auf die Values einer HashMaps nur noch als const zugreifen kann, man also die Werte spter
  nicht mehr ndern kann. Gerade beim FileAccess brauche ich aber auch die Mglichkeit, die Objekte spter noch zu ndern.
  Habe das daher erst einmal eingehackt, Christian sag bitte mal bescheid ob das so ok ist oder ob ich das anders lsen
  sollte.



>> 03.12.2007
[SB]
- HttpHandle: Beim Lesen von Daten ber das Netz kann es hufig vorkommen, dass noch nicht gengend Daten im Stream
  vorhanden sind, in dem Fall gibt Socket.Read() einfach so viel zurck, wie bereits vorhanden ist, auch wenn dies
  weniger ist als angefordert. Dies ist so ok und sollte denke ich auch nicht gendert werden, wenn man mit Sockets
  arbeitet muss man dies einfach einplanen. Beim Arbeiten mit Dateien wird jedoch davon ausgegangen, dass Read() genau
  so viel liest wie angefordert, wenn weniger gelesen wird, ist dies ein Fehler. Daher habe ich dies in HttpHandle::Read()
  so gendert, dass so lange immer wieder vom Socket gelesen wird, bis die gewnschte Datenmenge erreicht wurde, es
  kann also hier nicht mehr vorkommen, dass zu wenig gelesen wird. Bei grossen Dateien knnte dies also einen Moment
  lang dauern :-) 
- HttpHandle: Fehler behoben, es muss die gesamte URL bermittelt werden, damit ein Webserver, der mehrere Domains hostet
  (wie bei uns) wei, welche gemeint ist.
- HttpHandle: Es wird nun auch Http-Auth (Basic) untersttzt, damit kann also per Username und Passwort auf geschtzte
  Webseiten zugegriffen werden.
- Memory buffered files implementiert: Wird eine Datei mit dem Flag FileMemBuf geffnet, so wird der gesamte Inhalt der
  Datei eingelesen und im Speicher behalten, alle weiteren Lesezugriffe finden dann nur noch auf diese Buffer statt.
  Ich habe mich fr die Bezeichnung "Memory Buffered" entschieden, da "Memory Mapped" viele unterschiedliche Bedeutungen
  hat (z.B. auf OS-Ebene, um mittels gemappter Dateien IPC zu betreiben), da scheint mir "Memory Buffered" eindeutiger
  und daher leichter verstndlich. Der Buffer und der Zugriff darauf befindet sich in der Klasse File, und kann nur zum
  Lesen verwendet werden.
- ZipHandle: Das Zip-File wird nun mittel FileMemBuf geladen. Hier sollten wir uns noch berlegen, ob man das evtl. von
  der Dateigre abhngig machen sollte, oder irgendwie eine Mglichkeit geben sollte, dies wenn gewnscht zu deaktivieren.



>> 02.12.2007
[SB]
- Habe die Basisklassen von PLNetwork nach PLGeneral/Network verschoben, da Sockets und Netzwerkkommunikation eigentlich
  zu den System-Basisklassen gehren. Alles weitere, also die Struktur der Netzwerkkommunikation in PL, wird wie geplant
  in PLNetwork implementiert werden, die Basisklassen knnen jedoch auch an anderen Stellen ntzlich sein. 
- Netzwerk-Basisklassen berarbeitet und wo mglich vereinfacht.
- HTTP-Client hinzugefgt. Analog zu den ZIP-Dateien gibt es eine Klasse HttpHandle, die benutzt werden kann, um eine
  HTTP-Verbindung mit einem Server aufzumachen und Dateien zu bertragen. Diese Klasse kann bislang nur das ntigste, also
  nur das bertragen einer Datei per HTTP/1.0 sowie das auslesen der wichtigsten Header-Informationen. Alles andere kann
  spter erweitert werden.
- HTTP-Implementation fr das FS hinzugefgt. Damit kann per HTTP auf Dateien aus dem Netzwerk zugegriffen werden, was ich mir
  sehr ntzlich vorstelle, um z.B. News von der Webseite zu laden (oder auch Updates). Dank der Schachtelung ist natrlich auch
  etwas wie "http://www.pixellight.org/test.zip/test.txt" mglich, was auch gut funktioniert, allerdings nicht zu empfehlen ist :-)
- Linux-Implementation fr das FS hinzugefgt.
- Generische Funktionen fr das Kopieren und Verschieben von Dateien hinzugefgt. Zunchst wird versucht, die systemspezifische
  Implementation fr die entsprechende Funktion zu verwenden, wenn dies fehlschlgt, wird es mit der generischen Variante
  versucht: Wenn man z.B. eine Datei aus einer Zip-Datei irgendwo hin kopieren mchte, wird dies mit der Systemfunktion
  natrlich nicht gehen. Das Herunterladen einer Datei aus dem Netz kann man nun also z.B. so erledigen:
    File("http://www.pixellight.org/test.zip").Copy("C:\\test.zip")



>> 01.12.2007
[SB]
- Funktionalitt von ZipHandle vervollstndigt.
- FileZip und FileSearchZip unter Verwendung von ZipHandle wieder implementiert und getestet. Das Verhalten je nach
  Lesemodus (Binary oder Text) an die Systemfunktionen angepasst.
- Beim ffnen einer Datei wird die Implementationsklasse automatisch ermittelt: Entweder mittels des Protokolls,
  oder durch Suche nach ".zip/" oder ".pak/" im Dateinamen. Dadurch mu eine Zip-Datei als Verzeichnis so geffnet
  werden: Directory("test.zip/"), da "test.zip" an sich auch eine valide Datei wre. Innerhalb der Zip-Datei sind aber
  z.B. "test.zip/test" und "test.zip/test/" identisch.
- Eine Problematik beim Verwenden von Zip-Dateien: Mir ist aufgefallen, dass in einer Zip-Datei nicht unbedingt alle
  Unterverzeichnisse auch aufgelistet werden. Wenn ich unter Windows direkt oder mit TugZip eine Zip-Datei packe, gibt es
  z.B. die Eintrge "test/dir1/test1.txt" und "test/dir1/test2.txt", aber weder "test/dir1/" noch "test/". Je nachdem,
  welches Programm man verwendet, ist dies mal so und mal so, aber offensichtlich kann man sich nicht darauf verlassen,
  dass alle Verzeichnisse auch direkt aufgelistet werden. Dieses Problem in den Zip-Klassen zu lsen wre denke ich etwas
  aufwendig, da man die Pfade auseinandernehmen und eine eigene Liste erstellen mte, anstatt einfach nur alle Eintrge
  in der Zip-Datei durchzugehen. Spter sollte man dies wohl tun, damit es keine Probleme mit "schlechten" Zip-Dateien gibt,
  im Moment wrde ich aber einfach darauf achten, dass die Zip-Dateien vernnftig sind - zip unter Linux trgt beispielsweise
  alles korrekt ein :-)



>> 21.11.2007
[SB]
- bertragen der Zip-Implementation begonnen.
- Neue Klasse ZipHandle erstellt, welche auf einer Zip-Datei arbeitet. Vereinigt die Funktionalitt von StreamZip und IteratorZip,
  denn diese getrennten Klassen arbeiteten letztlich beide auf dem File-Handle von DirectoryZip, was ich sehr undurchschaubar
  finde. Weitere Zip-Funktionalitt war auch noch innerhalb von DirectoryZip und FileZip verstreut, das wurde ebenfalls in diese
  Klasse bertragen. ZipHandle besitzt nun selber den File-Handle fr die Zip-Datei und soll als generelles Interface dienen, um
  den Inhalt der Zip-Datei aufzuzhlen und anschliessend z.B. auf den Anfang einer Datei zu springen und diese auszulesen.
- Neue eingebettete Klasse ZipHandle::ZipEntry hinzugefgt. Diese Klasse enthlt die Informationen zu einem Eintrag
  innerhalb der Zip-Datei. Damit sind diese Informationen nicht mehr direkt in ZipHandle (bersichtlicher), auerdem kann so
  leichter eine Liste von Zip-Entrys erstellt werden, was man z.B. innerhalb der FS-Abkapselung machen knnte, um den Zugriff
  auf das Directory schneller zu machen. 
- Da die verteilten Zip-Funktionen recht verwirrend waren, bin ich mir nicht 100% sicher, ob ich alles richtig bertragen habe.
  Christian: Bitte schau nochmal genau drber und teste wenn mglich ZipHandle etwas, ob noch alles richtig funktioniert.
- ZipHandle berarbeitet und versucht, das Interface sowie die Variablennamen verstndlicher zu machen. Diese Klasse soll fr
  sich alleine genommen schon leicht verwendet werden knnen, um auf eine Zip-Datei zuzugreifen und diese auszulesen. Die weitere
  Abstraktion ber FileZip und FileSearchZip dient dann nur noch dazu, Zip-Files auch transparent ber das FS-Interface nutzen
  zu knnen. Es soll aber auch ganz ohne gehen, die gesamte Zip-Funktionalitt soll also in ZipHandle vorhanden sein.  
- Kleinen Test implementiert, der den Zugriff auf Zip-Dateien nur ber ZipHandle demonstriert testet. Konnte bisher keine Fehler
  feststellen, das Verzeichnis eines Zip-Files sowie der Inhalt der enthaltenen Dateien werden mir korrekt angezeigt. 



>> 20.11.2007
[SB]
- Basisklassen und Win32-Implementation fr das Dateisystem sind weitgehend vollstndig (bis auf Suchfilter).
  Das Klassenlayout wurde stark vereinfacht und gleichzeitig teilweise erweitert, so ist das Erstellen, Lschen,
  Umbenennen, Verschieben usw. nun direkt ber ein File- oder Directory-Objekt mglich. Dabei gibt es nun auch
  ein Muster, welches wir sonst selten haben: Gleichnamige Funktionen in abgeleiteten Klassen, die *nicht* virtuell
  sind. File::Create erstellt eine neue Datei, whrend Directory::Create ein Verzeichnis erstellt. In der Basisklasse
  gibt es diese Funktion nicht, daher drfte dies kein Problem darstellen, und ber das verwendete Interface legt
  der Programmierer deutlich fest, was von beidem er tun mchte, das ganze scheint mir so also auch am intuitivsten zu sein.
- Mittels Assign kann das Datei-Objekt auf einen neuen Dateinamen gelenkt werden. Dabei werden automatisch vorher
  geffnete Dateien geschlossen, das Objekt "zeigt" also dann auf eine andere Datei (diese mu nicht mal vorhanden sein).
  Beispielsweise kann so eine Datei oder ein Verzeichnis angelegt werden: Directory("test").Create();
- Dateiflags vervollstndigt und in hoffentlich blicherer Weise verwendet (z.B. gibt es nun neben FileWrite auch FileRead,
  ebenso gibt es FileBinary und FileText).
- Die Url-Klasse wird nur noch intern eingesetzt, im Interface werden dagegen nur noch Strings bergeben. Ansonsten mte
  man stndig Methoden doppelt machen, obwohl der User wohl meist sowieso Strings bergeben wird. Ausserdem sollte Url
  sowieso so selten wie mglich eingesetzt werden, um unntiges Parsen des Dateinamens zu verhindern.



>> 19.11.2007
[SB]
- Klasse Url berarbeitet und vereinfacht. Ein Pfad wird nun *immer* intern in URL-Form gespeichert, d.h. mit Protokoll
  und mit '/' als Trennzeichen. Beim Umwandeln werden auch nicht mehr unterschiedliche Url-Instanzen kopiert, sondern
  direkt die Strings wie gewollt umgewandelt. Dies scheint mir am einfachsten und ist in der Benutzung konsistent, da
  es keine Unterschiede mehr geben kann, in welcher Form verschiedene Url-Instanzen ihre Werte vorliegen haben. Im allgemeinen
  mchte man eine Url meist im einheitlichen Url-Format angeben, dieser Zugriff ist daher auch immer der schnellste, da nur
  ein String zurckgegeben werden muss. Will man dagegen in ein spezielles Format umwandeln, ist dies etwas aufwendiger, dafr
  macht man dies meist nur einmal (z.B. beim Erzeugen einer FileWin32-Instanz). Da diese dann nur als String und nicht mehr
  als Url gespeichert wird, entfllt dafr aber auch der Overhead, noch einmal die umgewandelte Url in ihre Bestandteile
  zu zerlegen.
- FileObject: Die URL eines jeden Objektes wird jetzt immer ohne ein abschlieendes '/' gespeichert. Damit ist der Dateiname
  eines FileObject immer korrekt, und man kann sich sicher sein, wie dieser verwendet werden mu (z.B. kann der Suchpfad
  eines Verzeichnisses jetzt immer korrekt durch Hinzufgen von /*.* erzeugt werden). Eine URL kann aber weiterhin Pfade
  speichern, die mit / enden, da dies fr eine URL von Bedeutung sein kann.



>> 13.11.2007
[SB]
- Rewrite des Dateisystems begonnen.
- Globale Klasse FileSystem entfernt.
- Die Klassen FileObject, File und Directory bleiben von der Funktionsweise sehr hnlich, werden nun aber direkt verwendet,
  mssen also nicht mehr dynamisch erzeugt werden und beinhalten auch keine virtuellen Funktionen mehr.
- Die systemspezifischen Implementationen werden von der Klasse FileImpl abgeleitet und kapsel sowohl die Datei- also auch
  die Verzeichnisoperationen ab. Ein FileObject erzeugt eine Instanz einer von FileImpl abgeleiteten Klasse und verwendet
  diese.
- Das Auflisten/Suchen von Dateien wird wie bisher ber eine eigene Klasse gehandhabt, wobei SearchHandle in FileSearch
  umbenannt wurde. Diese Klasse verwendet ebenfalls das Backend-Schema, zu einer Instanz von FileSearch gehrt daher
  immer eine systemspezifische Implementation welche von FileSearchImpl abgeleitet ist.
- Alle Dateifunktionen sollen ber die Klassen FileObject/File/Directory zu verwenden sein, z.B. auch das Erstellen
  neuer Dateien oder Verzeichnisse ebenso wie das Lschen. Dies sollte einfacher zu verwenden sein als vorher, wo manche
  Funktionen nur ber das globale Filesystem-Interface ausgefhrt werden konnten.



>> 12.11.2007
[SB]
- Rewrite begonnen. Ziel ist es, die Basisklassen deutlich zu vereinfachen und zu verschlanken, wobei folgende Ziele
  verfolgt werden:
  * Alle Klassen sollten mglichst direkt instanziiert werden knnen, damit es dem Programmierer frei steht, ob er eine
    Klasse direkt verwendet oder dynamisch erzeugt, was auch eine effizientere Nutzung ermglicht. Es sollte daher nicht mehr,
  wie bisher, eine dynamische Erzeugung von Objekten erzwungen werden, da dies auch die Problematik der spteren
  Speicherfreigabe beinhaltet und generell komplizierter in der Verwendung ist.
  * Mglichst keine globalen Manager mehr, welche alle Instanzen einer oder mehrerer Klassen verwalten. Dies ist zwar manchmal
    sinnvoll (z.B. fr Ressourcenmanager), aber oftmal auch komplett unntig (z.B. Dateisystem, Systemklassen allgemein).
  * Die Basisklassen sollten mglichst schlank sein, also direkt mglichst einfach zu verwenden sein und dabei mglichst
    wenig Overhead erzeugen. Dies bedeutet vor allem, dass die Basisklassen vom RTTI unabhngig sein sollen und
    daher deutlich von den RTTI Klassen getrennt werden, diese arbeiten dann auf einer hheren Ebene ber den Basisklassen.     
- Ausserdem werde ich versuchen, folgende Konventionen einzuhalten:
  * Keine Verschachtelung mehr von Unterverzeichnissen, da dies eher wieder unbersichtlicher wird als bersichtlicher. Also
    wird es z.B. nur noch das Verzeichnis FileSystem geben, darin jedoch keine weiteren Unverzeichnisse fr Zip, Win32, Linux etc.    
  * Das Backend-Prinzip wird konsequent umgesetzt, also berall dort, wo es Systemspezifische Implementationen gibt, wird
    es nach aussen eine Systemunabhngige Klasse geben, welche die Details ber eine systemspezifische Implementationsklasse
    abkapselt (1:1-Beziehung). Dieses Vorgehen bringt am wenigsten Probleme mit sich und ist sehr flexibel und ist daher besser,
  als z.B. direkt die Systemspezifischen Klassen abzuleiten (zumal dies nicht damit vereinbar ist, die Klasse direkt zu
  instanziieren).



>> 23.10.2007
[SB]
- Definition von _CRT_SECURE_NO_DEPRECATE in CMakeLists.txt hinzugefgt. Dabei ist mir aufgefallen, dass im VC-Projekt
  diese Definition nicht auf die bliche Weise unter "Prprozessordefinitionen" hinzugefgt wird, sondern per
  "zustzliche Optionen" der Kommandozeile. Habe das mal gendert, da ich keinen Grund sehe das hier anders zu machen
  als bei den sonstigen Definitionen und man so nur unntig suchen muss.



>> 20.10.2007
[SB]
- zlib.dll auch aus den Installationsanweisungen in der CMake-Datei entfernt.



>> 19.10.2007
[CO]
- zlib wird im VC8 Projekt nun genauso wie in der CMake-Datei statisch eingebunden. 'zlib.dll' aus dem Runtime-Ordner gelscht.



>> 13.10.2007
[CO]
Alle Projekte:
- Einige 'const' eingefgt
- Einige '#define' entfernt
- Ein paar Abstze eingefgt



>> 07.10.2007
[CO]
Alle Projekte:
- Einige 'const' eingefgt um dem Compiler das Leben etwas einfacher zu machen und mglichen unerwnschten Manipulationen
  vorzubeugen
- Dort wo es problemlos mglich war machte ich beim Speichern das zu speichernde Objekt Konstant. Bei ein paar Loadern wie z.B.
  Mesh Loadern ist dies leider nicht mglich da Index Buffer beim Lock verndert werden.
PLGeneral:
- String(const Variant &cVariant) entfernt da berflssig, da nutzt man lieber Variant::GetString() :D
- Variant: Entfernte alle 'char*'-Funktionen da intern sowieso als 'String' gespeichert wird und man es daher gleich auch
  so bergeben kann ohne das es einen wirklichen Unterschied macht. Die 'GetString()'-Funktion erzeugt nun auch gleich den
  String und gibt diesen zurck ohne das dieser eventuell in 'm_sString' gespeichert wird... das macht die Sache zwar langsamer
  wenn fters diese Funktion hintereinander aufgerufen wird - allerdings hat diese Funktion wirklich konstant zu sein.
- Parameters::GetParams() entfernt da dies einen Iterator zurckgab ber den man die Variablen htte verndern knnen +
  diese Funktion wurde nirgends verwendet.



>> 17.09.2007
[CO]
- Nahm das aktuelle Experimentelle Error System heraus da dies erstmal wohl nicht weiterverfolgt wird. Hab dafr im
  lab-Repository ein entsprechendes Projekt mit diesem System angelegt.
- Entfernte nach Rcksprache mit Stefan 'PLBool'. Wir wollten zwar das noch solange drinnen lassen bis die Sache wie/ob
  wir ein 'Error System' implementieren geklrt ist - allerdings ist es nicht abzusehen ob/wann das gemacht wird. Darum
  kommt das nun raus damit die Codes nicht mehr ganz so unfertig/hchst Experimentell wirken. Sollte man dann irgendwann
  ein 'Error System' haben, msste man eh nochmal alles im Detail durchgehen.
  Das war nun zwar wieder einiges an Fleiarbeit, aber so isses wieder viel besser da bersichtlicher + weniger Overhead...
  die einzelnen dll's sind gleich um ein paar KB (eine davon sogar um 30! :) kleiner geworden. *g*



>> 15.09.2007
[CO]
- XML-Klassen: Die Konstruktoren noch etwas aufgerumt - keine Ahnung wieso ich das damals so umstndlich machte. 'void *'
  hab ich allerdings als Parameter gelassen, man 'knnte' zwar eine direkte Referenz auf das TinyXml Objekt bergeben, aber
  dann 'msste' diese TinyXml Klasse als 'Predefinition' in unseren XML-Headern stehen... und das will ich nicht. :D
  Nur die 'XmlDocument' Klassen Dokumentation weist darauf hin das intern TinyXml verwendet wird, ansonnsten sollte das wie
  gehabt absolut verborgen bleiben WIE das Implementiert ist.
- CmdLineParser nochmal etwas aufgerumt



>> 14.09.2007
[CO]
- Element & Resource: 'Delete()'-Funktion liefert als Rckgabewert nun ob alles gut ging oder ein Fehler auftrat



>> 13.09.2007
[CO]
- Da ich in Jens 'Kabiene'-Szene hin und wieder recht heftige stocker habe wenn ich einen neuen Raum betrete (wie es aussieht
  muss die GPU viele Textur Daten umschaufeln) das dazu fhrt das alles kurz 'einfriert' und ich danach weit auerhalb der
  Szene bin, versuchte ich solche unregelmigkeiten im Timing etwas zu Kompensieren.
  In 'Timing::Update()' wird die nderung des Zeit unterschiedes mit dem des letzten Frames verglichen und wenn diese Werte
  ZU stark voneinander abweichen wird hier 'geglttet'. ber die neue Funktion 'GetTimeDifferenceNoCompensating()' kann
  man sich den 'wirklichen' Zeit unterschied ohne 'Korrekturen' zurckgeben lassen um z.B. feststellen zu knnen ob
  unregelmigkeiten auftraten.



>> 08.09.2007
[CO]
- DirectoryZip::SearchCentralDir() vereinfacht, der Zwischenbuffer liegt nun direkt auf dem Runtime-Stack
- DirectoryZip::OpenObject(): Der verwendete ZIP-Iterator liegt nun direkt auf dem Runtime-Stack



>> 24.08.2007
[CO]
- SystemWin32::ErrorCodeToString() statisch gemacht da man wirklich keine Instanz der System Klasse dafr braucht
- DynLibWin32::Load(): Gibt nun ber 'SystemWin32::ErrorCodeToString()' eine Fehlerbeschreibung aus
- Localization::SetLanguage(): Nahm hier das [TODO] raus. Diese Funktion setzt wirklich nur einen String, fr das Laden
  der konkreten Sprachen ist die jeweilige Implementation selbst verantwortlich. Generell wird die Sprache am besten NUR
  beim Programm-Start gesetzt und geladen, denn das jederzeit ndern zu knnen wre ziemlich Tricky... denn man msste dann
  irgendwie ALLES Informatieren das sich die Sprache gendert hat, alle Strings in allen Programmteilen mssten sich updaten
  etc. - sehr viel sehr unschne Arbeit fr wenig Nutzen. Das sparen wir uns lieber und gehen den einfachen Weg. :D



>> 22.08.2007
[CO]
- Machte ein paar nderungen an der Time-Klasse:
  - Ein paar statische Zeiten spendiert, 'Null' wird z.B. in PLNetworkIRC::IRCConnection::ProcessServerMessage()
    verwendet.
  - Fgte eine Funktion Namens 'ToString()' hinzu ber die man sich eine String Reprsentation der Zeit zurckgeben lassen kann.
  - m_nDay in m_nDayOfMonth + die entsprechenen Funktionen umbenannt damit eindeutig ist WAS das ist
  - 'EMonth' fngt nun wie EDay bei 0 (wie bei Linux und nicht wie bei Win32 SYSTEMTIME) an damit das einheitlich ist + man
    sich direkt die in ToString() verwendete String Representation des Monats/Tages ber ShortMonthName[Month] bzw. ShortDayName[Day]
    zurckgeben lassen kann.
  - Einfache vergleichs-Operatoren hinzugefgt.
  - Funktion IsLeapYear()' hinzugefgt die ermittelt ob ein gegebenes Jahr ein Schaltjahr ist oder nicht.
  - Funktion 'SetUnixDate()' hinzugefgt.
  - Funktion CalculateDayOfWeek()' hinzugefgt die den Wochentag berechnent auf den ein Datum fllt. SetDOSDate() nutzt
    diese Funktion.
  - 'Unkown' aus 'EDay' entfernt da man sich diese Information nun berechnen lassen kann wenn man diese nicht direkt hat.



>> 21.08.2007
[CO]
- "NoMemoryManager.h" entfernt da wir das derzeit so nicht brauchen da wir keine Memory-Makros nutzen
- Konnte in "Checksum::Get(const String &sClass, File &cFile, PLResult *pResult)" das [TODO] entfernen da es mittlerweile
  mglich ist zu prfen ob man aus einer Datei lesen kann.



>> 07.08.2007
[CO]
- FSTools: ValidatePath(): War leider etwas Problematisch da man nicht genau wusste ob nun am ende ein '/' eingefgt werden
  sollte oder nicht. Darum zerlegte ich diese Funktion in zwei Funktionen:
  - Einmal ValidateFilePath() welche einen Dateinamen korrekt macht
  - Und ValidateDirectoryPath() welche auf ValidateFilePath() aufbaut + sicherstellt das am Ende ein '/' ist
  -> Gefllt mir zwar nicht wirklich gut, alledings wsste ich nicht wie man das anderst handhaben sollte... der User MUSS
     wissen WAS dieser 'Pfad' Darstellt, darum muss er uns das auch mitteilen damit man nicht irgendetwas falsches annimmt.
     "C:/MyDirectory/Test" knnte ein Verzeichniss sein, aber auch eine Datei ohne Dateiendung, darum MSSEN Verzeichnisse
     bei uns ausdrcklich mit '/' am Ende gekennzeichnet werden damit keine Mehrdeutigkeiten vorhanden sind. Allmhlich fnde
     ich es irgendwie erleichternd wenn wir berall bei Datei/Verzeichniss Namen die 'Url'-Klasse nehmen wrden - das wrde an
     vielen  Stellen einiges einfacher machen da man nicht mehr irgendeinen Mehrdeutigen Schrott bergeben bekommen kann.
     Derzeit sind an vielen Stellen immer hnliche Abfragen, und an ein paar Stellen auch nicht wo es dann schnell mal zu
     Problemen kommen kann. :(
  -> Auf jedenfall sind sind nun keine FS Basis Pfade mehr 'doppelt' eingetragen (dort kam gerade durch eventuell fehlende
     '/' einiges durcheinander)



>> 03.08.2007
[CO]
Allgemein:
- Nahm berall
    m_pImage->SetInteger(PLGraphics::Image::Mode_OriginSet,  true);
    m_pImage->SetInteger(PLGraphics::Image::Mode_OriginMode, PLGraphics::Image::Origin_UpperLeft);
  vor dem Laden von Bildern raus - diese Einstellungen sind/waren bei uns bereits Default, und innerhalb von PL sollte da
  auch nix umgestellt werden. (0, 0) ist bei uns also berall 'links oben'. (u.a. DirectX nutzt diese Regel) Texturen die
  der GPU bergeben werden nutzen bis jetzt "(0, 0) ist links unten". (wie in OpenGL) Bis jetzt war das 'nur' inkonsistent,
  aber da wir nun verstrkt dds nutzen (um die Textur Massen halbwechs bewltigen zu knnen) zeigte sich das dies hier sehr
  unhandlich ist da dds von DirectX kommt. Zwar passt DevIL immer braf 'oben/unten' fr uns an, aber bei den DXTC Daten die
  wir, wenn verfgbar direkt zur GPU jagen, wird nix verndert. (war auch wenig Sinnvoll wre da man sich dadurch wieder
  den Geschwindigkeitsvorteil kaputt machen wrde :)
  Dadurch hatte man dann 'geflippte' Texturen. Darum nun dieses nderung, damit das zum einen bei uns einheitlich wird +
  das man die Vorteile die dds bietet richtig nutzen kann.
  Musste nun zwar sorfltig prfen wo z.B. Textur Koordinaten verwendet werden und dort ber "1-y" vertauschen, oder "1-y"
  rausnehmen wo nun nicht mehr vertauscht wird - aber das lohnte defintiv. Endlich ist da Ordnung drinnen und in
  PLMesh::Texture::Load() konnte ich nun endlich einen doofen Hack rausnehmen der sowieso nicht zu 100% funktionierte.
  (ber dieses 'flip'-Problemchen stolperte ich schon frher im Zusammenspiel mit cube dds Texturen)
- Stellte berall wo mglich/sinnig Texturen auf das dds-Format um. (Texturen != OS Gui Bitmaps, da macht das natrlich weniger
  Sinn da man dadurch keine Vorteile hat :)
-> Es wird sicherlich noch einige Tage dauern bis ich 'soweit alle' Stellen angepasst habe die von diesen nderungen betroffen
   sind. Aber im groen und ganzen geht alles wieder wie vorher - nur halt flotter zu laden + Grafiker haben direkt selbst
   Kontrolle ber die MipMaps und was genau fr Kompression verwendet werden soll. :D
   (ohne dds geht das im Grunde nur automatisch -> man hat weniger Kontrolle)



>> 02.08.2007
[CO]
Allgemein:
- Alle Doxygen Konfigurations-Dateien ber "doxygen -u" auf den neusten Stand gebracht
- Machte bei allen Loadern alle Funktionen const. Da es von diesen Loader Klassen jeweils nur eine globale Instanz gibt darf
  keine der Funktionen etwas an diesen Objekten ndern oder man bekommt sptestens bei Multi-Threading probleme. Ein paar
  wenige Loader nutzen nun einfach 'pro Instanz'-Daten.



>> 01.08.2007
[CO]
- 'SearchHandleZip' hatte nicht das gleiche Verhalten wie die anderen Implementationen die zuerst '.', anschlieend '..' und
  erst dann die 'richtigen' Dateien auflistet... das viel in 'PLSceneViewer.exe' auf wenn man im Datei-Dialog in ein
  'zip-Verzeichniss' wechselte, aber keine '..' mehr da waren zum zurck gehen.



>> 30.07.2007
[CO]
- Loadable: Merkt sich nun auch den 'original' Dateinamen der zum Laden verwendet wurde
- LoadableType::AddLoader: Wenn ein Format bereits im Manager durch einen anderen Loader eingetragen wurde so ist das kein
  Fehler, sondern heist nur das man nicht eindeutig ber die Dateiendung rausbekommen kann welcher Loader fr dieses Format
  zustndig ist. Dies ist allerdings KEIN Problem da sowieso immer bekannt sein sollte WAS man denn eigentlich laden will,
  also obs ein Mesh, eine Scene etc. ist. Das DirectX Format kann z.B. als Mesh verwendet werden, aber da es sehr flexibel
  erweiterbar ist + Hierarische Strukturen hat kann es genauso auch als Scene genutzt werden.
  Was allerdings auch vorkommen kann ist, das z.B. zwei verschiedene Mesh Formate die gleiche Dateiendung haben, ja eventuell
  sogar im Grunde das gleiche Format sind, aber unterschiedliche Versionen davon. Derzeit wird soetwas noch nicht Untersttzt,
  msste sich spter aber erweitern lassen... macht die Sache allerdings bestimmt nicht einfacher oder bersichtlicher. *g*
- Nahm die String Duplizierung aus Loadable::Reload() heraus, in Loadable::Load() ist nun ein universellerer 'Sicherheits'
  Test drinnen



>> 22.07.2007
[CO]
- 'Function': Machte den Konstruktor protected und Dokumentierte krftig da ich gerade ein paar Stunden damit verbrachte
  rauszubekommen was 'genau' (hatte vorher nur eine sehr grobe Vorstellung) das ist bzw. wie man es verwendet. In PLBaseTest
  gibts nun einige Tests fr diese Funktionalitt... anhand dieser Tests hab ich mich an die Sache rangetastet - Stefan,
  gib mir irgendwann bitte bescheit ob ich das soweit richtig verstanden habe und es auch wie vorgesehen nutze. :)
  Die Investierte Zeit hat sich auf jedenfall gelohnt, denn nun versteh ich was da abluft - wirklich eine sseeehr feine
  Sache. :)
- Container-Klassen abermals durchgeschaut und kleinigkeiten verbessert



>> 21.07.2007
[CO]
Alle Projekte:
- Die paar 'realloc' welche noch verwendet wurden durch 'MemoryManager::Reallocator()' ersetzt + stellen an denen noch z.B.
  'memcpy' verwendet wurde ebenfalls umgestellt damit wirklich alles ber den Memory Manager luft. Das mag zwar auf den
  ersten (und eventuell zweiten und dritten und... *g*) Blick 'extrem' erscheinen, hat aber durchaus so seine Vortelle da
  alles eine 'Zentralverwaltung' passiert. (...big brother is watching you...)
PLGeneral:
- SystemWin32: Erste ffentliche Funktion eingebaut: ErrorCodeToString(): Wandelt einen Win32 Fehler Code den man ber
  GetLastError() erhalten hat in einen PL-String den man dann z.B. direkt ins Log schreiben kann... das hatte ich vor einiger
  Zeit schonmal irgendwo lokal reingehackt als ich mir beim Debuggen Win32 Fehler als String zurckgeben lies.
  In SystemLinux hab ich soetwas nicht eingebaut da es unter Linux eine Funktion namens 'strerror' gibt die sich sehr leicht
  weiternutzen lsst.
- System: Neue Funktion: IsLittleEndian(): Damit kann man feststellen welche Byte-Reihenfolge die aktuelle Maschine fr
  grere primitive Datentypen verwendet. Zuknftig knnen wir diese Funktion nutzen um zu entscheiden wie man z.B. ein
  'float' in eine Binr Datei schreiben oder auslesen muss. Das bringt allerdings erst 'wirklich' etwas sobald wir nicht mehr
  wie momentan direkt ber die Write/Read-Funktionen der File-Klasse diese Daten schreiben/lesen... da muss dann ein kleiner
  Wrapper her damit wir 'wirklich' Plattform unabhngig werden, also auch damit klarkommen wenn die Byte-Reihenfolge anderst
  herum ist. :)
  Ich habe die Funktion 'IsLittleEndian()' und nicht 'IsBigEndian()' genannt da wir derzeit eigentlich nur auf Little-Endian
  Gerten arbeiten und ich denke auch diese Anordnung in unseren Binr Formaten behalten werden - der Funktionsname deutet
  also so bereits an mit welcher Anordnung PL 'intern' arbeitet.
- Nahm die auskommentierten Memory-Makros aus 'MemoryManager.h' nun komplett raus da wir das denk ich mal so nicht nutzen
  werden da es einfach 'unschn' und fehleranfllig ist - es wre einfach nur doof 'berall' 'MemoryManager.h' einbinden zu
  mssen nur damit die Makros 'wirksam' werden. Wenn man brav mit new/delete arbeitet braucht man das auch nicht wirklich.



>> 19.07.2007
[CO]
Alle Projekte:
- Wenn ber new Instanzen von Klassen erzeugt werden, aber dem Konstruktor nix bergeben wird, war die Schreibweise nicht
  einheitlich. berwiegend hatten wir z.B. "new MyClass()" -> also mit "()" am Ende. So sieht man im Grunde sehr hufig,
  und mittlerweile bin ich diese Schreibweise auch durch Jave gewohnt. Daher nderte ich das entsprechend. (aber nicht
  wenn z.B. Primitive Datentypen oder Strukturen erzeugt werden... das kommt mir da etwas merkwrdig vor und das sieht
  man auch praktisch nie so geschrieben :)
PLGeneral:
- Fand noch zwei Stellen wo ich sehr einfach malloc/free durch new/delete ersetzen konnte. Wo immer mglich (also praktisch
  berall :) sollte man lieber new statt malloc etc. nutzen - dadurch braucht man sich dann auch keine Sorgen zu machen 'wo'
  bzw. 'wer' den Speicher anlegt. 'new' lsst sich ja sehr einfach berladen was auch bereits gemacht wird... aber 'malloc' &
  CO kann man nicht wirklich berladen. Zwar knnte man ein Makro schreiben, (was ich zum probieren auch machte :) das fhrt
  allerdings dann zu mehr Problemen (teils sogar zu Compiler fehler in Third-Party libs) als es Nutzen bringt.
  An ein paar Stellen wird noch realloc genutzt, diese Stellen werde ich bei Zeiten noch ndern damit wir in PL wirklich
  nur new/delete nutzen um mglichen Problemen der Speicherverwaltung gleich von Anfang an aus dem Weg zu gehen.
  (man muss soetwas ja nicht provozieren :)



>> 08.07.2007
[CO]
Alle Projekte:
- Entfernte einige &<Name>[0] da & und [0] automatisch vom Compiler hinzugefgt wird und das ohne besser Lesbar ist :)
PLGeneral:
- Fgte ein paar  #error "Unsupported platform"  ein (z.B. in SystemImpl.cpp)



>> 06.07.2007
[CO]
- Die Datei & Klassen Namen der FS Implementationen folgten nicht der Benennung der anderen PL Dateien



>> 24.06.2007
[CO]
Alle Projekte:
- Merkte gerade das in den meisten Dateien der inline Implementationen z.B.
    #ifndef __PLRENDERER_SHADERCGBACKEND_INL__
    #define __PLRENDERER_SHADERCGBACKEND_INL__
  etc. steht, also wie bei den Headern. Dies ist hier allerdings vllig berflssig da diese Dateien NUR von den jeweiligen
  Headern selbst eingebunden werden drfen und dort bereits im 'geschtzten'-Teil liegen. (dem Compiler unntige Arbeit
  sparen iss immer ne gute Sache, auch wenn das absolut nicht ins Gewicht fllt *g*)
PLGeneral:
- 'PL_F2DW()' und 'PL_DW2F()' aus 'PLRenderer/Types.h' entfernt und in 'PLGeneral/Tools/Tools.h' als FloatToUInt32() und
  UInt32FloatTo() eingefgt. Zum einen fand ich es schon lange nicht mehr sonderlich prall das diese zwei Funktionen (frher
  Makros :) so lieblos irgendwo in der Gegend herumstehen + die Namen selbst waren nicht mehr ganz korrekt und nicht
  sonderlich aussagekrftig.



>> 23.06.2007
[CO]
Alle Projekte:
- Verbesserte an einigen Stellen gro/kleinschreibung. Wenn z.B. mit 'windows' das Betriebssystem und nicht etwa 'GUI Fenster'
  gemeint sind sollte das 'Windows' geschrieben werden da Name. 'win32' konsequent zu 'Win32' gemacht. 'linux' ist ebenfalls
  ein Name, also 'Linux'.
- Bei 'Abkrzungen' wurde so richtig wild gemischt und ich selbst war auch immer sehr unsicher 'wie' man das nun 'berlicherweise'
  schreibt. Da wollte ich schon lange mal was machen damit das halbwechs konsequent ist. Daher googelte ich erstmal etwas +
  informierte mich auf Wikipedia wie man blicherweise diverse Dinge schreibt. Danach nderte ich u.a. 'url/Url' -> 'URL',
  'xml/Xml' -> 'XML', 'html/Html' -> 'HTML', 'zip/Zip' -> 'ZIP', 'gui/Gui' -> 'GUI' (bis auf die Dateiendung 'gui') - nur in den
  Dateinamen nderte ich erstmal nix da dies die Lesbarkeit etwas verschlechtert - da knnen wir uns spter berlegen ob wir das
  so lassen, oder ob wir das berall durchwech konsequent schreiben wollen damit keine Unklarkeiten reinkommen. Das alles knnte man
  natrlich als 'belanglose fusselei' abtun... allerdings empfinde ich soetwas als wichtig da es gerade in der Informatik mittlerweile
  sooo viele Abkrzungen gibt und ich es auch in Mathematik hchst verwirrend und strend empfinde wenn ein und dieselbse Sache
  immer wieder etwas anderst geschrieben wird - das hilft definitiv nicht Anfngern sich in die Materie einzuarbeiten! :(
  Zudem ist PixelLight generell 'case-sensitive' so das wir da (vorallem den Grafikern *g*) mit gutem Vorbild vorausgehen sollten.
PLGeneral:
- FileSystem vom Style und der Ordnung her aktualsiert. Also Dinge privat gemacht die privat zu sein haben, Konkrete
  Implementationen werden wo das nicht bentigt wird oder wnschenswert ist nicht Exportiert. Wo mglich Zeiger zu Referenzen
  gemacht damit man den NULL-Fall nicht bercksichten muss. Einige Kommentare verbessert oder genauer gemacht. Einige short
  zu int16 und long zu int32 (+ unsigned Variationen) gemacht damit das in PL berall gleich ist + das ist deutlich besser
  lesbar + man weis wirklich ganz genau was das fr gren zu sein haben.
- Bei der File-Klasse ein 'IsReadable()' hinzugefgt. Dies wurde bereits im Loadable-System bentigt + ist das passende
  Gegenstck zu 'IsWritable()'
- LogFormater Implementationen umbenannt da diese nicht dem PL Namens Style folgten und es mich auch schon mehrmals strte
  das ich erstmal kurz die einzelnen Implementationen zusammensuchen musste - durch die Namens-nderung sind diese Dateien
  wenn man Alphabetisch Ordnen lsst immer nett beisammen was enorm Handlich ist.
- BufferedReader Implementationen umbenannt da diese nicht dem PL Namens Style folgten
- CMakeLists.txt: LogFormaterConsole.cpp fehlte
- 'PLEFileSeek' von FileSystem.h in die File-Klasse verschoben und in 'ESeek' umbenannt. 'PLEFileAccess' von FileSystem.h
  in die File-Klasse verschoben und in 'EAccess' umbenannt. Dadurch konnte man auch gleich wieder Header abhnigkeiten
  reduzieren. :)
- FileSystem: GetRootDirectory() und GetCurrentDirectory() liefern nun Referencen statt Zeiger zurck denn diese Dinge
  MSSEN immer gltig sein... ansonnsten luft gerade etwas soetwas von total daneben. Durch diese nderung wird an einigen
  Stellen der Code nun etwas bersichtlicher da man keine NULL-Abfragen mehr machen muss/sollte.
- FileSystem: GetCurrentDirectory() fgt nicht mehr automatisch eine Referenz zum aktuellen Verzeichniss hinzu



>> 22.06.2007
[CO]
- Entfernte aus Timing die Funktionen Start(), Stop() und GetEllapsedTime() und fhrte eine neue Klasse Namens 'Stopwatch'
  ein welche diese Funktionalitt bereitstellt. Stellte gleich eine Handvoll Stellen in verschiedenen Projekten auf diese
  neue Klasse um - das ist wirklich sehr Handlich. :)
- Time um SetDosDate()-Funktion aus ZipDate erweitert und ZipDate anschlieend entfernt da doppelte Funktionalitt



>> 16.06.2007
[CO]
Alle Projekte:
- Entfernte bei allen virtuellen und nicht Implementierten Funktionen (=0) das Export Makro da in diesen Fllen nicht bentigt
PLGeneral:
- 'PL_UNUSED'-Makro entfernt da dieses mittlerweile gerade im Zusammenhang mit ungenutzten Referenzen wo man dann zwanghaft
  Header einbinden muss obwohl nix bentigt wird sehr unhandlich wird - zudem wollte Stefan das sowieso vor einigen Montaten
  raushaben. :)
  Das war eine Zeitlang recht nett dieses Makro um berall zu checken ob Parameter berhaupt bentigt werden bzw. korrekt
  genutzt werden, mittlerweile ist das aber nicht mehr wirklich ntig. Die 'nicht verwendet' Warnung erscheint blicherweise
  nur in der allerhchsten Warn-Stufe, wenn das jemand aktiv haben will, muss er es fr sein Projekt wieder per Hand aktivieren.



>> 12.06.2007
[CO]
- Sleep() von der System Klasse in ThreadManager verschoben da dies dort Thematisch besser reinpasst (der aktuelle aktive
  Thread wird schlafen gelegt...)



>> 09.06.2007
[CO]
- MemoryCopy() & MemorySet() & MemoryCompare() aus Wrapper.h in MemoryManager.h verschoben, das ist dort denke ich recht
  gut aufgehoben
- MemoryManager.h: Defines auskommentiert: Diese Definitionen sind leider recht problematisch und verursachen recht schnell
  Fehler in 'Fremd-Header'.



>> 08.06.2007
[CO]
- BufferedFileReader: Laut Konstruktor Dokumentation wird die bergebene Datei automatisch freigegeben, das war allerdings
  nicht der Fall wenn das Dateiende bereits erreicht war - vereinfachte/verallgemeinerte daher den Konstruktor etwas
- An einigen Stellen wo mglich/sinnig Zeiger durch Referenzen ersetzt. Uh, verstehe gar nicht wieso ich das frher noch
  nicht gesehen habe das es 'meistens' ber Referenzen viel eleganter und sicherer geht da man den 'NULL'-Fall nicht
  bercksichtigen muss wenn er eigentlich gar nicht erst vorkommen sollte. :)
  Ist zwar einiges an Arbeit nun alle Codes/Interfaces nochmal genau durchzuschaun, aber es lohnt definitiv + nebenbei
  fallen mir auch noch immer einige andere Dinge auf die nicht mehr ganz Up-To-Date sind... ganz nebenbei stehen in ein paar
  Wochen bei mir mal wieder Prfungen im Studium an und da sind solche Arbeiten genau das richtige da man das nebenbei
  machen kann ohne sich Gedanklich voll reinhngen zu mssen was zur Prfungszeit weniger optimal ist.



>> 07.06.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'childs' in 'children' gendert (das war an einigen Stellen noch falsch :)
PLGeneral:
- XmlAttribute: QueryIntValue() & QueryDoubleValue() ndern den Wert der bergebenen Variable im Fehlerfall nicht, damit
  ist das Verhalten vergleichbar zu den hnlichen Funktionen in XmlElement
PLNetwork:
- Wo mglich/sinnig Zeiger durch Referenzen ersetzt



>> 05.06.2007
[CO]
- Time fr die Tage Enums spendiert
- Semaphore: m_nValue wurde nicht initialisiert (?)
- Thread::Thread(bool bMainThread): Hier wurden die Variablen nicht initialisiert



>> 29.05.2007
[CO]
- Erweiterte das Var-Interface etwas damit man besseren Zugriff auf die Enumeration-Daten hat



>> 26.05.2007
[CO]
- Das mischen von Debug/Release Builds gestern klappte nicht wirklich gut. Es gab merkwrdige Crashs etc. da beide Builds
  intern unterschiedliche VC Memory Manager nutzen die nicht wirklich kompatibel zueinander sind. Da ich das aber wirklich
  wirklich endlich mal sauber am laufen haben wollte befasste ich mich heute etwas mit der Speicherverwaltung. Heraus kam
  ein eigener minimal Memory Manager der im 'PLGeneral/Core'-Ordner liegt und der die C++ new/delete Operatoren 'berld'.
  Solche Operationen werden nun direkt in unseren eigenen Memory Manager 'umgeleitet' der frs erste nur malloc/free nutzt.
  Alles Speicher anlegen/freigeben findet nun also NUR noch innerhalb von PLGeneral statt und dadurch verschwinden diese
  merkwrdigen Speicherproblemen + wir haben viele weitere mglichkeiten wie Speicher-Statistiken, Sicherheits-Checks -
  oder das die Implementation einer komplett eigenen Speicher-Verwaltung!
  Der einzige Hacken bei der Sache ist, das jedes Projekt nun per Hand 'PLGeneral/Core/MemoryManager.inl' einmal irgendwo
  einbinden msste damit diese Operatoren sauber berladen werden...
- Fgte einen Header Namens 'PLGeneral/ModuleMain.h' hinzu. Dieser ist das gegenstck von 'PLGeneral/Main.h' welches fr
  Anwendungen verwendet wird. Verschob aus 'RTTIDefs.h' die paar Module-Makros in diese neue Datei - das sind Dinge die
  genauso wie in 'PLGeneral/Main.h' NUR einmal pro Projekt fr den Einstiegspunkt bentigt werden. 'PLGeneral/Main.h'
  baut somit auf 'PLGeneral/ModuleMain.h' auf, welches wiederum 'RTTIDefs.h' nutzt - so msste das recht berschaubar sein.
  Ich muss allerdings zusgeben das 'berschaubarkeit' nicht der eigentliche Grund fr diese kleine nderung war, sondern
  meine aktuellen arbeiten am Memory Manager. NUR einmal pro Projekt sollte 'PLGeneral/Core/MemoryManager.inl' eingebunden
  werden welches dann new/delete Operatoren mit PL eigenen Implementationen 'berschreibt'. Allerdings wollte ich das nicht
  jedesmal an zig verschiedene Stellen schreiben mssen da man es mal schnell vergisst und dann der Memory Manager nicht
  korrekt in diesen Modulen arbeiten kann. Daher wird dieser eine Header gleich automatisch in 'ModuleMain.h' eingebunden das
  so oder so genutzt wird - wenn man sich an die PL Richtlinen hlt und 'PLMain' etc. nutzt... wer das nicht tut und meint
  er msste selbst beim Einstiegspunkt herumwurschteln der muss sich halt auch selbst um andere Dinge kmmern. *g*
  Somit muss sich der User also berhaupt nicht um diese Speicher-Geschichte kmmern.
-> Als Folge dieser nderungen ist das mischen von Release/Debug Builds nun endlich mglich. Da im Grunde im PL-SDK IMMER
   Release genutzt wird und mir die Plugin-Datei nderungen von gestern nicht soo gut gefielen da es dadurch etwas
   unbersichtlich und unntig aufwndig wird, machte ich diese Plugin-Datei nderung wieder rckgngig... lies es aber
   hier im Diary stehen damit man nachlesen kann was wieso etc.
   Nutze ich die Release Versionen von PL kann ich aber immer noch mein eigenes Programm wie gehabt Debuggen - das klappt
   sogar mit Dll's. Natrlich kann man mit dem Debugger nicht in die PL Funktionen 'einsteigen', aber das wrde sowieso nicht
   wirklich gehen da im SDK die cpp-Dateien von PL nicht liegen. :)
   Leider ist derzeit ein zu 100% mischen nicht mglich. Trage ich z.B. als Release Library eine Debug Version ein, wird
   die dll zwar ohne Crash etc. geladen, aber die RTTI Klassen werden nicht Regestriert... genau weis ich noch nicht was
   da im Detail abluft. Aber das was mir wichtig war, also z.B. Debuggen einer dll im zusammenspiel mit einer release exe
   klappt ganz wunderbar.



>> 25.05.2007
[CO]
Alle Projekte:
- In den letzten Tagen lies ich in allen Projekten nach 'DEFINE_VAR_LIST' suchen und stellte sicher das die am RTTI
  hngenden Variablen direkt in der Konstruktor Initialisierer-Liste initialisiert werden.
PLGeneral:
- Base: CreateInstance(): 'bSetVars'-Parameter entfernt. Das kann man als User selbst nachtrglich machen wenn man will -
  zudem wrde das nicht Initialisieren nicht wirklich Sinn machen bzw. wre hchst Gefhrlich da man undefinierte Zustnde
  htte. (bzw. frher hatte) Generell sollten IMMER alle Klassen ihre Variablen selbststndig auf korrekte Default Werte
  setzen (also unabhngig ob diese am 'RTTI' eingehngt sind oder nicht) die mit den in den RTTI Makros angegeben Werten
  bereinstimmen. Gefllt mir zwar nicht wirklich dieses 'doppelte' reinschreiben von Default-Werten, wsste aber momentan
  nicht wie man das anderst lsen sollte. Auf diese weise kann man u.a. bereits in den Klassen Konstruktoren diese Variablen
  nutzen was voher nicht so ohne weiteres mglich war da die Variablen erst 'nach' dem erzeugen auf die Default-Werte gesetzt
  wurden... das war eine sehr unglckliche Situation in die ich in den letzten Jahren natrlich immer mal wieder reinstolperte.
  'DEFINE_VAR_RO' ging frher nicht korrekt da SetVars() genutzt wurde was dann natrlich das setzen der 'read-only'
  Variablen zu verhindern weis.
  Auch war das Initialisieren von am RTTI hngenden Variablen in der Initialisierer-Liste der Konstruktoren inkonsistent.
  Einmal wie z.B. in Vector3 wurde dort initialisiert da man diese auch ohne RTTI nutzen kann, und bei anderen Klassen wie
  z.B. SceneNode nicht da diese 'nur' ber das RTTI Instanziert werden knnen.
  Zusammenfassend hat man mehr 'Sicherheit' da immer Variablen in bekannten Initialzustnden - da muss wie blich natrlich
  JEDER Klassen-Schreiber dafr sorgen! CreateInstance() ist schlanker + weniger 'Overhead' beim erzeugen von Instanzen -
  da das RTTI System mittlerweile sehr intensiv genutzt wird ein sicherlich nicht ganz unerheblicher Faktor... wird z.B.
  eine *wirklich* groe Szene mit mehreren tausend Nodes eingeladen spart man sich nicht gerade wenig Arbeit ein und auch
  wenn man mit dem Debugger Schrittweise den Code Analysiert ist das nun um einiges durchschaubarer.
  Hab mal noch kleine Performance Tests in 'PLSampleScene.exe' gemacht - grte Szene (F3) die 4098 Nodes hat, aber nur
  'sehr' wenig verschiedene Daten nutzt und daher optimal fr diesen Test ist: (jeweils zwei anlufe)
  - Vorher: 6.483 sec & 6.191 sec 
  - Nacher: 5.571 sec & 5.232 sec
  -> Also in dieser Szene mit 'etwas mehr' Nodes 'minimal' schneller, jedes bischn bringt uns weiter. :)
- Plugin XML Dateien: Ich berlegte mir bereits seit geraumer Zeit wie man das mit Debug/Release Builds 'mischen' am besten
  auf die Reihe bekommt - denn im ffentlichen PL-SDK liegen NUR Release Builds (bzw. sollten!) und trotzdem soll man auch
  seine auf PL aufbauenden Projekte korrekt Debuggen knnen. Wenn man die Debug Builds hat sollen diese auch genutzt werden
  knnen. Von 3ds Max hab ich auch 'nur' die Release Version, und kann trotzdem meine Exporter Plugins dafr korrekt Debuggen,
  also irgendwie ist das sauber realisierbar. :)
  Schlgt das einladen einer 'Library' fehl, so knnen nun alternative 'Fallback Libraries' verwendet werden. Konkret ist
  das bei Debug-Libraries sinnvoll. Im ffentlichen PL-SDK sind blicherweise keine Debug Versionen von PixelLight dabei,
  folglich schlgt der Versuch diese zu laden fehl - als Fallback wird nun versucht die entsprechende Release Library zu
  laden. Hat man also die Debug Version (warum auch immer *g*) wird diese korrekt genutzt, ansonnsten die Release Version.
  Als 'normaler PL-User' bin ich aber denk ich ganz froh die Release-Builds von PL beim Debuggen nutzen zu knnen, denn
  diese sind um einiges (!!) flotter und so kann man sich recht gut auf das Debuggen seines eigenen Projektes konzentrieren.
  Somit kann man problemlos und ich denke mal recht Intuitiv Release & Debug Builds mischen - das Plugin System ber diese
  XML Dateien msste nun soweit alles knnen das wir derzeit brauchen.
  Nahm den Parameter der 'PLGetPluginInfo'-Funktion im 'DEFINE_MODULE_PLUGIN'-Makro heraus und fgte dafr eine weitere Funktion
  namens 'PLIsPluginDebugBuild' hinzu ber die ermittelt werden kann ob das Plugin als Release oder Debug bersetzt wurde.
  ClassManager::LoadPlugin() kann dann auf wunsch einen Build Type Test erzwingen so das NUR zusammen passende Builds verwendet
  werden knnen - als Default ist dies allerdings deaktiviert da dies normalerweise nicht ntig/blich ist bzw. sein sollte.



>> 22.05.2007
[CO]
- Bugfix: Class::GetVar(): Meine nderung der Implementation vom 18.03.2007 war natrlich nicht ganz korrekt da nicht
  bercksichtigt wurde das es sehr wohl sein kann das die Variablen der Basis Klasse noch nicht Initialisiert sind - korrigiert.



>> 21.05.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'choosen' in 'chosen' gendert



>> 19.05.2007
[CO]
Alle Projekte:
- In Funktionen wo hufiger Instanzen von RTTI Klassen erzeugt werden und 'zur Sicherheit' geprft wird ob die Basis Klasse
  korrekt ist machte ich eine kleine rein Funktions interne Optimierung:
  Statt Class::HasBaseClass(String) wird nun Class::HasBaseClass(Class) genutzt wodurch man sich HashMap Operationen spart
  und sofort immer einen korrekten Zeiger auf die Basis Klasse hat. (der IMMER korrekt ist da Kern-Komponenten!) Zustzlich
  kann nun unsere String Klasse ihre Muskeln spielen lassen: Class::HasBaseClass(Class) nutzt intern String::Compare()...
  und hier muss dann am ende NUR noch ein einfacher Zeiger Test gemacht werden um festzustellen das die Basis Klasse gefunden
  wurde ohne die Strings selbst wirklich miteinander zu vergleichen - noch Effektiver gehts wohl kaum! *g*
  An Stellen wo teils nur ein einziges mal pro Programm start Class::HasBaseClass() verwendet wird lohnt soetwas natrlich
  nicht - aber bei z.B. PLEngine::SceneContainer::Create() ist das durchaus eine feine Sache.
PLGeneral:
- Loader: RTTI Variablen sind nun endlich 'read only'. Dies erreichte ich dadurch das nicht das RTTI die Variablen anfangs
  Initialisiert, sondern das die Variablen sauber wie man es gewohnt ist in der Initialisierer Liste der Konstruktoren
  initialisiert werden. Von Loader abgeleitete Klassen 'berschreiben' indem diese den jeweiligen Konstruktoren entsprechend
  neue Werte bergeben - das ist so wirklich deutlich besser. :)
- HtmlLogFormater: Funktionen etwas umsortiert so das die Reihenfolge der Daten immer gleich ist
- Machte bei LogFormater Implementationen einiges 'private' da man nicht weiter davon ableiten knnen soll + ein paar
  ffenliche Funktonen wurden nicht exportiert



>> 17.05.2007
[CO]
- Stack & Queue: Pop(): Kommentar erweitert (fr eine Situation wo man aufpassen sollte)



>> 15.05.2007
[CO]
- System::DeleteEnvironmentVariable() Implementation fehlte
- Bei den System-Klassen einige Dinge 'private' gemacht wo entweder nix von auen drauf zugreifen soll oder wo man nicht
  weiter Ableiten knnen soll
- Ein paar 'const' hinzugefgt
- Im Loadable System einige Zeiger zu Referenzen gemacht, so muss man bei den Kommentaren nicht mehr 'NEVER NULL!'
  dazuschreiben da es bereits von anfang an unmglich ist NULL-Zeiger zu bergeben.



>> 12.05.2007
[CO]
- Class::GetBaseClasses() entfernt da es hierfr keine Implementation (mehr) gab (?)
- ClassManager::GetClasses() gibt keine Liste mehr zurck, sondern bekommt eine als Parameter bergeben. Zum einen ist
  das so nun konsistent mit z.B. Class::GetVarList(), aber noch viel wichtiger ist, das so herum nun nicht mehr aufwndig
  viel herumkopiert werden muss. Das gleiche in der Module Klasse.
- Var: Machte ein paar grundliegende Funktionen protected. NUR Class darf hier direkt drauf zugreifen, so ist gewhrleistet
  das z.B. wirklich IMMER eine Variable zu einer Klasse gehrt.
- Machte an den RTTI Klassen einige 'Sicherungs'-Manahmen indem ich einige Parameter & Funktionen const machte (an vielen
  Dingen hat der User einfach selbst nix zu ndern :) und dort wo
  man nicht 'umbedingt' einen Zeiger als Parameter bergeben muss wird nun stattdessen eine Referenz verwendet - denn die kann
  ja nie NULL werden und so kann der User schonmal weniger Schrott bergeben + man spart sich Sicherheits-Abfragen. (die teils
  nicht vorhanden waren)
- Durch die nderungen kann man sich nun sogar in 'RTTIDefs.h' das Einbinden von 'Var.h' sparen :)



>> 11.05.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'socked' in 'socket' gendert
- Rechtschreib-Korrektur: 'terminal NULL', ich glaub damit meinte ich 'terminating zero' (jeder lacht aber keiner sagts :)
PLGeneral:
- String: In der Funktions-Beschreibung von GetLength() fehlte eine ganz entscheidende Information, 'terminating zero'
  ist in der Lnge nicht enthalten. berall anderst stand das bereits wenn ich nix bersehen hab.
PLNetwork:
- Im Server-Destruktor muss man noch zur Sicherheit 'StopHost()' aufrufen da dieser Aufruf vom Host-Destruktor aus
  dummerweise in der Host Implementation von StopHost() landet und daher wenns mal mies luft nicht sauber aufgerumt wird
- Im Destruktor von Socket() wird nun zur Sicherheit 'Close()' aufgerufen... etwas spter nach merkwrdigen 'Problemen'
  merkte ich das ich nicht ganz verstanden hatte was bei Sockets abgeht. Natrlich darf man das hier NICHT automatisch
  schlieen. Damit ich das nicht nochmal mache fgte ich ein entsprechendes Kommentar in diesem Destruktor ein. *g*
  Das gleiche in der Create()-Funktion wo es ebenfalls nicht angebracht ist automatisch Close() aufzurufen.
- Socket::Close() liefert nun anstatt 'int' ein 'bool' zurck welches nur angibt ob alles gut ging oder nicht, denn mit der
  Implementations abhngigen Fehler ID sollte der User nicht in Kontakt kommen bzw. er kann damit im allgemeinen nix
  anfangen da er nix von der konkreten Implementation weis. (bzw. wissen sollte *g*)
  Das gleiche beim Rckgabewert der Bind() und Listen() Funktionen.
- Socket::Create() gibt nun einen Fehler-Code zurck
- Socket::m_nSocket ist nun auf INVALID_SOCKET wenn 'ungltig'
- Connection::OnReceive(): Der bergebene Buffer mit den erhaltenen Daten ist nun 'const' da dieser Buffer selbst nicht
  direkt manipuliert werden 'sollte' (knnte wenns dumm luft irgendwann mal unfeine Seiteneffekte erzeugen)
- Stellte auf PLBool um damit das erstmal Einheitlich ist
- Erweiterte die Kommentare so das mglichst keine Fragen mehr offen bleiben was z.B. Parameter machen/was zurckgegeben
  wird etc. Einiges muss man aber bei Zeiten auf jeden Fall noch genauer Beschreiben, vorallem ein paar kleine hintergrund
  Informationen.



>> 10.05.2007
[CO]
- Sortierte ins Diary so richtig alte Eintrge aus "PLSDK/internal/old_diaries.zip" ein



>> 09.05.2007
[CO]
- Sortierte ins Diary alte Eintrge aus "PLSDK/internal/old_diaries.zip" von ab "02.04.04" ein
- Neue abstrakte Basis-Klasse eingefhrt: 'Iterable': Alles was einen Iterator Implementiert sollte von dieser Klasse
  abgeleitet sein. 'Map', 'Heap' und 'Container' sind somit nun also von 'Iterable' abgeleitet - so bekommt man eine noch
  etwas schickere und stimmigere Klassen-Hierarchie. :)



>> 21.04.2007
[CO]
PLNetwork:
- Socket::Recv() in Socket::Receive() umbenannt (man spart nicht wirklich was und muss sich nen krzel merken)
- Klassen Beschreibungen anhand von Stefans Konzept vom 08.03.2007 hinzugefgt/erweitert



>> 20.04.2007
[CO]
- Timing::Update(): Auf PLBool umgestellt



>> 18.04.2007
[CO]
Alle Projekte:
- Nach kurzer Rcksprache mit Stefan gestern nderte ich (automatisch, also ') = NULL;' zu ') = 0;' gleiche mit const,
  ersetzen lassen, insgesammt an 688 Stellen + 1 wobei diese eine Stelle nur unglcklich Formatiert war so das man per Hand
  ranmusste :) alle z.B. 'virtual void Test() = NULL' in 'virtual void Test() = 0' da 'NULL' in OS-Headern leider nicht immer
  zwanghaft als '0' oder '(void*)0' definiert ist - unter Linux ist das schonmal als '__null' definiert und dann gibts
  Compiler Fehler im Zusammenspiel mit z.B. 'virtual Test() = NULL' und man muss dann immer genau nachprfen wo/wie NULL in
  Headern einfach umdefiniert wurde das nicht wirklich die bersichtlichkeit frdert. :(
  Neben diesen Compiler-Problemen war dies ber 'NULL' auch hin und wieder etwas unhandlich wenn man wie in
  'PLGeneral::Iterator.h' eigentlich berhaupt kein Include bentigt, aber durch 'NULL' dann eben doch den PLGeneral-Header
  einbinden musste. Ich googelte etwas und schaute mir verschiedene C++ Codes durch, fand aber irgendwie nichts wo bei
  virtuellen-Funktionen 'NULL' statt '0' verwendet wurde. Wenn ich mich recht erinnere sah man das 'frher' hufiger,
  heute aber nicht mehr wirklich oft.
- Nahm '-U__GNUG__' Linux Compiler Definition aus allen CMake-Dateien heraus
PLNetwork:
- Sobald man in 'PLGeneralLinuxIncludes.h' das von z.B. 'gethostbyname' bentigte '#include <netdb.h>' einband bekam man
  in '/usr/include/netdb.h:661' einen merkwrdigen Compiler-Fehler.
  Stephan und ich fanden zusammen ber herumstochern heraus das die Compiler Option '-U__GNUG__' dafr verantwortlich ist,
  nahm man diese jedoch heraus wurde 'NULL' zu '__null' umdefiniert und man bekam bei virtuellen-Funktionen Probleme wenn
  '= NULL' verwendet wurde, daher die '= NULL zu = 0'-nderungen von oben. :)
- PLNetwork & PLNetworkIRC lassen sich nun auch unter Linux bersetzen



>> 14.04.2007
[CO]
- Base::SetVars() verbessert so das man z.B. auch 'Flags=""' in z.B. einer Szene-Datei schreiben kann ohne eine Fehlermeldung
  zu bekommen das ein abschlieendes '"' fehlen wrde
- Thread::Join() Kommentar etwas erweitert... wie ich gerade in PLPhysicsNewton::WorldThread::~WorldThread() feststellen
  musste ist ein 'join' ohne Timeout mit Vorsicht zu geniesen...



>> 09.04.2007
[CO]
- Nahm weitere 'return' heraus
PLNetwork:
- Nahm weitere 'return' heraus



>> 08.04.2007
[CO]
- Formte einge Codes um so das man weniger 'return' bentigt was die Sache etwas bersichtlicher macht
- ClassManager.cpp: 'NO_GROUP'-Definition entfernt da dies mittlerweile nicht mehr verwendet wird
- ZipSearchHandle::CheckFileInDirectory(): Hier wird nun 'm_pZipDir->m_bCaseSensitive' bercksichtigt
- ZipDirectory: Neue Funktion: IsCaseSensitive() wird von ZipSearchHandle::CheckFileInDirectory() bentigt
- Base::IsVarDefault(): Arbeitet nun Case-Sensitive da PL generell Case-Sensitive ist
PLNetwork:
- Formte einge Codes um so das man weniger 'return' bentigt was die Sache etwas bersichtlicher macht



>> 07.04.2007
[CO]
- Dort wo in der String Klasse 'isdigit()' oder 'isalpha()' verwendet wird, wird zur Sicherheit auf 'unsigned char' gecasted
  da man sonst schnell ein Assert bekommen kann wenn man z.B. '' im String stehen hat. :(



>> 31.03.2007
[CO]
PLNetwork:
- Host::RemoveConnection(): Hm, hier fehlte das austragen der Connection aus der Liste (absicht?)
- OS/Standard-Header werden nun nur noch in den Implementationen eingebunden
- Ein paar Sicherheits-Tests in 'Socket'-Klasse eingebaut
- Globale 'Initialize()'-Funktion entfernt da es etwas unhandlich ist das Manuell aufzurufen. Das luft nun wie bei Image
  ber einen globalen Guard.



>> 29.03.2007
[CO]
PLNetwork:
- Einige einfache Stellen auf unsere String-Klasse umgestellt
- Connection: SendMsg() ist durch unsere String Klasse nun berflssig
- Connection: In Send() gabs wenn ich das richtig sah ein Speicherleck da der Daten-Speicher nicht wieder freigegeben wurde
  - durch die String Klasse natrlich nun kein Thema mehr :)



>> 27.03.2007
[CO]
- Linux Port etwas aufgerumt



>> 25.03.2007
[CO]
- Types.h entfernt. berall wo X, Y, Z, W genutzt wurde durch entsprechende Vektor-Enums ersetzt damit man weiterhin sofort
  erkennen kann welche Komponente verndert wird. R, G, B wurde nur an einer einzigen Stelle verwendet. PL_UNUSED-Makro
  in die OS-Header verschoben.
- NULL-Definition in die OS-Header verschoben



>> 24.03.2007
[CO]
Alle Projekte: Alle CMake Dateien:
- Einige Leerzeichen/Tab nderungen in den CMake Dateien
PLGeneral:
- System: Neue Funktion: GetPlatform(): Diese Funktion gibt im Gegensatz zu GetOS() nur einen bergeordneten Plattform
  Namen wie z.B. 'Win32' fr ein 32 Bit Windows System etc. zurck
- Xml Plugin Format nach Stefans Vorschlgen vom 25.02.2007 gendert. Es gibt nur noch eine Plugin Datei und keine fr
  Release und Debug. In der Datei kann es beliebig viele 'Platform'-Blcke geben, jedoch werden nur die bercksichtigt
  welche mit System::GetPlatform() zusammenpassen. (daher diese neue Funktion :) Innerhalb eines 'Platform'-Blockes kann
  es verschiedene 'Library'-Eintrge geben welche jeweils einen Release oder Debug Type haben knnen. Diese Dateien knnen
  absolute Pfade haben (nicht wirklich immer Sinnvoll *g*) oder relativ zur Plugin-Datei liegen.
  Passte alle Plugin-Dateien entsprechend an. Diese nderungen machen wie Stefan schon sagte die Sache bersichtlicher und
  ganz nebenbei mchtiger da ein Plugin nun z.B. aus mehreren Bibliotheken bestehen kann und diese nicht mehr zwangslufig
  im gleichen Ordner liegen mssen wie die Plugin-Datei selbst. :D
  Dependencies werden in diesen Plugin-Dateien pro Library wie gehabt eingetragen. Das ist jedoch rein optional und soll
  wirklich nur dazu dienen das man immer den berblick behlt was von wem abhngt so das man nicht lange herumsuchen oder
  gar herumprobieren muss.



>> 23.03.2007
[CO]
Alle Projekte: Alle VC-Projekt Dateien:
- Deaktivierte die Linker Option '/INCREMENTAL' (nur genderte Methoden neu bersetzen) da diese in Konflikt mit '/LTCG'
  (gesammte Projekt Optimierung) stand. Damit ist nun folgende Linker Warnung wech:
  "LINK : warning LNK4075: /INCREMENTAL wird aufgrund der Angabe von /LTCG ignoriert."
PLGeneral:
- Im Release Build wird die Bibliothek 'LIBCMT.lib' ignoriert da diese laut Linker Warnung in Konflikt mit einer anderen
  stand.



>> 18.03.2007
[CO]
Da wir mittlerweile sehr viele RTTI Klassen haben und spter gerade bei konkreten Projekten sicherlich nochmal einige
hinzukommen versuchte ich die vom RTTI verbrauchten Resourcen 'etwas' in den Griff zu bekommen OHNE das System komplett
umzubauen. Also minimalste nderungen mit grt mglicher Verbesserung damit das nicht mehr ganz so zh luft was mich
ehrlich gesagt mittlerweile etwas strt.
Auf die Hash Map Optimierung vom 14.03.2007 kam ich erst als ich mir mal angeschaut hatte warum bereits einfachste
Programme vergleichsmig viel Speicher verbrauchten und beim starten auch viel zu lange brauchten. Es stellte sich heraus
das die Enum Dinge in der Vars Klasse sehr viel Overhead erzeugten. Es wurde gerade fr die Enum Hash Map viel zu viel
Speicher verschwendet obwohl diese bei nicht Enum Variablen absolut nie bentigt wurde. Ich berlegte mir dort ob man
die Hash Map da nicht gleich ganz rausnehmen sollte, lies das aber erstmal da es nun nicht mehr so heftig ist und ich meine
nderungen an diesen Komponenten so klein wie mglich halten will.
Eine andere Sache ist die, das wir zwar viele RTTI Klassen haben, aber ebenfalls viele in den meisten Anwendungen berhaupt
nicht nutzen. Daran DAS RTTI Klassen da sind, da kann man nix ndern auer nicht bentigte Plugins zu deaktiveren. Aber ber
das bewrte 'Lazy Evaluation'-Muster das schon so gut im Scene Graph klappt konnte man das ohne zu groe Eingriffe Resourcen
schonender machen:
- Class: In 'Init()' werden die Variablen der Basis Klasse NICHT mehr zu der aktuellen Klasse hinzugefgt da dies einfach
  nur unntig ist. Stattdessen gehen die Funktionen 'GetVarList()' und 'GetVar()' einfach bei Bedarf Rekursiv zu der Basis-
  Klasse weiter - Funktionsmig also keine nderung, aber Resourcen schonender und auch bersichtlicher.
- Class::AddVar(): "Overwrite an already existing variable?"-Teil entfernt da dies nun durch die nderung von oben
  berflssig ist
- Die Klassen Variablen werden nun nach dem 'Lazy Evaluation'-Schema Initialisiert, sprich, erst wirklich dann wenn diese
  zum ersten mal wirklich bentigt werden... was fters NIE der Fall ist und dann mssen die Variablen auch NIE Initialisiert
  werden :D
-> Der Windows Task Manager zeigte mir bei 'PLSampleInitExit' vor dieser nderung einen Speicherverbraucht von '31.368 K'
   an, danach '29.980 K' + es startet minimal flotter. (hab derzeit bei mir alle nicht umbedingt bentigten Plugins whrend
   der Entwicklung deaktiviert, sonst wren das nochmal ca. 10 MB mehr Speicher)



>> 16.03.2007
[CO]
Alle Projekte: Einige Inkonsistensen behoben:
- In Headern wurde beim Einbinden von '*.inl' im Block einmal 'Implementation' oder 'Inline includes' geschrieben. nderte
  das berall in 'Implementation' da dies hufiger verwendet wurde... so braucht man nur nach '//[ Implementation' zu
  suchen um all diese Stellen angezeigt zu bekommen.
- 'filename' wurde nicht berall gleich geschrieben, einmal 'FileName', oder 'file name'. Da 'filename' bei uns am meisten
  verwendet wird und das u.a. so auch auf Wikipedia geschrieben wird und mein bersetzungs-Tool das so ebenfalls kannte
  machte ich das einheitlich da es mich nun schon ein paar mal verunsicherte wie man das schreiben soll - zudem ist das
  irgendwie doof wenn das innerhalb eines Projektes immer mal wieder anderst geschrieben wird, auch wenn beide schreibweisen
  'richtig' sind... so muss man nicht pro Funktion schaun wie es jeweils geschrieben wird. *g*
- Entfernte den Begriff 'dll' bei z.B. dem 'Import/Export'-Block oder Header Titeln damit das verallgemeinert und nicht
  Begrifflich Windows bezogen ist.
- Bei einigen Klassen sind die Methoden in einzelne 'Blcke' unterteilt, versuchte den Block Titel soweit einheitlich einzurcken



>> 14.03.2007
[CO]
- HashMap Speicher Optimierung: Die internen Slots werden NICHT mehr sofort angelegt, sondern erst dann wenn das erste Element
  eingefgt wird... denn es kann durchaus vorkommen das eine HashMap warum auch immer mal berhaupt nicht genutzt wird, und in
  dem Fall braucht diese intern keinen weiteren Speicher anzulegen. :)
  Der Windows Task Manager zeigte mir bei 'PLSampleInitExit' vor dieser nderung einen Speicherverbraucht von '35.596 K' an,
  danach '31.368 K'.



>> 12.03.2007
[CO]
Alle Projekte: PLBase:
- Mit den Header nderungen bin ich in PLBase nun erstmal soweit durch - mittlerweile wird von TortoiseSVN fast alles rot
  Dargestellt da gendert. Also nicht ber die Masse an genderten Dateien wundern, das zieht sich wirklich durch alle Projekte
  durch. Ich finde das nun wirklich um 'einiges' besser als vorher - auch wenn es noch Details zu verbessern gibt.



>> 10.03.2007
[CO]
- Container + Implementationen: Add() & Remove() & Copy() & Compare(): 'nCount' ist nun uint32, wenn 0, so wird alles hinter
  Start kopiert. <0 war sehr ungeschickt und auch teils fehlerhaft Implementiert - zudem machte das wenig Sinn, wenn jemand
  nix machen will, so hat er erst gar nicht diese Funktionen aufzurufen! :)
- Machte die besprochenen Header nderungen die auch in PLNetwork schon so gut klappten. In PL Headern sollten unter keinen
  umstnden mehr direkt oder indirekt z.B. Standard-Header reinkommen, also u.a. kein direktes 'memcpy' mehr in Headern/Inline
  Implementationen. Da ich die Codes nochmal komplett durch schauen musste, nderte ich dabei gleich Dinge die wir mittlerweile
  anderst schreiben. (u.a. 'strukturierter') Wo mglich reduzierte ich die Abhngigkeiten von z.B. Headern durch Predefinitions
  oder verschieben von Inline in cpp noch weiter. Auch machte ich die besprochenen nderungen bei der Verwendung von Namespaces,
  also berall 'using namespace' in cpp sobald etwas einmal bentigt wird.
- Kleine 'Wrapper'-Klasse im Tools-Ordner hinzugefgt fr Dinge wie z.B. 'memset' die wir in Headern oder Inline-Implementationen
  nutzen. (was nur sehr selten der Fall ist!)



>> 09.03.2007
[CO]
Neues Projekt: PLNetwork:
Stefan schickte mir gestern per E-Mail PLNetwork das er vor 3 Jahren oder so schon mal geschrieben und immer mal wieder kurz
aktualisiert hatte. Wie besprochen Integrierte ich dieses Projekt in PixelLight. Machte auch ein paar erste kleine nderungen
die Funktionsmig aben nix ndern sollten: (solche nderungen sind ganz nebenbei optimal zum in etwas einarbeiten *g*)
- Host: Ersetzte die stl vector Klasse durch unsere List Klasse
- Socket::Close(): Hier stimmte glaube ich etwas nicht ganz, da z.B. gleich bei 'closesocket' die Funktion verlassen wurde, und
  etwas weiter unten dann (nicht wirklich *g*) die Variablen zurckgesetzt wurden
- nderte ein paar Variablen wie z.B. 'Port' in uint32 damit man gleich von vorne an keine negativen Werte bekommen kann
- Passte hier und da minimal den Code Style an die anderen Projekte an
- Machte hier gleich die nderungen die wir fr alle Projekte machen wollen, also nur 'using namespace...' in cpp, ein Header
  hat selbst wirklich ALLES zu definieren/includieren was er selbst braucht - inklusive des Lib-Headers der eigenen Lib



>> 02.03.2007
[CO]
- FileSystem::SetBaseDirPriority() & LoadableType::SetSearchPathPriority() Implementiert
- Loader::OpenFile(): Da das File System bei absoluten Dateinamen nicht erst lange herumsuchen muss, versucht das Loadable System
  erstmal den wahrscheinlichsten absoluten Pfade zu nutzen - das klappt meistens und die Ladezeiten werden dadurch sprbar krzer!
  Gerade in groen Szenen wie z.B. der aktuellen vom Dungeon Demo ist das Laden nun um einiges annehmbarer - zwar natrlich noch
  nicht Optimal (Memory Mapped Files mssten hier nochmals einiges bringen) aber zumindestens nicht mehr tzend. *g*



>> 02.03.2007
[SB]
- Da es keine Header geben sollte, die nur dann fehlerfrei benutzt werden knnen wenn vorher noch andere Header eingebunden werden
  (also Abhngigkeiten des Headers nicht im Header selbt eingebunden werden), habe ich PLGeneralWin32Header.h berall dort, wo
  Win32-Datentypen in einer Klasse direkt verwendet werden, auch direkt in dem entsprechenden Header eingebunden. Zustzliche
  Abhngigkeiten werden dadurch nicht erzeugt, da diese System-Header sowieso nur in den eigenen .cpp Dateien eingebunden werden
  und in der Factory-Funktion, die das bentigte System-Objekt erzeugt. An beiden Stellen muten vorher also auch die System-Header
  eingebunden werden, um die Header-Datei berhaupt verwenden zu knnen, was wie gesagt niemals passieren sollte.   
- PLGeneralOSHeaders.h entfernt. Dieser Header wurde nur ein einziges Mal eingebunden, und sollte auch in Zukunft nur sehr selten
  gebraucht werden, da man meist gleich entweder eine Win32- oder Linux-spezifische Datei hat. Dieser Header ist daher unntig,
  und kann in diesen seltenen Fllen durch eine direkte Fallunterscheidung ersetzt werden



>> 28.02.2007
[CO]
- FileSystem::Mount(): Unterscheidet nun zwischen gro/kleinschreibung wie es berall in PL der Fall ist
- ZipDirectory::GetName(): Gab etwas anderes zurck als ich erwartet htte und als es die Dokumentation zu FileObject::GetName()
  beschrieb. Daher nderte ich es so das es passt und fgte eine neue Funktion 'GetNameWithinZipFile()' hinzu welche den Namen
  innerhalb der Zip-Datei zurckgibt.



>> 26.02.2007
[CO]
Alle Projekte:
- Ging die Namensgebung der Funktionen nochmal durch welche im Grunde nur 'ja' oder 'nein' zurckgeben. GetEnabled, GetActive etc.
  zu IsEnabled, IsActive etc. Da wir momentan noch PLBool drinnen haben musste ich nur nach bool Suchen ("bool Get") lassen. :)
  Ein paar Funktions-Namen lies ich jedoch, an Stellen wo 'Is' irgendwie noch unpassender als 'Get' ist und ein 'Has' auch irgendwie
  fehl am Platz ist - da msste man eventuell nochmal schaun ob die Funktionnamen an sich berhaupt Sinnvoll sind.
  (wenn man mal gerade nix besseres zu tun hat *g*)



>> 25.02.2007
[SB]
- Neue Klassen-Templates fr Funktions-Objekte hinzugefgt. Das sind recht praktische Zeitgenossen, mit denen Zeiger auf Funktionen
  als Objekte gespeichert werden knnen. Diese Objekte knnen dann genauso aufgerufen werden wie Funktionen. Im Gegensatz zu
  Funktions-Pointern knnen diese Objekte aber nicht nur Zeiger auf statische Funktionen sein, sondern auch Zeiger
  auf Member-Funktionen von Klassen, die zusammen mit einem Zeiger auf ein Objekt dieser Klasse gespeichert werden.
  Bitte beachten: FunctionTmpl.inl funktioniert etwas anders als unsere blichen .inl Funktionen, daher auch der etwas andere Name,
  da es sich eben nicht nur um die Inline-Implementation von Function.h handelt. Das #ifdef in dieser Datei wurde NICHT vergessen
  sondern ist GEWOLLT weggelassen worden, da die Makros ansonsten nicht mehr richtig funktionieren wrden! :-)   



>> 24.02.2007
[SB]
Alle Projekte:
- Alle Projekte so angepat, da sich wieder alles mit VC7 bersetzen lt.
- Alle CMake Projektdateien angepat: Es wird jetzt ein anderes Kommando fr die Postbuild-Kommandos verwendet, da es bei der
  alten Variante u.U. zu Problemen mit den Abhngigkeiten und der Reihenfolge der Projekte kommen konnte. Auch wird so der
  Postbuild-Vorgang nicht mehr als eigenes Target angezeigt.  
PLGeneral:
- Undef einiger weiterer Definitionen aus den Window-Headern in PLGeneralWin32Includes.h hinzugefgt, die bentigt wurden da es
  sonst Namenskonflikte mit eigenen Methoden aus SystemImpl gibt.



>> 23.02.2007
[SB]
Alle Projekte:
- Alle Projekte so angepat, da sich alles auch wieder unter Linux bersetzen lt



>> 23.02.2007
[CO]
Alle Projekte:
- Da ich gerade vom Compiler in den PL Beispielen mal wieder gesagt bekommen hatte das es einen Namespace Konflikt gibt und
  nicht entschieden werden kann ob 'Rectangle' denn nun ein "Win32 Rectangle" oder ein 'PLMath::Rectangle' sei hatte ich einfach
  absolut KEINE Lust mehr auf dieses total bescheuerte herumgehacke mit den Namespaces etc. nur weil irgendwo ein OS Header
  reinkommt den man eigentlich berhaupt nicht braucht und dort halt Dinge definiert sind die man ebenfalls nicht braucht sondern
  wirklich nichts als rger machen. Daher baute ich das endlich mal so um das OS Header NUR noch dann reinkommen wenn man diese
  WIRKLICH braucht, also in den konkreten OS Implementationen. berall sonst darf von nun an absolut NICHTS OS Abhngiges mehr
  reinkommen - und falls das doch mal 'ntig' sein sollte luft etwas falsch, denn es MUSS ohne gehen.
  Bei den erstaunlicherweise sehr kleinen nderungen damit das ohne stndige OS Header klappt gab es ebenfalls erstaunlicherweise
  praktisch keine Probleme da wir im laufe der Jahre bereits alles 'virtualisiert' hatten. :)
  Beim bersetzen unter Windows klappt das nun so ganz wunderbar, und man hat endlich in Projekten welche rein auf PL aufbauen
  praktisch (also bis auf das InputSystem, durch das leider noch derzeit OS Header reinkommen) keine Namespace Probleme mehr mit
  OS-Dingen. *freu*
  An ein paar Stellen bei denen Windows-Header genutzt werden, musste ich ein paar unschicke 'undefs' wie z.B. #undef MessageBox
  einfgen, (gerade in PLGeneralWin32Includes.h ist das krass) ansonnsten bekam ich einmal Compiler Fehler da wir Funktionen haben
  die genauso heien, und beim anderen mal Linker Fehler das etwas nicht gefunden wurde was wir gar nicht nutzen. Diese define
  Dinge der OS Header sind wirklich belst und ich bin total froh das wir diese nun nur noch an 'sehr' wenig Stellen einbinden
  mssen.
  Bei den Linux Headern hab ich gekennzeichnet was umbedingt raus sollte.
PLGeneralLinux.h & PLGeneralWin32.h:
- Nahm THREAD_HANDLE heraus da es nirgends mehr verwendet wird
- NativeDirectory liegt nun direkt in FileSystem.cpp, der Benuter sollte davon nix sehen
- RTTI: Wie kurz besprochen PL_VAR_STRING & PL_VAR_FILENAME welche mit klassischen C-Strings arbeiteten entfernt und dafr
  PL_VAR_PLSTRING & PL_VAR_PLFILENAME in PL_VAR_STRING & PL_VAR_FILENAME umbenannt. Alle Projekte daran angepasst.



>> 22.02.2007
[CO]
- ModuleID<T>::SetModuleName() & ModuleID<T>::SetModuleVendor() & ModuleID<T>::SetModuleDescription():
  Tests auf Buffer berlauf eingebaut + statt strncpy wird nun memcpy genutzt damit einen VC 2005 nicht mit Warnungen
  in allen Projekten zumllt.
- An Stellen wie z.B. SystemWin32::GetEnvironmentVariable() wird nun neben 'Unicode' auch 'UTF8' geprft, ist es ein UTF8 String
  mssen die Daten als Unicode zurckgegeben werden damit kein Informationsverlust stattfinden kann... da Windows nur wchar_t
  und kein direktes UTF8 kann muss leider immer Konvertiert werden, aber da kann man nix dran ndern. (hnliche Thematik dann
  unter Linux, nur umgekehrt *g*)
- Win32File::Rename() auf unsere String Klasse umgestellt. Mssen wir bei Erfolgt ebenfalls auch den neuen Dateinamen speichern?



>> 21.02.2007
[CO]
Alle Projekte:
- Machte wie besprochen die Umstellungen auf die 'sicheren angeblichen Standard-Funktionen' vom 11.02.2007 wieder rckgngig,
  denn wie sich herausstellte sind diese leider nicht wirklich Standard - auf jedenfall wird das derzeit nicht von sonderlich
  vielen Compilern untersttzt und daher ist das leider unbrauchbar fr uns. :(
  Schaute mir dabei gleich alle Stellen wo diese C-String Funktionen genutzt werden genau an damit es keine Buffer berlufe
  geben kann. berall auerhalb der String Klasse stellte ich soweit irgend mglich/sinnig die letzten Stellen die ich finden
  konnte auf unsere String Klasse um damit man sich gar nicht erst mehr mit den C-String Funktionen herumrgern muss. In den
  Projekten in denen VC 2005 trotzdem noch meckert das etwas 'potentiell unsicher' sein deakvierte ich diese Warnungen einfach,
  wir wissen (meistens :) schon ganz genau was wir tun und mssen uns da nicht von einem Compiler zujammern lassen. *g*
  -> *bin heute noch nicht ganz mit diesen Arbeiten fertig geworden*
PLGeneral:
- FSTools::ValidatePath(): Gleiche nderung wie gestern in Win32FSTools::ConvertToWindowsPath()
- ZipDirectory::GetComment(): So gendert das kein 'strcpy' mehr verwendet wird, zudem bernimmt die String Klasse direkt den
  Buffer (habs getestet, funkt noch korrekt :)
- Ein paar Kommentare von ZipDirectory & ZipStream korrigiert oder genauer gemacht
- ZipIterator::GetCurrentFileInfo(): Die String Klasse bernimmt den Buffer mit dem Dateinamen und Kommentar direkt
- Fgte in diesem VC 2005 Projekt bei den Compiler Optionen "/D "_CRT_SECURE_NO_DEPRECATE"" ein damit keine unntigen
  Warnungen kommen
- Formte in der String Klasse ein paar Ausdrcke um so das es etwas besser Strukturiert rberkommt



>> 20.02.2007
[CO]
Alle Projekte: Machte wie besprochen den ersten Schritt bei den Plugin-nderungen:
- ClassManager::ScanPlugins(): Sucht wie vorher auch nach Plugins, kann dies jedoch nun auch Rekursiv machen
- ClassManager::LoadPlugin(): Prft ob es wirklich eine '.plugin'-Datei ist, lies die Meta-Informationen aus und prft dabei
  gleich den 'Typ' auf gltigkeit/bereinstimmung oder ob ein Plugin aktiviert/deaktiviert ist. Danach wird der Name der
  Dynamischen Bibliothek ermittelt - derzeit wird der Plugin Name genommen und entsprechend gendert so das Plugin und
  Dynamischen Bibliothek also erstmal im gleichen Verzeichniss liegen mssen. Anschlieent wird wie gehabt (also 1 zu 1
  bernommen :) die Dynamischen Bibliothek eingeladen.
- Verschob die Plugins der verschiedenen Projekte sammt bentigter externer dlls in einen Plugin-Unterordner + dort wo sinnig
  in weitere Unterordner + schrieb entsprechende '.plugin' Dateien in denen ebenfalls vermerkt ist welche dll's diese bentigen,
  was ich recht hilfreich finde. Hier mssen wir uns allerdings noch berlegen ob wir das drinnen lassen da z.B. unter Linux die
  Dateiendung natrlich anderst ist + auch teils die Namen der bentigten Dynamischen Bibliothek, oder ob wir fr jedes OS
  Seperate Dateien machen oder ob das innerhalb der Plugin-Dateien nach OS unterteilt ist.
- DynLibManager::LoadLibrary() & DynLib::Load(): Damit man Plugins + abhngige Dynamischen Bibliothek problemlos auch in
  Unterordnern halten kann was durchaus Sinnig ist nderte ich das Verhalten dieser Funktionen minimal. Die Windows Funktion
  lsst netterweise zu das die anderen ntigen dll's zuerst im gleichen Verzeichniss wie die eingeladene dll zu suchen sind.
  Wenn es unter Linux soetwas nicht gibt muss man es so lsen wie ich es zuerst unter Windows machen wollte: Einfach das
  aktuelle Verzeichniss kurzzeitig entsprechend ndern. Dynamischen Bibliotheken sind also zuallererst im 'kleinsmglichen Scope'
  zu suchen. *g*
- Passte die Post-Build Operationen aller VC & CMake Projekt entsprechend das herum kopieren)
PLGeneral:
- BufferedStringReader auf unsere String Klasse umgestellt. Diese Implementation ist sogar schlanker und bersichtlicher bei
  gleicher Effektivitt. :)
- Win32FSTools::ConvertToWindowsPath(): Das 'gromachen' des Laufwerksbuchstaben 'Unicode sicher' gemacht
- ClassManager::GetVarType(const String &sType) Case-Sensitive gemacht da PL generell Case-Sensitive ist
  (da diese Funktion bis jetzt nirgends genutzt wird, musste man auch nichts prfen ob das korrekt verwendet wird :)
- Hack: Class::Init() Registriert sich in LoadableManager damit dieser von neuen Loadern Wind bekommen kann. Das war leider
  ntig da ansonnsten u.a. in "PhysicsPlayground.scene" Sichtbar Dinge nicht korrekt Funktionierten. (was mich schon geraume
  Zeit strte, da die Ragdolls dort wirklich extrem cool rberkommen *g*) In dem Falle bekam man die Meldung das die Ragdolls
  nicht eingeladen werden konnten da 'Radgoll' nichts sei was eingeladen werden knnte. Bei Config ist es im Prinzip genauso,
  aber da man da zum Glck derzeit nix von merkt war auch kein Hack dafr ntig. :)
  Klassen melden sich bei LoadableManager nicht ab, da dies derzeit nicht absolut ntig ist - ich wollte einfach die Hacks
  so gering halten wie mglich und fgte auch ausreichene Dokumentation dazu damit man spter noch weis warum das drinnen ist.
- Loadable::Save(File *pFile, const Parameters *pParams) prft ob die bergebene Datei beschreibbar ist
- SearchFilter::CheckMatch() auf unsere String Klasse umgestellt. Ich brauchte einige Zeit um in etwa nachvollziehen zu knnen
  was hier passiert. Ich hoffe das ich das Funktionsmig soweit verstanden und korrekt ber unsere String Klasse realisiert
  habe so es Funktionsmig keinen Unterschied gibt.
  Stefan, wre super wenn du das auch nochmal genau Durchdenken knntest ob ich da nicht doch nun eine Funktions nderung
  drinnen habe... das war das komplizierteste was ich bis jetzt auf unsere String Klasse umgestellt habe und da kann schonmal
  was daneben gegangen sein. *bibber*
  (zumindestens einfache Dinge wie '*.pak' scheinen noch korrekt zu funktionieren, und das in '*' war der heftigste Teil :)



>> 16.02.2007
[CO]
- 'ConsoleLogFormater' hinzugefgt - stand schon so lange auf dem Plan obwohl so wenig Arbeit *g*
- ClassManager::ScanPlugins(): Musste hier leider einen Hack einfgen: "msvcr80.dll" und "msvcr80d.dll" sollte man nie per
  Hand einladen da ansonnsten eine dll Namens 'COREDLL.dll' verlangt wird (scheinbar WindowsC E) wovon ich nur eine nicht
  wirklich brauchbare Version im Netz nach langem suchen finden konnte. Hm, mit den Plugins mssen wir uns wirklich mal was
  berlegen, denn irgendwie hufen sich hnliche Probleme wenn man alle dlls einld und nach PL brachbaren Zeug durchforstet. :(



>> 12.02.2007
[CO]
- String: Neue Funktionen: IsValidInteger(), IsValidFloat(): Prfen ob im String eine gltige Integer oder Float Zahl ist,
  solche Tests werden u.a. fr die EditBox in PLGui bentigt.



>> 11.02.2007
[CO]
Alle Projekte: Auf VC 2005 'umgestellt':
- Als ich zum ersten mal etwas unter VC 2005 bersetze bekam ich natrlich viele 'Depriciated Fehlermeldungen' wie z.B.:
    c:\programme\microsoft visual studio 8\vc\include\string.h(73): Siehe Deklaration von 'strcpy'
        Meldung: "This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use
        _CRT_SECURE_NO_DEPRECATE. See online help for details."
  Zum Glck nutzen wir mittlerweile 'fast' berall (und wo das noch nicht der Fall ist und sinnig ist, wird das bald der
  Fall sein :) unsere eigene String Klasse so das sich dieses 'Warnungen' auf eine (groe) Handvoll Stellen beschrnkten.
  Da die 'Sicherheits'-Warnungen + die neuen zustzlichen Warnungen durchaus Sinnvoll sind stellte ich u.a. auf 'sichere'
  Funktionen um dennen man die Buffer gre bergeben muss damit sich Buffer berlufe vermeiden lassen. (ich denke da spricht
  absolut nix dagegen :) Es gibt noch aufwndigere Stellen wo man umstellen msste oder wo wir sowieso bald unsere eigene
  String Klasse nutzen, das mache ich als zweiten Schritt - wrde man das auf einmal machen knnten sich schneller Umstell-Bugs
  einschleichen... ich hoffe da sind bis jetzt keine reingekommen, denn bei dem +1 fr mit/ohne \0 muss man immer verdammt
  aufpassen und sich genau Informieren wie die verschiedenen Funktionen das bergeben haben wollen. (bitte die nderungen
  nochmal kurz berfliegen :)
- An Stellen wie z.B.
  .\src\Base\StringBufferASCII.cpp(285) : warning C4996: 'stricmp' wurde als veraltet deklariert
    C:\Programme\Microsoft Visual Studio 8\VC\include\string.h(213): Siehe Deklaration von 'stricmp'
    Meldung: "The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _stricmp. See online help for details."
  passte ich entsprechend an. ('Standardkonform' ist immer gut :) In 'PLGeneralLinux.h' kann man nun sicherlich einige 'stricmp' etc. entfernen.
- TinyXML: Mit VC 2005 neu bersetzt damit der Linker nicht meckert



>> 10.02.2007
[CO]
- SystemWin32::GetOS(): Erweitert damit auch Windows Vista + Service Packs erkannt werden



>> 01.02.2007
[SB]
Alle Projekte:
- CMake build system ist komplett, alle Projekte lassen sich sowohl fr Windows als auch fr Linux bersetzen
- Kleine Zusammenfassung, welche Probleme es mit CMake gab:
  - PROJECT_OUTPUT konnte nicht auf ein anderes als das Grundverzeichnis gesetzt werden (sollte eigentlich "bin" sein), da CMake
    ansonsten beim linux-build die Abhngigkeiten nicht mehr findet und sofort abbricht. Die Ausgabedateien werden also im
    Grundverzeichnis des Projektes erstellt, was aber nicht weiter schlimm ist, da es sich ja immer um max. 2 Dateien handelt
    und sich dort ansonsten nur die Projektdateien befinden.
  - Beim linux-build werden statische Bibliotheken, die eine Abhngigkeit von einer dynamischen Bibliothek darstellen, nicht nur
    zu dieser Bibliothek gelinkt sondern auch zu allen davon abhngigen Projekten (eine Erklrung hierfr findet sich in der CMake FAQ).
    Da die Pfade zu diesen Bibliotheken aber in den abhngigen Projekten nicht bekannt sind, werden diese nicht gefunden und das
    bersetzen bricht ab. Um das zu vermeiden mssen die externen Bibliotheken immer mit absolutem Pfad angegeben werden, anstatt
  LINK_DIRECTORIES zu benutzen.
- Altes Linux-Buildsystem ausgebaut



>> 28.01.2007
[CO]
Alle Projekte:
- VC Projekt-Dateien wie besprochen in die jeweiligen Grundordner verschoben



>> 27.01.2007
[SB]
Alle Projekte:
- Neues Build-System fr Linux auf Basis von CMake eingebaut. Die Projektdateien knnen dafr benutzt werden,
  sowohl die Linux-Version zu erstellen als auch mittels Cross-Compiling mit VC7 die Windows-Version.
- PLBase Projektdateien sind komplett, jedoch lassen sich zur Zeit noch nicht alle Projekte auch fr Linux bersetzen.
  Das Cross-Compiling fr Windows funktioniert aber schon perfekt :-)



>> 26.01.2007
[CO]
Kleinere Aufrumarbeiten in PLGeneral:
- "Friend declarations" in "Friends" gendert
- z.B. "Public interface" in "Public functions" gendert
- Namespace Style vereinheitlicht
- Ein paar Leerzeichen/Tabs korrigiert
- In ein paar Konstruktoren wurden nicht alle Variablen Initialisiert + an ein paar Stellen wurde noch nicht die
  Initialisierungs-Liste genutzt
- Ein paar const eingefgt
- In ein paar Headern wo mglich Includes durch Predefinitions ersetzt
- Fgte in einigen cpp-Dateien 'Blcke' hinzu damit man sofort sehen kann welche Funktionen public, private etc. sind
- Ein paar Kommentare korrigiert/vervollstndigt (u.a. "@remarks:" zu "@note" gemacht, oder "@remarks" zu "@note")
- An ein paar Stellen Codes etwas vereinfacht/verschnert, z.B. "for (;;)" in "do/while" gendert oder 'tote' Codes entfernt
  oder ein [TODO] davor gesetzt wenn nicht eindeutig klar war das es nicht mehr bentigt wird
... An der Funktionalitt sollte sich nichts gendert haben. Stellen wo man etwas Funktionell ndern/prfen
    muss hab ich mir erstmal nur notiert um diese in einem zweiten Schritt abzuarbeiten. (damit nix durcheinander kommt :)
    Gerade einige Umbenennungen waren mir sehr wichtig da diese das durchsuchen aller Projekte nach bestimmten Begriffen
    sehr erleichtern.
- BufferedStringReader::GetString(): Hier kann der String Buffer direkt bernommen werden. Bringt jedoch nur 'im Augenblick'
  etwas, denn BufferedStringReader msste man komplett auf die String Klasse umstellen ohne 'char *' zu nutzen *Unicode Sicher*
- CmdLineParser Code Style angepasst und 'printf' fr Debugging rausgenommen, soetwas sollte nie im Code bleiben und auch nie
  ntig sein... man braucht hier *wirklich* einen brauchbaren Debugger damit man keine printf-Krcken nutzen muss die den Code
  durcheinander werfen. Ich fand auch ein paar Stellen wo man die Implementation etwas vereinfachen konnte + Variablen die nix
  machten entfernen konnte. An der Funktionalitt hab ich nichts gendert.
- Bugfix: SearchFilter::SearchFilter(): "m_sFilter.ToLower()" entfernt da PL generell case sensitive ist
- Tokenizer: 'm_sSingleChars' Default Einstellung ist nun eindeutig wie gehabt "{}()[]<*>/=,;\"", in den Codes war auch noch
  "{}()[]<>+-*/=,;\"" auskommentiert drinnen und in der Klassen Dokumentation stand "{}()[]=,;\"" als Default. + und - machen
  im Zusammenspiel mit Zahlen welche ein Vorzeichen haben schwere Probleme, darum sollten diese Zeichen als Default keine
  einzelnen Zeichen sein.



>> 18.01.2007
[CO]
- Bugfix: FSTools::ValidatePath(): ".." und "." wurden nicht korrekt aufgelst da FSTools::GetFirstPath() ebenfalls '\' am
  Ende stehen hat. (war frher mal anderst) Dies viel vorallem im Datei-Dialog auf. :)



>> 16.01.2007
[CO]
- Timer: SetTimeScaleFactor(), SetSlowMotionFactor() und SetCustomSlowMotionFactor(): Der bergebene Faktor MUSS grer als
  0 sein, ist das nicht der Fall, liefern diese Funktionen nun einen Fehler zurck. Ein Faktor von 0 oder gar ein negativer
  Faktor macht an verschiedenen Stellen nur probleme und logisch berhaupt seinen Sinn. 0 ist das gleiche wie Pause, also
  kann man gleich 'richtig' Pausieren wenn man das will, und negative Faktoren, hm, dann msste ja automatisch alles
  rckwrts laufen... grrr... *g*



>> 23.12.2006
[CO]
- ChecksumCRC32 Checksum Implementation hinzugefgt
- ChecksumSHA1 Checksum Implementation hinzugefgt. Damit haben wir nun 3 Checksum Implementation (aller guten Dinge sind
  3... 3 Gui-Implementationen, 3 Renderer-Implementationen, 3 Sound-Implementationen... *g*)



>> 17.12.2006
[CO]
Alle Projekte:
- Bei den 'GetLoadableTypeName()'-Implementationen wird nun nicht mehr ein C-String zurckgeben, sondern diese Funktionen
  halten ihren Rckgabe-String in einem statischen PL String der zurckgeben wird. Auf die weise muss nicht jedesmal
  der *wirklich* statische String in einen PL String umgewandelt werden nur um kurz darauf wieder zerstrt zu werden.
  Statt z.B.
    String SceneContainer::GetLoadableTypeName() const
    {
      return "Scene";
    }
  wird nun
    String SceneContainer::GetLoadableTypeName() const
    {
      static String sString = "Scene"
      return sString;
    }
  geschrieben. Von auen merkt man also nix, und intern isses eine geschicktere Implementation. Das mag zwar die Performance
  nicht um das tausendfache steigern, aber wenn man soetwas machen kann ohne das es alles total durcheinander bringt sollte
  man das machen. An hnlichen Stellen sollten wir das immer genauso machen, bin daher mal die Codes durchgegangen und nderte
  es dort wo es sinnig ist. Wird nur "" zurckgeben, knnen wir das wie gehabt lassen da hier sowieso nix herum kopiert wird,
  oder wo der mehraufwand das berhaupt nicht rechtfertigt und es dadurch nur unbersichtlich wird sollten wir das ebenfalls
  wie gehabt lassen... z.B. bei pButton->SetText("Blah!").



>> 16.12.2006
[CO]
- Loadable: m_sAbsFilename muss leider protected sein da PLMesh::Texture und PLMesh::Material *sehr* spezielle Lade Funktionen
  komplett selbst Implementieren und entsprechend m_sAbsFilename in Eigenverantwortung setzen mssen.
- Loadable::Reload() darf der Lade-Funktion natrlich keine direkte Referenz auf 'm_sAbsFilename' bergeben da dieser String
  innerhalb der Lade-Funktion durch die Unload()-Funktion zurckgesetzt wird und dann natrlich nicht bekannt ist was denn
  nun geladen werden soll. :)



>> 13.12.2006
[CO]
Alle Projekte:
- Schaute mir alle Stellen in den Codes an in denen 'using namespace' verwendet wird: Nahm untige 'using namespace'
  heraus, entfernte z.B. 'PLGeneral' vor 'PLGeneral::uint32' wenn gerade PLGeneral als Namespace verwendet wird, fand und
  entfernte dabei einige mittlerweile unntigen Header-Includes.



>> 03.12.2006
[CO]
- Ich schaute mir nochmal kurz die verschiedenen Implementation von Container::Remove() (+ berall wo GetIndex() verwendet wird)
  an und merkte das diese bei weitem nicht Optimal war... denn da wurde ein int Wert von 'GetIndex()' ner Funktion bergeben die
  ein uint32 erwartete und konnte ein Element nicht gefunden werden wurde -1 in uint32 umgewandelt... ging zwar meistens gut
  da wir nie Container mit SO vielen Elementen haben, war aber natrlich nicht korrekt. Bei der Gelegenheit erweiterte ich die
  Container-Kommentare auch noch minimal so das mglichst keine Fragen offen bleiben.



>> 02.12.2006
[CO]
- Der Loadable-Manager ist nun ebenfalls ein Loadable und kann sich somit selbst Laden und Speichern. File System Basis
  Pfade werden momentan ebenfalls speichern, wenn das unntig/ungeschickt sein sollte, knnen wir uns berlegen wie wir
  das am besten anderst lsen.
- Loadable um Reload()-Funktion erweitert, das ist zwar praktisch 'nur' ein pLoadable->Load(pLoadable->GetAbsFilename()),
  passt aber wunderbar rein und wird auch mehrmals genutzt. PLMesh::Material und PLMesh::Effect erweitern diese Reload()
  Funktion indem nach dem Neuladen zustzlich noch die verwendeten Texturen neu geladen werden.
- Bugfix: BufferedFileReader: Beim beenden wurde Release() von File aufgerufen, aber beim Datei Zeiger speichern wurde
  keine Referenz hinzugefgt und so wurde in sehr unglcklichen Situationen die Datei einfach gekillt obwohl diese noch
  Referenziert und auch verwendet wurde. Fgte nur ein 'm_pFile->AddReference();' ein anstatt auf Smart Pointer umzustellen.



>> 01.12.2006
[CO]
Alle Projekte:
- Auf Anregung von Stephan nderte ich berall
    XmlDocument *pDocument = new XmlDocument();
  in
    XmlDocument cDocument;
  wodurch auch kein delete mehr ntig ist.
PLGeneral:
- Stack und Queue Kommentare minimal erweitert: Sucht man nun in PixelLight.chm z.B. nach 'FILO' wird man recht schnell
  das Stack Template finden. :)
- 'Timer' Klasse in 'Timing' umbenannt. Dieser Name ist passender - und ganz nebenbei kann's auch keinen Namenskonflikt mehr
  mit der neuen Timer Klasse in PLGui geben.
- Code im Destruktor von XmlNode entfernt da genau das gleiche in dessen Basis-Klasse XmlBase passiert (kein Fehler, nur unntig)
- Fgte bei den Xml-Klassen in denen es noch 'keinen' Destruktor gab einen leeren ein (wir hatten uns vor einiger Zeit geeinigt
  das wir das so machen wollen, also immer Destruktoren reinschreiben)



>> 30.11.2006
[CO]
- ClassManager::GetVarType(): PL_VAR_PLSTRING fehlte hier, merkwrdig das dies bis jetzt noch nicht aufgefallen war :D
- XmlDocument::LoadFile() setzt nun ebenfalls den Dokument Wert auf den Dateinamen aus dem dieses Dokument geladen wurde
- Verschob FSTools::GetRelativePath() in den Loadable-Manager. Dieser schaut als allerersten Schritt nach ob's fr diese Datei
  Endung berhaupt einen eingetragenen Loadable Type gibt, wenn ja, so wird die Anfrage einen 'relativen Pfad' zu erzeugen
  an diesen Loadable Type weitergeleitet.
FileSystem:
- Nahm folgende Funktionen heraus da nun das Loadable-System fr diese Jobs zustndig ist:
  GetNumOfSearchPaths(), GetSearchPath(), IsSearchPath(), AddSearchPath(), SetSearchPathPriority(), RemoveSearchPath(),
  ClearSearchPaths(), GetNumOfFileTypes(), GetFileType(), RemoveFileType().
- OpenInPaths() ist nun unntig und wurde daher entfernt
- Enfernte die Klasse FileType, Sie ruhe in Frieden *g*



>> 26.11.2006
[CO]
- Container Klassen etwas herausgeputzt: ein paar Klassen-Blcke hinzugefgt, Prefix bei Klassen-/Stuktur-Namen entfernt,
  ein paar kleinere Kommentare etwas gendert
- XML-Klassen etwas herausgeputzt: Hauptschlich Kommentare komplettiert/verbessert
- ClassManager::LoadPlugin(): Eine Datei wurde geffnet, aber nicht wieder freigegeben -> Stefan schau bitte nochmal drber
  nicht das ich da nun etwas vermurkst habe. :)
- LoadableManager & Config: Ich wunderte mich gerade das Ragdolls im Scene Viewer nicht mehr geladen werden knnen da angeblich
  'Ragdoll' ein nicht bekannter Loadable Typ ist... als ich der Sache nachging stellte sich schnell heraus das der Loadable
  Manager bereits nach Loadable Typen sucht und diese Registriert (in dessen Konstruktor) bevor der Runtime-Ordner nach Plugins
  durchsucht wurde. Das lsst sich momentan leider nicht 'beheben' da man sich nicht Informieren lassen kann wenn neue Plugins
  eingeladen wurden um anschlieend diese 'Neulinge' nach zu Registrierenden Komponenten zu durchsuchen. :(



>> 25.11.2006
[CO]
Alle Projekte:
- Schaute 'NULL' in allen Headern nochmal durch und ersetzte es im zusammenhang mit PL-Strings durch 'empty'
  (das waren noch Zeiten als wir 'char*' nutzten :)
PLGeneral:
- Loadable: Da es bei Mehrfachvererbungen (siehe PLEngine::SceneContainer oder PLPhysics::SNRagoll) leider schnell zu cast
  Problemen kommt baute ich bis eine bessere Lsung gefunden ist virtuelle 'LoadLoadable()' und 'SaveLoadable()' Funktionen
  ein mit denen sich das Problem 'umgehen' lsst. Sehr schade, denn bis auf dieses Problem ist das Loadable-System mittlerweile
  recht nett, sehr einfach zu verwenden und zu erweitern.
- Localization Loader + Implementation fr unser eigenes Format hinzugefgt
- Config Loader + Implementation fr unser eigenes Format hinzugefgt



>> 24.11.2006
[CO]
- Vereinfachte das Loadable-System noch etwas und nahm einige Dinge aus 'Resource' heraus diese nun in dessen Basis-Klasse 'Loadable'
  liegen... Machte zuvor eine Kopie Namens 'ElementManager' etc. da sehr oft 'Resource' allein von Namen her in der Verwendung
  nicht korrekt war. (oder zumindestens nicht wirklich passend) Das ist zwar ingesammt immer noch nicht sonderlich prall, aber
  immerhin etwas besser als vorher. :)
  'Resourcen' sind 'Dinge' wie man Einladen & Speichern und von denen man berlicherweise viele im Speicher hat und diese
  daher 'Verwaltet' haben mchte. 'Elemente' sind hnlich, aber einfacher und auch nicht lad oder speicherbar.
- Graph Loader + Implementation fr unser eigenes Format hinzugefgt
- Graph Path Loader + Implementation fr unser eigenes Format hinzugefgt



>> 11.11.2006
[SW]
- String: da die atof funktion unter linux auch locale abhngig ist, wird in den Funktionen GetFloat und GetDouble
      wie in den Format funktionen die locale auf "C" gesetzt.
- LinuxDirectory: ein Fehler bei der berprfung ob der Suchpfad mit einem "./" beginnt
  und dem lschen dieser 2 zeichen behoben. In der ursprnglichen Fassung wurde das Lschen durch die Stringfunktion Replace durchgefhrt,
  was aber einen bsen nebeneffekt hatte, wenn der pfad auch "../" enthielt.



>> 04.11.2006
[CO]
- Win32File & LinuxFile: Kann es wirklich sein das im Destruktor die Datei nicht geschlossen wurde falls diese noch offen
  war? (was bei Reference Counting schonmal passieren kann... der letzte hat die Tr zuzumachen... :)



>> 03.11.2006
[CO]
- Entfernte ein paar 'PLGENERAL_API' wo das nicht ntig ist da es rein PLGeneral intern genutzt wird
- Fgte einige 'const' ein
- Virtual vor Destruktor entfernt da unntig: (verwenden nur eingebettete Implementationen) Semaphore, Mutex, DynLib
- In einigen cpp-Dateien Kommentar Blcke hinzugefgt damit man sofort sieht ob die Funktionen public etc. sind
- System: Neue Funktion GetLocaleLanguage(): Diese Funktion gibt den Namen der aktuell eingestellten Programm Sprache wie z.B.
  'English' zurck. Diesen String kann man dann nutzen um im Lokalisations-System eine korrekte Default-Sprache zu whlen.
- ~ThreadManager: nderte das lschen noch vorhandener Threads da Theads sich beim lschen automatisch aus der Liste
  entfernen was beim Interator Probleme machen 'knnte'. In diesem speziellen Fall machte das zwar keine Probleme da der List
  Iterator intern direkt einen Zeiger auf das nchste Element hlt, aber beim z.B. Array-Iterator wrde das schon nicht mehr
  gehen... lieber auf Nummer sicher gehen. :)
- SystemWin32: SetThreadAffinityMask() aus PLEngine::PL::InitEngine() hierher verschoben
- Thread um SetPriorityClass() und SetPriority() erweitert, PLEngine::PL::InitEngine() nutzt diese Funktionen um das Programm
  mit einer gewnschten Prioritt laufen zu lassen. (bis jetzt wurde dort mit einem ifdef gearbeitet)
  Stephan, bitte schau mal nach ob das mit der Thread Prioritt unter Linux hnlich abluft, wenn nicht, so mssten wir uns
  zusammen berlegen wie wir das in PL handhaben wollen.



>> 28.10.2006
[CO]
- Loadable: Neue Funktion: GetAbsFilename() gibt den absoluten Dateinamen der Datei zurck aus dem dieses 'Ladbare Teil'
  geladen wurde. So einen absoluten Dateinamen braucht man fters mal, z.B. in PLMesh::Texture::Load() um nach einer
  entsprechenden 'plt'-Datei zu suchen oder wenn eine Resource 'neu geladen' werden soll. Noch find ich die aktuelle
  Lsung noch nicht sooo prall, mal schaun ob wir das noch irgendwie besser & universeller hinbekommen knnen - aber fr
  den Augeblick msste das reichen.
- FS: Directory::OpenCanonical(): Das Laden aus einer Zip-Datei anhand eines absoluten Namens klappte nicht (mehr) korrekt



>> 27.10.2006
[CO]
Alle Projekte:
- Nahm an ein paar Stellen <Extension>.ToLower() und CompareNoCase() heraus da wir generell zwischen gro/kleinschreibung
  unterscheiden wollen. In den Beispielen musste ich dadurch ein paar 3ds-Meshs per Hex-Editor korrigieren da Max irgendwie
  absolut keinen Wert auf gro/kleinschreibung legt und bei 3ds wie es momentan aussieht IMMER zwanghaft groschreibt.
  (da msste ich noch etwas Experimentieren ob dem wirklich so ist)
PLGeneral:
- 'Loader'-System eingebaut, dieses System lag bereits seit ein paar Monaten im Lab/PLResource-Ordner. Nahm 'File' aus
  den Klassen Namen heraus damit es etwas deutlicher wird das dies nicht 'direkt' etwas mit dem FS zu tun hat.
  Alles was irgendwie Lad- & Speicherbar ist sollte von nun an von 'Loadable' abgeleitet werden. Die konkreten Lade & Speicher
  Funktionen liegen in von 'Loader' abgeleiteten Klassen. Diese 'Loader' mssen sich wirklich NUR um das Laden & Speichern
  kmmern, und nicht um das ffnen/schlieen der Datei - das vereinfacht an vielen Stellen einiges. Abfragen welche Typen & Formate
  untersttzt werden kann man universell & bequem ber den 'LoadableManager'. Das muss nun also nicht mehr x mal neu
  geschrieben werden, sondern 'Loader' werden zentral automatisch Registriert und verwaltet. Das System ist noch nicht final
  und wird an ein paar Stellen noch etwas vereinfacht werden. Aber es ist denk ich schonmal etwas besser als vorher... leider
  brachte dies keine groartige Ladezeit Verbesserung, trotzdem ist nun beim Laden einiges an Overhead weg. :)
- XmlDocument: Lade-Funktion hinzugefgt der man dirkt eine Datei bergeben kann



>> 18.10.2006
[CO]
Alle Projekte:
- Fgte "#pragma once" in alle Header ein damit das bersetzen "minimal" schneller geht. Da dies sowohl unter VC als auch
  gcc bekannt ist, msste es damit keine 'Kompatibilittsprobleme' geben.
- Mithilfe von "__pragma" kann man Pragmas auch in Makros nutzen. nderte daher die PL_WARNING_PUSH & PL_WARNING_POP &
  PL_WARNING_DISABLE Makros entsprechend.



>> 17.10.2006
[CO]
Alle Projekte:
- Wie besprochen "PL_WARNING_POP", "PL_WARNING_PUSH", "PL_WARNING_DISABLE" Precompiler Makros eingebaut. Jedoch konnte man
  es leider nicht so realisieren das man direkt "PL_WARNING_DISABLE(4100)" schreiben kann... stattdessen muss man
  "#pragma PL_WARNING_DISABLE(4100)" schreiben. Nun mssten unter Linux die pragma-Warnungen weg sein. Wie genau man das lst
  wenn man bestimmte Warnungen unter Linux deakivieren will mssten wir sehen wenn das ein Thema wird.



>> 16.10.2006
[SB]
Alle Projekte:
- Habe mal versucht die Export-Makros etwas zu entwirren. In PLGeneral ist jetzt jedes dieser Makros auch noch etwas genauer
  beschrieben, damit hoffentlich keiner mehr verwirrt ist welches Makro wozu gut ist.



>> 14.10.2006
[SW]
Alle Projekte:
- Finale version fr das visibility attribute feature vom gcc.



>> 14.10.2006
[CO]
- Error System, zweiter Ansatz: (Namen & Implementation noch nicht final :)
  Hat eine Funktion einen 'boolschen' Rckgabewert, so wird statt bool/PLBool 'PLReturn' genutzt welches ein Smart Pointer
  auf ein 'Result'-Objekt ist. (Experimentelle Implementation) Trat kein Fehler auf, so zeigt dieser auf 'Result::NoError',
  bei Fehler auf ein erzeugtes Result-Objekt. Dieses Result-Objekt kann man wie gehabt genauso wie einen einfachen boolschen
  Rckgabewert verwenden falls man sich 'nur' dafr Interessiert ob es einen Fehler gab. Interessiert einen selbst das nicht,
  wird dank dem Smart Pointer dieses Result-Objekt automatisch wieder 'freigegeben'. Gibt eine Funktion z.B. einen String
  zurck, so sollte es IMMER einen Optionalen PLResult-Zeiger geben der auf Wunsch das Ergebniss bekommt. Zwar bietet der
  Error-Manager die Mglichkeit sich den 'letzen' Fehler zurckgeben zu lassen, dies ist jedoch NICHT Multithreading-Safe...
  aber falls das einen nicht juckt, kann man diesen Optionalen Parameter auch ignorieren und z.B. Error::GetLast() nutzen was
  etwas 'bequemer' zu verwenden ist - das ist dem User berlassen ob er dieses 'Risiko' eingehen will. Wir selbst sollten in
  der Engine aber NIE Error::GetLast() nutzen. :)
  Das System untersttzt auch 'Rekursion' so das man sich den vorherigen Fehler zurckgeben lassen kann um zu sehen wo der erste
  Fehler passierte. Anhand von Checksum::GetFile() kann man sehen wie das mit der Fehler-Rekursion derzeit abluft. Anhand von
  PLBaseTest::ChecksumTest() kann man sehen das dies bereits sehr gut klappt - wenn wir das so machen wollen, muss sich natrlich
  dann jede Funktion daran halten damit das durchgehend klappt und man Fehler bis an den Ursprung zurckverfolgen kann.
  Die bergebenen Funktions-Parameter sollten wenn mglich IMMER mit einem PL_ASSERT() auf gltigkeit geprft werden und in der
  Funktions Dokumentation sollte genau beschrieben sein ob ein Parameter gltig sein MUSS oder nicht. Hier wird aber wirklich
  nur geprft und gewarnt wenn etwas nicht stimmt, danach gehts frhlich weiter bis zum Crash.



>> 13.10.2006
[CO]
- PLMain Dokumentiert damit wirklich klar ist was die Parameter und vorallem der Rckgabewert zu bedeuten haben
- UTF8Tools: Die 3 neuen Funktionen von Stephan vom Style & der Namensgebung her angepasst. Kommentar "One or both strings
  can be pure ASCII Strings" entfernt da dies eine allgemein gltige UTF8 Eigenschaft ist. 'FindSubString' knnten
  wir eventuell auch 'IsSubString' oder 'GetSubString' nennen... von der Funktionalit her hab ich nix verndert - konnte
  mit den erweiterten Unit-Tests auch keine Bugs oder so finden. :)



>> 11.10.2006
[SW]
Alle Projekte:
- Die projekte verwenden das neue visibility feature vom gcc, wenn vorhanden.
PLGeneral:
- Neues Makro PLTEMPLATE_EXPORT hinzugefgt, mit denen unter Linux die Templates komplett exportiert werden knnen.
  Momentan betrifft das nur Array und Singleton



>> 06.10.2006
[CO]
Alle Projekte:
- Nachdem mich Stephan auf eine 'POD-Warnung' in "PLGui/Dialogs/ResourceManagerDialog.inl:288" aufmerksam machte,
  ging ich nochmals alle String::Format-Stellen durch und prfte auf PLT()-Makro verwendung - denn dieses gibt mittlerweile
  einen PL String zurck. :)



>> 01.10.2006
[CO]
- Bugfix: XmlDocument::GetRootElement() -> Hier ging der Aufruf nicht ber GetPLNode() und daher wurde keine korrekte eingebettete
  PL XML Node erzeugt. (gut das Stephan diese Funktion mal ausprobiert hatte *g*)



>> 28.09.2006
[SW]
Alle Projekte: PLBase:
- Die linux-projecte dateine an die nderungen angepasst.



>> 27.09.2006
[CO]
- Auf PLBool umgestellt und wie blich alle Projekte entsprechend angepasst. Stellte auch dort auf PLBool um wo das true/false
  bereits passte damit das 'Einheitlich' ist und das einbauen eines netten Fehler Systems leicher geht. (man muss fast nur noch
  nach PLBool suchen *g*)
  Beim Linux Teil *knnte* es noch Stellen geben wo man noch den Fehler Code anpassen muss.



>> 26.09.2006
[SW]
- In RTTIDefs.h an zwei stellen (void)0 anstelle von 0 geschrieben um eine gcc-4.x warnung zu beheben
- ClassManager::LoadPlugin da der DynLibManager momentan in der Hasmap von bereits geladenen Libs nur den Dateinamen speichert,
  wird nun der GetLibrary nur der Dateinamen bergeben und nicht der komplette pfad.
  Wenn jemand was dagegen hat soll es entweder wieder zurckndern oder mir bescheid geben. (diese nderung wieder auf wunsch von stefan revidiert)
- ein paar dumme printfs rausgeschmissen, die eigentlich nicht hochgeladen werden sollten



>> 26.09.2006
[CO]
- Machte ein paar kleinere erste Style anpassungen



>> 21.09.2006
[CO]
- Einfache Error-System Klasse hinzugefgt + diverse Makros die einem das Leben mit Fehlern etwas einfacher machen
- Checksum & Config Klasse auf bessere Fehlerbehandlung umgestellt um zu sehen ob wir das so machen knnen/wollen



>> 21.09.2006
[SB]
- Neue Klasse Url hinzugefgt. Diese Klasse verwaltet einen Pfad oder Dateinamen, kann zwischen den Unix/Windows Formaten sowie
  der URL Darstellung konvertieren und beinhaltet die blichen Funktionen um einen Pfad in Verzeichnis, Dateiname, Extension aufzuspalten etc.
  Im Gegensatz zu den Funktionen aus FSTools ist die Klasse darauf ausgelegt, mglichst flexibel zu sein, und mit so vielen Eingaben
  wie mglich noch irgend etwas anfangen zu knnen. Kommt also z.B. ein Dateiname bunt gemischt mit \ und / herein strt das die
  Url Klasse nicht, der Pfad wird erstmal so gespeichert ohne gleich zwangslufig konvertiert zu werden. Sobald man dann einen fr das
  System gltigen Pfad braucht lt man sich die Url umwandeln, damit sie korrekt wird.
  Im FS wird ab sofort nur noch diese Klasse verwendet und damit die alten FSTools Funktionen ersetzen. Auerhalb kann die Klasse natrlich
  auch verwendet werden, um z.B. an einen Pfad/Dateiname/Extension o.. heranzukommen, zum Speichern eines Dateinamens sollte sie allerdings
  nur sehr selten verwendet werden, da sie einiges an Speicherplatz braucht. Normalerweise sollte ein Pfad also weiterhin einfach als String
  gespeichert werden.
- FSRefCount entfernt. Die Basisklasse fr alle FS Objekte (auch SearchHandle) ist nun FileObject, welches direkt von RefCount abgeleitet ist.
- FileObject: EType hinzugefgt, welches angibt um was fr ein Objekt es sich handelt. Dies wird nun nur noch in der FileObject Klasse behandelt,
  die virtuellen Funktionen zu diesem Zweck wurden daher entfernt.
- FileObject: Hat nun keinen Pointer mehr auf FileSystem, da es davon nur eine Singleton-Instanz gibt, auf die jetzt direkt zugegriffen wird.



>> 20.09.2006
[SB]
- Neue Hilfsklasse PLBool hinzugefgt. Die macht nicht viel, auer einen bool zu speichern, und kann benutzt werden, um die
  true/false-Umstellung zu machen. Die Klasse ist so aufgebaut, da sie *nicht* automatisch von/nach bool konvertiert,
  sondern bei jedem solchen Versuch einen Compilerfehler generiert. Das kann also so benutzt werden:
  - In der Funktion, die umgestellt werden soll, den Rckgabetyp von bool in PL_BOOL umndern
  - return true -> return PL_FALSE
  - return false -> return PL_TRUE
  - Alle Projekte compilieren, dadurch gibt es berall dort eine Fehlermeldung, wo die Funktion benutzt wird, z.B. bei
    if (TheFunction()), oder if (!TheFunction()) etc. Dort kann nun die Umstellung erfolgen:
  - if (theFunction()) -> if (PL_NOT theFunction())
  - if (!theFunction()) -> if (PL_IS theFunction())
  - Wenn sich wieder alles bersetzen lt, kann man den Typus wieder auf bool setzen und per Suchen/Ersetzen alles zurck umwandeln
  - 'PL_FALSE' -> 'false'
  - 'PL_TRUE' -> 'true'
  - 'PL_NOT ' -> '!'
  - 'PL_IS ' -> ''
Auf diese Weise sollte die Umstellung wesentlich erleichtert werden, und dank der Compilerfehler mte man auch *alle* Stellen finden,
an denen die jeweilige Funktion verwendet wird, man kann also nichts mehr bersehen. Natrlich mssen immer alle Projekte compiliert werden,
denn nach dem Umwandeln sieht fr die Compiler wieder alles richtig aus, auch wenn man ein Projekt noch nicht angepat hat. Hoffe das macht
diese Umstellung etwas ertrglicher ;-)



>> 19.09.2006
[CO]
- UTF8Tools: Neue Funktionen FromWideCharacterString() & FromWideCharacterString() + nderte ein paar Namen so das klar ist
  das es sich z.B. um einen 'wide character' handelt. nderte den Datentyp von 'wide character' von uint32 zu wchar_t - das
  ist zwar irgendwie total doof da wchar_t keine fest vorgegebene gre hat, allerdings knnen wir mit uint32 'wide character
  Dingen nix anfangen da die Windoof Unicode Funktionen nunmal leider wchar_t und kein UTF8 oder uint32 nutzen. :(
  Hatte mir zuerst berlegt wchar_t UND uint32 Versionen der Funktionen anzubieten - aber das wre dann doch etwas zuviel
  des guten geworden. Hat man mit wchar_t Problemen da es z.B. unter Windows zu klein ist, muss man ganz einfach NUR UTF8
  in seinem Projekt nutzen - es hindert einen ja bei unserer String Klasse bald (sobald fertig Implementiert) nix dran! *g*
- String Klasse: GetUTF8() msste mittlerweile Problemlos funktionieren -> Stephan, wenn du willst kannst du mal den Linux
  Port entsprechend anpassen bzw. mit GetUTF8() durchtesten ob das wirklich bereits brauchbar klappt. Der Rest muss noch
  ausgearbeitet werden.



>> 18.09.2006
[CO]
- Neue Tool-Klasse: UTF8Tools: Diverse UTF8 Funktionen die man immer mal wieder bentigt. Hatte diese zuerst direkt als statische
  Hilfs-Funktionen in StringBufferUTF8 drinnen bis ich merkte das es immer mehr Funktionen wurden die man ebenfalls noch bruchte...
  Daher entschloss ich mich diese Funktionen in einer seperaten Hilfs-Klasse abzulegen damit das nicht zuviel auf einmal wird.
- Fing damit an die String Klasse um UTF8-Support zu erweitern (noch nicht lauffhig!)



>> 13.09.2006
[CO]
Alle Projekte:
- Schrieb bei jedem "#pragma warning(disable : <Number>)" dazu was genau dieses deaktiviert (... zumindestens bei VC...)



>> 12.09.2006
[SW]
- in Main.h das setlocale(LC_ALL, "") hinzugefgt(unter Linux), da dadurch die systemlocale fr den Prozess gesetzt werden, ist ntig,
  da sonst im PLSampleGui die jpanischen schriftzeichen nicht angezeigt wurden.
- Durch die nderung in der Main.h tauchten problem auf, wenn man floats in String und zurck umwandelt, da im Deutschen das Trennzeichen ein ',' ist und im Englischen ein '.'.
  Um das problem zu lsen wurde in den Format-Funktionen des String-Klasse die locale auf "englisch" ("C") gesetzt und am ende der Funktion wieder auf die systemlocale zurckgesetzt.
  Das Problem und die Lsung(momentan nur fr LINUX als test) habe ich zusammen mit Christian ausgearbeitet.



>> 11.09.2006
[CO]
- Beseitige Warnungen die erscheinen wenn der Compiler auf Warnungs-Level 4 gestellt wird:
 - Per Absicht nicht verwendete Variablen (da z.B. Virtuelle Funktionen) sollten mit PL_UNUSED() gekennzeichnet werden
   damit hier nicht angewarnt wird.
 - Beim Einbinden externer Header (z.B. tinyxml.h) deaktiviere ich diverse Warnungen da wir hier nix ndern sollten.
 - Musste das PL_LOG-Makro minimal umschreiben damit nicht immer angewarnt wird das ein Ausdruck dort Konstant ist.
 - Deaktivierte die Warnung "warning C4201: Nicht dem Standard entsprechende Erweiterung: Struktur/Union ohne Namen" da
   ich nicht rausbekommen konnte wie man das besser machen knnte ohne das diese Warnung erscheint. :(
   (einfach keine Unions nutzen ist KEINE Option! ;-)
-> In den Projekten in denen ich die Warnungen beseitige hab ich im Debug-Modus erstmal Warn-Leven 4 aktiv gelassen. Solange
   es nicht strt knnen wir das so lassen und bekommen ein paar weitere ntzliche Tips vom Compiler wo mglicherweise
   etwas noch nicht ganz ok aussieht. Viele der 'zustzlichen' Warnungen sind durchaus hilfreich... um nur ein Beispiel fr
   einen dadurch gefundenen Bug zu nennen:
      PLPhysicsNewton::WorldNewton::GenericContactBegin:: -> if (nCollisionGroup1 && Ignore)
    -> !! bler Bug der nun zum Glck angewarnt wurde! ;-)
   Desweiteren werden auch Variablen angewarnt die zwar Initialisiert, aber nie verwendet wurden, ebenfalls recht ntzlich,
   und wie schon oben erwhnt sollte man PL_UNUSED() verwenden wenn das schon korrekt so ist.
-> Ich werde sicherlich noch ein paar Tage brauchen bis ich durch alle Projekte sauber durch bin. :)



>> 10.09.2006
[CO]
- Config: - GetVarBool() entfernt da man dafr mittlerweile auch locker GetVar().GetBool() schreiben kann.
          - GetVarFloat() entfernt da man dafr mittlerweile auch locker GetVar().GetFloat() schreiben kann.
- FSTools::ValidatePath(): Bei einem der Zahlreichen String-Anpassungen der letzten Zeit kam hier ein kleiner Bug rein so
  das es zu Problemen mit '/' oder '\' kommen konnte. Stefan, wre nett wenn du irgendwann spter ber diese Funktion
  nochmal drber schaun knntest - nicht das ich das Schrittweise kaputt oder zu umstndlich gemacht habe. :)
- Variant um GetString()-Funktion erweitert damit man sich ausdrcklich die String-Version des Wertes zurckgeben lassen
  kann ohne vorher auf String casten zu mssen



>> 08.09.2006
[CO]
- Abstraktes Checksum-Interface + MD5 Implementation hinzugefgt



>> 04.09.2006
[CO]
Alle Projekte:
- Fand einige Stellen an denen es z.B. netter ist vVector.x anstatt vVector[0] zu schreiben
PLGeneral:
- Types.h: FALSE, TRUE, und NULL flogen heraus bzw. verschob diese Definitionen in den Linux Teil da diese dort soweit ich
  weis bentigt werden. (bei Windows werden diese Dinge in den Win32-Headern definiert)



>> 04.09.2006
[SW]
- Linux implementation des Unicode(wchar_t) supports, habe den aufruf der durch "int vswprintf( wchar_t *buffer,const wchar_t *format, va_list argptr )"
  durch die funtion "int vswprintf(wchar_t *buffer, size_t count, const wchar_t *format,va_list argptr)" ersetzt, da unter linux nur die mit dem count parameter gibt.



>> 01.09.2006
[CO]
Alle Projekte:
- Wie Stefan es wnschte verwenden wir nun berall 'd' als Prefix fr 'double' anstatt ein universelles 'f' fr 'floating point'.
PLGeneral:
- Lokalisierungs-System eingebaut. Das System an sich ist recht einfach aufgebaut und auch leicht zu bedienen. Texte sind
  in Gruppen aufgeteilt und jedes Projekt kann seine Texte in einer eigenen Gruppe anlegen damit es z.B. keinen Konflikt mit
  PL-Texten gibt. Wie blich ist das 'Localization' Format in XML gehalten.
  Da wir bereits berall wo Sprachabhngige Texte verwendet werden das 'PLT'-Makro verwenden, waren die Code Umstellungen minimal.
  Nur den Header '#include <PLGeneral/Tools/Localization.h>' muss man nun einfgen wo man Sprachabhnige Texte hat. Neben
  dem 'PLT'-Makro welches 'PixelLight' als Text-Gruppe nutzt gibt es noch ein 'PL_TEXT'-Makro bei dem als zweiter Parameter
  die Gruppe angegeben werden muss. Ob wir das 'PLT'-Makro drinnen lassen mssen wir noch sehen, auf jedenfall ist es im Augenblick
  noch nett da man die Codes dadurch nicht ndern musste oder sich um die Gruppe innerhalb der PL-Codes kmmern muss.
  Als 'native'-Sprache verwenden wir innerhalb von PL Englisch. Fr diese 'native'-Sprache ist keine Lokalisierungs-Datei
  ntig da der Englische Text gleich als Schlssel fr die bersetung verwendet wird. Wird keine bersetzung gefunden weil
  gerade z.B. Englisch als Sprache aktiv ist, so wird einfach dieser Text-Schlssel als Ergebniss verwendet. :)
  Was im Augenblick noch fehlt ist ein Tool welches Codes als Eingabe bekommt, nach unseren Lokalisierungs-Makros sucht
  und die Gefundenen Dinge in einer bzw. mehreren Lokalisierungs-Dateien auflistet so das man die Codes nicht per Hand nach
  zu bersetzenden Texten durchwhlen muss.
  Auch wre es wohl sinnig wenn die Beispiele & Tools ihre Texte in eigenen Gruppen verwalten wrden, das muss man aber
  noch ausjungeln wie was am besten ist. Hier ein Beispiel wie so eine Lokalisierungs-Datei aussieht:
    <?xml version="1.0" ?>
    <Localization From="English" To="Deutsch">
        <Text Name="Hello">Hallo</Text>
        <Text Name="This is a test">Dies ist ein Test</Text>
    </Localization>



>> 30.08.2006
[CO]
- Jede String Buffer Implementation speichert nun noch den String in einem jeweils anderen Format. Hab ich z.B. einen ASCII
  String, fordere aber einen Unicode-String an, so wird intern eine Unicode-String Variante erzeugt. Fordere ich nochmals
  Unicode an, so wird direkt dieser gepufferte Unicode-String zurckgegeben. Sobald der Orginal String verndert wird, wird
  dieser gepufferte String 'schmutzig' und muss sobald er wieder angefordert wird neu erzeugt werden. Arbeitete die internen
  String Konvertierungen aus, also wenn ich z.B. 'sMyString = sACII + sUnicode' schreibe.



>> 29.08.2006
[CO]
- String Klasse um wchar_t-Unicodes erweitert. In unseren Projekten sollte nun immer bei den Compiler-Einstellungen 'Unicode'
  anstatt 'Multi-Byte' verwendet werden was normalerweise die Standard-Einstellung ist. Da wchar_t von der gre her nicht
  fest Definiert ist, sollte man NIE davon ausgehen das ein Buchstabe 2 Byte oder so gro ist sondern IMMER sizeof(wchar_t)
  verwenden. Zudem sollte man aus diesem Grund wchar_t Strings auch nicht in Dateien speichern oder aus solchen Laden. Das
  sollte man dann ber das 'sicherere' UTF-8 Format machen sobald dies Implementiert ist. Durch die nderung der Compiler
  Einstellung wurden einige fehlerhafte String-Stellen gefunden wo z.B. !sMyString abgefragt wurde, 'true' zurckgegen wurde
  obwohl der Rckgabewert ein String war etc. - also Stellen die man bei den krassen String Umstellungen von damals bersehen
  hatte. :)
  An ein paar Stellen wie z.B. im Win32 PLGui Backend wird bereits das Format des PL Strings geprft und dann entsprechend
  die Unicode oder ASCII OS Funktions Variante verwendet... wie man anhand von PLSampleGui sehen kann geht nun auch Japanisch
  ganz wunderbar. *g*



>> 28.08.2006
[CO]
- Vorherige String Klasse durch die berarbeite String-Klasse ersetzt. Das Interface ist noch kompatibel mit dem alten und
  wurde nur minimal erweitert. Die ASCII Implementation ist komplett Implementiert, wurde an einigen Stellen neu geschrieben
  und mit den erweiterten String-Tests geprft so das halbwechs sichergestellt ist das nicht wieder von neuem ble Bugs
  reingekommen sind. ;-) (zudem luft alles auch im Release Modus noch stabil was auch schonmal ein gutes Zeichen ist *g*)
  Das sehr gut funktionierende String-Buffer Konzept wurde natrlich beibehalten, jedoch haben String Buffer nun auch noch
  den Job die konkreten String Operationen auszufhren - abhngig von deren internen String-Format. Die String Klasse selbst
  ist also sogesehen 'nur' noch ein String-Buffer-Container der bestimmte allgemeine Bedingungen prft so das diese nicht
  in jeder String Buffer Implementation erneut gemacht werden mssen.
  Es kamen noch ein paar zustzliche Hilfs-Funktionen hinzu damit man Strings auch mit Zahlen recht einfach zusammenbasteln
  kann. Beispiel: sString = 5 + sString + '_' + true + "HeHo" + 55.9; -> 5MyString_1HeHo55.9
  Damit kann man nun relativ einfach an vielen stellen String::Format() ersetzten was vorallem dann sehr sinnig ist wenn
  dort auch noch Strings miteingewoben werden sollen... man also GetString() nutzen muss. GetString() sollte man jedoch
  wo immer mglich in den PL innereien vermeiden da man sich fr auf ein String Format (sollte IMMER Unicode sein) festlegen
  muss. Zudem vergisst man bei String::Format auch mal schnell GetString() und dann bekommt man Schrott zurck - der VC Compiler
  meckert das ja leider nicht an. Am besten & flexibelsten & sichersten ist das String-System, wenn ALLE String Operationen
  KOMPLETT ber die String Klasse gemacht werden und GetString() NUR genutzt wird um z.B. dem OS den String zu bergeben.
  (sprich, um mit der Welt auerhalb von PL zu Kommunizieren *g*) Hlt man sich an diese Spielregel, so braucht man sich nicht
  darum zu kmmern ob man gerade mit ASCII, Unicode, UTF-8 oder weis der Teufel was arbeitet - man verwendet einfach 'PL-Strings'
  und gut iss. ;-)
  Was noch fehlt sind Unicode-String Buffer die ich als nchstes angehen werde.



>> 26.08.2006
[CO]
- System: GetProgramName() -> Gibt den Namen des laufenden Programms zurck. (z.B. 'c:\MyApplication\Test.exe')



>> 25.08.2006
[CO]
Alle Projekte:
- Nach dem ffnen eines FS Verzeichnisses wurde meistens nicht geprft ob das gut ging - verbesserte dies um Crashs zu vermeiden
  falls das ffnen eines Verzeichnisses mal nicht klappen sollte.



>> 24.08.2006
[CO]
Alle Projekte:
- Fand noch ein paar Stellen an denen anstatt stricmp/strcmp die String Funktionen verwendet werden knnen.
- Es gab noch ein paar Interface-Stellen wo 'const char*' anstatt 'String' verwendet wurde. Bei z.B. TestCase::GetName()
  ist dies aber durchaus Absicht da die Tests selbst nicht bereits von unserer String Klasse abhngig sein sollen.
- Entfernte extra 'const char*'-Funktionen in diversen Interfaces wie z.B. PLGeneral::Tokenizer so das 'nur' noch die eigene
  String Klasse verwendet wird. Da die String Klasse mittlerweile auch 'nur' einen Pointer auf einen 'char*' String halten
  kann 'ohne' dabei den gesammten String zu kopieren, ist dies ebenfalls kein 'Performance'-Problem. :)
- An ein paar Stellen wo String::CompareNoCase verwendet wurde wird nun == verwendet welches zwischen gro/kleinschreibung unterscheidet.
- Ersetzte wo mglich String::Format durch String Addition. Zum einen ist das etwas kompakter & besser Lesbar, aber viel wichtiger:
  Das wird so mit z.B. Unicode Strings weniger Probleme bereiten da es nicht mehr ber GetString() abluft.
- Entfernte einige <MyString.>GetString() wo das nicht wirklich ntig ist.
PLGeneral:
- String: Nahm die Print()-Funktion heraus da diese in der berarbeiteten String Klasse auch nicht mehr vorhanden ist. Ab
  jetzt muss man das immer ber String::Format() machen, so gibt's nur noch eine einzige Funktion dafr (kein doppelter Code)
  und die 'Performance' wird darunter wohl auch nicht wirklich leiden. ;-)
- String::String(const char *pszString, bool bCopy = true, uint32 nLength = 0) -> Am Ende kann man nun noch optional
  die Lnge bergeben. Dies ist u.a. in PLMesh::EffectLoaderFX recht praktisch da man hier einen sehr langen String hat
  wo man aber bereits genau weis wie lange dieser ist.
- Tokenizer::Start(const char *pszBuffer, long nSize) entfernt und die Codes in den anderen Projekten entsprechend angepasst.
- BufferedStringReader::BufferedStringReader(const char *pszBuffer, uint32 nSize) entfernt.



>> 23.08.2006
[CO]
- Da ich momentan an einer neuen String Implementation mit Unicode Support Arbeite muss ich zwangslufig die String Dinge
  nochmal gaaaaaanz genau durchgehen. Dabei vielen mir gleich ein paar Dumme Dinge in der aktuellen Version auf - UND, wie es
  aussieht fand ich sogar unseren bsen Release Crash Bug!!! String::Replace(char nOld, char nNew) -> 'Set pointers to new
  location' war NICHT in Ordnung, denn da bereits nIndex drauf addiert wurde durfte man nicht einfach nochmal zustzlich
  die String Lnge draufzhlen um das Ende des Strings zu bekommen... denn nun schoss man ber den Speicher heraus und es
  wurde irgendwo herumgeschrieben wo das nicht sein durfte - KEIN Wunder das dies Probleme machte! *g*



>> 22.08.2006
[CO]
Alle Projekte:
- Die Projekte verwenden nun die .lib's in PLSDK/Actual/libs anstatt die aus den build/win32 Verzeichnissen.
PLGeneral:
- Stellte TinyXML von 2.4.3 auf 2.5.0 (Beta) um. Da etwas an der Lib verndert wurde muss diese auf jedenfall noch
  gepackt vorliegen damit man selbst neu bersetzen kann. (tinyxml_2_5_0_changed.zip)



>> 21.08.2006
[CO]
- XmlDocument: GetErrorDesc() so erweitert das standardmig auch in den String geschrieben wird 'wo genau' der Fehler
  auftrat - das will man in den meisten Fllen natrlich auch direkt wissen. :)
  Mir viel dabei auf das die Xml-Datei Namen noch nicht den eigentlichen Klassen Namen entsprachen, nderte dies.



>> 17.08.2006
[SB]
- Bei Log::Open() den Paramter fr den LogFormater mit dem Standardwert "" versehen, falls man keine Parameter mit angeben mchte
- Log::GetLogFormater() gibt nun kein const-Objekt mehr zurck, da man ansonsten auf die Optionen, die dieses Objekt zur Verfgung stellt,
  gar nicht zugreifen kann. Das Objekt mu also auch vernderlich sein, damit man sich den LogFormater zurckgeben und dann bequem
  dessen Optionen ndern kann
- Einige Kommentare berarbeitet



>> 16.08.2006
[SW]
- Log: XmlLogFormater hinzugefgt.



>> 14.08.2006
[CO]
- String: berarbeitete die Replace()-Funktion nochmal sorgfltig, z.B. war bereits der 'Count' am Anfang nicht ok. Die nochmals
  etwas erweiterten String Tests konnten nun keine Fehler mehr feststellen. (was allerdings leider nicht bedeutet das nix mehr
  drin wre ;-)



>> 13.08.2006
[SW]
- HTML LogFormater hinzugefgt: Und im zuge dieses LogFormaters die OpenFunktion des Logs um den Parameter sParameters erweitert.
  mit diesem Parameter ist es nun mglich die LogFormater bezogenen Parameter zu ndern, welche ans RTTI angebunden sind.
  beim HTML LogFormater sind das die Parameter Title(zum setzten des HTML-Titels), Header(dieser Text direkt nach dem <body>-tag geschrieben)
  Background(zum setzen einer Background farbe bzw. bild) und DefaultTextColor(zum setzten der default Farbe fr den Text).
- Log::GetLogFormater hinzugefgt. Hiermit ist es mglich sich den aktuellen LogFormater zu hohlen um dann optionen des LogFormater zu ndern.
  (z.b. beim HTML LogFormater kann man darber die Formatierung der Meldungen fr jeden Loglevel seperat angeben).
- Log: die maximale anzahl der Loglevel von 2^32 auf 255 reduziert, da chris und ich glaube das kaum jemand mehr als 255 Loglevel brauchen wird.
- String::Replace: Hier wurden die restliche Zeichen des alten Textes nicht in den neuen String bertragen, nachdem der eigentliche Replace beendet war.



>> 12.08.2006
[CO]
Log nderungen:
- Bei LogLevel wieder meine nderungen eingespielt, also wie besprochen das nur mit 'Debug'. Bei der Ausgabe steht dann auch
  nur 'Debug' - wie Stephan auch merkte wird das hier zuviel Text, das einzige was ich noch mehr hier habe ist das bei Debug
  wirklich 'nur' Debug und nicht Debug0 steht. Erst bei 'User Debug' Levels steht dann Debug1 etc. dabei.
- Verschob das Makro wieder nach oben wie Stephan es vorschlug, unterschied macht das keinen. Ich selbst geh die Codes nur
  immer von oben nach unten durch, und wenn dann oben etwas verwendet wird das aber 'rein Code liniear' gesehen erst 'unten'
  definiert wird sieht das fr mich immer etwas merkwrdig aus... aber bei Makros iss das ja Funktionsmig kein Unterschied...
  und wenn es euch oben besser gefllt schreiben wir das mit den Makros *immer* oben.
- Wie Stefan vorschlug bei PL_LOG wird vor Level PLGeneral::Log:: eingefgt -> passte alle Codes an, viel schlanker so das nun ist :)
- Nahm wie von Stephan vorgeschlagen die Update-Funktionen heraus, fgte nun *aber* wie von mir geschrieben eine Flush Funktion
  hinzu damit ich von PLEngine::SNConsole aus einen Flush ERZWINGEN kann unabhngig vom Flush Log Level das die Konsole natrlich
  *nicht* ndern soll... zustzlich *MUSS* dort auch noch geprft werden ob sich die Datei seit dem letzten Check gendert hat,
  sei es durch ein frheres Log Flush oder durch eine Datei nderung des Users. (warum auch immer er eine machte)
  Derzeit ist das OS abhngig Implementierte, aber das berarbeite FS wird dann ja solche Infos ebenfalls bereitstellen so das dies
  dann universell machbar ist.
- ... bei dieser neuen Flush Funktion merkte ich das Log::Write() noch nicht ganz ok war. Denn sobald m_qLastMessages einmal voll war,
  wurde nach jedem Output flush ausgefhrt. Darum fgte ich m_nFlushMessages hinzu. Bei jedem Eintrag wird das um eines erhht, und
  erst wenn m_nBufferedMessages erreicht ist wird dieser Counter zurckgesetzt und ein Flush ausgefhrt.
- Fgte nach 'Quiet' noch ein Log Level namens 'Always' ein. In SNConsoleBase::ProcessCommand() *muss* der gerade eingebene
  Befehl *immer* unabhngig vom aktuell Eingestellten Log Level ausgegeben wird, auer natrlich Log Ausgaben sind wieso auch
  immer mal komplett deaktiviert. Darum ist 'Info' hier nicht nutzbar. Wenn jemand da eine andere Idee hat wie man das lsen knnte gebt
  bescheit... so wie das jetzt im Augenblick alles ist luft auch die PL Konsole wieder so sauber wie vor der Log Umstellung.



>> 08.08.2006
[SB]
- Kleinen Fehler im Log-Makro behoben: __LINE__ ist eine Zahl, daher mu es im printf-Style mit %d
  in den String eingefgt werden, das %s fhrte natrlich zu einem Crash



>> 07.08.2006
[CO]
Alle Projekte:
- Stellte auf das neue Log System um



>> 06.08.2006
[CO]
- Timer um Funktion GetTimer() erweitert. Hierbei handelt es sich um einen allgemeinen Timer auf den einfach der aktuelle
  Zeitunterschied bei jedem Update addiert wird.



>> 31.07.2006
[CO]
- Array<AType>::Add(const AType Elements[], uint32 nCount): Hier habe ich Vorsichtshalber das memcpy durch Element weise
  Kopieren ersetzt, denn soetwas wie memcpy kann ja leider sehr schnell nach hinten Losgehen vorallem wenn man etwas komplexere
  Klassen direkt nutzt. Es ist zwar noch memset drinnen um auf *ausdrcklichen* User Wunsch neue Elemente zu Initialisieren,
  da wsste ich allerdings nicht wie man das anderst machen knnte, einfach jedem Element '0' oder so zuweisen geht ja nicht.



>> 28.07.2006
[CO]
- In SystemLinux/SystemWin32 wird im Konstruktur nun auch srand aufgerufen um den Zufallsgenerator zu Initialisieren. Bis
  jetzt stand in PLMath::Math ein Kommentar das man dies selbst ber diese Funktion machen muss, und in PLEngine wurde dies
  dann auch gemacht... allerdings sollte man soweit irgend mglich auf OS/Standardfunktionen verzichten um eventuellen
  Inkompatibilts oder Makro Problemen gleich von anfang an die Luft anzuschnrren.



>> 26.07.2006
[CO]
- Stellte alles auf die neue HashMap um und nahm die alte HashTable Klasse heraus. Beim Umstellen viel mir auf, das wenn
  etwas aus einer HashMap entfernt wurde das Objekt selbst bergeben wurde, und nicht dessen Name. Wann immer mglich sollte
  man Namen/Keys bergeben da diese *sehr* viel schneller gefunden und entfernt werden kann - bei einem Objekt/Zeiger muss
  man erst die GESAMMTE HashMap durchlaufen um den entsprechenden Eintrag zu finden.
- Nahm an ein paar Stellen 'stdio.h' etc. heraus wo man dies nun nicht mehr bentigt. (vor der String Umstellung brauchte man das
  dort wohl noch) Gerade in Headern sollte man es soweit mglich vermeiden solche Header einzubinden um eventuellen Problemen
  die dadurch entstehen knnen zu vermeiden. (Makros etc.)
  Das ist momentan zwar noch nicht Optimal, zeigt aber wo es hingehen knnte/sollte. So bekommt man dann auch hoffentlich weniger
  Probleme wenn man mal einen Memory Manager/Tracker hinzufgt, denn manche dieser Standard Header berschreiben new etc. was
  dann ziemlich ungnstig ist.



>> 23.07.2006
[CO]
- Fgte wie vor einigen Wochen mit Stefan bereits besprochen String::SetCharacter() hinzu.
  Ersetze in FSTools::ValidatePath() 'sValidPath.Delete(0, 1); sValidPath.Insert(&c, 0, 1);' durch 'sValidPath.SetCharacter(0, c)'.



>> 22.07.2006
[CO]
- FSTools::GetDirectory(): Hier habs noch einen Bug, wenn in einem gegebenen Pfad kein Verzeichniss vorhanden war, wurde der
  gesammte String als Verzeichniss zurckgegeben was aber sicherlich nicht gewollt war. Es wird in dem Fall nun ein leerer 
  String zurckgegeben. Das gleiche in FSTools::GetFirstPath(). Auch musste FSTools::ValidatePath() angepasst werden da GetFirstPath()
  es wie es bereits in der Funktions-Kommentierung stand am Ende ein '/' hat. Der File System Unit Test luft nun ohne das
  'Fehler' festgestellt werden. (vorher gabs Fehler bei den zip-Tests)
- Stephan fand gestern noch einen Fehler in XmlDocument::SaveFile(), hier wurde FSTools::GetPathPrefix() anstatt FSTools::GetDirectory()
  verwendet um das Verzeichniss herauszufinden in dem sich die Datei befindet. Solche Stellen gabs noch ein paar mal und ich korrigierte
  das berall.
- berall wo man eine Datei ffnet um einen Tokenizer darauf arbeiten zu lassen wird eine Datei im Binary Modus geffnet, ansonnsten
  im Text Modus. Diese Stellen waren bereits mit einem [TEST] versehen und Stefan und ich hatten das auch bereits vor einer weile kurz
  besprochen. (Immer Text Modus kann Probleme machen, und huftig ist/war das leider auch der Fall :(
- Den Fehler in RefCount<AType>::Release() behoben den ich bereits am 16'ten gefunden hatte. Fgte desweiteren zur Vollstndigkeit
  == und != fr 'Direkte Zeiger' hinzu. Ebenfalls wird nun VOR einer Zeiger zuweisung geprft ob dies bereits der aktuell gesetzte
  Zeiger ist, machte man diesen Test nicht, konnte es zu einem blen Crash kommen wenn man einen Reference Counted SmartPointer sich
  selbst zuwies. Die entsprechenden Bast Tests laufen nun sauber & stabil.



>> 21.07.2006
[SW]
- Linux port nderungen von Christian teilweise angepasst/fehlendes hinzugefgt.



>> 16.07.2006
[CO]
- Xml-Klassen: Diverse Definitionen nun mit gro/kleinschreibung geschrieben. Das ist zum einen Lesbarer, und manchmal sogar
  etwas krzer da man keine '_' mehr braucht.
- Types.h: Nahm einige mittlerweile total veraltete Definitionen heraus (das meiste wurde auch berhaupt nicht mehr genutzt)



>> 16.06.2006
[SW]
- GetOpts in CmdLineParser umbennant
- CmdLineParser:
  eine Parse-funktion fr PLGeneral::Array<PLGeneral::String> hinzugefgt.
  und 2 statische funktionen ( String CmdArrayToString(int argc, char** argv) und
    Array<String> CmdStringToArry(String cmd_str) )
  hinzugefgt.
  Die 1. Funktion Convertiert das char argumenten Array in ein String um
  Die 2. Funktion Convertiert ein String in ein Array<String> um.
- PLMain bergibt nun ein PLGeneral::Array<PLGeneral::String> fr die cmd-Parameter



>> 13.07.2006
[CO]
- HashString<AType>::~HashString(): Hier fehlte ein [], die Klasse ist zwar sowieso veraltet und mittlerweile durch HashMap
  ersetzt, aber solange das noch drinnen ist mssen eventuelle Bugs raus :)
- String::GetSubString(): Es wurde Speicher angelegt, korrekt gefllt und einem String() Konstruktur bergeben, da dieser jedoch
  selbst den String kopiert und nicht den Zeiger bernimmt, hatten wir danach ein Speicherleck. Hab dem String(const char *pszString)
  Konstruktor erstmal einen Optionalen Parameter geben ber den man dann festlegen kann das dieser Speicher bernommen, und nicht
  kopiert werden soll... hat Vorteile wenn man das festlegen kann, ist aber auch etwas 'Gefhlich'. Ld man z.B. eine Datei ein,
  so kann man den 'Buffer' nun direkt an String bergeben ohne das nochmal kopiert und danach der eingelesene Buffer wieder
  gerstrt werden muss. Standardmig wird aber immer Kopiert.
- String: Dem StringBuffer muss man nun immer die Lnge des Strings bergeben. Da diese IMMER bekannt ist, ist es einfach nicht
  so prall diese vom StringBuffer nochmals ermitteln zu lassen. Zudem ist der Zeiger auf den String innerhalb es StringBuffers
  NIE NULL, sobald es NULL wird, wird auch der StringBuffer nutzlos... Nahm daher auch den StringBuffer Konstruktor ohne
  Parameter heraus. Auf z.B. m_pStringBufffer->GetString() muss man daher NIE prfen da es NIE NULL sein kann - bis auf eine Stelle
  in der String Klasse wurde das auch nie geprft. :)
  Machte die interne StringBuffer Implememtation inline und nahm 'Sicherheitsabfragen' wie z.B. pszString == NULL heraus da diese hier
  einfach nur Sinnlos sind, es ist schlichtweg ein ganz bler Fehler der eigentlich NIE passieren drfte wenn hier mal NULL kommt,
  und wenn das mal der Fall ist, so ist das ein Bug in der eigentlichen String Implementation der behoben werden muss.
- DynLibManager::~DynLibManager(): Hier wurde der Iterator nicht wieder gelscht
-> Die oberen Bugs fand ich als ich zum Testen mal den Memory Manager von http://www.fluidstudios.com/ im PLGeneral
   Header includierte, der merkte sofort das in der Hash Table der Speicher anderst wieder freigegeben wurde als er erzeugt wurde.
   Auch wurde ein Speicherleck in String::GetSubString() angemeckert - und tatschlich war was noch was... wir sollten uns
   wohl dranmachen unseren eigenen kleinen Memory Manager/Tracer zu schreiben, denn gerade bei solchen Speicherlecks hilft das
   enorm viel.



>> 29.06.2006
[CO]
- Bitset::Resize(): Das gleiche wie gestern in Array::Resize()



>> 28.06.2006
[CO]
- Array::Resize(): Hier konnte es zu Problemen kommen wenn ein Array intern bereits genug Elemente hatte und nach einem
  'Gre ndern' bereits alle Elemente 'hinzugefgt' sein sollten. Erstaunlich das dies bis jetzt noch nicht aufgefallen war.



>> 26.06.2006
[CO]
- CmdLineParser: 'DEBUG' zu '_DEBUG' gemacht damit das unter VC klappt



>> 17.06.2006
[CO]
- Container: Neue Funktion 'uint32 Add(const AType Elements[], uint32 nCount)'



>> 14.06.2006
[SB]
- Style-Anpassungen an GetOpts vorgenommen. Bitte mehr auf Spaces und Tabs achten
- PLMain arbeitet nun nur noch mit PLGeneral::String



>> 07.06.2006
[SW]
- Neu Klasse GetOpts hinzufgefgt. Mit dieser Klasse lt sich hnlich, wie die getopt funktion unter linux, Optionen parsen.
  Die Klasse wertet nur die Optionen aus welche ihr vorher bekannt gegeben worden sind.



>> 05.06.2006
[CO]
- ResourceManager: Neue Funktion: LoadResource(): Create() sollte jeweils NUR eine Resource erzeugen, aber diese nicht auch noch
  eventuell gleich einladen... dafr ist nun die neue Funktion da. Siehe PLMesh Tagebucheintrag von heute fr mehr Informationen.



>> 04.06.2006
[CO]
- String: Vor ein paar Tagen hatte ich in der String Klasse StringBuffer aus dem Interface in die Implementation verschoben
  damit das Interface mglichst keine Implementations Details enthlt und etwas bersichtlicher ist. Allerdings konnte man nun
  nicht mehr beim Debuggen ohne weiteres 'in den String' schaun was oft sehr hilfreich ist. Machte daher diese nderung wieder
  zu gunsten des Debugging rckgngig. Fgte auch gleich ein kleines Kommentar hinzu warum das public ist, nicht, das ich in
  ein paar Jahren wieder vergessen habe wieso das public ist und wieder auf die schlaue Idee komme das in die Implementation
  zu verschieben. ;-)
- Map: Neue Funktion: Replace() -> Stephan viel auf das diese Funktion welche recht ntzlich ist noch fehlte



>> 30.05.2006
[CO]
- String: Mir viel gerade auf das wir zwar operator =(const char *pszString) hatten zum String kopieren, aber keine Funktion
  wo man nur eine bestimmte Anzahl von Zeichen kopieren konnte. Also fgte ich eine Copy()-Funktion hinzu welche bereits
  im OpenGL Renderer verwendet wird. Ersetzte auerdem 'strcpy' durch 'strncpy' da das erstere mittlerweile 'deprecated' ist
  da keine berprfung auf Speicherberlauf. Nahm auch ein paar mehr oder weniger berflssige 'strlen' heraus.
  Verschob die interne StringBuffer Klasse in die String.cpp Datei damit das Interface etwas aufgerumter ist.



>> 25.05.2006
[CO]
- Module::GetClasses() die gleichen Parameter wie bei ClassManager::GetClasses() verpasst damit es einheitlich ist.
  Die Codes der Funktionen sind identisch, baute am Anfang noch eine Abfrage ein ob alle Regestrierten Klassen zurckgebenen
  werden sollen, in diesem Fall kann man sich extra Arbeit sparen und einfach die Klassen Liste zurckgeben. In
  PLEngine::GuiDebugScene::UpdateClassList() macht es die Sache mit dem einheitlichen GetClasses() auch etwas einfacher da
  ich mir dort gleich eine Liste mit in Frage kommenden Klassen zurckgeben lassen kann ohne per Hand aussortieren zu mssen.
  (der Grund fr diese nderung :)



>> 23.05.2006
[SW]
- Linux backend zum filesystem auf die Strings umgestellt



>> 22.05.2006
[CO]
Alle Projekte:
- Fand in diversen Projekten noch Stellen wo man z.B. Vector3::ZERO einsetzen konnte anstatt ein neues Temporres Objekt zu erzeugen.
  Fand auch jede Menge stellen in denen man Werte direkt den Konstruktoren bergeben konnte anstatt diese Werte intern erst
  initialisieren zu lassen um anschlieend einen Wert zuzuweisen.
- Ein paar Variablen Namen angepasst wo man z.B. einen Zeiger auf Zeiger hat (also z.B. **ppMyPointer)
PLGeneral:
- String::LastIndexOf(): An ein paar Stellen in den Codes wurde der Rckgabewert in uint32 gespeichert was probleme gab wenn
  nichts gefunden wurde und '-1' daher als Ergebniss kam.
- FileSystem: IsBaseDir() hinzugefgt. Da es bereits auch IsSearchPath() gibt und ich bereits an ein paar Stellen umstndlich
  per Hand prfte ob ein gegebener Pfad ein Basis Verzeichniss ist oder nicht um z.B. diesen Pfad dann gegebenenfalls whrend
  dem einladen einer Szene Temporr als Basispfad einzusetzen, denk ich diese Funktion hat im FS seine Existensberechtigung. :)
  Machte bei der Gelegenheit gleich ein paar int zu uint32, damit verschwinden ein paar Compiler cast Warnungen an diversen
  Stellen.
- String: + Operator hinzugefgt damit man auch soetwas wie sResult = "A" + sString schreiben kann... wird bereits in
  PLSamplePhysics verwendet da hier recht praktisch.



>> 21.05.2006
[SB]
- Bsen Fehler im String behoben: Beim Duplizieren des StringBuffers hatte sich ein Fehler eingeschlichen, so da nicht
  wirklich ein neuer Stringbuffer benutzt wurde. Daher wurde also im falschen Buffer geschrieben, so da sich Strings vernderten,
  die eigentlich vorher kopiert worden waren. Ein weiterer Fehler war auch noch in Replace(char, char), dort wurde der Index
  innerhalb des Strings erst nach dem Kopieren des Buffers berechnet, so da man hinterher wieder im alten Buffer landete.
- FileSystem auf String umgestellt. Nach dem Beheben des String-Fehlers funktionierte das meiste wieder erstaunlich gut, nur ein
  paar kleine Fehler die bei der Umstellung des FS passiert waren. Da die FS Funktionen aber aus heftigen String-Manipulationen
  bestehen, die nun dank String-Klasse vllig anders implementiert werden muten als vorher, kann es aber gut sein da noch weitere
  Fehler auftauchen. Also bitte mal verstrkt auf Probleme mit dem FS achten.
- Einige kleine Umstellungsfehler beseitigt
- String: Replace(char, char) vereinfacht, so da nur noch eine Schleife bentigt wird. Schleife in Schleife wobei die erste dann
  abgebrochen wird ist unschn und sollte vermieden werden :-)



>> 18.05.2006
[CO]
- Nachdem Stephan beim bersetzen mit gcc bei der Funktion PLPlugins -> PLSceneNodes1 -> SNLightning.cpp -> GenerateLightning()
  eine Warnung bekam da etwas nicht const war und 'pPoint[f]+vDest' einmal als Parameter verwendet wurde was eine Warnung
  verursachte, fgte ich in GeneralWin32.h etwas hinzu so das auch bei uns bei Warnungs Level 3 bei soetwas eine Warnung kommt.
  (die Warnung empfinde ich als sinnig :)



>> 16.05.2006
[SB]
- Resourcen-Klassen auf Strings umgestellt
- Log-Klasse auf Strings umgestellt
- Profiling-Klasse auf ... Na ihr knnts euch wohl denken ;-)
- Einige Style-Anpassungen vorgenommen
- PLBase::FromString() und PLBase::VarChanged() auf String umgestellt und alle Projekte darauf angepat



>> 15.05.2006
[SB]
- Nochmal die XML Klassen verndert. Die vorherige nderung hatte zur Folge, da in den Klassen mit einem public Konstruktor
  erstmal eine interne Node erzeugt wurde, und dann wieder berschrieben wurde (Speicherleck). Leider fllt mit keine sinnvolle
  Lsung ein, denn auch eine statische Methode mte ja intern einen Konstruktor aufrufen, gleiches Problem also.
  Habe daher den internen Konstruktor wie vorher wieder eingebaut, nur statt (void*) nimmt er nun (void*, int).
  Das ganze ist nur ntig, weil ansonsten ein Aufruf von z.B. XmlText("Bla") einen Compilerfehler wegen Aufruf eines privaten
  Konstruktors auslst (void* passt "besser" als String, daher wird das genommen). Darum also nun der zustzliche Parameter int,
  der wird zwar nicht verwendet, verhindert aber diesen Fehler.



>> 14.05.2006
[CO]
- Container/Functions.cpp hinzugefgt in dem die Implementation fr die String Funktionen liegen. Sobald man die String Klasse
  nutzt muss man PLGeneral einbinden, aber nutzt man 'nur' die Container Templates ohne String Klasse, so braucht man PLGeneral
  nicht einzubinden - praktisch fr z.B. Max Exporter damit man nicht fr alles diese grsslichen stl Klassen nutzen muss. :)



>> 14.05.2006
[SW]
- POD-warnungen gefixed



>> 14.05.2006
[SB]
- RTTI Funktionen grtenteils auf Strings umgestellt. Dies bringt ein paar Probleme mit sich, denn da die RTTI Funktionen nun natrlich
  auch Strings zurckgeben, ist es nicht mehr so einfach mglich, festzustellen ob ein Fehler aufgetreten ist. Zumeist ist "" als
  Rckgabe zwar ein Anzeichen fr einen Fehler, jedoch knnte natrlich auch der leere String eine gltige Variable sein.
  Anders herum ist es auch problematisch, denn wenn eine Variable auf "" gesetzt werden soll, wird jetzt vermutlich der Standardwert
  gesetzt - bei Strings kann jedoch wirklich "" gemeint gewesen sein. Dieses Problem bestand allerdings vorher auch schon, von daher
  sollte es erstmal keine greren Probleme geben, nach den ganzen Umstellungen berlege ich mir genau, wie wir das mit den Standardwerten
  knftig machen wollen.
- Base besitzt nun keine Funktionen mehr, um die Variablen aufzuzhlen oder an ein Var* zu kommen. Dafr mu dann halt
  GetClass()->GetVar() geschrieben werden (intern passierte ja sowieso nichts anderes). 
- GetVarTypeAsString() in GetVarType() umbenannt - die Funktion heit nun als in "beiden Richtungen" gleich
- Config: m_szVariableValue entfernt. Sollte einmal der Fall eintreten, da aus zwei Threads auf das gleiche Config-Objekt zugegriffen wird,
  wrde das bse schiefgehen. Wir mssen daher in Zukunft darauf achten, da alles Thread-Safe ist
- Tools: CombineStrings() entfernt. Diese Funktion ist uerst unschn und wurde sowieso nur an einer Stelle verwendet, wo sie berhaupt
  nicht notwendig war. Die anderen String-Funktionen teilweise umbenannt, damit besser zu verstehen ist was die machen.
- Da die XML Klassen leider noch keine Strings verwenden, war es an einigen Stellen ntig, so etwas wie String(pszString).GetBool() zu schreiben.
  Damit diese Stellen hoffentlich spter nicht vergessen werden, habe ich mich bemht diese immer mit einem [TODO] zu markieren. 
- Es sind immer noch an viel zu vielen Stellen Konvertierfunktionen fr Strings vorhanden, teilweise in dreifacher Ausfhrung und jedesmal
  leicht anders implementiert :-( Habe daher angefangen die zu vereinheitlichen, das werde ich aber in den kommenden Tagen erst richtig angehen.
- XML Klassen auf Strings umgestellt  



>> 13.05.2006
[CO]
- Erweiterte HashMap & SimpleMap um eine Vergleichs-Funktion. Da die definierbaren Funktionen recht universell sind, packte ich
  diese in eine gemeinsame Datei Namens 'Functions.h' welche im Container Ordner liegt.



>> 12.05.2006
[CO]
- Fand einen Bug in HashMap::CSlotsList::Add() -> Falls dies nicht das erste Element dieses Slots ist, so wurde der Next 
  Zeiger nicht Initialiert.



>> 11.05.2006
[SB]
- Class Groups wurden entfernt, da diese knstliche Definition von Gruppen so keinen Sinn mehr ergab.
  Da die Gruppen sowieso mit den Ableitungen von einer Basisklasse bereinstimmen, ist es sinnvoller gleich
  nach Basisklassen zu suchen. Nur das Aufzhlen von Gruppen ist jetzt nicht mehr mglich, wird aber auch
  nicht wirklich gebraucht. Das Interface von ClassManager wurde daher so angepat, da man sich entweder alle
  abgeleiteten Klassen einer Basisklasse direkt zurckgeben lassen kann, oder nur die direkt abgeleiteten.
  Einige Klassen wurden auerdem auf Strings umgestellt.



>> 09.05.2006
[SB]
- Externe Libraries wurden nach "external" verschoben und dort entpackt, damit das Projekt direkt bersetzt werden kann
  und keine Archive mehr entpackt werden mssen. Evtl. Sourcen knnen innerhalb der Lib-Verzeichnisse abgelegt werden,
  aber auch nur wenn diese wirklich bentigt werden, weil z.B. fr PL etwas verndert werden mute.
  Die Projekte wurden entsprechend angepat.



>> 26.04.2006
[CO]
- XML Klassen: Ein paar Leerzeichen & Tabs verbessert
- FileSystem: RemoveBaseDir(): Der bergebene Pfad muss zuerst 'korrigiert' werden so das dieser auf jedenfall mit dem
  intern gespeicherten Pfad bereinstimmt.



>> 22.04.2006
[CO]
- Stefan und ich besprachen gestern das Iterator Problem und entschieden das es das beste ist, zustzlich in den Container
  Klassen neben GetIterator() noch GetEndIterator() anzubieten welches 'hinten' im Container startet. HasNext() gibt
  also 'false' zurck und HasPrevious() 'true'. Die nderung in den Klassen war nicht wirklich aufwndig. Passte gleich die
  Stellen in allen Projekten an wo man einen Iterator fr einen Rckwrtsdurchlauf verwendet.
- XmlDocument::LoadFile(): Hier gabs gleich zwei kleinere Problemchen. Man muss die Datei im Binrmodus ffnen damit TinyXML
  End Of Line (EOF) behandeln kann, und zum anderen fehlte ganz am Ende '\0'. Nun funktioniert im XML Test das Parsen von
  'demotest.xml' korrekt. In der neuen TinyXML Version wurde hier etwas gendert, darum konnte es nun Probleme geben.



>> 21.04.2006
[CO]
- HashMapIterator Konstruktor: Sind keine Elemente in der Map, so wird der Konstruktor nun sofort wieder verlassen da man
  ja bereits weis wie die Suche nach dem ersten Map Element ausgehen wird. Ist NUR ein Element drinnen ist es allerdings
  etwas Problematisch. Hab das nun erstmal so gemacht das man ein nchstes aber kein Vorheriges Element zurckbekommt. Hier
  muss man sich wirklich berlegen wie man diesen Sonderfall behandeln will, denn HasPrevious() gibt hier nun momentan immer
  false zurck. Dieses Problem gibts in jeder Iterator Implementation.
- Bei der Gelegenheit schaute ich gleich nochmal die Container Klassen durch und entfernte berflssige Tabs & Leerzeichen



>> 20.04.2006
[CO]
- Container Klassen um Copy-Konstuktoren fr den eigenen Typ erweitert



>> 17.04.2006
[CO]
- Stellte auf TinyXML 2.4.3 um. Anscheinend wurde intern etwas an den Strings gendert, wird hier nun NULL bergeben gibts
  einfach einen Crash. Daher musste nun in
    XmlDeclaration::XmlDeclaration(const char *pszVersion, const char *pszEncoding, const char *pszStandalone)
  eine Sicherheitsabfrage rein.



>> 08.04.2006
[CO]
- Pool & FastPool: FreeElements(): Hatte vergessen den Fall zu bercksichtigen wenn gerade berhaupt keine Elemente vorhanden 
  sind...
- Bitset: Machte einige Funktionen inline



>> 05.04.2006
[CO]
- Pool & FastPool: FreeElements(): Die alte Implementation war viiieeel zu umstndlich. Man muss einfach nur die gesammte 
  Liste gerade verwendeter Elemente in die Liste der freien Liste 'anhngen'... das macht Pool & FastPool dort wo man sehr 
  hufig Elemente einfgt, lscht und alles komplett zurcksetzt extrem Performant. :)



>> 28.03.2006
[SB]
- Base::GetClassName(): return false bei "const char *" ... ? in return NULL gendert :-)



>> 22.03.2006
[CO]
- Base::GetClassName(): Sicherheitsabfrage ob Klasse vorhanden ist eingebaut



>> 12.03.2006
[SW]
- Fehler in PLGeneral/Main.h behoben, explizites angeben des Namespaces fr String da nicht immer
  sicher ist, das "using namespace PLGeneral;" vorher "verwendet" wurde wenn dieser Header includiert wird.
- Fehlerausgabe unter linux hinzugefgt, wenn das laden einer LIB fehlschlug.



>> 27.02.2006
[SW]
- SemaphoreLinux.cpp: Der Check fr den Maximalen wert des Semaphore eingebaut.
- TheadLinux.cpp: Der Execution Mutex (Er wird verwendet um Join(Timeout) zu implementieren ) wird
  in Terminate() und in Join(Timeout) explizit unlocked.
  In Terminate() wird er unlocked weil der Thread hier nichtmehr dazu kommt den Mutex selbst freizugeben.
  Wenn in Join(Timeout) der Mutex->Lock(Timeout) erfolgreich war, so muss der Mutex dort auch unlocked werden,
  da sonst beim nchsten start des selben Thread-objectes der Thread nicht im versuch des "Locken" des Execution-Mutex
  blocked.



>> 27.02.2006
[SB]
- Ebenfalls noch einige kleine Style-Dinge hochgeladen. Das mit den Tabs und Freizeichen ist manchmal Geschmacksache,
  vor allem wenn man Variablen untereinander anordnen will etc. Am Anfang einer Zeile sollte jedoch immer Tab verwendet
  werden. Ebenfalls sollte darauf geachtet werden, da Freizeilen auch wirklich frei sind, sprich keine Leerzeichen oder
  Tabs darin enthalten sind
- Einige kleine nderungen im Linux Port:
  - MutexLinux: Habe den pthread mutex von einem Pointer in eine direkte Variable verwandelt, da bei allen Beispielen
    die ich gefunden habe keine Pointer verwendet wurden, sondern die Struktur direkt. Die Variable heit nun entsprechend
    m_sMutex, da es sich um eine Struktur handelt. Das mit dem Pointer war natrlich auch in Ordnung, allerdings scheint
    man sich das dynamische Erstellen hier sparen zu knnen, es ist also nicht notwendig (deswegen aber nicht falsch).
    In dem Falle htte allerdings nach pthread_mutex_destroy() noch das Objekt selber per delete gelscht werden mssen,
    da die Funktion dies allem anschein nach nicht tut (wie sollte sie auch unterscheiden, ob das Objekt dynamisch erzeugt
    worden ist oder nicht). Und es ist nicht notwendig, beim Portieren die gleichen Namen zu verwenden wie im Win32 Port -
    dort handelt es sich ja um ein Mutex-Handle, welches man vom System zurckbekommt, daher m_hMutex, handelt es sich aber
    dann beim Linux Port um einen Pointer, so sollte auch der Name in m_pMutex oder wie jetzt fr eine Struktur m_sMutex
    verndert werden.
  - Die System-Ports sollten mglichst die Terminologie der entsprechenden System bernehmen, damit sich ein Windowsprogrammierer
    z.B. im Windows-Port gleich zurechtfindet und ein Linux-Programmierer im Linux Port. Daher sollten die Datentypen entsprechend
    angepat werden und nicht per Definitionen vereinheitlicht werden - dies ist ja auch nicht mehr ntig, denn es handelt sich
    ja gerade um systemspezifische Klassen, welche nur im entsprechenden System funktionieren mssen. Das unabhngige Interface
    wird ja von den Klassen System, Thread, Mutex etc. bereitgestellt und benutzt die Impl-Klassen als Backend. Daher besteht
    also in den Backends selber keine Notwendigkeit mehr, irgendwelche Datentypen umzudefinieren oder zu vereinheitlichen :-)
  - DynLibLinux: Habe daher HANDLE m_hModule in void *m_pLib umbenannt
  - ThreadLinux: Variable in m_nThreadID umbenannt
  - ThreadLinux: In RunThread lpParameter in pParameter umbenannt. lp ist wieder nur fr Windows und den dortigen Datentypen LPVOID blich
  - ThreadLinux: In RunThread ppThread in pThread umbenannt. pp deutet auf einen zweifachen Pointer hin, es ist jedoch ein direkter Pointer
  - ThreadLinux: m_pMutex wurde nicht in jedem Fall initialisiert, jedoch spter benutzt. Nun wird es immer mit NULL initialisiert
  - Die neuen Member-Variablen wurden dokumentiert
  - Variablen sollten immer im kleinst mglichen Kontext deklariert werden, also am besten beim ersten Benutzen und dann gleich
    initialisieren. Wenn es anders geht also mglichst nicht am Anfang einer Methode die Variablen deklarieren und dann erst
    spter benutzen
  - Bitte Debug-Code immer mit [DEBUG] kennzeichnen
  - In den Kommentaren "Windows" durch "Linux" ersetzt :-)
- Der Linux Port ist wirklich schon sehr gelungen, ist einfach toll wie bersichtlich das jetzt schon geworden ist :-)
  Hier noch ein Paar Anmerkungen bzw. Dinge die noch getan werden mssen:
  - ThreadLinux: Die Verwendung von m_pMutex mu noch etwas berarbeitet werden. Beim Join beispielsweise mu wohl nicht mehr Unlock()
    aufgerufen werden, dann wenn der Mutex noch gelocked wre drfte pthread_join gar nicht zurckgeben. Auerdem ist das Lschen
    des Mutexes an vielen Stellen nicht ok, denn dann geht der Aufruf beim nchsten Starten des Threads schief, da der Mutex nicht
    mehr da ist. Eigentlich mte es reichen den Mutex nur im destruktor wieder zu lschen, beim Abbrechen des Threads etc. mu nur
    darauf geachtet werden, da korrekt Unlock() aufgerufen wird.
  - SemaphoreLinux: Hier fehlt noch die Behandlung des Max-Values. Bitte mal schauen ob Linux das bietet, wenn nicht ist die Frage
    ob wir das selber einbauen, oder ob dieses Feature unter Linux halt nicht zur Verfgung steht. Falls wir das selber machen
    sollte dies vielleicht besser in Semaphore geschehen und damit einheitlich fr alle Systeme. Bld ist es natrlich wenn eine
    Semaphore auch von anderen Prozessen verwendet wird, aber in dem Fall wrde auch jetzt schon das Mitzhlen des aktuellen Wertes
    schiefgehen, und solange es dafr keine Systemfunktionen gibt ist das Problem wohl auch nicht zu lsen



>> 27.02.2006
[CO]
- Linux Dateien dem VC Projekt hinzugefgt (werden jedoch vom Build ausgeschlossen)
- Machte beim Linux hier und da ein paar kleine Style nderungen damit alles wie aus einem Stck aussieht... die Linux 
  Implementation ist sehr viel bersichtlicher als vor dem PLGeneral umbaun - gute Arbeit Stephan. :)
- Mir ist aufgefallen das an einigen Stellen wo z.B. als Abtrennung von Funktions Sammlungen bei z.B. 
    //[-------------------------------------------------------]
    //[ Public virtual ThreadFunction functions               ]
    //[-------------------------------------------------------]
  oft keine zwei Leerzeilen waren - bis jetzt hatten wir es hier immer so gemacht das wir hier zwei Leerzeilen hatten um 
  die Funktions Blcke schner zu trennen so das man schon beim berfliegen der Codes sehr schnell erkennt was zusammen 
  gehrt. Ist natrlich wieder so eine Geschmacksfrage - ich pershnlich finds so aber einfach bersichtlicher.
  Das ist natrlich wieder so ein mehr oder weniger Sinnfreies 'kleinmist' Zeug... allerdings erleichtert ein durchgngig 
  Einheitlicher Code Style enorm die Arbeit wenn man sich dafr Entscheidet eine Style nderung vorzunehmen wie wir es in 
  der Vergangenheit ja schon recht oft gemacht hatten. :)
- An ein paar Stellen '/*<' durch '/**<' ersetzt... wenn ich solche Dinge per zufall finde, so ndere ich diese immer 
  gleich so das es nicht noch mehr Stellen werden... man arbeitet ja oft mit Copy'n'Past oder schaut nach wie es woanderst 
  geschrieben wurde. ;-)



>> 26.02.2006
[SW]
- Linuxport auf die Klassen-Umstellung angepasst
- In der Thread-klasse die Funktion Stop in Terminate umbenannt, da die Bezeichnung Stop in meinen Augen nicht 
  "Kill den thread" sondern "Sende thread ein signal damit er sich beendet" bedeutet.



>> 25.02.2006
[SB]
- Haupt-Header von 'General.h' in 'PLGeneral.h' umbenannt
- Projekte an nderungen angepat



>> 23.02.2006
[SB]
- Habe mit der kompletten Umstrukturierung von PLGeneral begonnen. Das Projekt teilt sich ab jetzt in 3 Teile: Base, System und Core.
  In Base kommen alle Basisklassen und Datentypen, welche die Basis von PLGeneral bilden, also sprich Base, String, die Container, XML, Graphics etc.
  In System befinden sich die Klassen welche welche eine Abstraktion des Systems darstellen, also die frhere Platform Klasse, Filesystem, Threading, Libraries, Timing usw.
  In Core letztlich kommt dann das Application-Framework, welche PLGeneral zur Verfgung stellt. Das ist insbesondere das RTTI mit allen dazugehrigen Klassen, also
  Klassen, Module, Config etc. Das wird dann nach und nach ausgebaut, so da ein richtig schnes Framework entsteht. Die Trennung von System und Core ist wichtig,
  denn dies sind zwei vllig unterschiedliche Dinge, es war daher nicht schn da diese vorher zusammen waren.
- Die Platform-Klasse wurde entfernt, da diese nicht gut gelungen war. Dafr befinden sich in System nun alle systemabhngigen Klassen, jeweils mit einer
  Implementierung fr das jeweilige System. Die Win32 Implementierung ist jeweils schon dabei, die Linux-Implementierung knnte Stephan nachtragen :-)
  Das meiste kann aus der alten Platform-Klasse kopiert werden, es hat sich inhaltlich nicht viel verndert, nur das Interface ist schner geworden.
- Die System-Klassen benutzen nun ein Backend-System, es gibt also jeweils eine System-unabhngige Klasse als Interface, und eine Implementierungsklasse mit Ableitungen
  fr jedes System. Das Interface besitzt dann einen Pointer auf die Implementierungsklasse. Das ist zunchst komplizierter, hat jedoch den Vorteil da das Interface
  und die Implementierung komplett voneinander getrennt sind, damit entsteht nicht wieder so ein Chaos wie in der alten Platform-Klasse.
- Habe den Threads und der Synchronisation ein vernnftiges OOP System spendiert. Die Thread und Synchronisations Funktionen befinden sich in Threading, es gibt einen
  ThreadManager der die aktuellen Threads auflisten kann etc, fr die Threads selber gibt es eine Klasse Thread, Mutex und Semaphore sind ebenfalls eigene Klassen.
  Damit ist dies nun endlich auch vernnftig objektorientiert, wie es sich fr C++ gehrt.
  Das schreiben eines Threads geht nun auf verschiedene Arten, bevorzugt aber so: Eine Klasse MyThread wird von Thread abgeleitet und ihre Run() Methode berschrieben.
  Mit new MyThread und pMyThread->Start() kann der Thread dann gestartet werden. Auf diese Weise hat der Thread ein Objekt zur Verfgung und mu nicht mehr ber void*
  Pointer umstndlich Daten bergeben bekommen. Bitte in Zukunft darauf achten auch bei neuen Funktionen gleich vernnftig objektorientiert zu arbeiten, und nicht pltzlich
  in unserem kompletten OOP Framework altbackene prozedurale Methoden zu verwenden. Auch ist es nicht gut das Win32 Interface inklusive der gesamten Kommentierung
  einfach zu kopieren, denn erstens legt man sich damit auf das oftmals merkwrdige Windows Interface fest, und zweitens hat Microsoft sicherlich ein Copyright auf seine
  Hilfetexte :-) Also wenn neue Funktionalitt eingebaut wird bitte auch die Mhe machen das vernnftig zu designen, so da es schn ins System passt.
- Beim Umbauen der Threads bitte wenn mglich von Thread ableiten, oder zumindest von ThreadFunction. Ich habe lange berlegt, ob ich die Mglichkeit eines Function-Pointers
  berhaupt noch anbieten will, habe mich dann dafr entschieden. Das heit jedoch nicht, da das nun berall einfach weiter verwendet werden sollte, da es am einfachsten
  ist das so umzubauen. Die OOP Methode ist viel flexibler und besser, der Funktionspointer sollte nur in Ausnahmefllen verwendet werden.
- Die System-Klasse wurde um ein paar nette Funktionen erweitert, so kann man nun z.B. den Computernamen und den Usernamen abfragen. Ebenfalls soll hierber eine
  Versionsverwaltung implementiert werden, so da z.B. Plugin-DLLs schnell feststellen knnen, wenn sie mit einer inkompatiblen PLGeneral.dll arbeiten. Auch dient dies
  natrlich den Log-Ausgaben. Das mu jedoch noch vernnftig implementiert werden.
- Die Methode GetCPUMhz() aus der Tools-Klasse wurde ebenfalls nach System verschoben.



>> 20.02.2006
[CO]
- Array, Bitset: RemoveAtIndex(): Fand und behob einen bsen uint32 Umstell-Bug... war ja klar das so eine Umstellung 
  diese Viecher anlockt ;-)
  Resize(): Auch hier gabs noch einen heftigen Bug - wow, das ich das bis jetzt bersehen hatte, hm, die Container Tests 
  sind wohl noch nicht genau genug... :)



>> 12.02.2006
[SW]
Alle Projekte: Subversion:
- habe das property svn:eol-style fr die neuen Dateien gesetzt.
    um dies automatisch zu machen sollten folgende optionen in der config-datei 
    von subversion vorgenommen werden:
    [miscellany]
    enable-auto-props = yes
    
    [auto-props]
    *.c = svn:eol-style=native
    *.cpp = svn:eol-style=native
    *.h = svn:eol-style=native
    *.inl = svn:eol-style=native
    *.dsp = svn:eol-style=CRLF
    *.dsw = svn:eol-style=CRLF
    *.sln = svn:eol-style=CRLF
    *.vcproj = svn:eol-style=CRLF
    *.sh = svn:eol-style=native;svn:executable
    *.py = svn:eol-style=native
    *.txt = svn:eol-style=native
    SCons* = svn:eol-style=native
    Makefile = svn:eol-style=native
    
    damit sollte jede datei die passende eol-kennung(bis auf die vc-projekt-dateien immer die kennung, welche vom OS verwendet wird)
    beim auschecken haben.
PLGeneral:
- Stellte die linux-thread-functionen auf pthread um.



>> 10.02.2006
[CO]
- Wie mit Stefan vorhin im Chat besprochen nderte ich die Stack & Queue Klassen etwas so das Pop nun NICHT mehr das 
  entfernte Element zurckgibt da dies ziemlich Problematisch war. Stattdessen sollte man sich das Element nun ber 
  GetTop()/GetBottom() zurckgeben lassen und danach Pop() aufrufen - oder Pop() einen Zeiger bergeben der das Element 
  bekommen soll. (falls man nicht immer zwei Funktionen aufrufen mchte :)



>> 09.02.2006
[CO]
- Binominal Heap Iterator implementiert, vorwrts ging ja noch, aber rckwrts war etwas fies zu Implementieren. Da in 
  diesem Heap nur der Nachfolger, aber nicht der Vorgnger bekannt ist, ist das rckwrts durchlaufen auch nicht wirklich 
  gut von der Laufzeit her. Dort habe keinen Vorgnger Zeiger eingebaut da er hier unntig ist und 'nur' die Iterator 
  Implementation fr rckwrts durchlauf vereinfachen wrde - da aber Iteratoren keine gngige Operation auf Heaps sind, 
  entschied ich mich dagegen hier im Binominal Heap pro Eintrag noch mehr Speicher zu verschwenden.
- Neue Heap Implementation: FibonacciHeap: Hat gewisse hnlichkeiten zum Binominal Heap, jedoch geht u.a. das einfgen 
  neuer Elemente superflott... dafr ist das entfernen von Elementen etwas Aufwndiger da hier dann auch gleich etwas 
  aufgerumt werden muss. Ohne diese Funktion luft es zwar auch korrekt, aber dann hat man im Prinzip nur eine 
  doppelt verkettete List und diese Struktur wird Witzlos. :)
  Wir haben nun drei gngige Heap Implementationen - das sollte frs erste reichen.



>> 09.02.2006
[SB]
- Singleton hat nun wieder einen Destruction Guard, da die Benutzung des SmartPtr hier nicht mglich war.
  Aufgrund des static initialization order problems kann es vorkommen, da der statische SmartPtr spter initialisiert wird,
  als der Singleton. Beim Aufruf von GetInstance() wird also die Instanz erzeugt und im SmartPtr gespeichert, danach wird
  dann aber erst der SmartPtr initialisiert und somit der Zeiger wieder auf NULL zurckgesetzt, so da beim nchsten Aufruf
  von GetInstance() eine zweite Instanz erzeugt wird und die erste natrlich auch niemals mehr gelscht wird.
  Die statische Instanz welche das Lschen des Singletons berwacht darf also keine Daten haben, die initialisiert werden
  mssen, daher mu hier doch wieder der speziell darauf abgestimmte Destruction Guard verwendet werden
- Der Destruction Guard besitzt nun eine leere inline Methode, welche innerhalb des Singleton einmal aufgerufen wird.
  Dies ist notwendig, damit der Compiler die statische Instanz erzeugt, ansonsten scheint diese in einer template-klasse
  wegoptimiert zu werden, wenn nicht einmal darauf zugegriffen wird. Die Methode macht also nichts ist aber notwendig,
  damit der Compiler richtig arbeitet. Interessant ist, da dieses Problem nur bei Template Klassen auftrifft, bei Nicht-Templates
  funktioniert das mit der statischen Instanz auch ohne solche einen Trick
- Im Singleton werden nun auch die Zuweisung und der Copy-Constructor deklariert, um ein Kopieren des Objektes und damit
  die Umgehung des Singletons zu verhindern
- Die unschne Methode CheckInstance() wurde entfernt, statt dessen wird ber ein Destroy-Flag berprft, ob das Objekt
  bereits gelscht wurde. Damit wird whrend der Deinitialisierung das Objekt nicht noch einmal neu erzeugt, nachdem es bereits
  gelscht worden ist.
  Generell sollte man whrend der Deinitialisierung keine Singletons mehr verwenden, da diese schon gelscht worden sein
  knnten - static DE-initialization order problem ;-) Also sollte z.B. in einem Destruktor eines Singletons nicht mehr auf andere
  Singletons zugegriffen werden. Sollte man es doch einmal tun mu auf jeden Fall der Rckgabewert von GetInstance() auf NULL
  berprft werden, da dies nun zurckgegeben wird, falls die Instanz bereits gelscht wurde
- Singleton generell noch etwas berarbeitet



>> 08.02.2006
[CO]
- Heap Interface um GetTop() und ExtractTop() erweitert um das 'oberste' Element anzufragen bzw. zu entfernen
- Neue Heap Implementation: BinominalHeap: Nachdem ich erstmal die Theorie soweit kapiert hatte war die Implementation 
  nicht soo schwer wie ich anfangs dachte, eigentlich sind nur CTree::Union() und ExtractTop() etwas kompliziert gewesen - 
  der Rest war 'trivial'. ;-)
  Die entsprechende Iterator Klasse muss ich noch Implementieren...



>> 07.02.2006
[CO]
- Fr Heaps (Priority Queue) gibts nun wieder wie frher ein eigenes allgemeines Heap Interface da Heaps einfach etwas 
  anderes sind als Maps. (das erkannte ich erst wieder als ich mich wieder genauer mit den Datenstrukturen befasste :)
  Wie auch bei Container & Map hab ich Support fr Iteratoren Implementiert. Dies ist zwar genauso wie bei Map eher 
  unblich bei dieser Datenstruktur, jedoch ist das ein nettes Feature. In welcher Ordnung die Elemente beim Iterator 
  zurckgegeben werden kann man wie bei Map nicht wirklich vorausgesagen - man weis nur das das ERSTE Element jeweils das 
  grte/kleinste aller Elemente ist - je nach verwendeter Compare-Funktion.
- Binary Heap an neues Heap Interface angepasst
- Nam den Sicherheits-Test innerhalb einiger Container Iteratoren der prfte ob der Container Zeiger gltig ist heraus 
  da total berflssig - dieser Zeiger MUSS immer gltig sein, ansonnsten luft gerade etwas total schief... ;-)
- Einige Container Iterator Implementationen waren noch nicht ganz korrekt.



>> 06.02.2006
[SB]
- PLGeneral_Rewrite Branch entfernt. Die nderungen wurden grtenteils in den main Branch bertragen, der Rest mu sowieso
  noch einmal komplett berarbeitet werden, was dann direkt in den aktuellen Sourcen geschieht.
- Kleine Fehler in RefCountPtr und SmartPtr entfernt. Diese Klassen werde ich wohl nochmal grndlich durchgehen mssen, da der
  Compiler ja leider nur die Teile compiliert die auch wirklich bentigt werden. Und diese Klassen sind schon etwas kompliziert,
  da sie einige template Tricks verwenden :-)
- Singleton: DestructionGuard entfernt. Statt dessen wird der Zeiger nun in einem SmartPtr gespeichert, dieser lscht genauso wie
  vorher der Guard das Objekt wenn er selbst gelscht wird (also am Ende des Programmes, da es sich um eine statische Instanz handelt).
  Diese statische Instanz wird auch korrekt initialisiert, was wohl daran liegt da sie nicht selbst zum Template gehrt - dies ist wohl
  ein Fehler der Sprache, da dies nicht korrekt funktioniert.
  Singleton ist nun von RefCount abgeleitet, damit der SmartPtr vernnftig die Referenz halten und lschen kann. Die Ableitung ist
  jedoch private, da ansonsten jeder den RefCount erhhen oder verringern knnte, und somit das Singleton ad absurdum fhren wrde.
  Damit der SmartPointer dennoch den RefCount nutzen und die Instanz lschen kann, mute er als friend deklariert werden.
  Falls es Probleme mit dieser Lsung gibt, bitte Bescheid sagen, denn dies ist schon einigermaen kompliziert - und bei den
  Templates noch durchzuschauen fllt hier schon etwas schwer :-)



>> 06.02.2006
[CO]
- Bitset: Die Anzahl der bentigten Integers wurde noch nicht immer korrekt berechnet + verbesserte das Initialisieren 
  der Bits. Container::GetSize() Kommentar etwas erweitert damit wirklich klar ist WAS hier zurckgebenen wird.
  (Kommentar also bitte nicht lschen :)
- Tokenizer: Da momentan + und - als einzelnde Zeichen betrachtet werden funktioniert ParseNumber() nicht korrekt - 
  negative Zahlen werden nicht mehr korrekt gesetzt. Entweder msste man bei ParseNumber() nun nach Vorzeichen ausschau 
  halten oder wir behandeln diese Zeichen nicht als einzelnde Zeichen. (hab das erstmal auskommentiert damit alles sauber 
  luft)
- FastPool: FastPoolElement: Virtuellen Destruktor etc. hinzugefgt damit alles sauber ber die Bhne luft



>> 05.02.2006
[SB]
- String: Konstruktor mit Printf-Funktionalitt wurde entfernt, da dies nicht bei jedem String erwnscht ist.
  So war es unmglich, einen normalen String der ein Prozentzeichen (%) enthlt zu speichern. Statt dessen
  gibt es nun die statische Funktion Format, die einen formartierten String mit Printf syntax erstellt und einen
  String zurckgibt (named constructor).
- Tokenizer:
  - Fehler in ParseEquation(String, int&) entfernt - hier fehlte die Referenz, das Ergebnis wurde also nicht zurckgegeben
  - SingleChars zu {}()[]<>+.*/=,;" verndert. Damit drfte die bliche Syntax von C Programmen besser abgedeckt werden
- Auf String::Format() umgestellt



>> 04.02.2006
[SB]
- String:
  - IsFixedNumeric() in IsNumeric() umbenannt. Man mu hier im Hinterkopf behalten, da es um Eigenschaften der Zeichenkette geht (nicht um den Inhalt!),
     und das umfat z.B., ob diese nur aus alphabetischen Zeichen besteht, nur aus numerischen oder aus alpha-numerischen Zeichen. Diese Begriffe sind
     allgemein bekannt und daher sollten diese Funktionen nun sehr verstndlich und eindeutig sein. An solchen Stellen sollte drauf geachtet werden, da keine
     eigenen Begriffe erfunden werden, da dies auenstehende nicht verstehen wrden, noch dazu wenn z.B. Fixed noch eine ganz andere Bedeutung hat
     (Fixkomma Zahl), das verwirrt die User dann noch einmal unntig, in diesem Fall also lieber gleich nach allgemein bekannten Begriffen suchen, wenn es
     einem einmal nicht einfllt :-)
  - IsFloatingPointNumeric() entfernt. Diese Funktion gehrt nicht in den String, da es sich nicht mehr um die Eigenschaft einer Zeichenkette handelt. Aus was
    fr Zeichen eine Zeichenkette besteht kann direkt als Eigenschaft dieser Zeichenkette gesehen werden, dafr die Funktionen IsAlphaNumeric() etc.
    Hier jedoch geht es eigentlich schon um den Inhalt, und dafr sollte ein Parser zustndig sein. Abgesehen davon sollte so eine Funktion dann auch gleich
    ein anerkanntes Floating-Point Format erkennen, die sehen dann etwas komplizierter aus (123.4567E10 (f/d) o..) Dafr gibt es aber genug Definitionen, die
    man dann benutzen kann. Im Moment bleiben wir beim alten Verfahren, da wir nicht alles auf einmal machen knnen, spter werden dann solche Dinge gleich
    korrekt geparsed z.B. mittels regulrer Ausdrcke.
  - Einige Kommentare angepat
  - Bei einigen Funktionen const hinzugefgt
- Profiling:
  - Kleine nderungen im Coding Style



>> 04.02.2006
[CO]
- Profiling: SelectNextGroup() & SelectPreviousGroup() behob kleine uint32 umstell Fehler
- String:
  - Compare Funktionen wie besprochen um Start Position Parameter erweitert, in der Implementation werden ein paar 
    Sonderflle bercksichtigt in denen man auf einen Schlag weis ob die Strings gleich sind oder nicht - gerade beim 
    Vergleichen lngerer Strings wird das enorm Speed bringen.
  - IsSubString() wie besprochen gendert und neue Funktionen IndexOf() & LastIndexOf() hinzugefgt.
  - IsCharacter() entfernt da mittlerweile berflssig... IsCharacter() das kann man nun auch selbst per Hand in zwei 
    Schritten machen. (z.B. sToken.GetLength() == 1 && sExpected.IsSubString(sToken))
  - < und > Operatoren hinzugefgt um Strings Lexikographisch vergleichen zu knnen (fr sortieren wichtig)
  - Neue Funktionen: Replace() in 3 Varianten, einmal fr const char *, String und fr Buchstaben - Ich wrde wirklich gerne 
    diese spezielle Replace Funktion fr Buchstaben behalten da die Implementation deutlich einfacher ist. Zwar wird auch 
    in der String-Replace Implemenation getestet ob es sich nur um Buchstaben handelt und dann eine schnellere Implementation 
    gewhlt, aber in der const char * msste ich dazu erst die Lngen der Strings ermitteln lassen was hier ja nicht 
    'for free' ist... und will man wirklich nur Buchstaben austauschen ist diese extra Funktion handlich & Performant.



>> 03.02.2006
[SW]
- Linux buid: build is wieder fehlerlos unter linux
  habe in RTTIDefs.h den rckgabewert von CLASS_OFS von PLGeneral::uint64 auf size_t gendert.
  da size_t immer die passende lnge auf dem entsprechenden sysstem hat.
  (32Bit-System -> 32 Bit, 64Bit-System -> 64Bit)



>> 03.02.2006
[CO]
- Container Klassen: Intern verwendete Klassen & Strukturen sind nun nicht mehr von auen 'sichtbar'... vorallem 'HashMap' 
  sieht nun in der Implementation ziemlich krank aus - dieses Template wirrwar ist kaum noch lesbar. ;-)
- String:
  - Compare Funktionen kann man nun noch optional die Anzahl der zu vergleichenden Zeichen bergeben, so muss man nicht erst 
    umstndlich sich einen String & dann einen Substring davon erzeugen lassen damit man bestimmte Regionen von Strings 
    vergleichen kann.
  - Neue Funktion: IsSubString(): Prft ob ein gegebener String ein Unterstring ist
  - Delete() fngt nun auch den Fall ab wenn der String nun leer ist
  - Print() prft nun ob der bergebene String NULL ist (ansonnsten gabs einen Crash in '_vscprintf')
  - GetSubString(): Position Parameter wird auf korrektheit berprft
  - IsAlphabetic() & IsAlphaNumeric(): Kommentare um jeweils eine kleine Beispielzeile erweitert, denn ich hatte total 
    verpeilt fr was diese eigentlich da sind und nahm an es wrde sich um 'ist keine Zahl/ist eine Zahl' Funktionen handeln. 
    Stefan klrte mich kurz im Chat auf und jetzt ist diese Sache natrlich total logisch - aber da es sicherlich auch 
    andere nicht auf anhib peilen werden lieber kurz nen Beispiel dazu. :)
  - Neue Funktionen IsFixedNumeric() (hm, besserer Name??) prft ob der String eine Zahl ist, IsFloatingPointNumeric() prft 
    ob es eine Fliekommazahle ist



>> 31.01.2006
[CO]
- HashMap: HashSlot zu einfacher Stuktur gemacht, das spart Funktionsaufrufe und ist auch etwas kompakter. HashSlot speichert 
  nun auch den Vorgnger, dadurch war nun auch die Implementation der 'Previous' Iterator Funktionen mglich - wobei diese 
  HashMap Iterator Implementation fr 'vorwrts' & 'rckwrts' Support etwas Tricky ist... aber ich glaub das es kaum 
  einfacher gehen wird. :(
- SimpleMap Implementiert - diese Klasse verwendet intern 'Fast Pool' damit das huftige Einfgen & Lschen etwas flotter 
  von dannen geht, aber zum auffinden der entsprechenden Eintrge muss man natrlich sequentiell die gesammte Liste 
  durchgehen... diese Klasse sollte daher mit bedacht eingesetzt werden. Andere Map Implementationen wie z.B. 'Binary Heap' 
  sind hier deutlich flotter und diese Implementation hat noch den netten Seiteneffekt das die Elemente vom Iterator gleich 
  'nach Schlssel geordnet' zurckgegeben werden was bei dieser Implementation 'for free' kommt. Bei SimpleMap und HashMap 
  ist dies nicht der Fall und ein geordnetes zurckgeben der Element zu 'erzwingen' wre hier definitiv nicht gut da diese 
  Implementationen das einfach nicht 'untersttzen' und dies dann extra Implementiert werden msste was dann recht langsam 
  wre. Jede Implementation hat hier genauso wie die Container-Klassen vor und Nachteile die man geschickt nutzen sollte. 
  Wenn wirklich bentigt knnten wir spter noch extra Funktionen anbieden die Elemente 'IMMER' geordnet zurckgeben - ob 
  nun performant oder nicht... aber in den meisten Fllen ist es egal in weiler Reihenfolge die Elemente zurckgegeben 
  werden und da sollten wir defintiv die Sache nicht unntz knstlich ausbremsen.



>> 30.01.2006
[CO]
- Nahm wie mit Stefan besprochen die Funktion ExpectCharacter() wieder aus dem Tokenizer und implementierte eine vergleichbare 
  Funktion namens IsCharacter() in der String Klasse.
- Container, Map & Iterator Templates um virtuellen Destructor erweitert, auch bei Templates scheint dies Pflicht zu sein - 
  gut das genau zu wissen. :)



>> 29.01.2006
[CO]
- Prfte ber Doxygen ob die Kommentare soweit ok sind und verbesserte ein paar Stellen



>> 24.01.2006
[CO]
- Tokenizer: Neue Funktion: ExpectCharacter(): hnlich wie ExpectToken(), aber erwartet das der nchste Token ein einzelner
  Buchstabe ist welcher mit einem der bergebenen Buchstaben bereinstimmt. Wird bereits in Var::CheckMinMax() verwendet um 
  zu prfen ob ein " oder ' vorhanden ist.
- Var::CheckMinMax() Funktionen an neuen Tokenizer angepasst
- Base::SetVars() an neuen Tokenizer angepasst



>> 23.01.2006
[SB]
- Tokenizer verndert, so da bei Quotes erst die Anfhrungszeichen ("), dann der Inhalt und dann noch einmal die Anfhrungszeichen zurckgegeben werden.
  Ist das Wort leer, so wird es nicht zurckgegeben. Auf diese Weise kann der Tokenizer sowohl fr strikte Syntax
  verwendet werden oder es kann wie bisher einfach der Inhalt der Quotes ausgelesen und weiterverarbeitet werden



>> 22.01.2006
[CO]
- Resource Manager & Profiling Klassen an uint32 angepasst damit die Warnungen verschwinden



>> 21.01.2006
[SB]
- Neue Tokenizer Klasse geschrieben. Intern benutzt diese nun eine vernnftige State-Machine (TheoInf lt gren) ;-) Dies ist zwar u.U. etwas langsamer, sollte dafr
  aber wesentlich stabiler sein und ist vor allem verstndlicher zu lesen
- Die Klasse arbeitet nun mit Strings anstatt mit char arrays
- Die Optionen werden nicht mehr beim Starten des Parsers festgelegt sondern ber eigene Get/Set Methoden
- Die grundlegende Funktionalitt des Tokenizers wurde besser von den erweiterten Parser-Funktionen getrennt. Diese sind zwar nach wie vor vorhanden, sollten aber nur
  eingesetzt werden, wenn keine strikte Syntax gebraucht wird. Im allgemeinen sollte der Tokenizer nur die Tokens liefern, danach mu der Output vernnftigt
  geparsed werden
- Neue Klassen: BufferedReader, BufferedStreamReader und BufferedFileReader. Diese Klassen werden benutzt, um Schritt fr Schritt aus einem Stream oder einem
  Buffer zu lesen. Dies wird im Tokenizer verwendet, so da dieser jetzt auch direkt aus Dateien parsen kann. Leider ist die Implementierung nicht so performant wie sie
  sein knnte, dies sollte spter noch einmal berarbeitet werden. Auerdem sollte es eine Stream-Klasse geben, die Byte fr Byte zurckgibt, der BufferedStreamReader
  knnte dann auf beliebige Streams angewendet werden. Auf diese Weise knnte jeder Stream verwendet werden, nicht nur Dateien sondern auch z.B. Netzwerk-Streams o..
- Codes an neuen Tokenizer angepat



>> 21.01.2006
[CO]
- Etwas an den Container Klassen gefeilt, u.a. wird nun dort so mglich/sinnig uint32 anstatt int verwendet - dadurch kann 
  man gleich von vorne heraus Negative Werte ausschlieen so, das man sich intern extra Abfragen sparen kann. Bei 
  GetIterator() kann man nun optional einen Start Index setzen. Die Iterator Konstruktoren sind nun protected so das diese 
  NUR von dem jeweiligen Container Typ erzeugt werden knnen.
- Bitset: Damit wir endlich ein paar cpp-Dateien im Container Ordner haben machte ich das Bitset Template zur normalen 
  Klasse. Ein etwas weniger wichtiger Grund war, das man nicht jedesmal <bool> angeben muss - denn ein anderer Typ ist hier 
  sowieso nicht mglich/gewnscht... ein Bitset mit z.B. floats wre total daneben. :)



>> 17.01.2006
[SB]
- Alle Klassen auf Namespaces umgestellt. Das RTTI machte dabei etwas Probleme, die Makros mssen hier nochmal berarbeitet werden, es
  ist also mglich da externe Klassen im Moment nicht mehr richtig funktionieren.
- Alle Container-Klassen nach 'PLGeneral/Container' verschoben
- Quicksort nach 'PLGeneral/Tools' verschoben
- Verzeichnis 'FileSystem/Base' gelscht und alle Dateien direkt nach 'FileSystem' verschoben
- Patch von Christian fr einen Fehler in SearchMultiHandle eingearbeitet



>> 16.01.2006
[SB]
PLString:
- Die Operatoren gefielen mir noch nicht wirklich, da dies eine bunte Mischung aus der Verwendung von String und char* war.
  Habe nun bei den wichtigsten Operatoren jeweils beide Varianten eingebaut, wird dies mit char* aufgerufen ist es also minimal
  schneller, da nicht erst ein String-Objekt erzeugt werden mu
- StringModule wurde in StringBuffer umbenannt
- Der StringBuffer implementiert nun nicht mehr einen eigenen Reference Counter sondern benutzt PLTRefCount
- Hilfsfunktionen zur Verwendung von String-Buffern in der Klasse eingebaut. Dies erleichtert die Arbeit mit den Buffern, da ansonsten
  an vielen Stellen immer wieder das gleiche getan werden mute (Buffer kopieren wenn der String verndert wurde etc)
- Der String-Buffer bernimmt nun immer einen neuen Zeiger auf einen Buffer, die Mglichkeit einen eigenen Buffer zu allokieren und
  den bergebenen String zu kopieren fllt weg. Dies macht die Verwendung des Buffers wesentlich verstndlicher, zumal das Kopieren
  des Strings nur an einer einzigen Stelle ntig war
- Compare-Funktionen berarbeitet
- Konstrukturen mit einem Char-Zeichen als Parameter aus StringBuffer entfernt. Im String selbst bleibt dieser Konstruktor erhalten,
  damit Operationen auf Strings auch mit Buchstaben funktionieren, ansonsten wre das Umwandeln eines Buchstabens in einen String
  der Lnge 1 recht kompliziert
- IsAlpha: Wurde umbenannt in IsAlphabetic. Auerdem prft diese Funktion nun den gesamten String und nicht mehr nur ein Zeichen,
  fr ein einzelnes Zeichen sollte entweder die System-Funktion direkt aufgerufen werden oder SubStrings verwendet werden
- IsAlphaNumeric: Prft nun ebenfalls den gesamten String, ob dieser nur aus alpha-numerischen Zeichen, sprich alphabetischen ODER
  numerischen Zeichen besteht. Vorher prfte diese Funktion nur auf numerische Zeichen, der Name war also falsch
- PrintF in Print umbenannt. Naja typische Schnheitsoperation, sollte dies auf heftigen Widerstand stoen knnen wir es auch wieder
  umbennen, aber ich finde so ein groes F am Ende irgendwie hlich ;-)
- Insert (char) entfernt. Wenn dies nicht dringend und an performance wichtigen Stellen gebraucht wird sollte dies lieber ber einen String
  der Lnge 1 gemacht werden
- EatLeadingWhitespace und EatTrailingWhitespace umbenannt in TrimLeading und TrimTrailing. Auerdem noch Trim hinzugefgt, welches
  beides macht. Auerdem geben diese Funktionen nun ebenfalls den String zurck
- Konvertierungsfunktionen aufgerumt. Kleine nderung: Beim =(char) wird nun der Buchstabe ausgegeben, nicht dessen Ascii-Wert.
  Dies war zuvor inkonsistent, bei =(char) wurde die Zahl genommen, bei += jedoch der Buchstabe
- Const bei entsprechenden Methoden hinzugefgt
- String-Klasse liegt nun in Base
PLGeneral:
- PLTRefCount Template hinzugefgt, Basisklasse fr Reference Counting
- PLTRefCountPtr Template hinzugefgt, diese Klasse ist ein spezieller Reference Counter fr externe Objekte
- SmartPtr-Template hinzugefgt. Diese Klasse arbeitet mit dem PLTRefCount Interface und berprft dabei,
  ob das verwendete Objekt dieses Interface untersttzt oder nicht. Falls nicht wird mittel PLTRefCountPtr ein
  externer Reference-Counter fr das Objekt erzeugt, es ist jedoch besser, wenn die Klasse auf die gezeigt
  wird von PLTRefCount abgeleitet wird, da dies Fehler z.B. durch doppeltes Zuweisen des gleichen Zeigers
  besser verhindern kann
- Alle Klassen auf die neue PLTRefCount-Klasse umgestellt



>> 07.01.2006
[CO]
- RTTIDefs.h: Da 'VAR_OFS' bei Stephan unter Linux Compiler Warnungen verursacht bastelte er ein Makro welches unter Linux 
  keine Warnungen produziert. Da VC aber anscheinend kein '__alignof__' kennt musste ich hier defines einsetzen, unter 
  Windows das eine Makro, unter Linux das andere... vielleicht bekommt man irgendwann spter etwas Universelles zusammen das 
  berall sauber geht, aber ich denke wir knnen das erstmal so lassen.



>> 03.01.2006
[SW]
Alle Projekte:
- Habe das subversion property "svn:eol-style 'native' " fr die source-files, text-files und project-files gesetzt.
  dieses property sorgt dafr, das beim checkout,update die eol-kennung entsprechend des OSes ist
  d.h. unter linux ist die eol-kennung nur \n und unter windows \r\n und zwar egal vom welchem os aus diese
  Datei verndert oder erstellt worden ist



>> 02.01.2006
[SW]
- Memleak in der String-klasse unter linux behoben. Das Problem war das die _vscprintf-implementation
  fehlerhaft war(ein return hat gefehlt, *asche ber mein haupt*).
  Da die vsnprintf-function unter linux das selbe macht, wurde die protabele_vsnprintf-fn aus GeneralLinux.cpp
  entfernt.



>> 01.01.2006
[SW]
- habe die kompabilitt zu gcc 3.4 hergestellt bzw. zum c++-template standard
  zum einen musste ich den header string.h in HashTable.inl hinzufgen, weil sonst der gcc mit folgender fehlermeldung 
  bezglich strlen, strcpy,strcmp abbrach:
  "there are no arguments to `strcmp' that depend on a template parameter, so a declaration of `strcmp' must be available"
  Die nderung von AType zu AType1 in der friend declaration in den Dateien ResourceManager.h, ResourceHandler.h und 
  Resource.h war ntig weil sonst der gcc mit folgender Fehlermeldung abbrach:
  "include/PLGeneral/Base/ResourceManager.h:32: error: declaration of `class AType'
   include/PLGeneral/Base/ResourceManager.h:25: error:  shadows template parm `class AType'"
  es msste nur getestet werden ob diese nderungen keine probleme verursachen
- tinyxml: habe eine statische lib fr linux von tinyxml in den zips hinzugefgt und tinyxml.h so abgendert das sie auch 
  unter linux bersetztbar ist
  
  
>> 01.01.2006
[CO]
- PLTString &PLTString::operator += (char nCharacter): Hier waren die Parameter vertauscht



>> 22.12.2005
[CO]
- Optimierte PLTHashTable da diese Klasse recht hufig verwendet wird und etwas lahm war... die alte Implementation war etwas 
  drftig. Bei 'Add()' wird nun nicht mehr geprft ob dieses Objekt bereits eingetragen ist - das muss der User schon selbst 
  machen wenn er hier unsicher ist und das jedesmal inter zu prfen ist schlichweg zu Aufwndig... Codes angepasst habe ich 
  keine da wir eh vorher immer im  Falle des Falles prfen. Nahm diverse berflssige 'Sicherheitsabfragen' raus - denn in 
  den Innereien kann man IMMER davon ausgehen das die gegebenen Dinge stimmen da diese bereits vorher mal geprft wurden. :)
  Desweiteren wird nun zwischen gro/kleinschreibung unterschieden. Die neue Implementation ist nun teils mehr als doppelt 
  so schnell wie die alte und die Namen knnen beliebig lang sein.
- PLTResource & PLTResourceHandler: Die alte Resource Handler Implementation war viel zu umstndlich - daher machte ich dies 
  'direkter', Resource kann also intern direkt auf Handler zugreifen und umgekehrt... da diese Dinge stark zusammenhngen 
  ist das denk ich ok und es vereinfacht die Sache enorm. Wenn ein Resource Manager automatisch nicht lnger verwendete 
  Resourcen lschen soll, lschen nun die Resource Handler die alte Resource wenn diese nicht mehr verwendet wird.



>> 15.12.2005
[CO]
- Da PLTString nun stark an Bedeutung gewinnt, berarbeite ich die String Klasse nochmal komplett - die alte Implementation 
  war leider teils heftig Buggy/Unbefriedigend. Das berarbeiten war zwar einiges an Arbeit, aber ich denke es hat sich 
  definitiv gelohnt. :)
- Stellte intern die Speicherung von Namen im Resource Manager auf PLTString um - den Rest in PLGeneral wird Stefan 
  anpassen. Das verwenden von PLTString zur Speicherung von Namen bringt einige Vorteile, zum einen haben wir so keinen 
  Overflow mehr wenn man einen lngeren Namen hat als Speicher fr einen Namen verfgtbar ist... und zum anderen Spart man 
  einiges an Speicher da ein 'leerer' String gerade mal 4 Byte gro ist... und ansonnsten wird nur soviel Speicher fr den 
  String verwendet wie wirklich ntig ist. Also nicht mal fest char[256/1024 usw.] anlegen und hoffen das dies reichen 
  wird. ;-)
- In PLTParameters::AddParam() kam es nun nach 'PLTVariant *pVar = new PLTVariant(cParam);' zum Crash da in 
  'PLTVariant::m_sName' merkwrdigerweise Schrott stand. Machte hier eine kleine nderung, lies aber das vorherige als 
  Kommentar drinen. Stefan, schau bitte mal was hier schiefgeht und ob man es so wie es jetzt ist lassen kann.



>> 12.12.2005
[CO]
- PLTXmlElement::GetFirstAttribute(): An ein paar Stellen wo ich diese Funktion verwendete hatte ich vergessen vorher zu 
  Prfen ob hier berhaupt etwas zurckgegeben wird bevor ich es verwende - wieder soetwas wo man sich schwer wundert das 
  dies nicht schon vorher aufgefallen ist. ;-)
- Nahm wie besprochen die Prioritten aus dem Resource Manager da diese dort mehr rger als nutzen bringen
- PLTSingleton: 'm_pInstance' bekommt nun im Constructor die Instance zugewiesen und nicht mehr in GetInstance(). Nach den 
  kleinen nderungen im Resource Manager Template hatte ich hier in den konkreten Resource Managern nun das Problem das 
  in deren Constructoren teils GetInstance() verwendet wird - jedoch lieferte dies zu diesem Zeitpunkt NULL zurck da diese 
  Variable erst noch gesetzt werden musste. (endlos Rekursion :)
  Ich hoffe diese kleine nderung geht ok...



>> 08.12.2005
[CO]
- PLTResourceManager: Die Funktion Get(<Name>) ist nun virtuell, in der Engine beim Scene System hat diese Funktion eine 
  erweiterte funktionalitt da man ber z.B. 'Root.Scene.Jeep' auch 'absolute Namen' angeben kann. Machte SetResourceName() 
  Protected da es reichen msste wenn man ber PLTResource::SetName() den Namen einer Resource setzen kann. 
  PLTResource::SetName() ist nun ebenfalls virtuell da z.B. in der Engine bei PLTSceneContainer in Namen kein '.' vorkommen 
  darf und der Name 'Root' nicht verwendet werden darf. (NUR die Root Node selbst hat diesen Namen :)
  Dummerweise musste ich auch Get(<int>) virtuell machen und in PLTSceneContainer implementieren, ansonnsten bekam ich 
  folgende Fehlermeldung:
    "error C2664: 'PLTSceneContainer::Get': Konvertierung des Parameters 1 von 'int' in 'const char *' nicht mglich"
  Was machen wir hier? Irgendwie ist das total dmlich. :(



>> 02.12.2005
[CO]
- PLTHeap: Kann nun auf Wunsch auch den Key zurckgeben



>> 30.11.2005
[CO]
- PLTBase::SetVars(): Konnte kein '=' gelesen werden, wurde das nchste gefundene Wort 'bersprungen' was nicht korrekt war.



>> 20.11.2005
[SB]
- Habe das Interface von PLTContainer verndert: Die Funktion Add(const AType &Element) gibt nun ebenfalls einen AType* Zeiger zurck.
  Man braucht dies nicht, wenn man nur eine Liste von Zeigern hat, besteht die Liste jedoch aus direkten Objekten, welche kopiert werden,
  ist dieser Zeiger sehr ntzlich, ansonsten wrde es wesentlich umstndlicher.
- Habe in PLGeneral und PLMath alle Aufrufe von Add(const AType &Element) angepat - da vorher true als Fehler zurckgegeben wurde, nun
  aber NULL fr den Fehlerfall steht, mu leider jeder Aufruf angepat werden. Habe dies auch in den anderen Projekten getan.



>> 18.11.2005
[SB]
- Include von PLTLog in PLTSingleton entfernt, dadurch muten an anderen Stellen die Include-Files gendert werden



>> 10.11.2005
[CO]
- PLTResourceManager<AType>::SetResourceName(): Ohman, wie konnte DIESER total dmliche Bug nur soo lange unbemerkt 
  bleiben? (war natrlich mein verschulden :) Hier wurde zuerst der neue Resourcen Name gesetzt, und dann wurde die 
  Resource mit hilfe diesen neuen Namens aus 'm_lstNameHashList' entfernt und dann mit dem neuen Namen wieder 
  hinzugefgt... brrr, natrlich muss die Resource mit dem alten Namen aus 'm_lstNameHashList' entfernt werden.



>> 09.11.2005
[CO]
- PLTTools: Neue Funktion: CombineStrings(): Kombiniert Strings miteinander. Diese Funktion wird u.a. im Renderer in den 
  Shader Backends bentigt um den Shader korrekt zusammenzukopieren... denn hier mssen noch Renderer & Custom Definitionen 
  in den Shader eingefgt werden.
- PLTList: Get() & ReplaceAtIndex() & AddAtIndex() & RemoveAtIndex() & Compare() etwas Optimiert: Ist der Index in der 
  'hinteren' hlfte, so wird nun vom letzten Element rckwrts durchlaufen wodurch man in diesen Fllen eine bessere 
  Suchzeit hat... wenn man schon ne doppelt Verkettete Liste hat, so kann man auch ruhig die Vorteile die diese bietet 
  nutzen. ;-)
  Passte ebenfalls PLTPool & PLTFastPool entsprechend an.



>> 07.11.2005
[SB]
Alle Projekte:
- Habe im Repository die Verzeichnisse _Branches und _Tags entfernt - ich fand die strend, und wir nutzen das bisher eh nur sehr selten.
  Der PLGeneral-Branch sitzt nun direkt im Hauptverzeichnis, was nicht weiter stren sollte, zumal Branches ja sowieso keine allzu lange Zeit
  am Leben sein sollen :-)



>> 02.11.2005
[CO]
- Reset-Funktion zu PLTArray hinzugefgt mit der man den Array 'zurcksetzen' kann - recht praktisch das
- PLTTools: Neue Funktionen: GetIntegersFromString(), GetFloatsFromString() und GetDoublesFromString()



>> 01.11.2005
[CO]
- PLTXmlDocument: LoadFile() und SaveFile() setzen nun den Dokument Wert auf den Dateiname + einen TinyXML Fehlercode
  wenn die Datei nicht geffnet werden konnte.



>> 29.10.2005
[CO]
- PLTSystem: Vergrerte die Anzahl der Slots der Hash Tables von m_hashClasses & m_hashModules da ich derzeit 217 Klassen, 
  und 19 Module zhle - so ist die Hash Table wieder Effektiver und da es nur eine Instance von PLTSystem gibt gibts auch 
  Speicher mig keine Probleme.
- Es knnen nun auch Passwort Geschtze Zip-Dateien verwendet werden. Dafr musste ich PLTFile::Open() um einen weiteren 
  Optionalen Parameter erweitern. (das Passwort wenn bentigt)



>> 25.10.2005
[CO]
- PLTTools: Neue Funktion GetBooleanFromString() welche einem den booleanischen Wert in einem String zurckgibt. Dies ist 
  z.B. beim Auslesen von XML Attribute Werten recht praktisch da der User dadurch '0' oder auch 'false' schreiben kann.
  PLTVar::Set() verwendet nun ebenfalls diese Funktion damit das Einheitlich gehandhabt wird.
- PLTXmlElement: Schlgt das zurckgeben eines Attribute Wertes fehl, so ndert TinyXML troztdem die bergebene Variable - 
  das ist total unpraktisch und darum wird hier nun diese Variable nicht mehr gendert falls die Funktion fehlschlgt. 
  Hatte mir schon berlegt diese nderung direkt in TinyXML zu machen, sah aber davon ab da dies eventuell Probleme 
  verursachen knnte.



>> 24.10.2005
[CO]
- PLTBase: Um Funktion AddVarsToXMLElement() erweitert welche die Variablen zu einem XML Element hinzufgen. Dabei kann man 
  als Parameter bergeben ob die Variablen als Attribute oder Elemente hinzugefgt, und ob Variablen mit Default Werten 
  irgnoriert werden sollen. Da dieses 'Variablen zu XML Element hinzufgen' fters bentigt wird, ist diese hilfs Funktion 
  ziemlich praktisch. Das 'Gegenstck' zu dieser Funktion SetVarsFromXMLElement() ist ebenfalls vorhanden. Diese zweite 
  Funktion kann auf Wnsch selbstndig nach Variablen in den Attributen UND Child-Elementen suchen soll, Default Einstellung 
  ist jedoch Variablen nur in den Attributen suchen.
- PLTConfig ld & speichert nun in einem XML Format, dabei werden die verschiedenen Variablen als Elemente hinzugefgt 
  und auch Variablen mit Default Werten werden ebenfalls gespeichert - das ist hier irgendwie bersichtlicher.
- PLTXmlDocument: LoadFile() verwendet nun eigene File System Funktionen um eine Datei einzuladen und zu Parsen



>> 21.10.2005
[CO]
- PLTConfig: Beim Laden & Speichern kann man nun Optional angeben ob die Config Datei NUR im aktuellen Verzeichniss gesucht
  werden soll. Damit kann man Konflikte zwischen verschiedenen Config Files verhindern - z.B. das plztlich in PLSamples 
  Configs aus PLTools genommen werden da die gewnschten Configs in PLSamples nicht gefunden wurden und PLTools im FS als 
  Basis Pfad eingetragen ist... und somit wurden teils unerwnschte Einstellungen verwendet. :)



>> 05.10.2005
[CO]
- Musste in TinyXML eine weitere kleine nderung vornehmen: Hatte Probleme beim Scene Format da '[' und ']' nicht in Namen 
  vorkommen durften - aber somit konnte eine Scene nicht mehr geladen werden sobald eine RTTI Array Variable verwendet 
  wurde. Also erweiterte ich TiXmlBase::ReadName() so, das auch '[' und ']' in Namen akzeptiert werden... hoffentlich macht 
  das keine Probleme... hat jemand ne Ahnung ob das 'Absicht' ist das '[' und ']' bei XML nicht in Namen vorkommen darf, 
  sprich, es so in den 'Vorgaben' steht? Wenn ja, und wir uns daran halten wollen, mssten wir uns fr RTTI Array Variablen 
  etwas anderes berlegen was aber ziemlich unschn werden wrde.
- An ein paar Stellen wo das RTTI float Variablen in einen String schreiben soll %f durch %g ersetzt damit am Ende keine 
  berflssigen Nullen stehen.



>> 29.09.2005
[CO]
- PLTString::Insert() um weiteren optionalen Parameter erweitert. Ist dieser nicht -1 so gibt dieser die Anzahl der 
  einzufgenden Zeichen an. Desweiteren noch ein paar Tool Funktionen hinzugefgt.
- PLTSystem::ScanPlugins() um optionalen Parameter erweitert. Da wir mittlerweile ziemlich viele dll's haben kann 
  ScanPlugins() vorallem beim Programmstart im Debug Modus nervend viel Zeit in anspruch nehmen da zuerst einmal die dll 
  geladen werden muss und wenn nichts Interessantes drinen ist wird diese wieder entladen. Ist dieser neue Parameter auf 
  'true' (Default = 'true'), so wird anhand des Namens ein kleiner 'Vortest' gemacht so das man meist gut die hlfte der 
  dll's erst gar nicht zu laden braucht was den Scan Vorgang beschleunigt. Dabei wird das 'D' am Ende des Namens geprft. 
  Ist man im Release Modus und ist dort ein 'D' wie z.B. bei PLSampleSceneNodesD.dll so wird dieses Module komplett 
  ignoriert. Da wir selbst uns an diese Namens Konvention halten klappt das hier, der User msste sich am Ende auch daran 
  halten, oder beim Scannen diesen Parameter auf 'false' setzen damit nicht eigentliche gltige Module ignoriert werden. 
  Ist natrlich eine Sache die schnell daneben gehen kann wenn jemand nicht aufpasst - allerdings spart das Wertvolle 
  Ladezeit was ein deutlicher Pluspunkt ist... und eine andere Lsung um die ScanPlugins() Ladezeit zu verkrzen hab ich 
  bis jetzt noch nicht gefunden. Ich machte das da diese Ladezeit gerade im Debug Modus mittlerweile deutlich auffllig - 
  das iss schon fast so nervend wie bei 3D Studio Max wo am Anfang erstmal tausende von Plugins geladen werden welche man 
  teils gar nicht braucht was Debuggen zur Qualt macht. Das Scannen selbst kann man wohl nicht umgehen, aber halt wie 
  gesagt grob anhand des Names 'ausfiltern'. In meinem Debug Modus Test wurden frher beim Programmstart gut 252 mal dll's 
  geladen und entladen. Jetzt nur noch 39 mal - frher war das so hoch da wenn eine dll geladen wird ja auch gleich noch 
  alle damit Verbundenen dll's geladen werden, und beim endladen werden diese anderen dll's meist auch wieder entladen und 
  das gleiche Spielchen immer und immer wieder. Hoffentlich kommt Stefan mit dieser Lsung klar... oder findet etwas 
  besseres. ;-)
  Alternativ knnten wir vielleicht auch alle Plugin in extra Unterordner wie z.B. 'Plugins' und 'PluginsD' packen und dann 
  gezielt beim Initialisieren der Engine in diesen Ordnern Scannen lassen. Aber dann msste z.B. 'Newton.dll' auch im 
  entsprechendem Ordner liegen wenn man was 'rausgibt'... und im Grundordner msste dieses nochmal liegen falls die 
  Anwendung selbst Newton verwendet. (denn in diesem 'rausgeben' Fall wre es nicht gut an den Environment Variablen zu 
  drehen)



>> 25.09.2005
[CO]
Alle Projekte:
  Ging alle PL Projekte durch und machte einige RTTI Variablen 'read only':
  PLTImageLoader, PLTTextureCreator, PLTMeshCreator, PLTSkeletonAniLoader, PLTMeshLoader
PLGeneral:
- PLTFileSystem: Neue Funktion: IsSearchPath() -> Prft ob ein gegebener Pfad ein Suchpfad eines gegebenen Types ist. Dies 
  brauchte ich in PLTMeshLoader wo ich prfe ob ein Pfad bereits eingetragen ist. Wenn nicht, werden bei bedarf 
  whrend des Laden eines Meshs ein paar Suchpfade hinzugefgt und nach dem Laden wieder entfernt. (siehe PLEngine Diary)
- PLTFileType::RemoveSearchPath() korrigiert nun den bergebenen Pfad wenn ntig (sicher ist sicher)



>> 22.09.2005
[CO]
- Neue Funktion: PLTPlatform::ShellOpen(): Das OS ffnet eine Datei mit dem Programm welches mit diesem Datei Typ vernpft 
  ist. Weis nicht ob diese Funktion wirklich in Platform passt oder nicht doch eher ins File System. Auf jedenfall ist diese 
  Funktion recht ntzlich wenn man z.B. auf einen Link Klickt und sofort auf eine Internet Seite kommt - oder wenn man z.B. 
  im Mesh Editor ein Material ffnen will. (in dem Fall wird nen Text Editor mit diesem Material geffnet)



>> 10.09.2005
[CO]
- Der einzige Unterschied zwischen PLTPool und PLTResourceManager bestand darin das PLTPool Element zustzlich noch 
  eine Prioritt haben - wichtige Element liegen dann also immer am Anfang. Da Prioritten bei Resourcen sicherlich auch 
  nicht verkehrt sind erweiterte ich den Resource Manager um solche. Somit hat PLTPool nun keine Existensberechtigung mehr 
  und wurde gekillt. Ntige (meist kleinere) Anpassungen:
  - PLGeneral: PLTProfiling
  - PLModel: PLTAnchorPoint, PLTAnimationEvent, PLTAnimationInfo, PLTMesh, PLTMeshHandler, PLTMorphTargetAni
  - PLEngine: PLTSurfaceListener, PLTSky
  - MeshEditor: TGuiEditAnimationEdit
- Das mit PLTPool hatte ich mir nochmal angeschaut da ich den Namen PLTPool fr etwas anderes brauchte - es gibt nun eine 
  Neue Container-Klasse mit diesem Namen. Im Prinzip handelt es sich hierbei um eine Verkettete Liste wie bei PLTList, 
  jedoch gibts Intern zwei Listen, eine mit den aktuell verwendeten Elementen und eine Liste mit derzeit nicht bentigten 
  Elementen. Diese Klasse ist recht praktisch wenn man viele Dynamischen Elemente Managen will, also wenn hufig Element 
  gelscht und wieder hinzugefgt werden. Beim Lschen wird das eigentliche Element 'nur' zur Liste der freien Elemente 
  hinzugefgt, und fgt man wieder ein Element hinzu wird erst geschaut obs noch ein nicht verwendetes Element gibt - 
  ansonnsten muss wie bei der normalen Liste ein neues erzeugt werden.
- Neben PLTPool gibts noch eine schnellere Variante Namens 'PLTFastPool'. Bei diesem Container MSSEN die Elemente von 
  PLTFastPoolElement abgeleitet sein - damit kann man dann superschnell ein Element direkt vom Container entfernen ohne 
  voher wie bei PLTPool das reale Pool Element zu finden. Diese Klasse ist also Optimal wenn man sehr viele Elemente 
  regelmig lscht und hinzufgt. Ansonnsten verhlt sich diese wie alle anderen Container Klassen auch. In der Engine 
  werde ich wohl PLTParticleGroup auf diese Klasse umgestellen und die neue Scene Hierarchy 'PLTSceneHierarchySphereTree' 
  verwendet diese Klasse ebenfalls da hier oft etwas gelscht und wieder eingefgt wird und dies daher so flott wie mglich 
  gehen muss.
- In PLTList::RemoveAtIndex() war noch nen Bug, der Index wurde nicht erhht - das dies nicht schon vorher aufgefallen ist...
- PLTStack: PushBack() Privat gemacht da dies nicht in das 'bliche' Stack Schema passt
- Neue Klasse: PLTQueue (FIFO) ist das Gegenstck zu PLTStack (FILO)



>> 30.08.2005
[CO]
- PLTBitset::Resize(): Parameter waren vertauscht



>> 26.08.2005
[CO]
- Bei einigen XML Funktionen Funktionen ein Get davor gesetzt + ein paar interne Sicherheits Abfragen auf NULL Zeiger
- XML Interface Kommentare soweit vervollstndigt, sind aber noch hier und da nicht wirklich Aussagekrftig da die TinyXML 
  Doku hier leider teils lckenhaft ist. Einiges undokumentiertes Verhalten hab ich bereits direkt in den Codes nachgeschaut 
  und bei uns Dokumentiert. Drehte auch ein paar boolische Rckgabe Werte um so das diese zu unserem Style passen. 
  (bei Fehler 'true' statt 'false' - da wir fragen 'gabs nen Fehler?' und nicht 'ging alles glatt';-)
- PLTXmlDocument: Eigene Speicher Funktion eingebaut



>> 17.08.2005
[CO]
- XML Wrapper Versucht Nr. 2: Wie beim Treffen bei Jens Besprochen hat nun jede XML Klasse eine eigene Datei und alles 
  liegt in dem  Ordner. Zudem werden von diesen Klassen nun 'echte' Objekte erzeugt. Konkrete PL XML Objekte werden
  erst DANN erzeugt wenn diese bentigt werden - z.B. wenn man sich ein Element zurckgeben lassen will wird intern falls
  zu dem TinyXML Element noch kein PL XML Element vorhanden ist eines erzeugt.
  Mit dieser Lsung kann es sein das bestimmte Elemente/Attribute NIEMALS 'angefasst' werden und man hier daher auch keine
  eigenen PL XML Objekte erzeugen muss. (wird wohl vorallem bei Attributen der Fall sein :)
  Bei der Implementation gabs nen paar Kleinigkeiten zu beachten:
  Da die User Data Variable von TinyXML verwendet wird, muss man beim Kopieren und beim Einfgen der Objekte aufpassen da 
  sonst die PL XML Objekte Zeiger nicht mehr stimmen. nderte in TinyXML TiXmlNode::CopyTo() es so das User Data NICHT
  mehr mitkopiert wird - denn das im Wrapper zu kompensieren war zuviel Aufwand. (rekursiv)
  Das Lschen der PL XML Objekte war etwas mehr Aufwand da man rausbekommen musste wann ein TinyXML Objekt zerstrt wurde - 
  da TinyXML aber soetwas nicht anbietet erweiterte ich TinyXML um eine Destroy-Callback Funktion welche jedesmal aufgerufen 
  wird wenn ein Objekte zerstrt wird. Durch diese Mini Erweiterung spart man sich dann in unseren Wrapper eine ganze Menge 
  an Arbeit. :)
  Alles in allem find ich diesen Wrapper recht brauchbar und der Aufwand/Nutzen Faktor stimmt. Mit einer komplett eigenen
  internen Hierarchy wre alles mehr Arbeit als dies momentan der Fall ist. Zwar musste ich nun zwei mini nderungen an 
  TinyXML selbst machen - aber ohne diese nderungen htte man sich teils heftig im Wrapper verbiegen mssen um es sauber
  laufen zu lassen, ich finde das ist nen akzeptabler kompromiss zwischen 'TinyXML umschreiben und direkt in PLGeneral',
  'gesammte XML Hierachy selbst Managen' oder gar gleich 'komplett eigenen XML Parser schreiben'.



>> 16.08.2005
[CO]
- PLTTokenizer::GetNextToken(): Quote verhalten minimal gendert. Bis jetzt wurden = und ` gleich gehandelt. Man konnte also
  mit " starten und mit ` Enden. Nun wird es so gehandhabt das wenn mit " begonnen muss es mit " auch wieder enden muss. Hat
  den Vorteil das man nun Quotes 'Schachteln" kann was enorm Praktisch ist. z.B. kann man nun Problemlos eine Scene Node 
  erzeugen dessen Mesh automatisch erzeugt wird mit z.B. 
  pContainer->Create("PLTObject", "Sphere", "Pos=\"0.0 0.0 5.0\" MeshFilename=\"PLTMeshCreatorSphere 
  Name=`Sphere` Radius=`4.0` Detail=`20.0`\"");
- PLTArray: Ist nun wieder ein 'richtiger' Array, bei meinen Tests hatte ich keine Probleme und alles luft mit dieser 
  nderung genau wie frher. nderungen in den anderen Codes sind nicht ntig. Mit GetData() bekommt man den Zeiger auf 
  das erste Element des Arrays.
- Vertauschte bei PLTBitset & PLTArray Init & Add Parameter - denn Init sollte im Normalfall false sein und nicht gendert
  werden. (auer man weis genau was man tut :)
  Init ist praktisch wenn man GENAU weis das man einen Primitiven Variable Typ wie float hat oder einfache Klassen - aber 
  sobald z.B. virtuelle Funktionen ins Spiel kommen sollte man nie nie nie den Init Parameter auf True setzen da memset
  zum Initialisieren der Elemente verwendet wird!
  Keine Anpassungen in PLBase ntig, ansonnsten nur eine Handvoll Parameter Anpassungen in allen Projekten zusammen.
- PLTBitset: SetResizeCount() hat nun den Default Wert 320 - denn da jedes Element hier nur 1 Bit ist und je 32 Bits in
  eine Integer Variable 'passen' ist es so wesentlich Effizienter.
- PLTBitset & PLTArray: RemoveAtIndex() verkleinert nun bei Bedarf den Array wieder. NUR diese Funktion lscht die
  Elemente, alle anderen verwenden diese nur.
- PLTVar::SetEnumString(): Da m_lstEnum Array ist und jedesmal wenn ein neues Element hinzugefgt wird sich die Adresse 
  im Speicher von anderen Elementen ndern kann, darf man m_hashEnum erst nachdem alle Elemente eingetragen wurden
  erzeugen.



>> 10.08.2005
[CO]
- Wrapper fr TinyXml geschrieben und im Tools Unterordner abgeladen. (+ Base Test um XML Test erweitert)
  Der Wrapper ist noch nicht 'perfekt' und es fehlen noch nen paar PL spezifische Funktionen fr z.B. das eigene
  File System verwenden.



>> 06.08.2005
[SB]
- PLTWin32File::GetS() filtert nun nicht mehr das '\n' heraus sondern verhlt sich jetzt genauso
  wie fgets(). Vermutlich werden wir jetzt aufgrund des neuen Verhaltens einige andere Stellen
  anpassen mssen, aber es ist ja immer besser sich an Standards zu halten :-)
- PLTWin32File::PutS() gibt jetzt die lnge des Strings zurck, wenn es beim Schreiben keine
  Fehler gab, damit liefert PLTFile::Print() auch keine lstigen Fehler mehr. Bin mit nicht 100%
  sicher, ob das auch beim Textmode immer funktioniert, sollte aber eigentlich :-)
- Habe einen neuen Branch fr PLGeneral erstellt, an dem ich in nchster Zeit arbeiten werde.
  Da ich noch einiges an PLGeneral ndern mchte und es unpraktisch wre, dies im "laufenden Betrieb"
  zu tun, da dann stndig alles angepat werden mte, ist dies eine gute Gelegenheit, mal Branches
  in Subversion auszuprobieren. Dies ist also eine Kopie des aktuellen PLGeneral, an der ich
  beliebig arbeiten kann, wenn die Arbeiten abgeschlossen sind werden die nderungen wieder mit
  dem Hauptzweig gemerged - bei Bedarf kann man das auch zwischendurch schon machen, wenn ich z.B.
  nur einen kleinen Bugfix mache, der auch in der aktuellen Version ok ist, oder andersherum
  wenn jemand am Hauptzweig was ndert was ich gleich bernehmen kann. Also mal schauen wie gut
  das funktioniert :-)



>> 28.07.2005
[CO]
- Erweiterte das Resource Manager Template um die Virtuelle Funktion PLTResource::DestroyResource(), diese Funktion
  wird/sollte nun immer anstatt delete <Resource> verwendet werden. Als Standard ist ein einfaches 'delete' 
  Implementiert - in PLTSceneNode ist es aber ntig VOR dem Lschen die Scene Node sauber aus dem Container zu 
  entfernen. Vorher wurde in PLTSceneNode erst direkt im Destruktor der Knoten aus dem Container entfernt - dies 
  machte aber casting-Probleme da anscheinend bereits Teile des Objektes gelscht waren was dazu fhrte das
  DeInitFunction() nicht mehr korrekt aufgerufen wurde.



>> 11.07.2005
[CO]
- PLTPlaneSet::IsBoxIn() kann nun Optional noch mit ausgeben welche Ebenen die Box schnitten.



>> 11.06.2005
[CO]
- Da ich merkte das man das Informer&Listener Prinzip immer wieder bentigt und es mir einfach zu dumm wurde
  das immer wieder von neuem zu Implementieren erstellte ich Informer&Listener Templates an und legte diese im 
  Base-Unterordner ab. (PLTSceneQuery und PLTSceneQueryListener in der Engine verwenden diese Templates bereits)
- PLTString etwas erweitert



>> 17.05.2005
[CO]
PLTPlatform:
- Fgte Funktionen fr Multi-Tasking hinzu da die Rechner (und vorallem neue Konsolen :) immer mehr CPU's
  haben, muss man zwangslufig versuchen wo immer mglich bestimmte Aufgaben als eigene Tasks zu realisieren um 
  diese Systeme Effektiver nutzen zu knnen. PLPhysics z.B. werd ich dann gleich in einem eigenen Task laufen
  lassen da dies dort 'relativ' Problemlos mglich ist - und der Trend bei Physik geht eindeutig zum eigenen
  Task dafr. (Thema Physics CPU etc. :)
  Auch msste man nun so Ladebildschirme realisieren knnen welche lustige flssige Animationen zeigen whrend Parallel 
  dazu in einem Task die Daten geladen werden.
  Damit mssten wir auch das CPU/GPU Problem besser in den Griff bekommen... denn wenn die CPU im Hauptprogramm an einer 
  Stelle einmal dummerweise auf die GPU warten muss, wird die CPU im Hintergrund fr z.B. die Physics weiter verwendet so 
  das keine/kaum Resourcen brach liegen.
  Hab mich beim Design an der SDL Implementierungen Orientiert da dies im Endeffekt recht Einfach zu verwenden 
  und Sinnig ist. (und es lsst sich sicherlich kaum anderst machen da man ja nur die Grundfunktionen Wrapt :)
  Der User selbst kommt nur mit einer Handvoll Funktionen fr Task & Mutex in Kontakt. Intern und vorallem
  bei den Linux Implementierungen ist das alles teils ziemlich umstndlich - da man dort anscheinend XXX
  verschiedene Flle beachten muss. Hab dort die Funktionen aus SDL bernommen, Stephan muss da aber nochmal drber schaun
  ob das so ok ist und natrlich das mal ausprobieren - das wir endlich auch mal Multi-Tasking verwenden/unterstzen sollen
  war ja schlielich seine Idee. ;-)
  Ich bin mir seeehr sicher das es sich so wie es momentan ist noch nicht einmal bersetzten lsst. ;-)
  Erweiterte PLBaseTests gleich um einen einfachen Multi-Tasking Test.



>> 12.05.2005
[CO]
- PLTBase::SetVars(): Der Tokenzier behandelt hier '[' und ']' nun nicht mehr als einzelne Zeichnen da ansonnsten Variable
  Namen wie 'Test[3]' nur als 'Test' gelesen werden - sehr merkwrdig das dies bis jetzt noch nicht Aufgefallen war. ;-)
- PLTConfig::GetVarInt() bercksichtigt nun die Flle wenn die Variable vom Typ Flag oder Enum ist
- PLTResourceManager<AType>: Add() & Remove() waren noch nicht ganz ok. Der Resource wird nun mitgeteilt das dies nun in 
  dem Manager ist und bei Remove() das diese nun in keinem Manager mehr ist. Den Bug merkte ich erst als ich eine Resource
  nachtrglich einem Manager zuwies in es einen Crash gab als der Manager wieder gelscht wurde... ohmanohman, wie konnte 
  ich das nur bersehen. ;-)



>> 09.05.2005
[CO]
- In VC 7.1 spuckte der Compiler bei PLGeneral leider diverse Fehler aus. Diese liesen sich aber zum Glck recht leicht
  beheben:
- PLTSingleton
  template <class AType> PLTSingleton<AType>::__Destruction_Guard PLTSingleton<AType>::__Guard;
  Hier muss typename Eingefgt werden:
  template <class AType> typename PLTSingleton<AType>::__Destruction_Guard PLTSingleton<AType>::__Guard;
- PLRTTIDefs.h
  template <class T> typename PLTModuleID<T>::SelfInit__Class PLTModuleID<T>::__SelfInit;
  Hier muss ebenfalls typename Eingefgt werden:
  template <class T> typename PLTModuleID<T>::SelfInit__Class PLTModuleID<T>::__SelfInit;
- PLTParameters::AddParam(const char *pszName, const PLTVariant &cParam) -> cParam ist nun const -> Machte sonst Probleme
  unter VC 7.1. und noch krassere Probleme auf dem Linux Compiler :)
- Musste in PLGeneralWin32.h auf einmal das Makro 'min' selbst definieren da es ansonnsten nicht gefunden werden konnte
Beseitigte probleme welche bei Stephans Linux Compiler auftraten:
- PLTSystem: Friend Definitionen:
 'friend class PLTModuleID<int>;
' zu 'template<class T> friend class PLTModuleID;
' gemacht
- PLRTTIDefs.h: Ca Zeile 150: 'template PLTModuleID<int>;' wurde entfernt da es Compiler Probleme verursachte.
  (die Zeile wird anscheinend auch nicht bentigt :)
  Desweiteren musste hier 'PLSystem.h' eingebunden werden und in PLBase.h wurde 'PLSystem.h' entfernt.
  (sollte keinen Unterschied machen - tut es aber ;-)



>> 07.05.2005
[CO]
- PLTBase::SetVars() minimal gendert so das auch 'PLTTextureCreatorASCII3D Name=ASCII3D' verstanden wird. In dem Fall wird
  wie blich eine Fehlermeldung ausgegeben das bei 'PLTTextureCreatorASCII3D' ein '=' + Wert fehlt, der Rest wird nun aber 
  trotzdem weiterverarbeitet.
- PLTFileSystem::OpenInPaths() -> Hier wird nun zuerst in den Suchpfaden fr den Typen (falls angegeben) gesucht, erst 
  wenn das nicht klappt wird versucht direkt zu ffnen. (ansonnsten hatte pszType keine Auswirkung)



>> 27.04.2005
[CO]
PLTConfig:
- Implementiere die Funktionen Load() und Save(). Load() ist kein greres Problem, Save() hingegen bietet die Mglichkeit
  entweder ALLE aktuellen Konfigurationen zu speichern oder nur diejenigen welche in einer bestimmten Konfigurations-Gruppe 
  sind. PLTConfig::GetInstance()->Save("All.cfg"); speichert allso ALLES in eine Datei namens 'All.cfg', whrend
  PLTConfig::GetInstance()->Save("Engine.cfg", "PLTEngineConfigGroup"); NUR diejenigen Konfigurations Klassen in eine Datei
  speichert welche von PLTEngineConfigGroup abgeleitet wurden. PLTEngineConfigGroup hingegen wurde von PLTConfigGroup 
  abgeleitet. Auf die Art ist das Config-System nun sehr flexibel und man kann beliebig neue Gruppen von Gruppen von Gruppen
  etc. Erzeugen. Die Engine selbst ld/speichert also NUR 'PLTEngineConfigGroup'. :)
  Passte gleich PLRenderer (jedes Backend ld/speichert sich selbst), PLEngine und PixelLab + Plugins an. (nur minimalste 
  Erweiterungen :) Bei der Gelegenheit vergab ich dort auch gleich entsprechende Variable Namen.
- PLTFileSystem::AddBaseDir() -> Baute Abfrage ein ob dieser Basis-Pfad bereits Regestriert ist.



>> 23.04.2005
[CO]
Alle Projekte:
- Stellte bei ALLEN Projekten die Release Einstellungen etwas Resourcen schonender ein. Im Netz gibts nen kleinen 
  Artikel Namens 'Compiler Optimization Of MechAssault 2' wo diese Einstell 'Tips/Tricks' beschrieben wurden.
  - Exception handling /EHsc) wird Deaktiviert - wir verwenden dad sowieso nicht
  - Whole program optimization (WPO) Aktiviert



>> 10.04.2005
[CO]
- PLSingleton.inl: Hm, irgendwie will das mit PLTLog dort nicht funktionieren. Sobald das Log hier verwendet wird beendet 
  sich jedes Programm welches PLGeneralD.dll mal kurz prft sofort ohne weitere Warnungen!??



>> 09.04.2005
[CO]
- Stellte PLGeneral auf neuen Kommentar Style um. PLSingleton.inl: Dort wo '[TODO] Add to log' stand stellte ich auf PLTLog
  um. PLTZipDate -> Packte die Inline Funktionen in PLZipDate.inl.



>> 20.03.2005
[SB]
- PLTZipStream::Read():
  Auch hier mu nun nSize und nCount angegeben werden, um Daten aus dem Stream auszulesen.
  Zwar wird intern wieder multipliziert und Byteweise gelesen, jedoch ist dies zur Kompatibilitt
  mit anderen Funktionen ntig: Will eine Funktion einen Block von 18 Byte lesen, so ist der
  korrekte Rckgabewert nach dem Lesen '1', und nicht '18', die Anzahl der gelesenen Bytes mu
  also noch einmal durch die Blockgre geteilt werden. Genau dies fhrte zum Fehler beim
  Lesen von "standardflare.tga", da der falsche Rckgabewert '18' gefunden wurde, brach DevIL
  das Lesen der Datei ab


  
>> 20.03.2005
[CO]
- PLTZipFile::Seek() -> Wird der Offset auf 0 gesetzt, so wird nur zurckgesetzt, aber nicht 0 Bytes gelesen.
  (knnte probleme machen)



>> 02.02.2005
[CO]
- PLTVar::Set() -> Fgte optionalen Parameter hinzu mit dem man den Aufruf von VarChanged() unterdrcken kann. Z.B. ist
  der Aufruf von VarChanged() in PLTBase::IsVarDefault() total ungnstig da im schlimmsten Fall hierdurch etwas kaputt gehen
  kann - das hatte ich beim Klonen im WE. Danach waren die Orginal Entities pltzlich in keiner Gruppe mehr da der Gruppen
  String leer war. Diese Gruppen wurden Dynamisch hinzugefgt - dumme Sache das, derzeit hab ich noch keine Ahnung was man
  da machen kann auer auch die Dynamischen Gruppen einfach zu diesem String hinzuzufgen.
  Zudem ist das hier in PLTBase::IsVarDefault() nen totaler Overhead. Mir gefllt das zwar irgendwie nicht mit diesem Extra
  Parameter da priniziell IMMER Informiert werden sollte, aber bis uns fr PLTBase::IsVarDefault() was besseres einfllt ist
  das denk ich ok. Hauptsache es geht hier (vorallem im WE :) erstmal ohne oben Beschriebene Probleme beim einfachen
  Vergleichen zu erzeugen. Hatte mit VarChanged() auch bei PLTEntity Probleme wenn nen Entity noch nicht Initialiert war,
  aber bereits seine Variablen z.B. beim Initialisieren gesetzt wurden. Das umging ich dort ber IsInitialized() Tests. 



>> 25.02.2005
[CO]
- PLTBase::GetVars() -> Intern auf PLTString umgestellt da ansonnsten der String aus PLTString wieder zerstrt wurde und am 
  ende Schrott in pszBuffer Kopiert wurde.



>> 23.02.2005
[CO]
- PLTString um ein paar Sicherheits abfragen erweitert



>> 22.02.2005
[SB]
- Neue Klassen:
  - PLTVariant: Dies ist ein Variabler Datentyp, welcher verwendet werden kann wenn der Datentyp einer
    Variablen nicht feststeht. Dies wird bei dynamischen Parametern verwendet, auch knnte die Scriptsprache
    spter gebraucht davon machen. Ansonsten sollte es aber eigentlich kaum Verwendung dafr geben :-)
  - PLTParameters: Dynamische Parameterliste, die bei Methodenaufrufen bergeben werden kann. Im Moment ist
    dies nur fr den Konstruktor da, wenn das RTTI eine Klasse mit Parametern kreieren will. Sollte das
    RTTI spter noch um dynamische Methodenaufrufe erweitert werden, wird diese Klasse auch dort Verwendung
    finden
- RTTI-Makros angepat:
  - DEFINE_CLASS erstellt keine ffentlichen Konstruktoren mehr, arbeitet also so wie vorher DEFINE_CLASS_PRIVATE
  - Zum Erstellen ber CreateInstance() mu nun zustzlich das Makros DEFINE_CONSTRUCTION_PUBLIC hinzugefgt werden
  - Zustzlich kann ein Konstruktor definiert werden, dem Parameter bergeben werden knnen, dies geschieht mit
    DEFINE_CONSTRUCTION_PARAMS, der Konstruktor mu die form Class(PLTParams&) haben
  - Vor den Variablen mu die Liste mit DEFINE_VAR_LIST begonnen werden
  - Durch diese nderungen war es nun mglich, das Registrieren der Variablen wieder einfacher zu gestalten,
    es mssen also keine Variablen mehr rckwrts und von vorne eingetragen werden. REDEFINE_VAR wurde
    ebenfalls entfernt, statt dessen werden bei DEFINE_VAR schon vorhandene Variablen mit dem gleichen
    Namen einfach berschrieben
  - Neue PL_VAR-Variablentypen hinzugefgt
  - Bei DEFINE_VAR mu nun immer auch der Enum-String als letzter Parameter angegeben werden, dafr wurde
    DEFINE_ENUM entfernt
  - Bei DEFINE_VAR kann hinter der Variablen nun noch ein Variablen-Name angegeben werden. Ist dieser "",
    wird wie bisher der richtige Name der Variablen verwendet
- PLTBase: IsVarDefault() hinzugefgt
- Klassen an neue RTTI-Definitionen angepat



>> 11.02.2005
[CO]
- RTTI: REDEFINE_VAR() funktioniert durch die letzte nderung nicht mehr da die Basis-Variablen nun erst bei Init()
        eingetragen werden. Zuerst wollte ich ne PLTClass Interne Liste anlegen wo die dann bei Init() zu 'berschreibenden'
        Variablen eingetragen werden... Aber ich merkte schnell das dies etwas viel Aufwand ist - und wenn wir das so machen
        wollen wre es das beste wenn Stefan, der sich ja deutlich besser mit dem RTTI auskennt das bernimmt. Ich entschloss
        mich stattdessen erstmal in den MeshLoadern DEFINE_VAR() zu verwenden. Und will die Basis-Klasse dann ihre gleiche
        Variable eintragen geht das schief da diese Variable bereits vorhanden ist. War die einfachste Lsung - nur Typ
        Sicherheit hat man damit nun natrlich nicht... da knnte man ne Warnung ins Log schreiben wenn wir das so lassen
        wollen...
        Macht REDEFINE_VAR() berhaupt noch Sinn? Denn dann msste man auch DEFINE_ENUM() etc. Varianten anbieten.
- PLTLog::Open() -> Erzeugt nun ein neues Log wenn kein solches vorhanden ist.



>> 10.02.2005
[CO]
- PLTArray::AddAtIndex() und PLTList::AddAtIndex() waren noch nicht ganz ok. Wenn man ganz am ende ein neues Element einfgen
  wollte ging das noch nicht wie erwartet. Dadurch funktionierte bei mir dann das Regestrieren der Klassen-Variablen nicht
  richtig.



>> 09.02.2005
[SB]
- PLTConfig: Die Methoden GetVarb() etc. umbenannt in GetVarBool(), GetVarInt(), etc. Wie haben bisher immer aussagekrftige Namen
  verwendet, daher sollten wir dies auch hier tun. Es wre zu berlegen, ob Methoden dieser Art nicht gleich in PLTBase
  eingebaut werden sollten, um es dem Programmierer zu erleichten, auf Variablen zuzugreifen (ist natrlich dann
  schlecht, wenn der Programmierer den falschen Typ verwendet).
- PLTConfig: Habe AddClass() wieder entfernt und durch eine simple "Create-On-Demand" Lsung ersetzt, da mir kein Grund einfiel,
  der dagegen sprach :-) Wenn jemand versucht, auf eine Konfiguration eines bestimmten Typs zuzugreifen, wird erst
  einmal geschaut, ob es diese schon gibt. Wenn nicht, wird das Objekt in dem Moment erzeugt und zurckgegeben.
  Sollte whrend das Programm luft niemand versuchen, auf eine Config-Klasse zuzugreifen, wird diese auch niemals
  erzeugt, was ich auch fr genau richtig halte, warum sollte man erst einmal alle mglichen Objekte erzeugen,
  wenn diese dann gar nicht gebraucht werden? Wir mssen da nur evtl. beim Speichern darauf achten, aber es stellt
  sich mir sowieso die Frage, ob das Speichern der gesamten Konfiguration sinnvoll ist, da ja z.B. Game-Config und
  Engine-Config nicht zusammen in eine Datei kommen sollten.
- PLTSystem: Eintragen der Config-Klassen wieder ausgebaut (s.o.). Lsungen dieser Art sollten grundstzlich vermieden werden,
  da sie die Hierarchie eines Systems durcheinander bringen. PLTSystem steht ganz oben in der Hierarchie, d.h. alle
  anderen Teile der Engine verwenden PLTSystem, aber PLTSystem wei nichts von diesen anderen Teilen. Wenn wir nun
  anfangen, das zu ndern (PLTSystem wei pltzlich von PLTConfig und trgt dort Klassen ein), wird das ganz schnell
  unberschaubar, da in beide Richtungen aufeinander zugegriffen wird - wozu das fhren kann, sah man sehr deutlich
  beim alten FS, wo GetValidFileName() zu abwechselnden Aufrufen im Manager und im FS fhrte, dadurch konnte berhaupt
  nicht nachvollzogen werden, was wo getan wird und welches System wofr verantwortlich ist. Das gleich knnte leicht
  bei PLTConfig und PLTSystem passieren, wenn nun PLTConfig im Gegenzug anfngt, neue Klassen einzutragen, und schon
  pendeln die Aufrufe wieder hin und her. Darum also: Aufrufe immer nur in eine Richtung, so da die Hierarchie erhalten
  bleibt, niemals wieder zurck vom oberen Teil der Hierarchie in untergeordnete Teile.
- PLTSystem: Beim Eintragen der Klassen wird nun geschaut, ob die Basisklasse bereits registriert wurde, ist dies nicht der Fall
  wird so lange gewartet, bis die Basisklasse da ist und erst dann die Registrierung der Variablen aus dieser
  Basisklasse vorgenommen. Damit die Variablen in der richtigen Reihenfolge bleiben, mute ich bei den Schleifen und beim
  Eintragen der Variablen etwas tricksen, schnere Lsungen wren hier sehr willkommen. Bitte mal schauen ob die Probleme
  damit gelst sind, in meinen Tests hat's jedenfalls funktioniert :-)
- PLTSystem: Mir ist aufgefallen, da immer wieder PLGENERAL_API zu allen Funktionen hinzugefgt wird. Dies ist ok, wenn es wirklich
  bentigt wird, also die Funktion soll von auen verwendet werden und es gibt unaufgelste externe Symbole aufgrund des
  fehlenden Exports. Ist dies aber nicht der Fall, bitte nicht einfach so hinzufgen, denn die Entscheidung, welche
  Methoden exportiert werden sollen und welche nicht, ist an den meisten Stellen schon mit Bedacht gewhlt worden!
  Dies ist z.B. eine gute Mglichkeit, um noch etwas mehr Sicherheit zu gewhrleisten, indem Methoden, die nur intern
  verwendet werden sollen, auch nur intern aufgerufen werden knnen (im System ist dies z.B. bei kritischen Methoden
  wie dem Hinzufgen von Modulen der Fall). Dies kann dann auch nicht durchs Verndern eines Headers (protected in
  public ndern) umgangen werden, und ist daher fr solche kritischen Methoden ntzlich.
  Also bitte immer berlegen, ob das Exportieren einer Methode wirklich gewnscht ist, und nicht einfach alle Methoden
  exportieren.



>> 08.02.2005
[CO]
- PLTResourceHandler: Machte SetResource() virtuell da es man z.B. in PLTSkeletonHandler sobald eine Resource gesetzt wurde
  diverse Aufgaben erledigen muss.




>> 05.02.2005
[CO]
- PLTConfig: Neue Funktion: AddClass() -> Da jederzeit neue Module mit eventuell neuen Konfigurations-Klassen darin
  eingeladen werden knnen war es ntig eine Funktion anzubieten um neue Config-Klassen zu regestrieren.
  In PLTSystem::RegisterClass() wird nun versucht die neue Klasse in PLTConfig einzutragen - mir viel da 
  keine bessere Mglichkeit ein... vielleicht wre da ne art von System-Listener angebracht, falls man noch
  an anderen Stellen mitbekommen mchte wenn z.B. neue Klassen regestriert/entladen werden.
- PLTFile: Die Read&Write Funktion wurde so erweitert das man auch Count angeben kann -
  das war leider ntig da DevIL nicht korrekt laden konnte wenn man nSize*nCount direkt berechnete und als zu
  lesende Bytes bergab - da gibts anscheinend intern irgendwo doch nen Unterschied. 
  Auch bei ZLib ists nen Unterschied wenn man die Parameter size und count bei fread vertauscht.
  Stefan, wenn du weit wieso dad so iss klre mich bitte auf - ich kanns mir momentan noch nicht Erklren. ;-)



>> 04.02.2005
[CO]
- PLTResourceManager: In Create() wird nun die interne Funktion CreateResource() verwendet welche man in einem konkreten
  Manager berschreiben MUSS. Da das mit der automatischen Erzeugung im Template nicht klappt falls
  der Resource-Typ abstrakt ist, wie dies beim Sound-Manager der Fall ist, musste das gendert werden.



>> 02.02.2005
[CO]
- Ein paar kleinigkeiten an den Resource-Templates gendert



>> 01.02.2005
[CO]
- Neue Funktion: PLTFSTools::GetRelativePath() -> Macht aus einem Absoluten Pfad wenn mglich einen Relativen 
- PLTWin32FSTools::ConvertToWindowsPath() & PLTFSTools::ValidatePath() -> Kleine Laufwerksbuchstaben werden zu
  Grobuchstaben gemacht da es sonst Probleme geben kann. (ich hatte da eines in AddBaseDir() :)



>> 01.02.2005
[SB]
- PLFSTools, PLPlatform: Nannte FileNameEnding in FileExtension um.
  Dieser Begriff sollte wohl allgemein bekannt sein, und wir sollten es dem User nicht unntig schwer machen :-)
- PLSearchHandle: Nahm die nderung, da '.' und '..' grundstzlich aufgelistet werden, wieder heraus (und wenn ich
  es richtig sah, wurden inzwischen sogar alle Verzeichnisse aufgelistet). Dies mag an einigen Stellen ntzlich sein,
  doch es gibt gengend Situationen, in denen das ausdrcklich nicht gewnscht ist, doch die knnen dann nichts
  mehr daran ndern (z.B. versucht unser PluginSystem "." und ".." als DLL zu laden, was sicher nicht gut ist).
  Wenn also alle Verzeichnisse sowie bestimmte Dateien gefunden werden sollen, sollte dies ist zwei
  Schritten erfolgen, worin ich kein Problem sehe (der FileDialog macht dieses ja auch genau so), denn diese Lsung
  behindert im Gegensatz zur anderen nicht die entsprechend andere Situation.



>> 31.01.2005
[CO]
- Machte PLTProfiling zum Singleton und passte Engine etc. an.



>> 29.01.2005
[CO]
- Nahm die Module-Templates aus der Engine, benannte diese in ResourceManager etc. um, berarbeitete diese etwas - diese
  Resource-Templates liegen im Base-Unterordner da es universelle Grundklassen sind die man berall gut brauchen kann.
  Dabei implementierte ich es so das man auch Resourcen & Resource Handler OHNE Resource Manager verwenden kann. Ist jedoch
  ein solcher Resource Manager vorhanden so MUSS jede Resource einen einmaligen Namen bestitzen - und das wird intern 
  auch sichergestellt. :)
  Somit knnen diese Resource & Resource Handler Templates auch in PLRenderer, PLSound etc. verwendet werden, denn dort gibt
  es auch Resourcen, allerdings ohne konkreten Manager dahinter da dies dort unntig ist - das wrde sonst dort zuviel des
  guten sein.
- Die konkreten Template Implementationen von PLTStack, PLTHashTable, PLTHeapBinary, PLTSingleton liegen nun in seperaten
  'inl'-Dateien. Ich finde es einfach bersichtlicher wenn im Header NUR das Interface liegt. :)


>> 26.01.2005
[CO]
- PLTConfig: Funktionen wie GetVarb() hinzugefgt mit dem man komfortabel gleich den Boolean Wert abfragen kann etc.
- PLTFileType::AddSearchPath(): Pfad wird nun intern bei Bedarf 'korrigiert'



>> 21.01.2005
[CO]
- PLTPlatform: GetTickFrequency() entfernt und PLTTimer entsprechend angepasst. Dies war ntig da es erstens so nicht
  unter Linux ging (dort hab es schwere Probleme mit dem richtigen Timing...) und zweitens war das mit der extra Frequenz
  sowieso nicht so brall. ;-) Da der Name 'TickCount' nicht wirklich aussagekrftig war, benannte ich ihn in
  GetMilliseconds() und GetMicroseconds() um, damit wei man auch sofort in welcher Einheit man die vergangene Zeit
  zurckbekommt. Ein paar Dateien mussten in diversen Teilprojekten angepasst werden, aber nun msste das etwas Sauberer
  sein.



>> 17.01.2005
[CO]
- Kleinen Fehler in PLTFile::Seek() behoben - das viel mir erst auf als bei FMod das Streaming aus PLTFile einfach
  nicht funktionieren wollte - nun gehts. ;-)



>> 10.01.2005
[CO]
- PLTPlatform: Neue Funktion: GetModuleFileNameEnding() -> Gibt die Dateiendung von Modulen, also unter Windows 
  'dll' und unter Linux 'so' zurck. PLTSystem::ScanPlugins() verwendet nun diese Funktion. Das IMMER ber #ifdef
   zu machen wre keine so dolle Lsung gewesen. :)
- PLRTTIDefs.h: Foreward declaration von PLTSystem eingefgt da es ansonnsten unter Linux einen Compiler
  fehler gibt.
- PLGeneralWin32.h/PLGeneralLinux.h: Dort wird nun PLEXPORT/PLIMPORT definiert da man dies ja seehr oft bentigt.
  PLRTTIDefs.h -> DEFINE_MODULE_PLUGIN verwendet nun PLEXPORT. (ging ja sonst so nicht unter Linux :)
-> Das waren noch die paar Dinge wie Port-mig gemacht werden mussten. Damit es unter Linux problemlos bersetzen geht.
- PLStack.h: Nahm PLGeneral.h include raus da ich dann z.B. beim Max Exporter nun durch die weiter intern
  eingebundenen Dinge dazu gezwungen bin PLGeneral dort miteinzubinden was ich aber nicht will. :)
- PLTPlatformWin32::LoadModule() -> Der Dateiname wird nun zuerst in einen Win32-Pfad umgewandelt bevor die Lib
  geladen wird.



>> 10.01.2005
[SB]
- Die nderung vom 29.12. geht leider so nicht, weil sie dazu fhrt, da der DestructionManager
  nicht mehr korrekt gelscht wird und somit ein Speicherleck entsteht:
  DestructionGuard wird beim beenden deinitialisiert und lscht den DestructionManager
  -> dieser lscht alle Singletons
  -> Singleton ruft PLTDestructionManager::GetInstance()->RemoveObject(this) auf
  -> Dadurch wird der DestructionManager neu erzeugt und nie wieder gelscht.
  Dies habe ich nur deswegen so ausfhrlich aufgeschrieben um klarzumachen, da kleine und vllig
  harmlos aussehende nderungen beim RTTI sehr bsartig sein knnen, da das RTTI leider auf vielen
  Tricks basiert, aber genau dies ermglicht erst, da es so gut und einfach zu bedienen ist :-)
- Habe nun DestructionManager und DestructionObj gelscht, statt dessen hat jede Singleton-Klasse
  ab jetzt einen eigenen DestructionGuard, welcher das Singleton beim Beenden wieder lscht
  (damit ist die Abhngigkeit der Singletons von einem weiteren Singleton nicht mehr gegegeben).
- Die Klassen eines Moduls melden sich beim Beenden nicht mehr vom System ab, weil dies ein
  hnliches Problem wie oben ergab: Die Reihenfolge der Deinitialisierung statischer Variablen
  wird vom Compiler vorgegeben und kann nicht beeinflut werden, es passiert also, da zuerst
  das PLTSystem-Singleton gelscht wird und dann die Klassen eines Modules deinitialisiert werden,
  wenn diese dann PLTSystem::GetInstance()->Remove() aufrufen, wird PLTSystem neu erstellt und
  wir haben wieder ein Speicherleck.
  Um die Abhngigkeiten mglichst gerin zu halten, melden sich also die Klassen nicht mehr ab,
  sondern nur noch das Modul, wodurch automatisch alle Klassen entfernt werden. Um das Problem
  hier zu beheben, gibt es in PLTSingleton nun noch eine Methode CheckInstance(), welche nur die
  Instanz zurckgibt aber keine erstellt. Im oben genannten Fall meldet sich ein Modul also
  nicht mehr ab, wenn das System bereits deinitialisiert worden ist, denn in diesem Fall
  wurden ja sowieso schon alle Klassen beim Beenden gelscht.



>> 09.01.2005
[CO]
- PLTPool: GetElements() in GetNumOfElements() umbenannt, PLTProfiling musste entsprechend angepasst werden.
- PLTArray & PLTBitset & PLTList: Compare() so umgeschrieben das der Operator != nun nicht mehr zwangslufig vorhanden
  sein muss



>> 03.01.2005
[CO]
- PLTSearchFilter::CheckMatch() -> '.' und '..' kommen nun immer durch den Test, ansonnsten gibts probleme beim Auflisten
  des Inhaltes eines Verzeichnisses.
- PLTFSTools::GetFileNameEnding() -> Bercksichtigt nun auch nicht vorhandene Dateinamen Endungen
- PLTFSTools::ValidatePath() -> Fgt nun am Ende des Pfades noch ein / an falls dort keines ist damit Pfade immer mit /
  Enden.



>> 29.12.2004
[SW] + [CO]
- Die Linux Tests Crashten immer nachdem das Programm bendet wurden - nach Stundenlanger Such und dem durchgehen aller
  mglichkeiten waren wir schon nahe am Verzweifeln da man sich den Crash einfach nicht erklren konnte. Tja, und irgendwie
  landeten wir dann eher per Zufall im Destruktor von PLTDestructionManager und dort Crashte es beim Lschen eines Objektes.
  Es stellte sich raus das Zeiger ungltig waren - ein Blick auf den Destruktor von PLTDestructionObj zeigte das sich Objekte
  nicht wieder bei Tot abmeldeten sondern sich einfach ins Nirvana schlichen. ;-)
  Kleines Problem, merkwrdige Phnomene - viele Stunden suchen. ;-)
- PLGeneral und PLMathLib auf Linux portiert:
  -> Nun laufen PLBaseTest, PLFileTest und PLMathTest auch problemlos und sauber unter Linux - wir haben Teils auch alles ber
     Eclipse Debugt etc. Jetzt da diese Dinge auf zwei Platformen laufen kann man annehmen das es so nun schon recht ordentlich
     ist.  :):)



>> 27.12.2004
[CO]
- Passte PLTTimer an die aktuellen nderungen an. Die Timer Klasse verwendet nun PLTPlatform und ist dadurch Platform unabhngig
  und die ganzen Timer Platform-Dinge konnten entfernt werden - erleichtert das Portieren. :)
- Erweiterte PLTPlatform um GetTickFrequency() - wird fr PLTTimer bentigt
- Dort wo in PLGeneral noch PLTDynamicList verwendet wurde stellte ich auch PLTArray um. Hab nun die alten Listen Klassen +
  PLTDataSet was wir ja mittlerweile nicht mehr brauchen gelscht. Desweiteren alte Stack-Klasse herausgenommen.
  -> Endlich wieder Ordnung in PLGeneral - da Stephan und ich uns die nchsten Tage intensiv mit der Linux Portierung beschftigen,
     wollte ich dieses alte Zeug drauen haben so das wir nicht mit unntig vielen Dateien jonglieren mssen.



>> 26.12.2004
[CO]
- PLTArray: Musste internes Speicher Management etwas umstellen da es Probleme mit Klassen welche Klassen etc. beinhalten gab
  ... diese wurden dann nicht korrekt Initialisiert wenn alle Element in einem groen Buffer lagen. Nun hat PLTArray einen Buffer
  aus Zeigern auf die Elemente welche ber new erzeugt und ber delete wieder gelscht werden... hat den kleinen Vorteil das nun
  auch die Konstruktoren & Destruktoren verwendung finden. :)
  -> Mittlerweile ist auch das merkwrdige Static Initialization Problem in der Engine verschwunden und alles luft wieder
     einigermaen - so langsam mssten die Container Klassen aber so passen. :):)



>> 25.12.2004
[CO]
- PLTFileSystem: Um GetNumOfFileTypes() & GetFileType() & RemoveFileType() erweitert damit ich in 
                 GuiFileSystemDialog die Search Path Ansicht fllen konnte
- In PLTFileSystem::AddSearchPath() wurde der File Type Name nicht korrekt gesetzt
-> Diese nderungen wurden nur gemacht um GuiFileSystemDialog implementieren zu knnen - es zeigte sich ja schon bei
   GuiSystemView das es ganz Praktisch ist diese Dinge ber einen Dialog 'anfassbar' zu machen... zudem wird dieser Dialog
   auch in PixelLab verwendung finden damit man Einstellen kann von wo die Daten kommen sollen.
- PLTBitset & PLTArray: Resize() kann nun optional mitgeteilt werden das ALLE Speicherpltze fr Elemente automatisch
  zugreifbar sind... ist dann so als htte man alle Elemente einzelnd hinzugefgt. Dies ist immer wieder ntzlich wenn man
  einfach ein Feld haben will bei dem man frei auf die Elemente zugreifen kann ohne vorher alle ber Add hinzugefgt zu haben
  wie dies bei 'normalen Listen' der Fall ist.
  Wenn man Resize() per Hand aufruft sind immer standardmig ALLE Elemente gleich verfgbar, so, als htte man alle ber Add()
  hinzugefgt - denn wenn man schon selbst Resize() aufruft erwartet man normalerweise das alles gleich zugreifbar ist, xxx
  mal beim Array Add() aufzurufen wre schlichtweg zu umstndlich. :)



>> 24.12.2004
[CO]
- PLContainer: AddAtIndex(int nIndex) hinzugefgt um ein neues Element an einer bestimmten Stelle zu erzeugen
- In PLTConfig() korrekten Config Klassen Name gesetzt



>> 22.12.2004
[CO]
- PLTFSTools: Neue Funktionen: - GetFileNameEnding() -> Liefert die Datei-Endung zurck
                               - CutFileNameEnding() -> Liefert Dateinamen ohne Endung
                               - GetDirectory() -> Liefert das Verzeichniss eines Dateinamens zurck
- PLContainer Klassen minimal erweitert



>> 21.12.2004
[SB]
- PLTBase.h: Die virtuelle Funktionen stehen nun in einem eigenen Bereich, wie wir es sonst auch meistens haben. Ich finde
  das zwar an dieser Stelle etwas unschn, da z.B. die beiden ToString() Methoden damit auseinandergerissen werden, es
  dient jedoch der bersicht des Programmierers. Die Dokumentation der Methoden habe ich auch noch etwas erweitert.
- PLGeneral: Die Definition von systemabhngigen Klassen wird nun einheitlich in den Include-Dateien fr das jeweilige
  System vorgenommen. Dies fhrt zwar dazu, da einige Header immer eingebunden sind, scheint mir jedoch besser zu sein,
  da dann alle Plattformdefinitionen an einem Ort sind und somit schnell wiedergefunden werden knnen.
- FileSystem: PLNativeDirectory.h gelscht und die Definition entsprechend nach PLGeneralWin32/Linux.h verschoben
- PLTTimer: Anpassung an unseren blichen Stil, die Basisklasse ist nun abstrakt, da es kaum sinnvoll ist, diese direkt
  zu instanziieren (es gibt ja auf jeder Plattform eine systemspezifische Implementierung). Die Konstrukturen/Destruktoren
  sind nun protected (nicht unbeding ntig, aber einheitlich), und auch die Basisklasse besitzt Konstruktur/Destruktor
  wobei der letztere virtuell ist, da die Klasse virtuelle Methoden besitzt. Auch hier wurde die Definition von PLTTimer
  verschoben
- PLTPlatform: Neue Klasse, welche plattformabhngige Systemfunktionen enthlt. Der Einfachheit halber, und weil man es
  vom Namen her sowieso so erwarten knnte, habe ich PLTSystem einfach von dieser Klasse abgeleitet - damit braucht man
  sich nicht mehr berlegen, wer wo eine Instanz davon erzeugen knnte sondern bekommt diese bei PLTSystem::GetInstance()
  ja gleich mit (nur fr die Doku ist es nicht so schn, weil die Systemfunktionen nicht direkt in PLTSystem dokumentiert
  sind, allerdings sollten diese Funktionen sowieso nicht von einer Applikation verwendet werden, da wir ja alles schn
  mit unserem eigenen System abgekapselt haben). Auch die Timerfunktionen sind jetzt in PLTPlatform zu finden - fragt
  sich ob das so gut ist, wenn ja mten wir eigentlich auf die Unterteilung der Timerklassen verzichten knnen, oder?
- PLTSystem: Zum Zugriff auf dynamische Bibliotheken wird jetzt PLTPlatform verwendet, womit PLTSystem jetzt hoffentlich
  plattformunabhngig ist



>> 21.12.2004
[CO]
- Behob kleines Problem in PLTBase::GetVars() mit dem vergleichen von Default-Werten - denn z.B. bei float-Werten knnen
  u.a. am ende noch diverse Nullen sein - um solche Probleme zu verhindern wird zuerst der aktuelle Wert der Variable gespeichert,
  dann wird der Default Wert gesetzt welcher dann wieder als String ausgelesen wird, anschlieend wird der Variable Wert wieder
  auf seinen aktuellen Wert gesetzt - und nun hat man zwei vergleichbare Strings welche bei float Zahlen am Ende gleich viele  
  Nullen haben wodurch korrekt geprft werden kann ob dies wirklich der Default Wert ist.
  -> bei pVar->Set() ist es an dieser Stelle unntig und vielleicht auch etwas Riskant das in Set() pObject->VarChanged(m_szName);
     aufgerufen wird, vielleicht knnte man es hier noch etwas schner machen - hab aber die Finger davon gelassen da es ansonnsten
     zu viele nderungen geworden wren... Stefan, wenn du Zeit und Lust hast kannst du ja mal schaun wie man das besser Lsen
     knnte. :)
- Bei PLTBase::ToString() -> pszBuffer[nCopy+1] zu pszBuffer[nCopy] gemacht da das letzte Zeichen ansonnsten Schrott war :(
- PLTIterator um Funktionen erweitert um zum vorherigen Element zu springen, dies ist hin und wieder ntig wenn z.B. whrend
  der Iterator verwendet wird ein Element aus der Liste gelscht wird, in dem Fall muss man den Iterator um ein Element 
  zurcksetzen und ganz nebenbei wird nun endlich auch pPreviousElement in PLTList verwendet.
  (Previous() brauchte ich zum ersten mal in GuiSys::Update())
- PLContainer: AddAtIndex() ist Index = -1 wird nun am Ende eingefgt (wie frher)



>> 19.12.2004
[SB]
- Containerklassen in PLGeneral eingebaut, dabei die alten Klassen umbenannt, damit diese noch verwendet werden knnen
  und schrittweise umgestellt werden kann
- Iteratoren: Remove() entfernt, ein Iterator dient nun nur noch zum Anschauen der Container, nicht zum ndern. Dadurch
  ist es auch mglich, Iteratoren von const-Listen zu erhalten, dies ging vorher leider gar nicht
- Container: Jeweils einen operator= hinzugefgt, welcher die selbe Klasse als Parameter erwartet. Dies scheint leider
  ntig, da der Compiler diese Methode anscheinend implizit verwendet und nicht die vorhandene Methode mit PLTContainer
  als Parameter verwendet, wenn beide Operanden vom selben Typ sind (bei z.B. *pList = *pArray geht es dagegen!)
- PLGeneral: Auf neue Containerklassen umgestellt. Zunchst ist dies nur eine 1:1 Umstellung, also noch keine Verbesserung
  der Interfaces was Listen/Container angeht, dies wird im nchsten Schritt passieren (erstmal sehen, ob alles noch
  funktioniert)
- RTTI: Kleinen Fehler bei der Registration von Modulen behoben. Wenn ein Module zuerst registriert wird, bevor Klassen
  aus diesem Modul registriert worden sind, war die ModuleID noch nicht gesetzt worden, was dazu fhrte da die Klassen
  nicht dem Modul zugeordnet werden konnten. Da man auf die Reihenfolge der Initialisierungen keinen Einflu hat (das
  macht der Compiler), kann dies mal so und mal so passieren, es mu also in beiden Fllen funktionieren - und ich hatte
  es auf den worst-case ausgelegt, so da der best-case fehlerhaft war ;-))



>> 19.12.2004
[CO]
- PLTFSTools: Um GetPathInfix() erweitert damit es vollstndig ist. (prefix, infix & postfix :)
  Wollte das zuerst in GuiSys::SaveWindows() verwenden, dort reicht aber schon GetPathPrefix().



>> 18.12.2004
[CO]
- PLTVar::SetFlagsString(): Kleine zustliche Abfrage eingebaut damit bei Flags am anfang kein '|' steht.
- PLTVar: Musste m_szEnum vergrern da z.B. bei GuiSlider mehr Zeichen bentigt werden (hab lustige fehler am ende :)
- PLTFile::PrintLn() musste Buffer etwas vergrern da es oft nicht reichte - vielleicht finden wir da bei Zeiten ne bessere
  Lsung fr die Dynamische bergabe von Strings - f(char *text, ...)



>> 18.12.2004
[SB]
- PLTClass:  Constructor und Destructor sind jetzt protected, da ja nur die Klassen selber eine Instanz von sich erzeugen
             sollen und diese dann selbstndig am System anmelden
- PLTModule: Die Informationen ber das Modul wurden in zwei Teile aufgeteilt, einmal dem Info-Teil bestehend aus
             Name/Vendor/Description, und dem Handle-Teil, bestehend aus ModuleID, Instance-Handle und Dateinamen
- PLTSystem: Neue Funktion zum Registrieren von Modulen eingebaut. Ein Modul wird erzeugt, sobald die erste Klasse aus
             diesem Modul registriert wird, dann wird auch die Module-ID zugeordnet, danach kann dann diese Funktion
             verwendet werden, um die Informationen ber dieses Modul zu setzen
- PLTSystem: Einige Umstrukturierungen sowie Namensnderungen der Funktionen, die Funktionen zum Registrieren sind nun
             protected, womit das ganze wenigstens halbwegs sauber ist ;-)
- RTTI:      Makros zum Registrieren von Modulen so angepat, da diese sich per Selbstinitialisierung nun ebenfalls beim
             System anmelden, um ihre Informationen zu bertragen. Dadurch knnen nun sowohl interne als auch plugin-module
             registriert werden, die Makros wurden dafr entsprechend angepat und erweitert
- PLGeneral: Hauptdatei PLGeneral.cpp hinzugefgt, in welcher das PLGeneral-Modul registriert wird



>> 15.12.2004
[CO]
- Neue Listen-Klassen geschrieben welche die alten ersetzen werden. Es gibt nun eine universelle abstrakte Klasse namens
  PLTContainer. PLTList, PLTArray und PLTBitset werden davon abgeleitet. Desweiteren gibt es eine universelle Iterator
  Klasse fr die es jeweils pro Listen-Art eine spezielle Variante gibt. Die Codes hab ich noch nicht in PLGeneral 
  geladen da Stefan die Anpassungen in PLGeneral & PLGui vornehmen wird.



>> 13.12.2004
[CO]
- PLConfig.h: PLTConfigGroup eingefhrt, alle Configurations Gruppen sollten davon abgeleitet werden.



>> 13.12.2004
[SB]
- Module:    Es gibt nun fr jedes Module eine eindeutige ModuleID, welche von PLGeneral und nicht vom System vergeben wird.
             ber diese ID sollten die einzelnen Module angesprochen werden, da dies auf jeder Plattform funktioniert,
             die System-Handles sollten nur noch dann verwendet werden, wenn z.B. ein Modul wieder entladen werden soll,
             was jedoch innerhalb von PLTSystem passiert (es drfte also eigentlich gar keinen Grund geben, das System-Handle
             anstatt der ModuleID zu verwenden).
- Module:    Klasse berarbeitet, so da nur PLTSystem die wichtigen Daten der Klassen ndern kann sowie Zugriff auf die
             darin enthaltenen Klassen hat. Ebenso einige nderungen bezglich der Daten, da bei neuen Module zunchst
             nur die ModuleID bekannt ist, whrend die anderen Daten (Dateiname, Name, Vendor) erst spter bekannt
             werden. Btw: Es hat seinen Grund, da der Name nur Module und nicht PLTModule ist :-)
- PLTClass:  Anstatt des Module-Handles besitzt die Klasse nun nur noch die ModuleID ihres Modules
- PLTSystem: Auch hier wurden die Module-Handles durch Module-IDs ausgetauscht. Auerdem besitzt diese Klasse nun eine
             Methode, um die eindeutigen IDs zu erzeugen, dies wird von den RTTI-Makros benutzt um fr jedes Modul
             eine eigene ID zu erhalten
- RTTI:      Die Makros wurden so gendert, da sie pro Modul eine eindeutige ID erhalten und diese in ihren Klassen
             vermerken. Damit ist das System in der Lage, jede Klasse einem eindeutigen Modul zuzuordnen, auch wenn
             das System-Handle dieses Modules zur Zeit der Registrierung noch nicht bekannt ist (was leider immer
             der Fall ist, deswegen kann nicht einfach die HINSTANCE durchgereicht werden). Um dies zu erreichen,
             speichert eine Template-Klasse die ModuleID, welche sie vom System bekommen hat, und gibt diese an
             die Klassen weiter. Spter setzt das System die zugehrigen Daten wie System-Handle, Dateinamen etc.
             im Modul, so da diese Daten angezeigt werden knnen. Anmerkung: Dieses Vorgehen fhrt dazu, wirklich
             jedes Modul seine eigene ID bekommt, auch alle nicht dynamisch geladenen, dadurch sind also
             PLGeneral/PLEngine/PLGui/etc. unterschiedliche Module, welche allerdings erstmal alle den Namen
             "Internal" bekommen (wie kann man von loadtime-gelinkten DLLs den Namen herausbekommen?). Ob das ein
             Vor- oder Nachteil ist, kann unterschiedlich sein, wenn jemandem einfllt, wie man anders die Module
             und Klassen zuordnen kann, bitte sagen :-)
- PLTClass:  Der Gruppenname wurde entfernt, dafr kann jede Klasse als Basisklasse einer Gruppe definiert werden, welche
             dann alle abgeleiteten Klassen enthlt
- RTTI:      Das Makro DEFINE_GROUP() angepat
- PLTSystem: Gruppen wurden entfernt, dafr kann bei GetClassList() die Basisklasse angegeben werden. Zustzlich knnen
             alle als Gruppen definieren Klassen zurckgegeben werden



>> 12.12.2004
[CO]
- Bei der Klasse Module fehlten noch ein paar PLGENERAL_API - vielleicht sollte man diese Klasse bei Zeiten in 
  PLTModule umbenennen damit es einheitlich ist.
- PLTSystem::UnloadPlugin() -> Nur Dynamische Module knnen entladen werden
- PLTSystem::ScanPlugins() -> verwendet nun LoadPlugin() um die Module einzuladen
- PLTSystem::LoadPlugin() -> Module werden nun korrekt regestriert
- IsClass(), IsClassGroup() und IsModule() - hm, vielleicht wre ne art von Iterator Klasse nicht schlecht damit das 
  berall einfach Einheitlich ist :)



>> 30.11.2004
[SW]
- PLGeneral: linux port + project archiv upgedated



>> 29.11.2004
[SB]
- PLTBase: Der Destruktor ist nun wieder protected, da dies unbedingt ntig ist, wenn das ganze RTTI System berhaupt
           einen Sinn machen soll. Das Problem ist, wenn der Destruktor in PLTBase ffentlich ist, kann jede Klasse
           damit gelscht werden, es besteht fr die Klasse also keinerlei Mglichkeit mehr, dies zu verhindern. Damit
           wird die Verwendung von DEFINE_CLASS_PRIVATE() nutzlos, und alle Sicherheitsvorkehrungen von abgeleiteten
           Klassen knnen damit umgangen werden: z.B. PLTRefCount ist so angelegt, da es sich nur selber lschen
           kann, wenn der RefCount auf 0 sinkt, dies stellt sicher da das Objekt niemals gelscht werden kann, wenn
           es noch irgendwo gebraucht wird. Wenn nun aber PLTBase einen ffentlichen Destruktor hat, wird es
           mglich, dieses Verhalten von PLTRefCount zu umgehen und das Objekt von auen ungeachtet des RefCounts
           zu lschen, was natrlich gravierende Fehler zu Folge haben knnte. In PLTBase ist dies nun auerdem
           nher erleutert, warum Constructor und Destructor von PLTBase protected sind :-)
- RTTI:    Habe das RTTI nun so erweitert, da ein Objekt mit PLTBase::Destroy() gelscht werden kann, FALLS dessen
           Klasse mit DEFINE_CLASS() und nicht mit DEFINE_CLASS_PRIVATE() definiert wurde. Auf diese Weise kann
           man ein Objekt nur mit Hilfe eines PLTBase-Pointers lschen, aber nur wenn die Klasse dies explizit
           erlaubt, denn dies ist wichtig um die Wahl bei den Klassen zu belassen (s.o.).
           Hierzu waren einige nderungen in PLTBase, PLTClass und PLRTTIDefs notwendig



>> 26.11.2004
[CO]
- PLTBase: Musste Destruktor public machen damit ich Klassen Instanzen von denen ich nur einen Zeiger auf 
  PLTBase habe auch wieder zerstren kann. Ich hoffe das ist ok so - ich fand keine andere mglichkeit...
  (siehe PLTConfig::~PLTConfig())
- Neues Configuration-System PLTConfig als Singleton implementiert. Dieses Config-System verwendet das RTTI
  und lsst sich daher sehr einfach bedienen und erweitern. Load() & Save() ist noch nicht implementiert,
  ansonnsten funktioniert alles.
          


>> 24.11.2004
[CO]
- Neue Datenstruktur: PLTHeap welche als Priorittswarteschlange verwendet werden kann. Bereits implementierter
  konkreter Heap: PLTHeapBinary. Ich entschloss mich zu dieser abstrakten Template realisierung damit der Schlssel
  und der damit verbundene Wert sowie die konkrete Implementation mglichst universell sind.



>> 21.11.2004
[CO]
- PLTQuickSort: QuickSort Algorithmus der spter u.a. zum sortieren der Partikel verwendet wird. Ich hab versucht
  die Klasse so allgemein wie mglich zu halten, die Compare Funktion wird hnlich wie in Java ber eine abgeleitete
  Klasse implementiert. Lsst sich im Prinzip also genauso verwenden wie das bereits in VC vorhandene qsort - aber
  ich denke es ist das beste wenn man da was eigenes hat, man weis ja nie... ;-)



>> 21.11.2004
[SB]
- PLMain.h: Diese Datei beinhaltet nun einen plattformunabhngigen Einstiegspunkt fr die Programme. Die Lsung per Makro
  war zwar eine gute Idee, jedoch nicht wirklich praktikabel, da ein Zugriff auf Programmparameter und Optionen damit 
  faktisch unmglich gemacht worden wre, denn diese Parameter wren nach wie vor je nach System unterschiedlich gewesen.
  Auch fand ich die Verwendung dieser Makros nicht sonderlich schn, da innerhalb eines Makros-Blocks dann der
  Funktions-Quellcode gestanden htte, man aber gar nicht gewut htte, wie diese Funktion nun wirklich aussieht.
  Ein Programm, welches die plattformunabhngige Einstiegsfunktion verwenden will, mu nun einfach PLMain.h einbinden
  und die Funktion PLMain deklarieren, die Parameter dieser Funktion sind dabei nun wirklich auf jedem System gleich,
  da sie je nach OS unterschiedlich implementiert wird.
  Es mu natrlich darauf geachtet werden, da PLMain.h nur ein einziges Mal in eine .cpp Datei eingebunden wird, da
  ansonsten die Einstiegsfunktion fr das System mehrfach im Programm vorhanden wre und es dann beim Linken natrlich
  einen Fehler gbe. Dies sollte aber kein Problem darstellen, wenn dies einfach in der main.cpp verwendet wird, wie
  es wohl natrlicher Weise der Fall sein sollte.
- PLRTTIDefs.h: Makros fr den Programm Einstiegspunkt entfernt



>> 20.11.2004
[CO]
- PLRTTIDefs.h: Makros fr den Programm Einstiegspunkt hinzugefgt. (DEFINE_MAIN/END_MAIN) Diese sind zwar Optional, sollten aber
  IMMER verwendet werden damit man Plattform unabhngig bleibt ohne sich immer selbst drum kmmern zu mssen.



>> 19.11.2004
[CO]
- PLTTimer zum Singleton gemacht, PLTTimer in PLTTimerBase umbenannt und PLTTimer definiert das wie beim Gui automatisch jeweils korrekt
  je nach Plattform definiert wird so das man sich nicht mehr drum kmmern muss. Hab auch gleich die Linux Variante mit angepasst,
  Stephan - bitte gleich mal prfen ob ich nicht fehler reingemacht hab. :)
  Passte gleich alle Codes an so das der Renderer nun endlich von der Engine selbst unabhngig sein kann.
- PLTLog: Ein paar kleine nderungen gemacht, z.B. wird nun bei PLTLog::OutputString(const char *pszText) direkt in die Datei geschrieben
  damit man keinen Crash bekommt wenn der String lnger als 1024 ist. Bei den mit ,... gehen wir einfach momentan noch aus das diese Strings
  nicht ZU lang werden. ;)
- PLTFile: PutC() -> Parameter mit const versehen



>> 18.11.04
[SW]
- Bis auf das FS auf linux portiert und ein paar kleine include fehler behoben (pfadangaben)



>> 15.11.2004
[SB]
- PLTPluginManager wurde wieder ausgebaut, und dessen Funktionalitt nach PLTSystem verschoben. Dies ist sinnvoller
  und vor allem fr den Programmierer einfacher, da PLTSystem besser zwischen den Klassen und den Modulen verknpfen
  kann - das wre mit einer getrennten Lsung kaum mglich gewesen, da die Libraries und die Klassen damit scheinbar
  voneinander getrennt gewesen wren. Da PLTSystem nun aber beides managed, kann es die Klassen gleich den entsprechenden
  Modulen zuordnen und bietet so auch fr den Programmierer einen flexibleren Zugriff auf diese Informationen.
  PLTSystem ist jetzt also eine bergeordnete Klasse, die der Programmierer nutzen kann um auf Klassen und Bibliotheken
  zuzugreifen sowie alle Plugins zu managen, ohne dabei die Struktur der Applikation oder der Plugins festzulegen.
- PLTSystem wurde noch einmal in groen Teilen umgebaut, und ist nun sowohl einheitlicher als auch komfortabler.
  Dabei gibt es fr Klassen, Gruppen und Module jeweils eine Methode GetXXXList(), um alle Objekte des Typs aufzulisten,
  sowie eine Methode GetXXX(), um einzelne Objekte per Name bzw. ID anzusprechen. Es ist jetzt also mglich, alle
  Klassen, Gruppen oder Module aufzulisten sowie deren Zugehrigkeiten untereinander zu erkennen. Die Methode
  GetClassList() wurde dabei so erweitert, da entweder alle Klassen, oder alle Klassen einer Gruppe und/oder eines
  Moduls aufgelistet werden knnen, was die Einordnung der Klassen wiederum vereinfacht. Intern wurden die Methoden
  vereinheitlicht, auerdem sind die Add/Remove Methoden nun protected und knnen also nicht mehr wie vorher von
  auen aufgerufen werden, was htte mibraucht werden knnen.
- Die wahnwitzigen RTTI-Makros wurden noch einmal umgebaut, indem die Register-Funktionen nun nicht mehr Teil der
  zu registrierenden Klasse sind, sondern Teil der geschachtelten Info-Klasse. Durch Ableitung von der Basisklasse
  PLTClass und Aufruf der darin deklarierten Basisfunktionen _Register und _Unregister kann die Klasse dann bei PLTSystem
  angemeldet werden. Dieser weitere Trick dient nur dazu, die Add/Remove-Methoden von PLTSystem nach auen abzuschotten
  und als protected zu deklarieren, damit diese nicht beliebig aufgerufen werden knnen.
- Da sich die RTTI-Makros verndert haben, mssen smtliche Projekte, welche diese verwenden, neu bersetzt werden, damit
  die Klassen vom aktuellen System korrekt registriert werden knnen. Dies sollte jedoch in der Zukunft nicht mehr so
  oft vorkommen :-)



>> 06.11.04
[SB]
- PLGeneral: Das Template PLTShared wurde gelscht, die Idee war zwar nicht schlecht, htte aber zu mehr Verwirrung gefhrt
  als da es Nutzen gebracht htte. Es gibt nun also nur noch Singletons, welche nur eine globale Instanz der Klasse
  erlauben, dies gilt z.B. fr Syste, FileSystem, Log, etc. Die Klassen sollten also so strukturiert werden. da entweder
  beliebig viele Instanzen mglich sind (wie z.B. bei der Gui), oder nur eine globale Klasse, um eine saubere Struktur
  zu bewahren.
- PLGeneral: Neue Klasse PLTPluginManager eingebaut, welche das Laden und Verwalten von Plugin-DLLs bernimmt. Dabei wird
  berprft, ob eine DLL bereits geladen wurde und ob debug/release Modus bereinstimmen. Das Scannen einen Verzeichnisses
  nach Plugins wird zunchst von der Engine aufgerufen, jedoch kann ein Programm auch weitere Verzeichnisse Scannen.
  Zur Definition von Plugin-DLLs wurde PLRTTIDefs.h um entsprechende Makros erweitert.



>> 05.11.04
[SB]
- PLTRefCount: Abfrage des counts ist nun eine const-Funktion
- PLTFileSystem: Ist nun wieder ein singleton, es kann also nur eine einzige Instanz davon geben, die von allen
  Programmteilen verwendet werden mu. Dies ist aber kein Problem, da die Verwaltung von Suchpfaden nun doch
  nicht zentral im FS stattfinden wird, da dies einfach zu komplex geworden wre (vor allem auch die Verwaltung
  durch den Programmierer, denn die Implementierung war ja bereits komplett).
- PLTFileSystem: Beim erstellen des FS wird nun das aktuelle Verzeichnis vom OS bernommen
- PLTFSTools: GetFileName() gibt den Dateinamen aus einem kompletten Pfad zurck (splitpath() quivalent)
- PLTWin32Directory: Bei Angabe von "." wird das aktuelle Verzeichnis vom OS genommen
- PLTLog: Ist ebenfalls wieder ein Singleton, zur Unterscheidung verschiedener Logs wird diese Klasse entsprechend erweitert



>> 27.10.04
[CO]
- Behob kleinen 'Fehler' in den Vektor und Farb Klassen welche Offset Probleme im zusammenspiel mit dem RTTI erzeugten.
  Heute dazugelernt: "Vorsicht beim umgang mit this Zeigern!" ;-)
  Desweiteren ist es beim RTTI erfordlich das ALLE von PLTBase abgeleiteten Klassen virtuelle Destruktoren haben da es 
  ansonnsten bei delete [] zu einem Crash kommt - ebenfalls in PLTBase Notiert.



>> 15.10.04
[SB]
- PLTStack2: Da leider jedes Mal, wenn ich die Stack-Klasse benutzen will, irgend etwas nicht funktioniert, habe ich
  eine neue, sehr einfache Stack-Klasse geschrieben, welche auch wirklich nur das tut, was von einem Stack erwartet
  wird und dafr hoffentlich stabiler ist als die bisherige Klasse. Implementiert sind die Standardmethoden eines
  Stacks, Push()/Top()/Pop(), sowie noch eine Extramethode PushBack(), um ein Element an das andere Ende des Stacks
  anzufgen (dies ist vor allem beim Kopieren eines Stacks sehr wichtig). Ansonsten ist der Stack als einfache
  verkettete Liste implementiert, was vollkommen ausreicht da ja nur auf das Top-Element des Stacks zugegriffen werden
  kann, worauf immer ein direkter Zeiger existiert. Ein beliebiger Zugriff auf alle Elemente des Stacks ist also nicht
  implementiert und sollte auch nicht gebraucht werden, fr einen solchen Fall sollte entweder eine Liste oder eine
  Array-Klasse verwendet werden. Dann ist auch endlich gegeben, da sich die Containerklassen wirklich voneinander
  unterscheiden und somit je nach Situation optimal eingesetzt werden knnen.
  Die alte Klasse PLTStack sollte nun berall durch PLTStack2 ersetzt werden, oder durch eine andere Containerklasse,
  falls die Stackoperationen nicht ausreichend sind fr einen bestimmten Fall, danach sollte die alte Klasse gelscht
  werden und die neue Klasse in PLTStack umbenannt werden. Die zwei Klassen sollen also nur vorbergehend nebeneinander
  existieren, um die Anpassung zu erleichtern
- PLTTokenizer: Auch hier habe ich zunchst nderungen vorgenommen, ohne die alte Version davon zu entfernen, damit die
  entsprechenden Stellen problemlos angepat werden knnen. Die Methoden Push()/Pop() implizieren schon vom Namen her
  eine Stack-Funktionalitt, die sie dann jedoch nicht bieten, da nur ein einziger State gespeichert werden kann. Solche
  Dinge sind es aber, die spter andere Programmierer, die mit PL arbeiten wollen, in den Wahnsinn treiben werden, denn
  ein Programmierer wei, was er von einer Push()/Pop() Methode erwarten kann und wird nicht auf den Gedanken kommen, 
  da der Name vielleicht zu viel verspricht. Ich habe daher einen echten Stack in den Tokenizer eingebaut sowie
  Funktionen, um auf diesen zuzugreifen. Mit PushState() kann der aktuelle Status des Tokenizers auf dem Stack gespeichert
  werden, mit PopState() wird dieser wiederhergestellt oder mit DropState() vom Stack verworfen. Damit ist ein einfacher
  recursive-descent parser, der natrlicher Weise mehr als einmal den Status speichern mu, also sehr leicht zu schreiben.
  Auch hier sollten die alten Methoden entfernt werden und durch die neuen ersetzt werden, sobald alle Stellen angepat
  sind, wo dies verwendet wird. Sollten die alten Methoden aus irgend einem Grund erhalten bleiben, knnten sie z.B. in
  SaveState()/RestoreState() umbenannt werden, was auch ihrer Funktionalitt entsprche.



>> 08.09.2004
[CO]
- PLTArray um const [] erweitert



>> 05.09.2004
[CO]
- PLVar.h: Zwei Includes hinzugefgt



>> 29.08.2004
[SB]
- PLTRefCount: GetRefCount() ist nun const
- PLTVar besitzt nun eine Funktion, um eine Zeiger auf die Variable selbst zu erhalten. Da der Variablentyp natrlich nicht
  bekannt ist, ist der Rckgabewert ein void* Zeiger. Diese Funktion sollte natrlich nur mit grter Vorsicht verwendet
  werden, da man hiermit quer im Speicher rumschreiben kann. Auch alle Sicherheitsmechanismen wie readonly-variablen knnen
  mit dieser Funktion natrlich umgangen werden. Dennoch war eine solche Funktion ntig, um z.B. bei Variablen von Typ
  PL_VAR_CLASS an den Klassennamen heranzukommen (hierzu mu man sich den Zeiger auf das Objekt zurckgeben lassen und dann
  mit PLTBase::GetClassName() den Klassennamen ermitteln). Hierzu viel mir leider bisher kein besserer Weg ein...



>> 28.08.2004
[CO]
- Fgte PLTList<AType>::Add() noch einen Parameter hinzu mit dem man bei bedarf verhindern kann das geprft wird ob etwas bereits
  in der Liste ist. Bei GuiListBox war es ttlich wenn extrem viele Elemente eingefgt wurden - da war der Aufwand ganz enorm so das 
  es teils viele Sekunden dauerte bis alles eingefgt war. :(
  Durch das deaktivieren des Tests geht es zwar nur etwas flotter, aber immerhin.
  


>> 26.08.2004
[SB]
PLGeneral:
- Habe PLGeneral.h umgebaut: Hier werden nun die OS-Spezifischen include-files eingebunden, so da die Verwendung mglichst
  auf allen Betriebssystem identisch ist. Bei einer Portierung wird also einfach eine neue .h-Datei hinzugefgt und
  in PLGeneral.h mit den entsprechenden #ifdef's eingebaut. In PLGeneralWin32.h und PLGeneralLinux.h sind nun fr das
  jeweilige Betriebssystem die import/export Makros sowie  die Datentypen definiert.
  Die Unterscheidung zwischen Import und Export geschieht nun nicht mehr ber unterschiedliche .h Dateien sondern
  ber eine Compilerdefinition (welche von VC++ automatisch gesetzt wird, diese mte dann nur fr Linux in die
  Makefiles eingebaut werden)
- Datentypen angepat, es werden nun nur noch die ntigsten definiert: int32, uint32, etc. Diese sollten nur da verwendet
  werden, wo es auf die Bitgre des Datentyps explizit ankommt, also meist bei Dateizugriffen. Ansonsten sollten nur
  noch die primitiven Datentypen, also z.B. int, long, ... verwendet werden (fr Flags z.B. unsigned long). Da DWORD/WORD
  von vielen als Windows-Datentypen verstanden werden, die man nicht braucht, habe ich mich fr die Bezeichnung
  int16/int32/int64 entschieden, um klarzumachen da es nur um die Bitgre der Datentypen geht.
- PLTypes.h: Alle immer wieder verwendeten Datentypen/Definitionen der Engine befinden sich nun in dieser Datei,
  statt wie vorher noch in PLEngine. Da PLGeneral von den anderen Teilprojekten eingebunden wird ist dies besser,
  so mu PLEngine nicht mehr eingebunden werden, um z.B. die Definitionen fr X/Y/Z verwenden zu knnen, wie dies
  bisher der Fall war
- Dummerweise vergessene PLGENERAL_API in PLTVar eingefgt :-)
RTTI:
- PLTSystem: Fehler bei den ClassGroups behoben: Da "" nicht als gltiger Hash-String gilt, wird nun ein Dummy-GroupName
  verwendet, um Klassen ohne Gruppe zu bezeichnen
- SelfInit-Class so erweitert, da Klassen auch wieder automatisch ausgetragen werden, wenn das entsprechende Modul
  entladen wurde. Wenn kein SelfInit verwendet wird, mu der Programmierer stattdessen das Makro UNREGISTER_CLASS verwenden.
  Wie er mitbekommt, da seine DLL entladen wurde, ist dann allerdings sein eigenes Problem ;-)



>> 18.08.2004
[CO]
- PLTBase::ToString: Behob String Problem, der Zeiger auf den Speicher wurde ungltig da das String Objekt nach ToString() wieder
  zerstrt wurde und auch den String-Speicher selbst dabei killte.
- PLTSystem: Zwei neue Funktionen: GetVarType() & GetVarTypeAsString()



>> 10.08.2004
[SB]
- Neuer Variablentyp PL_VAR_PLSTRING zum Zugriff auf Variablen vom Typ PLTString eingebaut
- PL_ENUM Makros verndert: Der enum-string steht nun doch am Ende des Makros, da dies die Variablendefinition bersichtlicher gestaltet



>> 08.08.2004
[SB]
- PLTClass: Der Methode CreateInstance kann nun angegeben werden, ob die Variablen des erzeugten Objektes automatisch auf
  ihre Default-Werte gesetzt werden wollen, dies ist nun auch das Standardverhalten von CreateInstance().
- PLTBase: Neue virtuelle Methode VarChanged() eingebaut, diese wird aufgerufen wenn der Wert einer Variablen durch das
  RTTI verndert worden ist, um ggf. ntige Aktionen nach dem Verndern einer Variable durchzufhren



>> 07.08.2004
[SB]
- PLTBase, PLTClass: GetVarList(List, true) gibt nur die Variablen der eigenen Klasse zurck, ohne die von Basisklassen
  vererbten
- PLTVar::GetClass() gibt zurck, in welcher Klasse die Variable deklariert wurde
- Mittels DEFINE_ENUM knnen Aufzhlungs-Variablen registriert werden. Als Typ kann hier entweder PL_VAR_ENUM oder
  PL_VAR_FLAGS angegeben werden. Das Setzen der Variablen kann entweder ber die numerischen Werte oder ber die
  enum-Namen erfolgen: z.B. Set("2|4"); Set("beta"); Set("Read|Write");



>> 06.08.2004
[SB]
- PLTypes.h erweitert, so da die Definitionen an anderer Stelle komplett entfallen knnen. Die verwendeten Datentypen
  sollten jedoch noch einmal komplett berarbeitet werden
- Log-Ausgaben wieder eingebaut, dazu wird nun das "shared"-Log verwendet. Zur Zeit wird dieses jedoch nirgendwie aktiviert,
  deshalb verschwinden die Logausgaben im Nirvana :-)
- RTTI System erweitert:
  - Klassen beinhalten nun auch die Variablen ihrer Basisklassen
  - Es wird nun mit m_nBaseOfs auch der Offset zu PLTBase gespeichert, damit die Variablen auch dann noch korrekt gesetzt
    werden knnen, wenn eine Klasse nicht als erstes PLTBase in der Ableitungsliste stehen hat
  - DEFINE_VAR_READONLY erlaubt das Definieren von Variablen, die nur gelesen aber nicht verndert werden knnen
  - REDEFINE_VAR erlaubt das "berschreiben" von Variablen in abgeleiteten Klassen, dabei knnen DefaultValue,
    Description und Annotation verndert werden



>> 05.08.2004
[CO]
- Den Ordner Tools in PLTools umbenannt. Beim Includieren wre es am ende unschn wenn man #include <Tools/...> schreiben
  wrde, da vermiss ich irgendwie das PL davor... und so musste ich die anderen Codes nicht an die verschiebung von PLTools
  in PLGeneral anpassen. ;-)
  Vielleicht sollten wir auch die anderen Ordner entsprechend anpassen damit es einheitlich ist. 
  (wieder so ne dumme Namensgeschichte ;-)
- Bei ein paar Headern in PLTools noch PLGeneral.h eingebunden - bei der Gelegenheit ging ich gleich alle Includes unserer
  Projekte durch und passte alles an. (waren ja in letzter Zeit einige nderungen)
  Nun sieht man z.B. schn wie die Libs aufeinander aufbauen da alles geordnet ist.
- PLTimerWin32.inl & PLTimer.inl gelscht da die inlines dort nicht so doll sind (was dachte ich mir frher dabei? :-)
- PLTypes.h von der Engine in PLGeneral verschoben, musste PLTypes in z.B. PLList.h einbinden da in der Engine teils
  NULL unbekannt war da windows.h dort nicht eingebunden werden musste



>> 04.08.2004
[SB]
- PLTDestructionManager eingebaut. Diese Klassen sorgen dafr, da Instanzen von Singleton- oder Shared-Klassen am
  Ende der Programmausfhrung auch wieder gelscht werden. Die Implementierung ist relativ kompliziert, da man
  hierbei wieder sehr mit der Compiler- und Exportproblematik herumschlagen mute. Die Funktionsweise des Systems:
  - Statische Initialisierung wird durch Singleton::GetInstance() vermieden, dies ist ntig damit die Klassen sich
    ber Selbstinitialisierung beim Programmstart bei PLTSystem anmelden knnen. Wre PLTSystem eine statische
    Variable, knnte dies zu Problemen fhren, wenn PLTSystem noch nicht initialisiert wurde
  - Jede Instanz von PLTSingleton und PLTShared meldet sich beim PLTDestructionManager an. Dies ist mglich, da
    PLTDestructionManager selbst ein Singleton ist und daher bei der ersten Verwendung erzeugt wird
  - Am Ende mssen alle Instanzen wieder gelscht werden. Dazu dient die einzige statisch Variable
    PLTDestructionGuard::Instance, deren Destructor am Ende des Programmes automatisch aufgerufen wird. Diese lscht
    die Instanz von PLTDestructionManager, welche wiederum alle bei ihr angemeldeten Objekte lscht. Auf diese
    Weise werden alle erzeugten Instanzen auch wieder automatisch gelscht :-)



>> 03.08.2004
[SB]
- Neues Verzeichnis PLTools, hier befinden sich nun allgemeine Tool-Klassen
- PLTTokenizer nach Tools verschoben
- Klassen aus PLEngine nach PLGeneral verschoben, welche allgemein verwendet werden knnen. Die Klassen sind nun
  allgemein und knnen auch auerhalb der Engine verwendet werden, PLEngine-spezifischer Code wurde dabei entfernt
  und mu weitern in der Engine selbst ausgefhrt werden (z.B. Anzeige von Informationen etc).
  Verschobene Klassen: PLTLog, PLTProfiling, PLTTimer, PLTTools



>> 02.08.2004
[SB]
- PLTRefCount nach Base verschoben und von PLTBase abgeleitet
- PLTFile: Neue Methode PrintLn eingebaut
- PLTFile: Neue Methode Flush eingebaut
- PLTWin32File und PLTZipFile angepat



>> 01.08.2004
[CO]
- PLTDynamicList: In der Engine hab es nun mit den const/nicht const etwas probleme. Hab die Warnung
  "PLTDynamicList<AType>' : multiple assignment operators specified" frs erste Deaktiviert da diese ansonnsten tausende male
  kam. ;-)
  Bei Zeiten mssten wir nochmal schaun wie wir das besser machen knnen...
- PLTPool: Um Copy Operator erweitert



>> 01.08.2004
[SB]
- Neue Basisklassen PLTShared und PLTSingleton eingebaut. Dies sind Template-Klassen, welche verwendet werden knnen,
  um Klassen mit nur einer Instanz (PLTSingleton) oder mit einer gemeinsamen Instanz fr alle Programmteile (PLTShared)
  zu definieren.
- PLTFileSystem benutzt nun die neuen Basisklassen PLTSingleton und PLTRefCount
- PLTSystem: Anpassung an neue Basisklassen sowie kleinere Korrekturen
- Neue Definition PLGENERAL_TEMPLATE zum Exportieren von template-Klassen, dies mu bei allen zu exportierenden
  Template-Instanzen verwendet werden
- Verzeichnisse umbenannt



>> 30.07.2004
[SB]
- Habe das RTTI System in PLGeneral eingebaut und dafr die vorlufigen Plugin-Klassen wieder entfernt, da diese
  damit berflssig geworden sind :-)



>> 29.07.2004
[SB]
- Die Gruppe einer Klasse wird nun mittels eines eigenen Makros gesetzt, wird dieses nicht verwendet gehrt die Klasse
  keiner Gruppe an
- Die Basisklassen einer Klasse werden nun in PLTClass gespeichert und knnen dort abgefragt werden. Ebenso kann
  PLTBase::IsInstanceOf() als Shortcut zur Abfrage einer Basisklasse verwendet werden
- PLTBase selbst wird jetzt als Klasse registriert
- Beim Definieren einer Klasse wird nun eine interne von PLTClass abgeleitete Klasse erzeugt, welche dann in PLTSystem
  gespeichert wird. Dadurch ist es mglich, private Methoden von PLTClass zu verwenden sowie virtuelle Methoden
  zu berschreiben
- PLTClass::CreateInstance() kann benutzt werden, um eine neue Instanz einer Klasse zu erzeugen. Es mu allerdings noch
  ein Weg gefunden werden, da Klassen dieses Verhalten unterbinden knnen, wenn eine direkte Erzeugung von Instanzen
  nicht erwnscht ist
- PLTClass: Methoden zum ndern einer Klasse sind nun protected, knnen von Auen also nicht mehr aufgerufen werden,
  damit sind auch die konstanten Zeiger nicht mehr von Nten und wurden durch normale Zeiger (PLTClass*) ersetzt
- Pointer-Truncation Warnungen wurden beseitigt, indem zur Speicherung des Offsets nun der 64Bit-Datentyp int__64
  verwendet wird
- Neues Makro: Wird DEFINE_CLASS_PRIVATE anstelle von DEFINE_CLASS verwendet, so kann die Klasse nicht ber
  CreateInstance() instanziiert werden. Dies ist ntzlich fr Klassen, die nicht beliebig instanziiert werden
  sollen und daher meits auch keinen ffentlichen Standardkonstruktor besitzen
- Mittels der Compiler-Definition USE_SELFINIT kann bestimmt werden, ob die Selbstinitialisierung verwendet werden soll
- In PLTClass wird nun ein Module-Handle gespeichert, zu dem die Klasse gehrt



>> 28.07.2004
[SB]
- Zugriff auf Variablen vollstndig implementiert und getestet
- Klassen knnen nun in Gruppen eingeteilt werden, um einfach die Klassen eines bestimmten Typs auflisten zu knnen. Dies
  dient nur dem Entwickler zur Einfacheren Verwaltung seiner Klassen, z.B. sollten alle Plugins eines Typs den gleichen
  Gruppennamen bekommen (z.B. PLEntities), dann kann der Plugin-Manager sich eine Liste aller Klassen dieses Typs herausgeben
  lassen um die Plugins dann zu verwenden
- PLTVar wurde doch noch einmal umgeschrieben, es ist nun nicht mehr mglich, mit hilfe eines PLTVar-Objekts direkt auf
  eine Instanz einer Variablen zu zeigen, da dies zu Inkonsistenzen fhrte (PLTClass::GetVar() gab einen konstanten Zeiger
  auf PLTVar zurck, der nicht gelscht werden durfte, whren PLTBase::GetVar() ein neues PLTVar Objekt erzeugte, welches
  dann wieder gelscht werden mute!). Die jetzt zurckgegebenen Objekte mssen grundstzlich nicht mehr gelscht werden,
  da sie Zeiger auf feste Instanzen darstellen und nicht neu erzeugt werden. Dafr gibt es nun Methoden in PLTVar,
  um den Wert der Variablen bezogen auf eine Instanz zu setzen: SetVar(PLTObject*, const char *pszValue)
- RTTI Interface ist nun komplett



>> 27.07.2004
[SB]
- Neue Funktionen in PLTBase: ToString() und FromString(). Mit diesen Methoden wird der Inhalt eines
  Objektes in einem String bergeben. Dies entspricht in wesentlichen dem VarString, jedoch kann das
  Aussehen dieses Strings von der Klasse bestimmt werden, es mssen also nicht die Variablennamen
  angegeben werden (die Reprsentation eines 3D-Vectors knnte z.B. "10 20 30" sein, anstatt "X=10 Y=20 Z=30")
- Mittels PLTVar knnen nun Werte von Variablen gesetzt und abgefragt werden
- Klassen werden in PLTClassRegistry gespeichert und knnen dort abgefragt werden
- PLTClassRegistry wurde in PLTSystem umbenannt, da diese Klasse die allgemeine Verwaltung des Systems bernehmen
  wird (neben Registrierung der Klassen werden auch Plugins, Dynamic Libraries etc. in ihren Aufgabenbereich fallen,
  evtl. kann man spter auf Log etc. in PLTSystem einbetten)
- Die Klassen wurden berarbeitet und vereinheitlicht, z.B. wurden Unterschiede beim Zugriff auf Listen und Daten
  der Klassen beseitigt
- SelfInit-Part eingebaut, welcher die Klasse automatisch registriert
 


>> 25.07.2004
[SB]
- PLTVar berarbeitet, die Instanz des Objektes kann nun nur noch im Konstruktor bergeben werden
- Zugriff auf Variablen ber PLTClass implementiert



>> 24.07.2004
[SB]
- PLTVar fertiggestellt, diese Klasse beinhaltet Informationen ber eine Variable innerhalb einer Klasse. In PLTClass
  kann man eine Liste der registrierten Variablen abfragen, und in PLTObject knnen die Werte der Variablen gesetzt
  oder abgefragt werden. Zustzlich kann auch PLTVar die Instance einer Variablen darstellen, dann kann auch ber
  PLTVar auf die Werte der Variablen zugegriffen werden



>> 22.07.2004
[SB]
- Habe endlich einen generellen Weg gefunden, da die Variablen einer Klasse nicht mehr pro Objekt gespeichert werden
  mssen sondern nur noch einmal fr jede Klasse. Bisher besa jede Instanz einer Klasse eine eigene Variablenliste,
  in der die Zeiger auf die Variablen gespeichert wurden (die Informationen ber die Variablen wurden nur einmal
  gespeichert, dies fhrte jedoch dazu, da es zwei unterschiedliche Klassen fr Variablen geben mute, was auch
  nicht schn war). Dies ist nun nicht mehr ntig :-)



>> 21.07.2004
[SB]
- PLGeneral: PLTDynamicList und PLTList so erweitert, da diese nun auch mit konstanten Daten umgehen knnen.
  Dies ist z.B. dann ntzlich, wenn der Zugriff auf eine const PLTList/PLTDynamicList erfolgt
- RTTI System begonnen. Mit Hilfe dieses Systems wird es mglich sein, zur Laufzeit auf Klasseninformationen zuzugreifen,
  damit knnen z.B. die vorhanden Variablen oder Methoden eines Objektes abgefragt und verndert werden, sowie
  natrlich generelle Informationen ber den Typ eines Objektes abgefragt werden.
  Das System entspricht in seiner Funktionsweise dem EntityPluginSystem, ist jedoch allgemeiner und soll um einiges
  flexibler werden. Wenn alles klappt, wird durch dieses Klassensystem auch gleich ein sehr einfach zu verwendendes
  Pluginsystem zur Verfgung stehen, wobei die bisherigen Fallunterscheidungen nicht mehr bentigt werden sollten
  (bisher mute unterschieden werden, ob eine Klasse im Hauptprojekt, in der Engine-DLL oder in einer Plugin-DLL
  deklariert wurde, dies ist nicht sehr schn und kann hoffentlich vermieden werden). Auch das Scriptsystem wird
  nach der Implementierung der RTTI leicht zu entwickeln sein, da der Zugriff auf Klassen und Variablen/Methoden
  zur Laufzeit damit bereits implementiert ist :-)
  Das RTTI wird also eine Reihe von Basisklassen zur Verfgung stellen, die in der gesamten Engine verwendet werden,
  zustzlich wird es noch einige abgeleitete Klassen geben, welche fr bestimmte Klassentypen zum Einsatz kommen
  knnen (RefCount, Singleton, etc)



>> 30.06.2004
[SB]
PLFileSystem:
- Fehler in PLTSearchMultiHandle behoben: HasNextFile() gab false zurck, sobald der erste SearchHandle komplett durchlaufen
  war, dadurch wurden die anderen SearchHandles ignoriert
- Das Interface von PLTFileSystem wurde noch einmal leicht verndert. GetRootDirectory() gibt nun das System-Root-Verzeichnis
  zurck, dieses kann jedoch nicht selbst gesetzt werden. SetCurrentDirectory()/GetCurrentDirectory() ermglichen das Setzen
  eines aktuellen Verzeichnisses, sowie AddBaseDir() etc., welche im Prinzip weitere aktuelle Verzeichnisse hinzufgen lassen
  (falls mehrere bentigt werden). Hierdurch bleibt das System kompatibel zu den blichen Dateisysteme, erlaubt jedoch zustzlich
  mehr Kontrolle
- Zugriff auf Suchpfade und Rootverzeichnisse ist vollstndig, es funktioniert nun also alles was fr die Engine bentigt
  wird. Es knnen Dateitypen (z.B. "Textures", "Sounds", etc.) festgelegt werden und Suchpfade dafr angelegt werden.
  Das FS durchsucht dann beim ffnen einer Datei automatisch diese Pfade, so da sich die Anwendung nicht mehr darum
  kmmern mu, was wo liegt
- Suchpfade/Rootverzeichnisse ausgetestet und den PL-Realfall simuliert (separate Verzeichnisse fr Textures/Models/etc)



>> 29.06.2004
[SB]
PLFileSystem:
- Geschwindigkeitstests durchgefhrt. Leider ist das FS vor allem beim Zugriff auf viele kleine Dateien deutlich langsamer
  als die Standardfunktionen, beim Zugriff auf groe Dateien fllt der Unterschied allerdings kaum mehr ins Gewicht.
  Dies drfte hauptschlich an den vielen String-Operationen liegen, wie mssen also einfach austesten, ob dies im reellen
  Gebrauch negativ auffllt und ggf. versuchen, diese Funktionen zu optimieren
- Neue Funktion PLTSearchHandle::GetNextFileAbs(), diese Funktion liefert den absoluten Pfad zurck. Funktion wurde in
  allen abgeleiteten Klassen implementiert
- Neue Funktion PLTZipDirectory::GetZipFile(), liefert ein Handle auf die Zip-Datei zurck, die das Verzeichnis beinhaltet.
  Der Rckgabewert ist const, damit zwar Dateiattribute (Namen etc.) abgefragt werden knnen, die Datei aber nicht
  verndert werden kann
- Fehler in PLTZipSearchHandle behoben: Das zugrunde liegende Verzeichnis wurde nicht gesichert (refcount)



>> 28.06.2004
[SB]
PLFileSystem:
- Dateien aus Zip komplett berarbeitet und an den PL-Style angepat
- Alle Dateien berarbeitet und die blichen "Verschnerungen" vorgenommen :-)



>> 25.06.2004
[SB]
PLFileSystem:
- Beim Suchen mit Filter entspricht der Filter "" nun der Suche nach allen Dateien
- Beim Suchen mit Filter ist es nun auch mglich, noch Unterverzeichnisse mit anzugeben (z.B. Suche nach "subdir/*.txt")
- Mounten von Root-Verzeichnissen implementiert
- Dateitypen und Suchpfade wurden implementiert
- PLTSearchMultiHandle eingebaut: Dies ist ein Search-Handle, welches intern wiederum aus mehreren Search-Handles besteht
  und diese nacheinander abarbeitet
- PLTFileSystem interface wurde komplett implementiert
- Dateien aus Base und Win32 berarbeitet und komplett kommentiert



>> 23.06.2004
[SB]
PLFileSystem:
- PLEFileType und entsprechende Zugriffsmethoden in PLTFileObject wurden entfernt, IsDirectory() und IsFile() werden
  nun von abgeleiteten Klassen implementiert
- Neue Methoden GetName() und GetAbsName() in der Basisklasse PLTFileObject eingebaut, diese dienen dem Abfragen von
  relativen und absoluten Namen aller Dateiobjekte
- Interface von PLTFileObject wurde berarbeitet (const-Methoden)
- GetName() und GetAbsName() in allen abgeleiteten Klassen implementiert und getestet, es kann nun immer der relative
  sowie der absolute Pfad angefragt werden
- PLTSearchFilter implementiert, dieser filtert Suchergebnisse nach Wildcards
- Beim Erzeugen des Dateisystems wird das aktuelle Verzeichnis '/' automatisch als system-root gemountet
- Setzen des aktuellen Verzeichnisses implementiert
- Design von PLTFileSystem wurde festgelegt. Diese Klasse stellt das Hauptinterface zum FS dar, dient also dem Benutzer
  zum ffnen von Dateien und Verzeichnissen sowie zum Suchen von Dateien



>> 22.06.2004
[SB]
PLFileSystem:
- FSTools: Neue Funktion IsAbsolutePath() eingebaut
- PLTWin32Directory: Es knnen nun auch absolute Pfade angegeben werden (z.B. D:\test.txt), welche unabhngig vom aktuellen
  Verzeichnis gefunden werden. Auerdem kleine Anpassungen an IsValid() vorgenommen



>> 20.06.2004
[SB]
PLGeneral:
- Neue Basisklasse PLTRefCount in PLGeneral eingebaut, da dies nun bereits in mehreren Klassen verwendet wird.
  Davon abgeleitet gibt es speziell fr das FS die Klasse PLTFSRefCount, welche zustzlich die Anmeldung erzeugter Objekte
  beim FileSystem bernimmt



>> 19.06.2004
[SB]
PLFileSystem:
- Fehler behoben: Das MountParent-Attribut eines Verzeichnisses wird nun weitergegeben, wenn ein Unterverzeichnis geffnet
  wird. Dadurch bezeichnet MountParent jedoch nicht mehr unbedingt das direkte Superdirectory, wenn es gesetzt ist, sondern
  das Basisverzeichnis des gesamten Unterbaumes. Dies wurde ebenfalls in PLTZipFile implementiert
- Die einzelnen Implementierungen von PLTDirectory::Open() rufen nun intern OpenCanonical auf, wenn sie die Datei auf
  direktem Wege nicht ffnen knnen
- PLTWin32Directory und PLTZipDirectory: Enthlt der zu ffnende Dateiname ein / (bzw. \) am Ende, so wird nur ein
  PLTDirectory* zurckgegeben. Wird nur eine Datei gefunden, beendet die Funktion mit einem Fehler und gibt NULL zurck
- PLTFileSystem: Mount ist nun protected, darf also nur vom FileSystem selbst (und PLTDirectory) aufgerufen werden
- Weitere kleine Fehler in Mount() und PLTWin32Directory/PLTZipDirectory behoben. Der Zugriff auf Dateien und Verzeichnisse
  scheint nun komplett zu funktionieren
- ReferenceCounting und garbage collection wurden nun auch in PLTSearchHandle implementiert, damit dies einheitlich fr das
  gesamte FS ist
- Kleinere Fehler im ReferenceCounting und beim ObjectManagement behoben, dies scheint nun fehlerfrei zu funktionieren
  (nicht mehr bentigte Objekte werden selbstndig gelscht)
- Umstrukturierung der Open/OpenCanonical Funktionen. Dadurch konnten redundante berprfungen entfernt werden (ffnen von
  Verzeichnissen oder Dateien), und eine endlose Rekursion zwischen den Funktionen Open und OpenCanonical ausgeschlossen werden
- PLTDirectory::FindFirst() gibt nun einen SearchHandle zurck, der immer alle Dateien im Verzeichnis auflistet. Daher mu
  PLTSearchHandle also keine Suchmaske mehr implementieren, dies wird spter durch eine ContainerKlasse implementiert
- Hilfsfunktion FindFirst(pszFilter) und neue Klasse PLTSearchFilter erstellt, worber das Suchen von Dateien mit einem
  Filter mglich ist. PLTSearchFilter ist jedoch noch nicht implementiert
- Die Grundfunktionen des FS sind nun *endlich* komplett implementiert, d.h. es kann auf alle Dateien und Verzeichnisse
  zugegriffen werden, wobei ZIP-Dateien bei Bedarf automatisch gemountet werden. Auch der Zugriff auf Dateien und
  Verzeichnisse ber Dateisystemgrenzen hinweg ist mglich. Es fehlt nun noch das Mounten von root-Verzeichnissen
  sowie die Verwaltung von Dateitypen und Suchpfaden



>> 18.06.2004
[SB]
PLFileSystem:
- Beim ffnen des Verzeichnisses '..' wird nun immer das korrekte Verzeichnis zurckgegeben, auch wenn dazu auf ein frher
  gemountetes Verzeichnis zurckgegriffen werden mu
- OpenCanonical wurde implementiert. Diese Funktion ffnet einen Pfad Schritt fr Schritt, wobei wenn ntig auch Dateisystem
  gemountet werden (z.B. ZIP-Dateien)
- On-The-Fly-Mounten implementiert (z.B. beim ffnen von "C:\test.zip\test.txt")



>> 16.06.2004
[SB]
PLFileSystem:
- PLTZipDirectory wurde so erweitert, da nun auf ein bestimmtes Verzeichnis im ZIP-File zugegriffen werden kann.
  Mittels Open() knnen jetzt auch Unterverzeichnisse geffnet werden
- Fehler in PLTZipFile behoben: Das PLTZipFile erhht nun den Reference-Counter seines Zip-Verzeichnisses, damit
  dieses nicht gelscht werden kann, solange das PLTZipFile existiert
- Zip-Implementierung wurde komplett implementiert. Der Code basiert auf unzip.c, wurde jedoch objektorientiert umgesetzt



>> 14.06.2004
[SB]
PLFileSystem:
- IsValid() wurde als Basisfunktion in PLTFileObject fertiggestellt
- PLTFSTools::ValidatePath() wurde implementiert. Diese Funktion validiert einen Verzeichnisnamen, indem z.B. '..'
  und '.' soweit mglich entfernt werden, / und \ vereinheitlicht werden und sonstige Fehler mglichst korrigiert werden



>> 11.06.2004
[SB]
PLFileSystem:
- Das Interface von PLTFileSystem wurde noch einmal komplett berarbeitet
- Dateisysteme knnen nun gemountet werden, wobei der Typ des Dateisystems automatisch festgestellt wird
  (z.B. zum Mounten von ZIP-Dateien). Damit der Kontext erhalten bleibt, kann ein Basisdirectory bergeben werden,
  welches die zu mountende Datei enthlt



>> 05.06.2004
[SB]
PLFileSystem:
- Win32-Implementierung wurde komplett fertiggestellt



>> 04.06.2004
[SB]
PLFileSystem:
- Die Interfaces wurden noch einmal komplett umgestellt und vereinheitlicht
- Das Erzeugen und Lschen von Instanzen ist nun nur noch ber spezielle Methoden und Klassen mglich
- Reference-Counting fr PLTFileObject (und abgeleitete Klassen) implementiert
- Alle erzeugten PLTFileObject-Instanzen werden nun beim PLTFileSystem gespeichert und sptestens dann gelscht,
  wenn auch das PLTFileSystem selbst gelscht wird
- Auch PLTFileSystem selbst besitzt nun einen Reference counter



>> 26.05.2004
[SB]
PLFileSystem:
- Die erste Version vom PLFileSystem wurde fertiggestellt



>> 11.05.2004
[CO]
- PLGeneral: PLError wurde entfernt. Gelschte Dateien: PLBuffer.h, PLError.cpp, PLError.h. Nahm desweiteren PL_ASSERT
  aus diversen Codes heraus da WENN da msste man dies konsequent in ALLEN Codes machen. :)



>> 30.03.04
[SB]
- Plugin-Basisklassen in PLGeneral eingebaut. Diese ist noch nicht ganz fertig, funktioniert
  aber schon ganz gut. Es fehlen noch einige Optimierungen sowie die Verknpfung mit dem
  FileSystem, damit die Plugins leicht gefunden werden knnen. Auch mten die Klassen noch
  auf Linux Systeme angepat werden. Wenn dies fertig ist kann ein PluginManager in der Engine
  erzeugt werden, der alle Arten von Plugins einldt und zur fr Verfgung stellt, die
  einzelnen Programmteile benutzen dann den Manager um ihre Plugins zu erzeugen



>> 25.03.04
[CO]
- Wie ich sehe hat Michael nochmals PLTBuffer verbessert... ich selbst hatte gestern in PLBuffer in PLArray
  umbenannt und mehr oder weniger komplett umgeschrieben da ich diese Klasse mittlerweile im neuen Renderer beim
  Wrappen von Render States etc verwende und die alte Klasse nicht stabil genug war. Hatte die Codes aber noch
  nicht hochgeladen - PLArray.h ist nun auf dem Server, PLBuffer.h lass ich auch erstmal noch oben nicht das da
  etwas durcheinander kommt. :)



>> 23.02.04
[CO]
- PLTStack leicht modifiziert



>> 19.02.04
[CO]
- PLTString um Funktionen zum setzen und auslesen von Zahlen hinzugefgt.



>> 15.02.04
[CO]
- Plugin Systeme wie Entity und Sound: Dadurch das nun whrend der Entwicklung zwei Versionen eines jeden Plugins vorhanden
  sind (Debug und Release) gab es teils crashs da dann doppelt noch das andere z.B: Release Plugin eingeladen wurde was
  aufgrund inkompatiblem Compiler Modus einen crash verursachte. Diese Plugins haben nun intern einen vermerk ob diese im
  Release oder Debug Modus sind - Plugins in einem falschen Compiler Modus werden nun nicht mehr geladen. Nun msste das mit
  dem Release/Debug Problemen entgltig der Vergangenheit angehren! Wenn nun was nicht geht dann liegts nur an nichtzusammen
  passenden Release Versionen. (da z.b. eine dll veraltet ist :)
- PLTList und PLTDynamicList -> Add Funktion so erweitert das optional ein Index mitgegeben werden kann um 
  festzulegen WO in der Liste das neue Element eingefgt wird



>> 11.02.04
[CO]
- PLTLanguageManager::GenerateLanguageList() -> Kann nun auch aus einer Preload Datei im Languages Block die verfgbaren
  sprachen auslesen falls mal ALLE Daten in einer pak Datei sind und daher die Sprachverzeichnisse nicht direkt abgelesen
  werden knnen.
- PLTList + PLTDynamicList: -> Da man beim Kopieren oft Start+Anzahl trifft (siehe read etc) haben wir nun beide
  Kopier Funktionen drin, also Start+Anzahl und Start-End. (heist CopyFromTo())
  Da die Listen sehr hufig Verwendung finden msste es ok sein wenn man da etwas mehr komfort bietet.
  Die Kopier Funktionen mssten so nun wirklich passen. (getestet)



>> 07.02.04
[CO]
- Ein paar kleinigkeiten am alten FS gendert so das man nun im HDRI Viewer auch direkt pak/zip files einladen kann



>> 05.02.04
[CO]
- PLTTimer: Delay() in Sleep() umbenannt damit es identisch mit dem PLGui Sleep() ist. Ist zwar nun im GuiNative und Timer
  doppelt, aber so hat man alles Timer Relevante in der Engine sauber in einer Klasse beisammen. :)



>> 04.02.04
[CO]
- PLTDynamicList: Copy() kopierte durch <= ein Element mehr als man angab
- PLTList: Neue Funktion. Copy
- PLTBitset: Neue Funktionen: GetSize() -> Liefert die Bitset gre zurck
                              Copy() -> Copiert Bits in ein anderes Bitset



>> 01.02.04
[CO]
- PLTTokenizer: GetDataBlock() Funktionen erweitert. Es gibt nun neben der Block Schreibweise [X Y Z ...] auch alternativ
  {X, Y, Z ...} da man beide Schreibweisen hufig antrifft. wird z.B. im berarbeiteten Material Format bei den Parametern
  verwendet um dort ein fx-hnliches Aussehen beizubehalten damit die Grafiker nicht zu 100% umdenken mssen und es leicht
  ist ein fx File in unser eignes Material Format umzuschreiben.



>> 29.01.04
[CO]
- PLTList: neuer operator: Concat. Zur Verkettung zweier Listen.
  Desweiteren wurden in einem Kunstruktor noch nicht die Variablen Initialisiert. (siehe MH oben)



>> 22.01.04
[CO]
- PLTOutputDevice in PLTErrorOutputDevice und PLTError in PLError (da gleich statische instanz) umbenannt.
- Erweiterte PLGeneral Headers um jeweils ein kleines Beispiel wie man die verschiedenen Klassen einsetzt



>> 21.01.04
[CO]
- Nahm aus PLList, PLHashTable und PLStack wieder die Assertion Funktionen heraus da man durch diese selbst bei
  einfachen Templates GEZWUNGEN wurde PLGeneral ins Projekt mit einzubinden auch wenn man eigentlich 'nur' Templates
  aus PLGeneral verwendete. PLMath ist somit wie PLGeneral komplett eigenstndig - verwendet zwar z.B. Listen aus PLGeneral
  aber dies erfordert keine Einbindung von PLGeneral in das PLMath Projekt.
  In Klassen welche sowieso die Einbingung von PLGeneral erfordern kann man ja sorgenlos die Assert Funktionen verwenden. :)
- Einige von Michals nderungen an String und Error wieder angepasst - ich hoffe da kam nun nichts durcheinander da unsere
  Codes diesmal stark voneinander abwichen - Michael, passe bitte auf das du nicht auf dem Server
  bereits genderte Dateien berschreibst. (wie dieses Tagebuch oder Codes)
  Am besten bevor du etwas hochlds zur Sicherheit prfen ob jemand was dran gendert hat. Am FileSystem ndern wir erstmal
  nichts bis du nicht das ok gibst - sonst kommt das durcheinander. :)
  Sobald wir auf CVS umstellen wird das sicherlich besser da diese Programm dann heftig warnt wenn man Datein die man
  hochladen will auf dem Server gendert wurden.
  Ps. Es ist wirklich, wirklich wichtig das die Codes so sauber sind wie mglich und mglichst kein Buchstabe vom Style
  abweicht. Wir haben mittlerweile insgesammt weit mehr als 2 MB an Quellcodes und wenn man da anfngt mit soetwas nachlssig
  zu werden wird man sich ganz bestimmt spter mal drber rgern. Von daher kommts schonmal vor das wir mehr Zeit in die Code
  pflege stecken als in das schreiben des Codes selbst... aber es lohnt sich da man sich dadurch spter Zeit spart!



>> 20.01.04
[CO]
- PLTTokenizer::GetDataBlockInt() und PLTTokenizer::GetDataBlockFloat() -> Brechen nun ab wenn beendende Klammer ]
  gefunden wurde und fllen den Rest mit 0. Geben die Anzahl der gelesenen Elemente zurck.
  (PLModelLoad.cpp und PLTextureHandler.cpp mussten aktualisiert werden)



>> 12.01.04
[CO]
- PLTFile::GetS() -> Fehler korrigiert (sonst gibts probleme beim HDRI maps im Viewer einladen)



>> 09.01.04
[CO]
- PLGeneral.h muss nun nicht mehr inkludiert werden bevor man z.B. PLTBitset verwenden will
  (dies geschieht nun in den PLGeneral Headern automatisch)



>> 03.01.04
[CO]
- PLTDynamicList: Neue Funktion: Add() -> Fgt ein neues Element in die Liste ein und gibt einen Zeiger darauf zurck
- PLTBitset erweitert -> Prft nun auch ob ein gegebener Bit Index korrekt ist
- PLTTokenizer: Neue Funktionen: GetNextTokenBool() und GetTokenBool() -> Machen das gleiche wie die Funktionen ohne Bool
  am Ende auer das diese den gefundenen Token als boolean Wert zurckgeben (erkennt auch 'false' und 'true')
- berall in Formaten wo man statt einer 1 auch 'true' schreiben knnte ist dies nun dank umstellung auf GetNextTokenBool()
  auch mglich



>> 30.12.03
[CO]
- PLTString: Michales neue nderungen wieder angepasst (bitte noch mehr drauf achten wie wir was schreiben Michael :)



>> 27.12.03
[CO]
- Passte noch ein paar kleinigkeiten von Michaels nderungen an PLTString an. Find() gibt nun direkt den Index zurck.



>> 20.12.03
[CO]
- PLTFileSystem::GetFilenameEnding() -> Wenn Datei keine Datei endung hat so wird pszFilenameEnding nun auf "" gesetzt



>> 13.12.03
[CO]
- PLTTimer: Neue Funktion: GetTickCountLow() -> Macht das gleiche wie GetTickCount() nur mit weniger genauigkeit
- PLTDataSet.Get() -> Gibt nun NULL zurck wenn ungltiger Index -> ein paar stellen in der Engine an denen Zeiger
  verglichen werden mussten angepasst werden



>> 27.11.03
[CO]
- PLString: Neue Funktion: - TStringModule::GetUsage() -> Gibt zurck wie oft ein String Module verwendet wird
  Neue Operatoren: += -> Hngt einen String an einen String an +  -> Verbindet zwei Strings zu einem neuen



>> 25.11.03
[CO]
- Mir war ein paar Minuten langweilig und da warf ich nochmal einen kurzen Blick auf PLGeneral und behob
  ein paar kleine Schnheits fehler - also absolut unntige nderungen. (sieht nun aber etwas universeller aus ;-)



/*********************************************************\
 *  Eintrge aus altem Diary, damals noch ohne genaue Datum angaben. (oben -> unten = neuer -> lter)
\*********************************************************/



[SB] Neues Projekt PLGeneral erstellt, welches alle allgemeinen Toolklassen enthlt (Listen, Strings, ...). Die
     entsprechenden Toolklassen wurden aus PLEngine entfernt, alle Projekte wuredn umgestellt (betrifft nahezu alle
     Projekte)
[CO] In PLTypes.h stehen nun auch Daten-Typ definationen wie z.B. WORD oder DWORD
[CO] PLTTimer: Portabel gemacht -> System abhngige Funktionen abgekapselt
[CO] PLTFileSystem::GetValidFilename() -> Prft ZUERST ob eine Datei in einem Sprach Unterornder ist und somit fr eine
     Sprache quasi 'berladen' wird (wichtig fr Lokalisierungen :)
[CO] PLTFileSystem: Neue Funktionen: ConvertBackslashsToSlashs() und ConvertSlashsToBackslashs()
[CO] Kleinen fehler in PLTList::Remove(int nIndex) behoben
[CO] PLTModule::IsHandler() war mittlerweile veraltet und musste daher aktualisiert werden
[CO] PLTList & PLTDynamicList um ein paar hilfreiche weitere Funktionen erweitert - auch in PLGui2
[CO] PLTLog: GetSystemMetrics herausgenommen, somit ist diese Klasse Windows unabhngig :)
[CO] PLTLanguageHandler: Strings werden nun anstatt mit Get() mit [] angefordert, etwas krzere und angenehmere
     Schreibweise :) CustomUpdate-Funktionen entfernt da wechseln der Sprache whrend das Programm luft nicht mehr
     mglich ist. *nur probleme mach* -> API Doku um Language System erweitert
[CO] Ordnungs-Wahn: Alle Dateien nochmal durchgegangen um sicherzustellen das alle das gleiche Layout haben... also die
     Beschreibung der Dateien, #idndef usw.   Den Code durchgegangen um sicherzustellen das immer zuerst Get und danach
     erst Set funktionen kommen. (damit alles einem einheitlichen Schema folgt ;-)
[CO] File System um Ordner fr 2D Guis erweitert, der Gui2D Loaded setzt nun wie alle anderen Loader den Dateinamen
     selbststndig dynamisch zusammen
[CO] PLTPluginManager: Alle Entity Plugins befinden sich in einem Module (internal, dll, entities) dessen name nun im
     Plugin selbst gespeichert wird. Mit GetModulePluginList() kann man eine Liste aller Plugins in einem Module
     anfordern. GetNumberOfModules() und GetModuleName() um Module Namen zu erhalten.
[CO] PLTTimer: Neue Funktion: Delay() -> Hlt die ausfhrung des Programms fr eine gewisse zeit an
[CO] PLTDataSet: Neue Funktionen: GetTotalSize() of den gesammten speicherbedarf in Bytes abzufragen GetElementSize() ->
     Liefert die gre eines grund Elements in Bytes zurck GetAllocated() -> Liefert die Anzahl der belegten grund
     Elements zurck. Desweiteren oben eine kurze Beschreibung des Data-Sets hinzugefgt.
[CO] PLTModuleManager: Behob einen (mehr oder weniger) kleinen fehler beim Laden von Modulen... bei SetName() wird das
     Module in den Module Handler eingetragen, kann das Module nicht geladen werden so wird es nun wieder korrekt vom
     Manager entfernt (ansonnsten crash beim Laden von nicht vorhandenen Resourcen :)
[CO] PLTTools: Neue Funktionen: FlipRB3() & FlipRB4() -> Optimierte Assembler Funktionen welche die RB komponenten in
     einem RGB bzw. RGBA Buffer vertauschen... ist bei diversen Bild Formaten notwendig... und so kann man die
     Ladezeiten etwas verkrzen :)
[CO] PLTLog: Neue Funktion: GetActive()
[CO] PLTFile um Funktionen zum Schreiben in Dateien erweitert
[CO] PLTModuleHandler: Neue Lade Funktion welche den Handler direkt mit einem Objekt ld
[CO] Stil der Friend deklarationen in den Klassen vereinheitlicht (ber all nun friend class, so machts auch weniger
     probleme mit den Predefinationen :)
[CO] PLTTimer: mit GetFPSLimit() & SetFPSLimit() kann man nun eine FPS limitierung einbauen, diese FPS wird dann nicht
     berschritten... die Engine wird entsprechend aktualisiert, dadurch bleiben dem System mehr Resourcen fr andere
     Dinge -> in fertigen Anwendungen sollte es keine FPS limitierung geben, zum Debuggen usw. knnte es aber ntlich
     sein :)
[CO] PLTModelHandler: GetStaticBoundingBox() & GetCollisionBoundingBox() entfernt. Wird ein Modell geladen so bergibt
     dieses all seine Bounding Boxes an sein Entity. Wird ein Modell entladen so verliert auch das Entity automatisch
     ALLE Bounding Boxes. Im Modell Handler selbst ist nun nur noch eine Bounding Box welche fr die Sichtbarkeits
     bestimmung verwendet wird! (diese wird beim Modell Laden automatisch erzeugt)
[CO] PLTTools: Neue Funktionen: GetVarType() & GetVarTypeString() -> Tool-Funktionen welche einen Variable Typen in
     einen String konvertieren oder umgekehrt
[CO] nderte bei den Pfadangaben die Backslashs zu Slashs damit alles einheitlich ist (es sind ja zwei verschiedene
     Schreibweisen im Umlauf :)
[CO] Alle PL-Tools in PLTools verschoben (ME, WE & Max plugin)
[CO] Die PLEBitField Flags waren falsch... das fhrte zu einem ganz erheblichen Performance verlust (da die Clear flags
     somit schrott waren :)
[CO] PLTTools: Neue Funktionen: SetFlagsString() und GetFlagsFromString() zum setzen und auslesen eines Flag-Strings
[CO] Ist der Timer 'eingefrohren' so werden nun auch keine Eingaben usw. akzeptiert, alles steht still ;-)
[CO] PLTModuleManager & PLTModule gendert. Nun hat PLTModule einen zeiger zurck auf PLTModuleManager denn wenn der
     Name von PLTModule gendert wird, so muss der Module Manager aktualisiert werden! Wichtig da die Module meist mit
     ihrem Namen angesprochen werden, daher darf es keine doppelten Module Namen geben! :)  ('Hey DU!... wer ich? NEIN
     du!' ;-)
[CO] PLTTokenizer: Einige Funktionen wie z.B. FindToken() und GetDataBlockInt() setzten am Ende automatisch auf den
     nchsten Token, dies erwies sich als ziemlich unpraktisch, daher ist dies nun gendert. (Funktionen welche den
     Parser verwenden wurden angepasst)
[CO] PLTModuleManager: Instance Check vorherst herausgestrichen da es ansonnsten unmglich ist den Module Manager von
     einer Anwendung aus zu verwenden (da durch Template Problem Instance dort immer NULL), desweiteren nahm ich
     m_lstIDHashList heraus womit die Get(ID) funktion nun besser zum durchlaufen einer Module Schleife geeignet ist
[CO] Neue Funktion: PLTModuleManager::Create() -> Erzeugt ein neues Modul und liefert den Zeiger darauf zurck
[CO] ber PLTConfig kann man nun einstellen ob die 3 Ebenen visualisiert werden sollen oder nicht
[CO] PLTFileSystem::SetApplicationPath() fgt nun am Ende automatisch ein '\' ein wenn dieses nicht vorhanden ist
[CO] Neue Window-Klasse: PLTWindowOpenDialog -> Ein Dialog zum auswhlen von Dateien -> Nam
     PLTFileSystem::GetFilenameDialog() heraus da nun berflssig
[CO] PLTList ist nun nur noch ein 'Hilfmittel', sprich, es kann keine Zeiger mehr Lschen!
[SB] Makros geringfgig verndert und die Namen vereinheitlicht, ber PL_IMPLEMENT_BASECLASS knnen nun auch mehrere
     Basisklassen implementiert werden
[SB] Die Makros wurden so erweitert, da nun auch die Variablen der Entity-Klassen exportiert werden knnen. In einer
     VarTable werden diese Variablen dann mit ihren Namen gespeichert
[CO] PLTFileSystem: Neue Funktion: SetApplicationPath() -> Damit lsst sich der Pfad der Anwendung einstellen, im Fall
     des Modell Editos kann man diesen Pfad nun einstellen
[CO] Diverse Tool-Klassen erweitert
[CO] PLTModuleManager hatte teils gleiches problem wie das PLTGui... in den Listen wurden gelschte Eintrge nochmals
     gelscht...
[CO] PLTTime -> Mit m_fTimeScaleFactor lsst sich nun ein universeller Zeit Faktor einstellen welcher IMMER angewannt
     wird. In der Konsole kann man diesen mit 'timescale 'f'' einstellen... beim Debuggen hilfreich :)
[CO] PLTPool -> Die Prioritt eines Pool-Elements lsst sich nun verndern... praktisch wenn man ein Element vor einem
     anderen haben will (z.B. Sky layer verndern) :)
[CO] Baute eine Profiling Tool Klasse ein welche Hilfreich bei der berwachung der verschiedenen Engine Teile sein wird,
     grob gesehen ist es nur eine Klasse welche verschiedene Gruppen von Texten verwaltet... aber mit diversen
     Hilfs-Funktionen :)
[CO] Neue Tool-Klasse: PLTPool -> Verwaltet eine Gruppe von Elementen wie z.B. Animations Informationen, Anker Punkten,
     Animation Events usw.
[CO] Copy funktionen eingebaut in: PLTMesh, PLTDataSet, PLTList, PLTDynamicList, PLTStack, PLTBitset
[CO] Neue Tool-Klasse PLTBitset zum verwalten beliebiger bits (z.B. um zu vermerken ob eine Geometry schon gerendert
     wurde oder nicht)
[CO] PLTFileSystem -> Neue Funktionen -> GetOnlyFilename() und GetDirectory()
[CO] Neue Funktion: PLTTimer::GetTickCount()
[CO] PLTTokenizer: GetNextToken() liefert nun einen Zeiger auf den gefundenen Token zurck damit man diesen z.B. sofort
     via atoi() in eine zahl umwandeln kann
[CO] PLTList & PLTDynamicList & PLTStack: Nahm Funktionen FindFirst(), FindNext() und GetCurrent() heraus da diese
     potentielle Fehlerquellen sind und der Operator [] durch die intere Zeiger optimierung mittlerweile genauso wenig
     Performance bentigt
[CO] Behob einen Fehler in der Listen-Klasse (beim Lschen... man, wie viele Fehler sind denn noch im Code!?? ;-)
[CO] Code sinnloserweise 'verschnert' ;-)
[SB] PLTTokenizer: Habe einen kleinen Fehler in den Abbruchbedingungen der Parserschleife behoben: Es ist auch mglich,
     da sich z.B. Kommentare und ungltige Zeichen mehrfach abwechseln, diese mssen alle ignoriert werden und drfen
     nicht als korrekte Zeichen angesehen werden
[CO] Behob einen kleinen Fehler im ModuleManager (zuerst Remove() und dann Objekt selbst entladen)
[CO] Erstellte eine einheitliche Tokenizer Klasse... benannte meine Klasse um und fgte Funktionen deiner hinzu... nun
     haben wir ein Monster Tokenizer ;-)
[SB] PLTTokenizer: Delimiters knnen nun auch whrend des Parsens ausgewechselt werden
[SB] PLTTokenizer Klasse hinzugefgt, welche zum direkten Auslesen von Tokens aus einer Textdatei dient.
[CO] PLTParser: Neue Funktionen: CompareTokens(), FindTokens(), GetTokensValueInt(), GetTokensValueStr(),
     GetDataBlockInt(), GetDataBlockFloat(), Push(), Pop()
[CO] Das Laden aus Archiven funktioniert nun endlich!! :)
[CO] Arbeitete etwas am FileSystem weiter. U.a. kann man nun auch ber die Klasse PLTFile aus zip Archiven laden.
[CO] FileSystem: Dateien knnen nun auch auerhalb des Spieleordners liegen
     (dies sollte man aber trotzdem vermeiden :)
[CO] Baute eine Hash-Klasse ein (PLTHash) welche z.B. im Entity Manager verwendet wird
[CO] Baute PLTString Klasse ein
[SB] Module System eingebaut
[CO] PLTDataSet wurde erweitert und kann nun auch die Daten anderer Daten sets verwenden. Dies wird z.B. in PLTMesh
     verwendet um einzelne Daten mit anderen Meshs zu teilen. Ein Vorteil dieser Technik: Kommen die geteilten Daten
     'abhanden', so werden die anderen Daten Sets darber informiert.
[CO] Erweiterte PLTDataSet um einzelene Elemente um alles noch dynamischer zu machen. Um z.B. Textur Koordinaten zu
     speichern kann man entweder PLTDataSet<PLFLOAT2> fTexCoord (1 element) oder PLTDataSet<float> fTexCoord (mit 2
     elementen) verwenden... wobei die letztere Technik mehr freiheiten lsst. ;-)
[CO] umbekannt: PLTDynamicLinkedList in PLTDynamicList
[CO] umbekannt: PLTLinkedList in PLTList
[CO] beseitigte den hsslichen Zeiger auf die delete-Funktion...  (Projekt-Einstellungen auf SE werte eingestellt :)
[CO] einen dummen Rechtschreibfehler behoben
[CO] baute dein Data Set Template ein (und erweiterte es etwas :)
[CO] viele kleine Stil anpassungen :)
[CO] Ordner strukturierung & docs
[CO] Namens ndung
[CO] Intel-Jpg-Lib durch Independent JPEG Group's ersetzt
