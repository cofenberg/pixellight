>> 31.01.2012
[CO]
PLFrontendQt:
- "DockWidgetManager::ShowDockWidget()": Was not calling "show()", "activateWindow()" and "raise()" on a newly created RTTI dock widget.
  After this minor change the "QTreeView::scrollTo()" issue we noticed was completly gone, without changing anything on the system itself
  or on applications using this system. But it may just be luck that it's now working, and the discussed enhancement below should still
  be done to be on the safe side.
- An special issue occured in "DockWidgetSceneGraph::SelectObject()" when using "QTreeView::scrollTo()", resulting in an internal
  discussion showing me that it's appearently not obvious how the RTTI dock widget system works. So, I added the following description
  to "DockWidgetManager" to make it clear how the system is intented to work: ("Pre<method name>" and "Post<method name>" was just
  added as a result of this internal discussion)
  "
     When using the "CallDockWidgetsMethod()"-method to perform a broadcast, the following actions are performed:
    - Calling "Pre<method name>"
    - Calling "<method name>"
    - Calling "Post<method name>" (don't do anything in here which may influence the outside world)

    Just calling directly "<method name>" may not be enough for every broadcast participator due to the near endless
    possibilities what such a participator can actually do when receiving the broadcast. Let's have a more or less
    abstract example to make the background clear:
    For better usability a broadcast participator is calling the Qt method "QTreeView::scrollTo()" to bring something
    into the visible area. "QTreeView::scrollTo()" is using the widget size, which may change during the main-broadcast
    when any broadcast participator is for example opening another dock widget with additional information causing the GUI
    to reduce the hight of our own dock widget. Or changing the size of the main window. Or changing the display resolution.
    Or doing something totally unexpected crazy. So, while "QTreeView::scrollTo()" was correct at the exact time it was called,
    the desired final result visible to the user may not be correct when the main-broadcast has been finished.
    -> This is no problem of the GUI system, a GUI may not even be used at all in certain system constellation
    -> This is no problem of any application using this system, the using application can't know any technical details of
       a certain system constellation, nor what broadcast participators will do

    Let's take "DockWidgetSceneGraph::SelectObject() as a concrete example, even if it may not be used in a certain system
    constellation. In here, the order "issue" from above can't be resolved by simply ensuring that the broadcast receivers
    are in the order required to make the special case "DockWidgetSceneGraph::SelectObject()" behaves correctly. Reasons:
    1. Adding any fixed order would require additional information, which is not available to the system or users of the system
    2. The system itself does not know "DockWidgetSceneGraph::SelectObject()", nor does it know what any broadcast participator do
    3. Another broadcast participator like "Bob::SelectObject()" may require a totally different broadcast receiver order
    4. Another broadcast like "Bob::TakesOverTheWorld()" may require a totally different broadcast receiver order
    5. Any application using this system, can't know what's happening when doing a broadcast, and therefore can't
       add any special hacks to work around issues possible with certain system configurations, which are also not
       known due to the dynamic nature of the system. New plugins can add new dock widget required new special behaviour.
    6. Adding any restrictions to this chaotic system would artificially limit it's use or would add dependencies where no
       dependencies are required
    "



>> 29.01.2012
[SW]
PLFrontendQt:
- PLTreeItems: Add Tooltip information about the Attributes for the first column.



>> 29.01.2012
[CO]
PLFrontendQt:
- "DockWidgetSceneGraph::UpdateTreeView()": Ensure that at least the current selection remains
- "SceneGraphTreeModel::SceneGraphNodeModifierTreeItem" needs to be informed about the destruction of it's object



>> 28.01.2012
[SW]
PLFrontendQt:
- SceneGraphTreeModel: Added the Method GetModelIndexForSceneNode to get an QModelIndex from an PLScene::SceneNode instance.
  To find the item in the model the memory address of the PLScene::SceneNode item is currently used for comparison.
  If there is a better way to identify a SceneNode exclusivly without relaying on a memory address then inform me
- Added Helper.h which contains an template class which makes it easier to store an pointer into an QVariant and get the value back.
  (The template class is a copy from http://blog.bigpixel.ro/2010/04/storing-pointer-in-qvariant/)
- DockWidgetSceneGraph: Added the missing part of the SelectObject implementation



>> 25.01.2012
[CO]
- Log enhancements
  - Bugfix: "Log::Write()" as soon as the internal log message backup buffer was full, the log was flushed always with each new entry
  - By default, the log buffers now 1000 instead of just 10 messages, we're not that memory restricted, even on mobile devices :D
  - Added "EventNewEntry"-event
- Added "Queue::Top()"
- Added "Stack::Bottom()"
- "Queue" and "Stack" are now iterable as well
- "ScriptManager" is now also using "ClassManager::EventClassUnloaded"
- Bugfix: "LoadableType" was not destroying it's loaders
- "LoadableManager" is now also using "ClassManager::EventClassUnloaded"
PLFrontendQt:
- Added log dock widget
- Added scene graph context menu



>> 22.01.2012
[SW]
PLFrontendQt:
- Renamed PLDynVarFloatTreeItem to PLDynVarNativNumericTypeTreeItem. This Item now handles more numeric base types (float, double, signed/unsigned integers in 8 16 32 and 64 Bit)
- Extended the Delegate to set proper min/max ranges to the QSpinBox for 8/16 singed/unsigned integers.
	(Note for 64Bit signed/unsinged integers there is no spinbox)
- Added Tree Items for Vector3i/2i and Vector4



>> 21.01.2012
[SW]
PLFrontendQt:
- Renamed SceneNodeInfoDelegate to PLTreeItemsDelegate because this delegate is mainly usefull for models which uses internally PLDynVarTreeItems
- Added PLDynVarVector2TreeItem and PLDynVarEnumTreeItem
- PLDynVarColorTreeItem is now also useable for PLGraphics::Color4
- Extended the Delegate to create a Combobox editor for Enum values



>> 20.01.2012
[CO]
- "Runtime::ScanDirectoryPlugins()" & "CoreApplication::OnInitPlugins()" & "FrontendApplication::OnInitPlugins()" no longer search within a "Plugins"-directory.
  Those directories had been removed several month ago because they were just trouble, especially under Linux. In case one really needs such a directory, it's no
  problem to add the one-line-code within the user application.
PLFrontendQt:
- RTTI browser: "ClassInfoAttributeTreeItem": Added "Type" and "Default" information (quite useful e.g. when scripting)
PLScriptBindings:
- "ScriptBinding_PL_Timing": Added "IsPaused()" and "Pause()"



>> 19.01.2012
[CO]
PLFrontendQt:
- "DockWidgetSceneRenderer": Added same item delegate as Stephan did in "DockWidgetObject"



>> 19.01.2012
[SW]
PLFrontendQt:
- Reviewed all QObject::eventFilter usage and in all cases we now doesn't filter out events which we handle to add additional handling
- Added setting an ItemDelegate for the TreeView used bei the DockWidgetObject.
  This ItemDelegate adds additional (rudimentary) features when handling edits:
    - Showing a color chooser button for rtti members which represent an Color (currently only when the typ is Color3)
    - Showing a spin edit box when floating point values should be edit with directly setting the value to the rtti member when changing the value in the edit control.



>> 18.01.2012
[CO]
PLScriptBindings:
- "ScriptBinding_PL_Timing": Added "GetTimeScaleFactor()" and "SetTimeScaleFactor()"



>> 17.01.2012
[CO]
- "ObjectBase" is now using a reference counter. I want to be able to create RTTI class instances from within a script to be able to access loose C++ components,
  and when this instance is no longer referenced by the script it has to be destroyed automatically. When I added script support several month ago, I didn't touch
  this because it would have been to many changes at once - also I tried to find another solution without touching "PLCore::ObjectBase". I was unable to find another
  solution not involving several ugly and error prone hacks. This has to be a feature directly implemented within "PLCore::ObjectBase" to keep things simple.
  -> When just using C++, this change is uncritical because it only has an influence in case this reference counting is really used
  -> To be on the safe side, we now have to add a reference whenever we created an RTTI instance, else when passing this object to a script, it would be destroyed by
     the scripted automatically. Because I don't think that we're able to (or want to) add some thousands "AddReference()" without forgetting a single one, "ObjectBase"
     is not directly derived from "RefCount<ObjectBase>". Instead the interface is reimplemented, but with an initial reference count of 1 and the additional method
     "SoftRelease()" releasing a reference without destroying the instance automatically. This way we can use "ObjectBase" as usual, and when creating an RTTI class
     instance we call "SoftRelease()" before we pass the object pointer into the script so that the script is now fully responsible for it's the object.
  -> I'am of course not totally happy with this solution because having an initial reference count of 1 is inconsistent to "RefCount". "SoftRelease()" can also be
     misused. But I'am afraid there's no other solution, except saying "It's impossible to create an RTTI class instance from within a script"... but this solution
     was not acceptable for me either because it's limiting the use of scripting.
PLScriptBindings:
- Added "Object *ScriptBinding_PL_ClassManager::Create(String sClass, String sParameters)" and
  "Object *ScriptBinding_PL_ClassManager::CreateByConstructor(String sClass, String sConstructor, String sConstructorParameters, String sParameters)"
  making it possible to create RTTI class instance via script
PLScriptLua:
- "LuaUserData": Implemented Lua __tostring metamethod callback (called when Lua tries to convert the user data into a string)
- "RTTIObjectPointer" gets now informed when it's assigned object gets destroyed



>> 16.01.2012
[SW]
PLFrontendQt:
- FrontendMainWindow: Made the windows version of the native OS event handling the same as under linux.
  Because, we don't do a event filtering here, so there is no reason to hide some native OS events from Qt.
  Under windows it seems that for the events WM_ENTERSIZEMOVE/WM_EXITSIZEMOVE it doesn't break something obviously in Qt, but to be an the save side it is better to not hide any native OS events from Qt.
  (Maybe Qt does react on these events to do some "performance" tweaks regarding resizeing the toplevel window by the user)
  We only add additional handling for not Qt components when certain native OS events occures, because Qt itself doesn't provide any useful events for the problem we try to solve here (e.g. the camera spinns around while the user moves/resizes the window).



>> 14.01.2012
[CO]
PLFrontendQt:
- "DockWidgetManager": Exposed "ShowDockWidget()" & "GetFirstDockWidget()" & "HideDockWidgets()" & "DestroyDockWidgets()" to the RTTI



>> 14.01.2012
[SW]
PLFrontendQt:
- FrontendMainWindow: added linux part of an workaround to avoid that the "render window" process mouse move input events while the user moves/resize the toplevel window.
  Added also a workaround for the same problem when the user drags an DockWidget. The only thing which can't be worked around is that the "render window" processes mouse input events while the user resize a DockWidget.
  This is nearly impossible to solve, because in this case no widget gets an focus in/out event. A solution might be to disable processing the mouse input
  events from the main mouse pointer (also used by the windowing system) by PLInput when the mouse cursor leaves the area of the render window (leave event).



>> 12.01.2012
[CO]
- Added "Script::GetAssociatedFilenames()" and implemented the method within the Lua backend
PLFrontendQt:
- "FrontendMainWindow": Do only start the timer when the initialization phase is over
- "FrontendMainWindow::~FrontendMainWindow()": Stop the timer at once, safe is safe
- Added "FrontendMainWindow::SetUpdateInterval()"



>> 08.01.2012
[CO]
- "LoadableManager": Added "GetTypesByExtension()" and "GetLoadersByExtension()"
- "LoadableType": Added "GetLoadersByExtension()"
- Fixed confusing path style inconsistencies within "ApplicationContext"
  -> "GetAppDirectory()": The documentation stated that this method returns "C:\MyApplication", while it was acutally "file://C:/MyApplication"
      and e.g. "GetExecutableFilename()" returned a native path style
  -> "ApplicationContext": "SetStartupDirectory()", "SetLogFilename()" and "SetConfigFilename()" have to ensure that native path style is stored internally
     as the documentation states
- "ApplicationContext": "GetAppDirectory()" points to the application directory, e.g. "C:\MyApplication" on Windows. This single method was fine when
  we only supported 32 bit. Back then this was equal to the directory the executable was in. When adding 64 bit support there was need to put the binaries,
  including the executable, within a separate directory to be able to switch between 32/64 bit while still sharing the same data. Now, "GetAppDirectory()"
  points to e.g. "C:\MyApplication" while for 32 bit the executable is e.g. within "C:\MyApplication\x86". But its also possible that there are situations
  were both point to one and the same directory. This means that there's need for another method explicitly returning the directory the executable is in.
  -> Added "GetExecutableDirectory()"
-> When writing the unit tests for this class, Jens Schmer noticed those confusing inconsistencies and partly missing documentation about path style etc.
- "CoreApplication::OnInitPlugins()" & "FrontendApplication::OnInitPlugins()": There's no guarantee that the application executable directory is the same
  as the application startup directory
  -> If the application executable directory is not the same as the application startup directory, do also scan the application startup directory
  -> This behaviour is quite useful because it allows development of plugins which can be tested within e.g. PLViewer without copying files around,
     just set the current directory to your plugin directory when launching the viewer application
PLFrontendQt:
- "SceneGraphTreeModel": Do not show scene nodes or scene node modifiers with a set "Automatic"-flag within a GUI (yes, this all way planned over years *g*)
- "DockWidgetSceneRenderer" & "DockWidgetObject": Usability: Resize the first tree view column given to the size of its contents



>> 08.01.2012
[SW]
PLFrontendQt:
- Added FilterWidgetWithFilterTypSelector
- Added fallback icon f端r the filter type selector icon
- Renamed ClassListSortAndFilterModel to TreeSortAndFilterProxyModel, because this proxy model is useable for all Tree like models/views
- In the DockWidgetSceneGraph the tree can now be filtered with the new FilterWidgetWithFilterTypSelector either bei SceneNode name oder class name



>> 07.01.2012
[CO]
PLFrontendQt:
- Sadly, it appears that Qt's signal/slot mechanisms can't be used without QObject/Q_OBJECT. But we don't want to do a multiple inheritance
  like "class DockWidgetSceneGraph : public QObject, public DockWidgetScene" either because this can cause serious casting issues. Casting may
  work in simple cases... but I just had one of those situations were I wondered for a second why my "DockWidgetSceneGraph" data was messy, tried
  to remove the multiple inheritance at once and the issue was gone. So, we need to add another class just to be able to use Qt's signal/slot mechanisms.
  We can't use an embedded class for this either because Qt's MOC doesn't like this. :/
  -> Added "DockWidgetSceneGraphQObject" and "DockWidgetSceneRendererQObject"
- "DockWidgetSceneGraph": Added "SetSceneContainer"-broadcast
- "DockWidgetSceneGraph" is now asking his colleagues via "GetSceneContainer()" whether or not one of them knows the currently used scene container



>> 06.01.2012
[SW]
- PLFrontendQt: Added ClassListWidget which adds an filter line on top of the data view.
  The used filter widget is a copy of the FilterWidget class used by the Qt designer, with some minor modification.



>> 06.01.2012
[CO]
- "RegEx::Match()": Added early escape test: In case we try matching when we are already at the end of the string, we know the result without doing any matches
PLFrontendQt:
- There's no longer need to tell new instanced RTTI dock widgets about current states they might be interested in. They are autonomously communicating with each
  other and asking their fellows for required information. This way we can add new features without e.g. touching PLViewerQt.



>> 05.01.2012
[SW]
- PLFrontendQt: the items in the ClassInfoModel now shows a proper Tooltip



>> 05.01.2012
[CO]
- Added "Object::SignalDestroyed"-signal which is emitted when the object is destroyed. This means 8 additional bytes per "PLCore::Object"-instance on a 32 bit machine,
  but I was unable to think of any other decent way for this. There are situations were one needs to know when an RTTI object has been killed. An example for such a
  situation is "PLFrontendQt::DockWidgetObject" were the GUI has to be informed about the murder of it's fosterling.
  -> At first I tried the following solution:
    - Within "ClassManager" added
          Event<const Object*> EventObjectCreated;    /**< An object has been created (do not destroy the given instance), if you have another option, don't use this event to get this information in order to keep the internal overhead to a minimum */
          Event<const Object*> EventObjectDestroyed;  /**< An object has been destroyed (the object may already be invalid, do not destroy the given instance), if you have another option, don't use this event to get this information in order to keep the internal overhead to a minimum */
    - Within "Object" constructor/destructor added
      Object::Object()
      {
          ClassManager::GetInstance()->EventObjectCreated(this);
      }
      Object::~Object()
      {
          ClassManager::GetInstance()->EventObjectDestroyed(this);
      }
    - This way, the "PLCore::Object"-instance would not have gained 8 bytes more weight... but I assume the runtime overhead would have run faster out of control as I could have
      sayed "bad idea".
- Fixed invalid cast within
  SimpleList<ValueType>::SimpleList(const Container<ValueType> &lstSource, uint32 nStart, uint32 nCount)
  -> GCC found it
- When using "StringBuffer::GetNumOfBytes()" one has now to specify the internal string format. The previous approach was highly dangerous leading in worst case
  bug combination within a buffer overflow.
PLFrontendQt:
- Replaced the "SelectSceneNode" broadcast by the more generic "SelectObject"
- "DockWidgetSceneGraph::QtSlotTreeViewDoubleClicked()" now also reacts on selected scene node modifier
- "DockWidgetObject" supports now the generic "SelectObject" broadcast
- Removed "DockWidgetSceneNode" because there's currently no difference to the more generic "DockWidgetObject"
- "DockWidgetObject" is now using the new "PLCore::Object::SignalDestroyed"-signal
- "DockWidgetSceneRenderer" is now using the new "PLScene::SceneRenderer::EventDestroyed"-event
- "DockWidgetSceneRenderer": When the encapsulated Qt dock widget gets shown, there's a scene renderer refresh when required
- "DockWidgetManager::ShowDockWidget()": "pQDockWidget->raise();" was missing, now the Qt dock widget comes into foreground as indented



>> 04.01.2012
[SW]
- Implemented linux part of System::GetModuleFilenameByMemoryAddress(). It is using the glibc extension dladdr. On a short search it seems that this method
  exists also under Android 2.2 and up and Mac OS X 10.3 and up. Due lack of devel environment for those platform i can't check if this is true
- PLFrontendQt: moved the ClassInfoItemRoles enum back to the header
    The ClassInfoWidget now hides tabs for class items which are empty. And the Items in the tabs are now sorted.
    Fixed adding items for Properties
    Added MOdel items for Constructor and Methods (currently they return the signature given by the GetSignature Method for testing as tooltip)



>> 04.01.2012
[CO]
- "ClassManager": Renamed "GetModule()" into "GetModuleByID()"
- "ClassManager": Added "GetModuleByName()"
- "Module::GetFilename()" now returns a native style path, documented this behaviour
- Added "System::GetModuleFilenameByMemoryAddress()": We give this method a pointer to a memory address located in a certain shared library
  or executable, and we want to know the absolute filename of this shared library or executable.
- "ClassManager::RegisterModule()": Changed signatur parameter "uint32 nModuleID" into "const uint32 *pnModuleID". This way we have the module
  ID as well as a memory address inside the shared library or executable the module is implemented ("memory anchor"). We can now use this memory
  address together with the new "System::GetModuleFilenameByMemoryAddress()" to get the module filename.
  -> At least on Windows, "Module::GetFilename()" no longer returns an empty string for modules directly loaded at program start by the operation system
  -> Currently, the Linux implementation just returns a null pointer (nothing highly dramatical, I have no time to check this on another platform)
- "Frontend": Renamed "SetPositionSize()" into "SetWindowPositionSize()" to make clear that this is about the window, not the client area we're usually
  interested in
- "Frontend": Added "GetWindowPositionSize()", the counterpart of "SetWindowPositionSize()"
PLFrontendQt:
- Review of "ClassInfoModel", "ClassListModel", "HeaderTreeItem": Only the usual code combing to enable my eyes to locate code faster by jumping to usual places,
  no change in functionality
- "ClassInfoModel", "ClassListModel": Fixed Visual Studio 2010 compiler warnings like
    "warning C4482: nonstandard extension used: enum 'PLCore::EMemberType' used in qualified name"
- Added "ClassInfoWidget" & "RTTIBrowserWidget" from an RTTI browser example Stephan Wezel gave me, those are reusable GUI building blocks
- Added "DockWidgetRTTIBrowser" which is just a tiny helper class making it possible to create an RTTI browser dock widget instance at once
    -> WOW, Stephans RTTI browser works like a charm. By using it, it's finally possible (again) to browse through the RTTI in order to see which classes,
       attributes etc. are available. This information is quite useful when manipulating scene files within a text editor, adding user properties within 3ds Max,
       writing scripts... it's a kind of interactive realtime documentation. :D
- RTTI browser: Best to show and work only with class names including namespaces (unique names, this way we also don't have to explain to the user
  technical stuff when to use a namespace and when not, for the user it's just a name :)
- RTTI browser: Everything is derived from "PLCore::Object", expand this level by default when showing the class hierarchy
- "DockWidgetSceneGraph": Send broadcast when double clicked, not clicked. Same behaviour as in RTTI browser or PLViewerQt 3D viewport.
- General GUI titles: It's probably common to use something like "Scene Graph" instead of "Scene graph"
- RTTI browser: Module view: Added module filename within the tooltip (important information so one can see exactly where this modules comes from)
- "Frontend": Methods like "GetMousePositionX()" are now using the central widget of the Qt main window instead of the Qt main window itself. This way there are
  no issues when adding dock widgets to the Qt main window because the frontend itself is only concerned about the central widget and is not interested in the
  GUI stuff around it.



>> 03.01.2012
[SW]
PLFrontendQt:
- Added models for RTTI "browsing"



>> 03.01.2012
[CO]
PLFrontendQt:
- Added project description
- Added PixelLight RTTI dock widget manager
- "DockWidget": By default, when someone is closing the dock widget Qt hides instead of deletes it
  -> We could write
         setAttribute(Qt::WA_DeleteOnClose);	// Delete the dock widget instead of hiding it when someone is closing it
     to change this behaviour, but when "reopening" the previously made changes to the widget layout would be gone and
     we don't want this. So, long story short conclusion, don't change the default behaviour in here.
- "DockWidgetManager": Implemented dock widget broadcast by mirroring the "PLCore::Object"-interface. This is a quite universal way for a communication
  with and between the dock widgets... and e.g. scripts like Lua can participate in the communication...
- Dock widgets: Added first broadcast "SelectSceneNode": A RTTI method which is called when a scene node is selected
- "DockWidget": Added the same communication interface as in "DockWidgetManager", but the emitting dock widget is excluded and one does not have to make
  a dock widget manager test in order to broadcast something. This communication infrastructure is important, so, it has to be as easy to use and robust as
  possible.
- "DockWidgetSceneGraph" & "DockWidgetSceneNode" must take into account that the used scene node can be destroyed at any time
- "SceneGraphNodeTreeItem" (within "SceneGraphTreeModel.cpp"): We must take into account that the used scene node can be destroyed at any time. For now
  I tried to make as few changes as possible to remove the crash in this situation. Added the following comment within "SceneGraphNodeTreeItem::OnDestroy()":
      "Review this situation when the scene node get's killed, update the tree view. Maybe we don't need
       to have an own event handler for each and every tree item and a single one for the whole tree is enough.
       (maybe we just need to know that an item is now invalid due to removal, then rebuild the tree?)"
  so it can be seen what's going on. Currently this results in empty tree view entries, but better than a crash because we can see what happend.



>> 31.12.2011
[CO]
PLFrontendQt:
- "DataModels::SceneGraphTreeModel::GetQImage()": For some reason, "QImage" appears to be BGR instead of RGB although the documentation states otherwise
  (maybe a little/big endian thing?). Double checked "PLGraphics::Image" to ensure it's no bug, and I can't imagine that it's a Qt bug either. Now the icons
  look correct.
- Added "DockWidgetSceneRenderer"
- "DockWidget": Delete the dock widget instead of hiding it when someone is closing it
- "FrontendMainWindow::mousePressEvent(QMouseEvent *)": [HACK] As soon as there's a Qt dock widget there are focus issues?
  -> Central widget has the focus, click in dock widget, click back in central widget and no focus change?
     Even when destroying the dock widget the focus is now completely messed up?
  -> When adding "setFocus()", all those issues are gone... but why is there such an issue in the first
     place? I was unable to find anything in the Qt documentation and other approaches didn't work either. :/
  -> Spend some hours in trying to figure out what's going on, but I finally have to go on and so this current solution must do the job until someone else has
     a better solution or an explanation for this behaviour. Can be tested in "PLViewerQt".
- Another funny Qt dock widget behaviour: Central widget has the focus, moving the mouse to the docked dock widget and dragging it out so that it is floating and
  while doing so the central widget has still the focus, when stopping the action the focus jumps to the dock widget. Why hasn't the dock widget the focus at
  once when clicking with the mouse onto it in order to start the floating step? I'am starting to remember why I don't like to work with GUI stuff. :/



>> 30.12.2011
[CO]
PLFrontendQt:
- Added abstract PixelLight RTTI class "DockWidget" encapsulating a Qt dock widget. While PLFrontendQt already offers several basic building blocks one can use
  within a Qt project, the goal of those RTTI dock widgets is to provide something high level. One can imagine those guys as ready-to-be-used components which
  just need to be instanced to add new dockable features to a Qt main window. A RTTI dock widget has to be as simple as possible in it's usage and e.g. has to
  provide a decent default behaviour. That's why I talked about "high level", they take away a certain amount of freedom, but give you something to see usable
  results at once in a generic way. By writing e.g.
    const PLCore::Class *pClass = PLCore::ClassManager::GetInstance()->GetClass("PLFrontendQt::DockWidgetSceneGraph");
    if (pClass)
        pClass->Create(PLCore::Params<PLCore::Object*, QWidget*>(pQtMainWindow)));
  one has at once a new dock widget within the Qt main window which can be used to work with the default application scene graph. Due to the PixelLight RTTI
  new RTTI dock widgets can be added easily and then e.g. automatically be used within PLViewerQt. For example, within my master thesis I'am going to need
  special GUI elements to e.g. manipulate transfer function. Now, all I have to do is implementing such a new RTTI dock widget and I'am ready-to-go within
  PLViewerQt... and can also reuse those new RTTI dock widgets in other applications as well... :D
  I'am sure that in the end some RTTI dock widgets have to interact with each other. Similar to the intends of Android. Shouldn't be a problem by using the
  PixelLight RTTI, but that's for the next implementation step. For now it was only important to have the fundamental idea up and running to see whether or not it can work.
  Right now it looks like it's working pretty well without being complex... the PixelLight RTTI and Qt are doing all the hard work as well as the basic building
  blocks Stephan Wezel already wrote.
- Added "DockWidgetObject", "DockWidgetScene", "DockWidgetSceneNode" and "DockWidgetSceneGraph" dock widget RTTI classes to have something to start with. Currently
  the interface is quite basic and will be enhanced. I'am sure a lot more of those fellows will follow over time.



>> 30.12.2011
[SW]
PLFrontendQt:
- When setting the start SceneNode for the SceneGraphTreeModel the user can now specify if the start node should be hidden. The same parameter is also added to QPLDebugDialog::SetContext



>> 29.12.2011
[CO]
- "Frontend": The "GetImpl()"-method needs to be public because it might be required to e.g. access the Qt frontend
PLFrontendQt:
- Added missing "ressources.qrc" processing within the Visual Studio project file
- "FrontendMainWindow": To make it possible to add e.g. a menu bar, it's required to render only into the "central widget". By default there's no central widget -
  added "FrontendRenderWindow" for the actual render window and embedded it into "FrontendMainWindow" as central widget.
- "QPLRenderWindow" is now derived from "FrontendRenderWindow"
- "FrontendMainWindow::timerEvent()": When performing the update step, we need to check whether the frontend is still valid and running, if not we have to shut
  down our application
- Added static helper class "ConstructFileFilter" for constructing file filters for "QFileDialog"



>> 28.12.2011
[CO]
PLFrontendOS:
- "FrontendAndroid": "GetX()", "GetY()", "GetWidth()" and "GetHeight()": Lookout! We need to use the current content rectangle of the window, not the window surface
  because the OS may add something like a virtual back-key to the window surface. If we directly use the window surface something like the FPS display on the bottom
  of the screen might be cut off.



>> 25.12.2011
[CO]
- Over the last past days, Stephan reported some issues with RTTI classes being instanced multiple times. A known issue. Added Stephans patches adding some more
  compiler checks and finally did the export/import refactoring discussed some time ago. The required compiler/definition checks are getting more complex
  as we add support for more platforms and compiler versions. PLCore now defines "PL_GENERIC_API_EXPORT" and "PL_GENERIC_RTTI_EXPORT" for export as
  well as "PL_GENERIC_API_IMPORT" and "PL_GENERIC_RTTI_IMPORT" for import. Instead of performing the compiler/definition check in every project, those
  projects should now use this new definitions. Updated the projects performing export/import and removed no longer required files:
    - "PLDatabase": Removed "PLDatabaseLinux.h" & "PLDatabaseWindows.h"
    - "PLMath": Removed "PLMathLinux.h" & "PLMathWindows.h"
    - "PLGraphics": Removed "PLGraphicsLinux.h" & "PLGraphicsWindows.h"
    - "PLInput": Removed "PLInputLinux.h" & "PLInputWindows.h"
    - "PLGui": Removed "PLGuiLinux.h" & "PLGuiWindows.h"
    - "PLRenderer": Removed "PLRendererLinux.h" & "PLRendererWindows.h"
    - "PLMesh": Removed "PLMeshLinux.h" & "PLMeshWindows.h"
    - "PLScene": Removed "PLSceneLinux.h" & "PLSceneWindows.h"
    - "PLEngine": Removed "PLEngineLinux.h" & "PLEngineWindows.h"
    - "PLPhysics": Removed "PLPhysicsLinux.h" & "PLPhysicsWindows.h"
    - "PLSound": Removed "PLSoundLinux.h" & "PLSoundWindows.h"
    - "PLIRC": Removed "PLIRCLinux.h" & "PLIRCWindows.h"
    - "PLJabber": Removed "PLJabberLinux.h" & "PLJabberWindows.h"
    - "PLParticleGroups": Removed "PLParticleGroupsLinux.h" & "PLParticleGroupsWindows.h"
    - "PLSPARK_PL": Removed "PLSPARK_PLLinux.h" & "PLSPARK_PLWindows.h"
    - "PLlibRocket": Removed "PLlibRocketLinux.h" & "PLlibRocketWindows.h"
    - "PLCompositing": Removed "PLCompositingLinux.h" & "PLCompositingWindows.h"
    - "PLGuiXmlText": Removed "PLGuiXmlTextLinux.h" & "PLGuiXmlTextWindows.h"
    - "PLFrontendPLGui": Removed "PLFrontendPLGuiLinux.h" & "PLFrontendPLGuiWindows.h"
    - "PLDatabaseSQLite": Removed "PLDatabaseSQLiteLinux.h" & "PLDatabaseSQLiteWindows.h"
    - "PLDatabaseMySQL": Removed "PLDatabaseMySQLLinux.h" & "PLDatabaseMySQLWindows.h"
    - "PLDatabaseNull": Removed "PLDatabaseNullLinux.h" & "PLDatabaseNullWindows.h"
    - "PLDatabasePostgreSQL": Removed "PLDatabasePostgreSQLLinux.h" & "PLDatabasePostgreSQLWindows.h"
    - "PLScriptV8": Removed "PLScriptV8Linux.h" & "PLScriptV8Windows.h"
    - "PLScriptPython": Removed "PLScriptPythonLinux.h" & "PLScriptPythonWindows.h"
    - "PLScriptNull": Removed "PLScriptNullLinux.h" & "PLScriptNullWindows.h"
    - "PLScriptLua": Removed "PLScriptLuaLinux.h" & "PLScriptLuaWindows.h"
    - "PLScriptAngelScript": Removed "PLScriptAngelScriptLinux.h" & "PLScriptAngelScriptWindows.h"
    - "99TestPlugin": Removed "99TestPluginLinux.h" & "99TestPluginWindows.h"



>> 20.12.2011
[CO]
- "String"-class: Added "String &Insert(char nCharacter, uint32 nPos)" and "String &Insert(wchar_t nCharacter, uint32 nPos)" (there were already such
  "Replace()"-method variants)
- Bugfix within script implementation "PLScriptLua::RTTIObjectPointer::NewIndexMetamethod()": We can't just use "lua_tostring(pLuaState, 3)" because Lua
  will give us e.g. for a boolean type just an empty string, meaning that within a Lua script something intuitive like "MyRTTIObject.MyBooleanAttribute = true"
  would not work. Handled this Lua behaviour.



>> 15.12.2011
[CO]
- "Url": Added more examples within the documentation in order to be able to understand what the URL-class will do with provided data
- "System::GetCurrentDir()": Enhanced documentation to make it possible to understand it's behaviour
- When Thomas M端hsam worked on PLInstall, he noticed that the behaviour is different across multiple methods dealing with filenames and
  paths. I finally took the time to have a look into it by documenting behaviour of some methods in more detail and adding more examples.
  One typical confusion is whether there's a "/" at the end of a path - this is usually up to the user and e.g. the "Url"-class will not force
  a certain approach onto the user. Another confusion is whether not not there has to be a "file://" for every local path. This is another thing
  handled by the "Url"-class. For example "Url::CutFilename()" will omit the protocol for a local path (e.g. the result will not be
  "file://C:/Programs/App/"). I was unable to find an explanation for this within the documentation or diary, but I'am sure there's a good
  reason for this. Changing the behaviour of such a fundamental class on the fly is a no go, so I don't touch this right now. The overall
  URL handling in PixelLight is determined by the "Url"-class and other components of PixelLight should not try to break with "Url"-class behaviour.
- Reviewed the relatively new "Runtime"-class and ensured that the different methods return the paths in the same format
- "Runtime": The "Data"-methods no longer have a "/" at the end to have a similar behaviour across this class
- "LogFormatterText::Open()": Reverted the change from "19.10.2011", UTF8 within logs is trouble we best avoid... there are tools out there still
  having issues with UTF8 and UTF8 is in general more complex and for a simple text log those additional efforts and troubles are not justifiable. Wrote
  a hint into the first log line so that no one wonders when a cryptic Unicode character from a none English language doesn't show up correctly.



>> 10.12.2011
[CO]
- "MemoryManager": Made the methods inline in order to give the compiler a chance to optimize out function calls. Of course, for this it's required to include
  "standard"-headers into PixelLight headers which is potentially dangerous when it comes to cross-platform because usually this makes at least on one platform
  problems in a certain header include combination. But these memory operations are totally basic building blocks, same topic as in PLMath diary entry "15.11.2011"
  regarding to the "PLMath::Math"-class with fundamental math building blocks. So, this must be worth the rest. It's still better then directly using the
  "standard"-function because in case there are serious issues on a platform in the future, it's quite easy to resolve them because only this one header has to
  be touched. I added as usual a long comment explaining why this header is including "standard"-headers and also a long dirary entry so everyone can see that
  this isn't an inline-mood. :D
-> By the way, the first PixelLight diary, this one, just reached 10.000> lines... sure, there are spaces and one could play around with the line size, but hey,
   10.000> lines. Took just 9> years...
- Reviewed commit 1786dd0e5be679c566891d5aae62a6c38771df50 (see PLCore diary entry "03.12.2011")
  -> Looks fine in general, except that "PLCore::System" is already providing the required information, removed "ARCHITEXTUREANDBITSIZE_STRING" definition
  -> "LinuxCommon.cmake" was using "CMAKETOOLS_TARGET_ARCH" while it should have used "CMAKETOOLS_TARGET_ARCHBITSIZE"
  -> "PLCore::Systen::GetPlatformArchitecture()" returns for instance 'x86', 'x64', 'armeabi', 'armeabi-v7a' and so on (as extensively documented). Yes, the
     technical proper name for x64 would be "x86 architecture with 64 bit extensions", but that's far to technical and something like "x86_64" is more difficult
     to read and name during a conversation as the marketing term "x64". That's why e.g. the runtime subdirectory is named "x64", not "x86_64".



>> 07.12.2011
[CO]
- "SystemAndroid": Added "GetAndroidApp()" and "SetAndroidApp()"
- "SystemAndroid": Made some methods inline



>> 06.12.2011
[CO]
- While adding more unit tests, Jens Schmer found another bug within the container classes. When down resizing an full array, the number of elements within
  the array was not the new maximum number of elements, it was the new maximum number of elements -1. Interessting that this never caused any problems. Cool
  that we now have someone testing thru the classes in detail via unit tests. :D
- The implementation of "Class::GetDerivedClasses()" was
	const List<const Class*> Class::GetDerivedClasses() const
	{
		// Get list of derived classes
		List<const Class*> lstClasses;
		ClassManager::GetInstance()->GetClasses(lstClasses, m_pClassImpl->GetClassName(), NonRecursive, NoBase, IncludeAbstract);
		return lstClasses;
	}
  -> This is clearly quite ineffective, especially because it's a linked listed. Changed the signature of this comfort method into
     "void GetDerivedClasses(List<const Class*> &lstClasses) const"
     meaning that there is no longer a temporary coping around and such a signature is not totally unusual.
  -> Within PixelLight itself, this method is never used, so, no other updates were necessary



>> 03.12.2011
[SW]
- The GetRegistryDirectory Method checks if the path read from the "registry" exists and returns an empty string if not.
  Under linux added ARCHITEXTUREANDBITSIZE_STRING define which holds the architecture and bitsize string (e.g. x86 for 32bit x86 code or x64 for 64bit x86 code).
  The string from this define gets appended to the standard install paths of pixellight.



>> 03.12.2011
[CO]
- More inline within PLCore: "String", "Class", "ClassImpl", "ClassManager", "MemberDesc", "Module", "DynEvent", "EventDesc", "EventHandlerDesc", "ConstructorDesc",
 "FuncDesc", "ParamsParser", "ParamsParserXml", "VarDesc", "ApplicationContext", "CoreApplication", "Config", "Frontend", "FrontendApplication", "FrontendContext",
 "FrontendImpl", "Log", "LogFormatter", "LogFormatterHtml", "Buffer", "Connection", "Host", "Socket", "SocketAddress", "HttpClient", "HttpHeader", "Registry",
 "ScriptManager", "Runtime", "Pipe", "Process", "Chunk", "CommandLine", "CommandLineOption", "HTMLParser", "Loadable", "LoadableManager", "LoadableType", "Loader",
 "Localization", "LocalizationGroup", "LocalizationText", "ProfileGroupElement", "Time", "Version", "XmlAttribute", "XmlBase", "XmlComment", "XmlDeclaration",
 "XmlDocument", "XmlElement", "XmlNode", "XmlText", "XmlUnknown"



>> 30.11.2011
[CO]
- PLFrontendOS: Added empty "OSWindowMacOSX"-class as start point for the Cocoa (Objective-C API) port (X11 can be used on Mac OS X, but it's best to avoid using it
  to avoid compatibility trouble)
- PLFrontendOS: Renamed "XDnDFileDropHelper" into "Linux_XDnDFileDropHelper" to make clear that this helper class is Linux related



>> 29.11.2011
[CO]
- Feature request "ID: 3443487" (http://sourceforge.net/tracker/index.php?func=detail&aid=3443487&group_id=507544&atid=2063685): Added critical section support to
  the mutex implementation. This is a Windows specific thingy:
  - "Mutex":            Lock/unlock across multiple processes
  - "Critical Section": Lock/unlock only inside the same process
  -> Default has to be "Mutex" to be on the safe universal side
- PLFrontendQt: Visual Studio project file: Disabled annoying "warning C4127: conditional expression is constant"-warning, it's within the Qt
  headers were we can't change anything in there :/
- Added "CriticalSection"-class, a simple comfort class derived from mutex
- "FileObject", "File", "Directory", "Url", "System", "DynLib", "Mutex", "Semaphore", "Thread", "FileSearch", "Timing", "Tokenizer", "RegEx": Everything reasonable
  to be inline is now inline to give the compiler a chance to optimize out expensive function calls. I'am sure that over the time more of such changes will follow.



>> 26.11.2011
[CO]
- As feared yesterday, my "Socket::GetNumOfWaitingBytes()"-method wasn't really correct. As mentioned, my network topic experience is near to zero and to be honest,
  I don't have the time to get into it in detail because I already have to manage all other topics at once. Sadly, my day has only 24 hours - so, we have to rely on
  teamwork to get everything done. That's why I'am totally happy that within the bug tracker there's response (ID: 3442166) pointing me into the right direction. :D
  -> Renamed "Socket::GetNumOfWaitingBytes()" into "Socket::IsDataWaiting()"
- Bugfix (ID: 3442054 - http://sourceforge.net/tracker/index.php?func=detail&aid=3442054&group_id=507544&atid=2063682 ): "PLCore::Connection::Receive()" called
 "PLCore::Connection::OnReceive()" with the fixed buffer size, instead of with the number of received bytes
    -> Also reviewed this class and checked whether or not the comments are detailed enough
- While working on PLUnitTests, Jens Schmer noticed several issues and inconsistencies. I asked him to mark everything he's noticing, not only real bugs, but also
  usability stuff like when a method behaves another way as expected when reading the method name and documentation. I try to have a look at each point, one
  after another without, hopefully, breaking anything or introducing new issues.
  -> "Container"-class: Have a look at the following methods:
    virtual ValueType &Add() = 0;
    virtual ValueType &Add(const ValueType &Element) = 0;
    virtual ValueType &AddAtIndex(int nIndex) = 0;
    virtual bool AddAtIndex(const ValueType &Element, int nIndex) = 0;
    The last one has another return value as the other methods. That's definitly unexpected. Changed "virtual bool AddAtIndex(const ValueType &Element, int nIndex) = 0;"
    into "virtual bool AddAtIndex(const ValueType &Element, int nIndex) = 0;". As far as I can see, this method is never used, so, it should be safe to make this change.
  -> "Container"-class: Making a container to a copy of an empty container didn't work, the result has to be a empty container
  -> "Container"-class: Using the "Compare()"-method with two empty containers returned 'false' instead of 'true'



>> 25.11.2011
[CO]
- There's a first feature request at http://sourceforge.net/tracker/?group_id=507544&atid=2063685 "Socket::IsArrivalData() - ID: 3439371"
  -> I waited several days to give other team members the option to handle the request, but I'am sure that it's no good idea to have such open minor feature
     requests for several weeks...
  -> Added "Socket::GetNumOfWaitingBytes()" returning the number of bytes waiting to be received (non-blocking request)
  -> I have only a little bit of experience in network related topics, so, if I totally messed it up please tell me :D
- "PLFrontendOS::FrontendAndroid()": It's now required to provide the constructor with a frontend context instance. This way, it's e.g. possible to tell
  the frontend about the RTTI class name of the application to start.



>> 24.11.2011
[CO]
- Bugfix: "PLCoreLinux.cpp": The implementation of "wcscasecmp" and "wcsncasecmp" was broken (Mac OS X or Android don't have such primitive "standard" functions)
  -> "wcscasecmp": http://linux.die.net/man/3/wcscasecmp states
     "The wcscasecmp() function returns zero if the wide-character strings at s1 and s2 are equal except for case distinctions. It returns a positive integer if s1
      is greater than s2, ignoring case. It returns a negative integer if s1 is smaller than s2, ignoring case"



>> 16.11.2011
[CO]
PLScriptBindings:
- Exposed "PLCore::ClassManager::ScanPlugins"-feature to scripts
- Exposed "PLCore::System::GetPlatformArchitecture"-feature to scripts
PLScriptLua:
- Bugfix: "RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()": Boolean and string values were not handled correctly



>> 13.11.2011
[CO]
- Thomas M端hsam noticed that "System::GetCurrentDir()" returned, unlike many other methods, a native style instead path of an uniform style path and also sayed that
  this makes directly comparing paths impossible (this resulted in a discussion about interfaces :). It's first required to check in which form the given path is,
  and then converting them into an universal form so they can be compared. Searched the PLCore diary for the reason why this method is returning a native
  style path... it turns out that over the years, this had been changed multiple times:
  - "17.04.2008": I changed it from native to uniform with the argument now also Thomas M端hsam mentioned
  - "03.08.2010": Stefan Buschmann changed it from uniform to native form, I wasn't able to find an explanation for the change, but I'am sure there's a good one
    (no offence, I just try to understand changes in order to avoid a continues back and forth change and questions over the years)
  -> Because there were now issues and discussions, again, about the representation of paths, I reviewed the topic. The change from "03.08.2010" was probably done
     to keep everything as "close-to-metal" as possible, to avoid dozens back and forth conversion. While "it's always uniform across all platforms" would be nice
     for the API user, it wouldn't be that good in respect of the overal performance and the user wouldn't have a chance to influence this. Were not already done,
     documented the methods "passing thru" native style path.
- "SystemWindows::GetCurrentDir()" & "SystemLinux::GetCurrentDir()" were using "Url(sDir).GetNativePath()" while other similar methods directly returnd the OS style
  path wihouth touching it, changed it
- Linux port: Added several "String::FromUTF8()" when passing an OS "char"-String through the interface to don't loose Unicode data. Would be nice if someone could
  review this and similar places to ensure that we never convert an Linux UTF8 string into an ASCII string by accident...



>> 12.11.2011
[CO]
- "PLScriptV8" & "PLScriptAngelScript" & "PLScriptPython" & "PLFrontendMozilla" & "PLFrontendActiveX": Updated x64 Visual Studio project settings



>> 11.11.2011
[CO]
- "PLFrontendQt" & "PLFrontendPLGui" & "PLFrontendNull" & "PLScriptBindings" & "PLScriptNull" & "PLScriptLua": Updated x64 Visual Studio project settings



>> 04.11.2011
[CO]
- Fixed bug 3433006 (http://sourceforge.net/tracker/?func=detail&aid=3433006&group_id=507544&atid=2063682): The return value of "FileObject::GenericMove()"
  and "FileObject::GenericCopy()" was always "false"
- I had to add "GetInstance()" and "HasInstance()" to the interfaces of singleton implementations. This solution enhances the compability with legacy compilers
  like GCC 4.2.1 used on Mac OS X 10.6.
  -> The C++11 feature "extern template" (C++11, see e.g. http://www2.research.att.com/~bs/C++0xFAQ.html#extern-templates) can only be used on modern compilers like GCC 4.6
  -> We can't break legacy compiler support, especially when only the singletons are responsible for the break
  -> See PLCore::Singleton for more details about singletons
- Removed the "compiler, please keep my symbols"-hacks (see e.g. PLCore diary entry 23.10.2011), after the change from above, they are no longer required



>> 02.11.2011
[CO]
- "System"-class: Added "GetPlatformArchitecture()"
- String implementation: "ResetLocaleToC()": In case the current set locale is already "C" (the default if no one has messed around with the current set
  locale), we don't have to do anything



>> 01.11.2011
[CO]
- "Runtime"-class: Added "SetDirectory()" and "GetPLCoreSharedLibraryDirectory()", made "GetPLCoreSharedLibraryName()" public



>> 31.10.2011
[CO]
- "NULL_HANDLE" and "INVALID_HANDLE" are no longer classic definitions, instead they are now constants of the type "PLCore::handle" to give the compiler
  the chance to perform a type check
- Fixed bug 3431174 (http://sourceforge.net/tracker/index.php?func=detail&aid=3431174&group_id=507544&atid=2063682): Within the "PLCore::System"-constructor,
  the main thread was created incorrectly. Also reviewed the thread constructors.
- "System"-constructor cleanup: Removed "[HACK] Force the linker to keep the "Profiling"-class (don't strip it away)" because it's now within "PLCore.cpp"
  together with the rest of the same issues (see PLCore diary entry 23.10.2011)



>> 27.10.2011
[CO]
- "System": Added "GetSharedLibraryPrefix()" and "GetSharedLibraryExtension()"
- Added "SystemMacOSX" which is derived from "SystemLinux"
- "SystemWindows::GetPlatform()" now returns "Windows" instead of "Win32"/"Win64" to make it similar to "Linux", "Android" and "MacOSX". I try to avoid
  such breaking changes, but this one was necessary do deal with all the supported platforms in an uniform way.
- "System": Added "GetPlatformBitArchitecture()"
-> It's hightly recommended to make a clean build of PixelLight in order to avoid issues when using plugin files from before this change



>> 26.10.2011
[CO]
- "SystemLinux::GetPlatform()" & "SystemLinux::GetOS()": Added Mac OS X handling (it's not worth to derive an own class, yet)
- "ScriptManager::CreateFromFile()": Enhanced the method documentation in order to avoid problems like the one at
  http://dev.pixellight.org/forum/viewtopic.php?f=6&t=103



>> 25.10.2011
[CO]
- "Runtime::GetSystemDirectory()": We really need to check for the registry, first: When building for Linux, there are fixed build in locations like
  "/home/bob/pixellight/cmakeout/Base/PLCore/" and build executables will link against those shared libraries -> You'll receive
  "/home/bob/pixellight/cmakeout/Base/PLCore/" as PL system directory, not e.g. "/home/bob/pixellight/Bin-Linux/Runtime/x86" as expected.



鏤>> 23.10.2011
[CO]
- Interesting, just tried to build PixelLight on MS Windows by using CMake to create the Visual Studio projects files and then, as usually build PL with VC...
  but within PLMath the linker told me that a few "PLCore::Log" singleton symbols were missing. They were stripped way... I double checked the compiler
  settings, but they look the same, meaning the one created by CMake and the one within the Git repository I'll use during the development. Interesting,
  same compiler, same settings, but different results (maybe it's the order in which the files are compiled? :). Added the "usual hack" within "PLCore.cpp"
  to force the compiler to keep the required symbols.
- Implemented "DynLibLinux::GetAbsPath()"



>> 22.10.2011
[CO]
- "EventDesc::GetSignal()" & "EventHandlerDesc::GetSlot()" & "VarDesc::GetAttribute()": Gave in a null pointer into the not documented
  pointer parameter and got a crash. This should never happen. Changed the pointer parameter into a reference parameter.
- "VarDesc": Added "GetDefault()"-method to make it possible to request the default value of an attribute without the need to have an attribute
  instance in order to get this information
- "Object": Added "SetAttribute(const String &sName, const DynVar *pVar)". This is a comfort method allowing to write e.g.
    pFirstObject->SetAttribute("MyAttribute", pSecondObject->GetAttribute("MyAttribute"));
  instead of
    DynVar *pDynVar = pSecondObject->GetAttribute();
    if (pDynVar)
      pFirstObject->SetAttribute("MyAttribute", *pDynVar);
    In case there's no such attribute in "pSecondObject", nothing happens at all.



>> 21.10.2011
[CO]
- More Unicode related issues within the PixelLight forum: http://dev.pixellight.org/forum/viewtopic.php?f=6&t=91
  -> The next scheduled PixelLight release is in two days, so no big complete refactoring of for example the tokenizer.
     Only implementation completion and minor required updates.
  -> "BufferedReader": Added "GetStringFormat()"
  -> "BufferedReaderFile::ReadFromStream()": Implemented Unicode support
  -> "BufferedReader": "GetChar()" & "ReadChar()" now return "int" instead of "char" (identical to "File::GetC()")
  -> "Tokenizer::GetNextToken()": Implemented Unicode support
  -> Optimization: "Tokenizer::StreamIsChar()" read again from the string, although the current character was already available.
     Removed this function.



>> 20.10.2011
[CO]
- Exposed "ApplicationContext" to the RTTI
- "System::GetCurrentDir()" & "ApplicationContext::GetAppDirectory()": On Android, those are empty strings and just writing e.g.
    cApplicationContext.GetAppDirectory() + "/Data"
  resulted within "/Data", which was not correct. When working on the Android port, I catched this case and used e.g. "Data" in
  case the application directory was empty. Now that the Android port is working, I'am cleaning up and removing situations resulting
  in to many stuff to take into account when using the PixelLigth API. In case "System::GetCurrentDir()" & "ApplicationContext::GetAppDirectory()"
  have internally an emtpy string, '.' is returned meaning that
    cApplicationContext.GetAppDirectory() + "/Data"
  will result in "./Data" which is fine.



>> 19.10.2011
[CO]
- "FileWindows::PutS()" didn't take Unicode into account (... as well as some other functions in this class...)
- "File::Open()": Added string encoding format parameter
- Text based log formatter implementations are now using UTF-8 instead of ASCII
- "File::GetContentAsString()": Removed string encoding format parameter because it's now defined by "File::Open()"
- "File::GetContentAsString()": Added UTF8 support
- "LoadableManager::OpenFile()": Added string encoding format parameter
- "ScriptManager::CreateFromFile()": Added string encoding format parameter
- Fixed spelling error: "LogFormater" -> "LogFormatter"



>> 16.10.2011
[CO]
- "Socket": Fixed "warning C4244: 'initializing' : conversion from 'SOCKET' to 'int', possible loss of data" when compiling for 64 bit



>> 15.10.2011
[CO]
- "Object::SetAttribute(const String &sName, const DynVar *pVar)" & "DynVar::SetVar(const DynVar *pValue)" & "Type<T>::ConvertFromVar(const DynVar *pValue)":
  It was not documented whether or not "pValue" can be a null pointer, in case one passed into a null pointer it just crashed. This is not obvious to
  the API user. Changed it into a reference to make clear that it must be valid.
- "ClassReal::~ClassReal()" & "ClassReal::DeInitClass()" & "ClassManager::~ClassManager()": The class manager may have already been destroyed (random static
  de-initialization order), we need to take this situation into account



>> 14.10.2011
[CO]
- The extern template related changes I did yesterday solved my linker issue on Mac OS X. It turns out that on the Linux port, the extern
  template usage was not correct and caused multiple template instances all over PLCore. Tested it on Linux and Mac OS X as well as Windows, no
  more issues. :D
- New platform, new data type issues: "handle" was defined by using "unsigned long" on Linux and "unsigned int" on MS Windows. Now it's
  "unsigned __int32" on 32 bit, "unsigned __int64" on 64 bit, on all platforms. I hope this is causing less issues across multiple platforms and
  bit sizes.
- "Thread::GetID()" now returns "handle" instead of "uint32" (e.g. on MS Windows, "HANDLE" is a pointer... so 32 bit might not do the job)



>> 13.10.2011
[CO]
- When linking PLCore on Mac OS X, the linker complains about multiple symbols for "Singleton<Log>" and fails to link.
  After a day of stumbling around on the unfamiliar Mac OS X, I had no real glue what's going on... because the Apple GCC 4.2 is heavily
  out-of-date I compiled GCC 4.6.1 for the used system, and supected that the out-of-date Apple ld linker caused this problem (so I played
  around with GNU binutils etc). After talking with Stephan Wezel about the observed issues, he gave me the tip to check whether the "extern"
  in front of "template class" is really there when compling the source code under Mac OS X. So, I first read some more stuff about C++11
  extern template, looked how it's currently used... and the usage looked wrong. Under Linux (the Mac OS X port is just reusing the
  Linux port :), when compiling PLCore, there was no "extern" in front of "template class", and I guess that this means that everywhere this
  header was included, a new singleton template instance was created (just inside PLCore!) - this would at least explain why the Apple linker
  complained about multiple instances. Changed it. At this time, the changes are only tested on MS Windows. Tomorrow I'll do more tests and
  really hope that this solves the issue.



>> 11.10.2011
[CO]
- Yesterday, a fellow student had isses to get PixelLight up and running - as it turns out, there were PixelLight runtime configuration issues, again.
  Just like within the forum post http://dev.pixellight.org/forum/viewtopic.php?f=6&t=68 the MS Windows PATH environment variable was set correctly... but
  the registry key was missing. So, while the MS Windows PATH environment variable is usually no big deal and there's not really a way around it, this
  mandatory registry key on the other hand is a constant source of errors and frustration. So, I had a look into it.
  As it turned out, I already had a solution at "18.08.2011" but didn't see at this time that this also could be used to make the mandatory registry key
  only optional. The "Runtime::GetSystemDirectory()"-method is now also using the PLCore shared library in order to find the PixelLight runtime directory.
  Only when using a static version of PLCore, we have to use the registry key as last available option. Usually the dynamic shared library of PLCore is used,
  and so there's usually no need for this registry key and no problem in case it's not there.



>> 07.10.2011
[CO]
- "Runtime::ScanDirectoryPluginsAndData()" & "Frontend::Run()": In case of a total failure, there's now also the hint
    "Is the PixelLight runtime registered correctly? (see e.g. "PixelLightBuild.pdf" for details)"
  within the message to give at least a hint what's usually wrong when this failure happens. Of course, this means that an end-user will see this message as well... but
  on the other side, when delivering an application, the PixelLight runtime is usually directly put in the same directory as the executable so that everything can be found
  (= no chance that this message can occure).



>> 05.10.2011
[CO]
- Loadable: Renamed "Load()"-method using a filename into "LoadByFileame()"
- Loadable: Renamed "Save()"-method using a filename into "SaveByFileame()"
- Loadable: Renamed "Load()"-method using a file into "LoadByFile()"
- Loadable: Renamed "Save()"-method using a file into "SaveByFile()"
-> This change was necessary to make it possible to expose this methods to the RTTI (method names must be unique for this)
-> I fist thought about just renaming the file versions, but in the end I decided to be consiquent even if the method is now a little bit longer... but therefore one
   can guess what the method expects as parameters (and it's consitent to "GetByIndex()" & "GetByName()" and so on).
- PLFrontendOS: Added Android frontend (still some details to hammer out)



>> 04.10.2011
[CO]
- Windows: PLFrontendQt includes simplification: "Include\Qt" instead of "Include\Qt\Qt" (when building Qt, an additional install step was required to make real Qt headers,
  not headers just redirecting into the "src"-directory)
- "ClassReal::InitClass()" and "ClassDummy::InitClass()" didn't register the properties of the base class as expected. While all methods and so on from the base class and
  the base class of the base class and so on were registered, only the "own" properties of the base class were added to a derived class. Meaning that a derived class was missing
  properties of the base class it's base class was derived from. This looks like a bug (if it's no bug, it's a odd behaviour). Fixed it.
  (noticed it when implementing "PLAssimp::MeshLoader" and "PLAssimp::SceneLoader")



>> 27.09.2011
[CO]
- More fine tuning on "PLFrontendOS" & "PLFrontendQt" & "PLFrontendPLGui": When making the window visible, it's now also made active at once. If this is not done, debugging
  in Visual Studio doesn't make that much fun because the frontend window appears, a breakpoint is reached - but Visual Studio doesn't automatically come into foreground and
  gets the focus, the frontend window is still on the top and you may even not notice that you've reached a breakpoint. I think, when implementing the frontends, I delayed
  the window activation until everything is initialized so e.g. input controls are correctly activated/deactivated when the window gets active/inactive. Due to the progress
  in frontend fine tuning, this delay is no longer required.
- "DynLibLinux::Load()": If a shared libarary failed to load in dynamically, the application completly shut down. Fixed that.



>> 26.09.2011
[CO]
- "LoadableManager::OpenFile()" now resolves "./" because we always want to work with absolute paths so the user can easily figure out the absolute path later on by using "cFile.GetUrl()"
- "FrontendApplication::OnInitData()" & "CoreApplication::OnInitData()": The application and current directories should have the highest priority of all base directories because the application data is
  most likly in those directories



>> 16.09.2011
[CO]
- Added "ConsoleAndroid" which is derived from "ConsoleLinux" and just overrides the "Print()"-implementation. Even on Android, it's possible to write into the console, meaning "stdout"... but it's somewhat
  complicated to "see" this output when starting an apk file (meaning: not starting an native application via shell). In this console implementation, messages are not only written into the console,
  the Android in-kernel log buffer is used as well (use Androids "logcat" utility to access this system log).
- "SystemAndroid" now also overrides "GetConsole()" in order to make it possible to toggle the used console implementation ("ConsoleAndroid"/"ConsoleLinux")



>> 14.09.2011
[CO]
- Android port: Added "FileSearchAndroid" implementation
- Bugfix (Linux): "PLFrontendOS::OSWindowLinux::GetX()" & "PLFrontendOS::OSWindowLinux::GetY()" were not returning the window position correctly (window decoration issue). Tested it now several times,
  and when restarting an application, the previous window position and size is now restored correctly (even when using two monitors).



>> 13.09.2011
[CO]
- Bugfix: "PLFrontendOS::OSWindowWindows::SetPositionSize()": The MS Windows function "MoveWindow()" sets the window size, not the window client area size
  -> We have to calculate this window size basing on the given client area size
- Bugfix: "PLFrontendPLGui" was not returning and setting the window size correctly (the window border must be ignored)
- "PLCore::FrontendConfig" and "PLRenderer::Config" have now the same default size (800x600 still feels quite fine during development)
- "Frontend::Run()": By default, this method is now allowed to show an urgent message to the user in case of a failure (see also dirary entry "23.08.2011")
- Android port: "SystemLinux::UrgentMessage()" writes into the Android kernel log buffer
- Added "SystemAndroid" which is derived from "SystemLinux". In here, an "AAssetManager"-instance can be set for example by the Android frontend and received
  for instance by a special Android file implementation.
- Added "FileAndroid" using the Android asset manager (implementation is not yet tested)



>> 12.09.2011
[CO]
- "String"-class: Do never ever pass a null pointer into "strdup" because the behaviour isn't specified in POSIX (http://pubs.opengroup.org/onlinepubs/9699919799/functions/strdup.html)
  -> On MS Windows and Linux a null pointer will be returned, on Android it just crashes...
- "Log"-class Android: In verbose mode, messages are not written into the console (there isn't easy access to it on Android), instead the Android in-kernel log buffer is used (use Androids "logcat"
  utility to access this system log)



>> 06.09.2011
[CO]
- Android port related: The Android NDK has no support for "mbtowc()", added the implementation from http://bsd.unixdev.net/4.5BSD/src/usr.libexec/dictd/mbtowc.c
  http://bsd.unixdev.net/4.5BSD/src/usr.libexec/dictd/mbrtowc.c



>> 05.09.2011
[CO]
- The Intel C++ compiler has no support for nullptr + fixed some issues detected by this compiler
- Fixed "warning #82: storage class is not first"-warnings of the Intel C++ compiler when using warn level 4



>> 04.09.2011
[CO]
- When building with CMake, it's now possible to disable the ZIP support in order to remove the zlib external dependency. Please note that it's *not* recommended to disable the ZIP
  support and this option does only exist to make it easier to create minimal builds which are really helpful when starting with a new platform support. In such a situation, it can
  be really frustrating to deal with external dependencies when you just want to make the first step and want to see "anything" - but just can't because you first have to compile
  the external dependencies and pray that you did everything correct: Correct compiler & linker settings, e.g. correct ARM architecture and so on. If e.g. any linker issue occur,
  and you don't use any external dependency at all (in theory, at this very moment there's still the libpcre external depencency, at least at the moment) - you know that the problem
  is somewhere within your project and not within an external dependency. :D



>> 31.08.2011
[CO]
- Android port related: "MutexLinux::TryLock()":  There's no implementation of "pthread_mutex_timedlock()" within the Android NDK, even if the function is listed within the headers.
  Depending on the API level, it's defined out, meaning no compiler error when using API level 8, but a compiler error when using API level 9 (some sources stating this is an error
  within the shipped "pthread.h"-header). For Android, we have to fallback to "pthread_mutex_lock()" (right now, I don't want to spend hours to find a work around).



>> 30.08.2011
[CO]
- Android port related: Even if there's a "wchar.h"-header, wchar_t is officially not supported by Android (no problem, wchar_t is for Windows, UTF-8 for Linux and the string
  class handles both as well as ASCII). Added a "wcscasecmp()" & "wcsncasecmp()" implementation within "PLCoreLinuxWrapper.h" & "PLCoreLinux.cpp" used when compiling for Android.
- Android port related: "PLCoreLinux.cpp": The Android NDK has no support for "wcstof()". Added the implementation from http://www.opensource.apple.com/source/Libc/Libc-320/locale/FreeBSD/wcstof.c
  with minor adjustments to make it compile (no time to reimplement something on my one, and it's also not worth it, there's other stuff to do instead of reimplementing
  the c standard library...).
- Android port related: The Android NDK has no support for "wcstoumax()". Added the implementation from http://www.opensource.apple.com/source/Libc/Libc-320/locale/FreeBSD/wcstoumax.c
  with minor adjustments to make it compile.
- Android port related: "PLCore/ConsoleLinux.cpp": The Android NDK has no "term.h", but "termios.h" works (validating Linux build next time when I switch the OS, but not at this very
  moment and not for every minor change, even when a change breakes something under Linux for a short period)
- Android port related: "PLCore::ThreadLinux::Terminate()": "pthread_cancel()" is not supported by the Android NDK. "android-ndk-r6/docs/system/libc/OVERVIEW.html" states:
  "pthread_cancel() will *not* be supported in Bionic, because doing this would involve making the C library significantly bigger for very little benefit."



>> 29.08.2011
[CO]
- "Core/MemoryManager.cpp": For "memcpy()" etc. "string.h" has to be included when compiling for Android (wow, now I'm glad that we even encapsulated such primitive functions,
   else there would be more than just this file to update...)
- Android port related: "ConsoleLinux::ClearScreen()" in here, we don't need to use the curses library and can go a more portable way
- Android port related: "ConsoleLinux::GetCursorPosition()" & "ConsoleLinux::SetCursorPosition()": There's no native curses library on Android, and compiling one
  just for this usually never used function would be overkill. So, right now, those two methods are not supported when using the Android port (already spend far too much
  time on this curses library issue!).



>> 23.08.2011
[CO]
- Qt: It appears that there's going something funny on in here... The PixelLight Linux external packages of Qt Stephan Wezel created, don't need the "src" because the includes
  are real includes and not just references. When downloading the Qt sources and looking into e.g. "Qt\4.7.1\include\QtCore\qvector.h" I see "#include "../../src/corelib/tools/qvector.h".
  When now building Qt on MS Windows using the options
    "configure -platform win32-msvc2010 -release -opensource -fast -sse -sse2 -no-qt3support -no-scripttools -no-stl -nomake examples -nomake demos -no-openssl -no-webkit -no-phonon -no-style-motif -no-style-cde -no-style-cleanlooks -no-style-plastique -no-sql-sqlite -qt-style-windowsvista -D NOMINMAX -D VC_EXTRA_LEAN -D WIN32 -D _WINDOWS -D _CRT_NONSTDC_NO_WARNINGS -D _CRT_SECURE_NO_WARNINGS -D _CRT_SECURE_NO_DEPRECATE -D _CRT_NONSTDC_NO_DEPRECATE -D _ATL_SECURE_NO_DEPRECATE -D _CRT_NON_CONFORMING_SWPRINTFS -D STRSAFE_NO_DEPRECATE -D _UNICODE -D UNICODE"
  I still see the same within the include files, and no new, modified includes appeared. I can copy out the files from "Qt\4.7.1\src\" - but this seems odd. If this would be the
  preferred way to use Qt, why is there an include directory in the first place? Did I messed up with the Qt compile configuration? Does the Qt build system handles things in another
  way under Linux? Maybe the includes are handled during "install" on Linux? So, until it's clear what's going on, we need to use OS dependent handling. :/
  (no time right now to spend hours with this issue)
- "System": Added "UrgentMessage()"-method for a primitive way (e.g. by using a message box) to be able to tell the user that something went terrible wrong
- "Runtime::ScanDirectoryPluginsAndData()": By default, this method shows an urgent message to the user in case of a failure



>> 21.08.2011
[CO]
- Renamed "PLCore::CoreGeneralConfig" into "PLCore::CoreConfig"
- "Frontend": Added "GetX()" & "GetY()"
- "Frontend": Added "SetPositionSize()". "Frontend::SetPositionSize()" will do the rest of the job like checking for minimal size, ensuring that the frontend is always within
  the screen when using this method and so on.
- "FrontendApplication": By default, this application implementation will automatically restore the frontend position and size of the previous session. Although an application
  shouldn't care about the frontend, from the usability point of view, it's handy when the applications window is at the same position and size of the previous program
  execution. Because the frontend layer itself should be slim and shouldn't come with it's own configuration file, the only option I was able to think of was to make this to a
  task of an application.
- The frontend implementations now delay making the window visible until "Redraw()" or "SetPositionSize()" was called or the initialization was completed. This gives e.g.
  "FrontendApplication" an opportunity to set the frontend position and size before the window gets visible. If this is not done, the frontend window will be shown at first at a
  default position and then jumps to the position and size of the previous session. I was of course aware of this issue when designing the system, but didn't found a compact solution
  for this and therefore decided to have a look into it when the rest is up and running. This doesn't look&feel good, but at the point the frontend window is created there's no
  information available were to e.g. place the window. On the other hand, the frontend window should become visible as soon as possible after the program started so that the
  user can see that the application is now really running. So, in my humble opinion this solution is ok because the frontend implementation has to decide how to deal with this.
- "Frontend": Added "GetTitle()" & "SetTitle()"



>> 19.08.2011
[CO]
- "Frontend": Added "IsMouseOver()"
- "Frontend": Added "GetMousePositionX()" & "GetMousePositionY()"
- "PLFrontendOS::OSWindowWindows" fine-tuning: As soon as the MS Windows function "ShowWindow()" is called, the window gets visible at once... with a nasty white content which is
  somewhat blending when you're working in a dark room. It's like a flash. I did some research but didn't found an answer how to avoid drawing at all... I can remember that previous
  Windows versions just did draw nothing when provinding a null-brush in the window class resulting in the untouchen window background. The only solution that worked for me is to
  just give the window class a black brush and then after the window was made visible within WM_CREATE just catch the WM_ERASEBKGND in order to avoid overdraw (= flickering). Another
  solution might have been to just delay the window show until the render loop starts... but this would mean that, after the user started the application, he would see no reaction at
  all... even if it's just for a few milliseconds, but even then one might start the application again because it feld like the application didn't started at all.
- Removed "AbstractFrontend::OnDisplayMode()". For e.g. "PLRenderer::RendererApplication" it's the same as "OnFullscreenMode()" and I can't think of a real difference - this method just
  says "something related to fullscreen mode has been changed".
- "Frontend": Added "RefreshFullscreen()"



>> 18.08.2011
[CO]
- Renamed the "Core"-class into "Runtime" because it's all about the runtime (even the version information)
- "Runtime"-class: Added "IsDebugVersion()" returning whether or not a debug version of PixelLight is used
- "Runtime"-class: Added "GetType()" detecting automatically the type of the currently used PixelLight runtime installation. Every PixelLight based project using the PixelLight
  runtime needs at least the dynamic "PLCore"-library (the static library is not really within the runtime, it's for developers only). So, in order to automatically detect whether it's a local
  or a system-installed runtime, I just load in the PLCore module and check whether or not it's within the same directory as the running process ("System::GetExecutableFilename()" :).
- Renamed "Runtime::GetDirectory()" into "Runtime::GetSystemDirectory()" and renamed "Runtime::GetDataDirectory()" into "Runtime::GetSystemDataDirectory()" to make clear that this is the
  system installed runtime (there can be a local and system runtime at the same time, although this is not recommended)
- "Runtime"-class: Added "GetLocalDirectory()" and "GetLocalDataDirectory()", the counterparts to "GetSystemDirectory()" and "GetSystemDataDirectory()"
- "Runtime"-class: Added "GetDirectory()" and "GetDataDirectory()", et voila, there are those two methods, again. But unlike the previous implementation, those two guys return the
  PixelLight runtime used by the running process. This means, those methods "automatically" detect the "correct" PixelLight runtime. While it's still possible to explicitly request the
  directory of the local or system PixelLight runtime, it's hightly recommended to only use the automatic PixelLight runtime detection to avoid using possibly incompatible binaries.
- "Runtime"-class: Added a directory parameter to "ScanDirectoryPlugins()" and "ScanDirectoryData" to make it possible to use for example the result of "GetDirectory()", "GetLocalDirectory()"
  or "GetSystemDirectory()". If an empty string is provided, the result of "GetDirectory()" will be used, resulting in an "autodetection".
- "Runtime"-class: Added comfort method "ScanDirectoryPluginsAndData()". In case you don't care about technical details and just want the stuff runnable, then just call this method and be happy.
  The PixelLight runtime to use is detected automatically, all available compatible plugins are registered as well as compatible data.
- "Frontend::Run()": This was a complex one... answering the question who's responsible to initialize the important PixelLight runtime related stuff. Until now, this was only done
  within "CoreApplication::OnInitPlugins()" and "CoreApplication::OnInitData()" - but the frontend stuff is above this application process and is also already using PixelLight runtime
  features like dynamically loaded frontend implementation plugins. Yesterday I experimented with several possible solutions, but one was more complex as the next one. Until now, there
  was also the configuration setting "CoreGeneralConfig::UsePixelLightRuntime", but the configuration system is already using the RTTI (and I still think that this solution is really cool
  and unique compared to other, definitely more complex configuration systems) to let the user decide from the outside whether or not to use the PixelLight runtime. I don't know why, but
  until a few hours ago I didn't really realize that this option is somewhat pointless - because the configuration system is already using this information in order to load in this
  information. Also, this approach, having this option, was quite error prone because when deploying an application it's "really" easy to forget to set this option to 0 to avoid conflicts
  with an installed PixelLight SDK. On the other hand, when starting an application, the OS is in fact deciding for us which PixelLight runtime to use. When the PLCore shared library etc.
  are in the same directory as the executable, those shared libraries are used instead of the ones of an installed PixelLight SDK (I know that there are variations over different OS, but
  even under Linux we have configured the binares this way so one can "just" extract a package and start it at once without configuring the whole system). The only problem was the dynamic
  loading of plugins... which wasn't a problem after all because the OS decides for us whether to use a "local PixelLight runtime" or an installed "system PixelLight runtime". We just have
  to detect which type of PixelLight runtime was chosen by the OS and then load plugins from this PixelLight runtime. Only from this one. So, by creating a package and putting everything
  into it one needs in order to execute the application without any installed PixelLight SDK, one already sayed that a "local" runtime has to be used. No need to confirm this decision again
  by manipulation the "CoreGeneralConfig::UsePixelLightRuntime"-option. Mixing different PixelLight runtimes would be evil anyway. Long story, minor changes:
  -> Removed "Runtime::ScanDirectoryPlugins()" within "Frontend::Run()" (had a [TODO])
  -> "pl_module_application"- and "pl_module_application_frontend"-macros: Added "Runtime::ScanDirectoryPluginsAndData()" right after "PLMain", before anything else is done
  -> Added "Runtime::ScanDirectoryPluginsAndData()" at some other places as well ("Runtime::ScanDirectoryPlugins()" was already used several times, so this change isn't something new)
- Removed "CoreGeneralConfig::DelayedPluginLoading"-option (by default, this feature is always active)
- Removed "CoreGeneralConfig::UsePixelLightRuntime"-option (now done automatically and due to delayed plugin loading the required time is no longer worth talking about)
- "FrontendApplication": This application class reimplements "OnInitPlugins()" & "OnInitData()" because in here, the PixelLight runtime initialization is the job of a higher being
- Bugfix: "ClassManager::LoadModuleDelayed()" was setting no "Name", "Vendor", "License" and "Description" information
- Bugfix: "ClassManager::RegisterClass()": When a dummy class of a dummy module is replaced by a real class, the (previously) dummy class has to be removed from the dummy module because
  a class can only be within one module at the same time
- "CoreApplication"-constructor: In here, the default application data subdir was set to
    m_sAppDataSubdir = System::GetInstance()->GetDataDirName(m_sName);
  While this looks logically at first, it becomes somewhat annoying (otherwise I wouldn't have had noticed and touched it!) after working with it for some time and e.g. doing several experiments.
  Let me explain it in detail: Take the "50RendererTriangle"-sample for instance, by default the application data subdir for my debug version is "C:\Users\COfenberg\AppData\Roaming\50RendererTriangleD"
  and for the release version it's "C:\Users\COfenberg\AppData\Roaming\50RendererTriangle". Now create some more experimental applications to play around with PixelLight by using
  as few instructions as possible in order to figure out how everything works... after a while, one may find the "AppDataSubdir"-option and when looking into the "Roaming"-directory
  one may notice that it's full spam like "50RendererTriangle", "50RendererTriangleD", "XTest", "123Test" and so on... and it is now probably a little bit hard to figure out what's trash and
  what's from an important none PixelLight application. Also, each and every PixelLight sample application had "SetAppDataSubdir(System::GetInstance()->GetDataDirName("PixelLight"))" in
  it and such stuff may be confusing when just starting to get into PixelLight based development.
  -> For those reasons, I decided to make "SetAppDataSubdir(System::GetInstance()->GetDataDirName("PixelLight"))" to the default setting. This way, the samples are even more compact
     (yes, just one row and x nested method calls, but as mentioned, those may be confusing for beginners) but more important, if one "forgets" to set this to an individual setting, everything
     will be thrown into the "PixelLight"-directory. Later on, it's probably easier to remember that something was "PixelLight"-based and easier to find and remove spam-files... by e.g.
     just removing the one single "PixelLight"-directory completely.



>> 17.08.2011
[CO]
- The frontend stuff is working quite well and solves some prior design issues. This approach also answers the question how to use the application framework within e.g. the Qt based
  editor in order to manage the PixelLight part while the Qt editor does all the rest like main loop and window handling. The PixelLight editor kickoff was on 10.08.2011, primarily
  to see what's required for the tool. It will certainly take some time until this tool is usable, so, the goal wasn't to have a ready-to-use-editor in PL 0.9.8. Until now, e.g.
  PLFrontendQt had to reimplement a lot of application framework features because the application framework was heavily tied to PLGui and also did stuff like the main loop internally.
  (this is still possible, but derived application classes like the renderer application now follow another approach)
  As seen within the PixelLight editor project, it's now possible to just write a thin layered frontend implementation working as a kind of gate between the Qt framework primarily used
  within the editor, and the PixelLight framework, primarily used in PixelLight *g*. Each side shouldn't concern too much about the other one - in fact, Qt doesn't know anything about
  PixelLight and verce versa.
  Now that it's clear that the frontend design is the way to go, time to complete the system.
- Added "FrontendContext"-class. This class is derived from "ApplicationContext" and adds frontend related stuff. The parameters of the "Frontend::Run()"-method were just an overkill
  and there was another issue as well: To be flexible, the frontend system already is using the RTTI and when e.g. PLFrontendPLGui open it's window, the standard data packages must
  already be registered. Also, a frontend may want to set a windows position and size to the one used during the previous seasson, meaning it needs to be able to use a configuration.
  During the frontend initialization, errors may occur, so, log is required as well. Sadly, all those stuff is handled within "PLCore::CoreApplication" which is still ok for applications
  not using the frontend stuff at all... but "PLCore::FrontendApplication" has to hand over the control over this important infrastructure features to the frontend. The frontend itself
  hands over this stuff to the "FrontendContext"-class which is instanced and filled outside the frontend system and is just passed into the system.
  Of course, some information is now stored within two distinct systems (frontend and application), but I in my humble opinion that's ok for this system. Take "PLCore::FrontendApplication"
  for example, as the name of this class indicates, this is the base class for applications running within a frontend (the application host). The main loop as well as other logic is handed
  over to a host in order to become passive. Although a frontend application is always running within a frontend, it shouldn't care about the frontend. Just write our application as if there
  wouldn't be any "outer world". By following this philosophy as close as possible and only accessing frontend features when really neccessary, you enhance the chance that your application
  can be embedded within other applications like browsers such as MS Internet Explorer or Mozilla Firefox without problems. So, in order to get e.g. the executable filename, one just asks
  the application framework for it, not the frontend system feeding this information into the embedded application.
- "FrontendContext::Run()" now has just a frontend context as parameter
- Removed "FrontendContext::Run()" versions with traditional C-arguments. It has shown that those version are not required. For e.g. QApplication of Qt using this traditional C-arguments,
  one can reconstruct them out of the universal form... no, it's not a performance problem nor intricate. It's intricate to have 3 method versions to be implemented all over the place and
  in case of e.g. the Qt base editor, one doesn't use the "FrontendContext::Run()"-method at all.
- "FrontendContext" has a name which is used as default whenever a name is required (log, configuration, window title and so on). When using the macro "pl_module_application" or
  "pl_module_application_frontend" this name is automatically set to the module name of the executable. "FrontendApplication" is using this name to set the default application name ("SetName()")
  and default application title ("SetTitle()"). This name is often sufficient - removed "SetName()" & "SetTitle()" usage within e.g. the sample applications.
- PLFrontendPLGui: PLGui requires some images stored within "Standard.zip", it's the responsibility of this frontend to ensure it has all it needs



>> 16.08.2011
[CO]
- Added abstract context class "AbstractContext". All over PixelLight, "context"-classes are used in order to group important information or components. This abstract context
  class was introduced to make it easier to identify such context classes.



>> 15.08.2011
[CO]
- "ApplicationContext::SetExecutableFilename()": The default (meaning you can choose another way if you want to) application directory layout now looks as follows:
  - "Application Directory"
    - "Data" (put all data you need in here)
    - "x86" (put all x86 executables and binaries in here)
    - "x64" (put all x64 executables and binaries in here)
  ... I worked with such a layout for years within other projects and never had real problems to use x86 & x64 together during development. With this layout it should
  also be absolutly clear that the executables and binares are decoupled from the data. In PixelLight release 0.9.8 there are several structual changes, so, it's probably
  better do to this "64 bit support"-related one in this release as well so that the next released don't have so many structural changes.



>> 14.08.2011
[CO]
- "PLFrontendOS::OSWindowWindows" & "PLFrontendOS::OSWindowLinux" & "PLFrontendPLGui::Frontend" & "PLFrontendQt::FrontendMainWindow" are now calling "AbstractFrontend::OnSize()"



>> 13.08.2011
[CO]
- "PLFrontend::OSWindowWindows" & "PLFrontend::OSWindowLinux" now react on AltGr-Return as well (same behavior across all frontend implementations)
- "Frontend": Added "IsMouseVisible()" and "SetMouseVisible()" ("PLFrontendOS::OSWindowLinux" part not yet implemented)
- "Frontend": Added "SetTrapMouse()"
- "AbstractFrontend": Added "OnDrop()" ("PLFrontendOS::OSWindowLinux" part not yet implemented). I'am not going to reimplement PLGui as frontend, but this feature is another
  useful one and I reduce it's usage to simple strings (for more complex stuff one has to use a GUI system!).



>> 12.08.2011
[CO]
- "CoreApplication::Run()" now implements the lifecycle as well
- "PLFrontendMozilla" & "PLFrontendActiveX" now also call the "OnRun()"-method (for none embedded frontends this is done automatically within "PLCore::Frontend::Run()")
- The program entry point "PLMain" is now ignored when the definition "_WINDLL" and/or "_USRDLL" is set... this should make it more comfortable to deliver an application as shared
  library (easier to embedd into other applications) instead of an executable. Those two definitions are MS Windows definitions, as far as I know, Linux has no equivalent...
  but we need something to test against... so I just defined those two definitions within "CMakeTools_Apps.cmake" for Linux as well (I was just to lazy to invent totally
  new definition names).



>> 11.08.2011
[CO]
- String: Sadly, we can't use uint16 in order to let the compiler decide whether to use a whar_t or a uint16 version of a method. For instance, when using PixelLight within the
  Qt Creator (without changing all used default settings!), whar_t is defined as unsigned short. :/



>> 08.08.2011
[CO]
- "Frontend": Added virtual "OnRun()"-method. This method is called just before the frontend calls it's run-method in order to enter it's main-loop. Use this method for instance
  to pre-process command line arguments.
- "FrontendPixelLight" is now using the new "OnRun()"-method in order to fill the application context just like "CoreApplication::Run()" does
- "Frontend": Exposed the class to the RTTI
- "Class": Added "Create()"-method creating an object by using a given constructor name and typeless constructor parameters
- Implemented frontend arguments... I'am not really happy with the current solution because it just looks complicated. I tried some other approaches but this one was the best one.
  Maybe I find another, better solution later on - but for now it works and is quite flexible. I'am really happy that I introduced the "pl_module_application" & "pl_module_application_frontend"
  macros because they're hiding the complex frontend run call. Within the samples the frontend call is only done once within "45ScriptApplication" without this "standard use case"-macros.
[SW]
- "PLFrontendOS": added toggle fullscreen support and and setting window icon to linux X11 part
- "PLFrontendQt": added support for setting the application/window icon



>> 07.08.2011
[CO]
- Updated "PLFrontendQt::QPLRenderWindow". Drawing and updating states are now two distinct things for the frontend & application framework, so, "PLFrontendQt::QPLRenderWindow"
  has now only care about drawing.
- Moved the "PLCore::Timing"-update from "FrontendApplication::OnUpdate()" into the frontend implementations. "PLCore::Timing" can limit the update rate to a fixed one like
  60, meaning that the update process doesn't run more than 60 times per second. An application (the slave) shouldn't care about such a topic and the frontend (the master) should
  have control over this one as well. Please note that it is allowed that the logic update and draw update have different intervalls (but again, the application side doesn't care
  about this :).
- "Frontend": Added fullscreen mode support and implemented it for "PLFrontendOS::OSWindowWindows" (implementations for the other frontends will follow)
- "PLFrontendPLGui": Implemented fullscreen mode support
- "PLFrontendQt": Implemented fullscreen mode support
- "FrontendApplication::GetFrontend()" now returns a reference instead of a pointer. An "FrontendApplication"-instance is always running within a frontend, else the system becomes
  artificially complex. Therefore, the result of "GetFrontend()" must always be valid and there's no need for null pointer tests trashing the code.



>> 06.08.2011
[CO]
- Linux: Changed the type of "handle" from "int" to "unsigned long" (shouldn't really be a difference in the used bit length... even on 64 bit "long" is usually only 32 bit long...)
- Added "Core::ScanRuntimeDirectoryPlugins()" because the same stuff was done in "CoreApplication::OnInitPlugins()", "PLCore::Frontend::CreateInstance()", the sample "40ScriptHelloWorld"
  not using the application framework at all, "PLFrontendQt::Application::InitCore()" and so on.
- Added "Core::ScanRuntimeDirectoryData()", more stuff not only useful for "CoreApplication::OnInitData()"
- MS Windows: "PLFrontendOS" is now using the standard PixelLight icon for the main window of this frontend
- MS Windows: If a process has an own icon, "PLFrontendOS" is now using it instead of the standard PixelLight icon
- "PLFrontendQt": Removed unused "Application::ScanFSArchives()"-method
- Added "AbstractFrontend", same purpose as "AbstractLifecycle" => one and the same interface for the same task
- "AbstractFrontend": Added "OnUpdate()"-method. Drawing and updating states are now two distinct things for the frontend & application framework.



>> 05.08.2011
[CO]
- "Frontend": Added versions of the "Run()"-method using traditional C-arguments (char/wchar_t). Some frontends, like the Qt one, want to have the original C-arguments or someone
  may want to run a frontend by providing it with traditional C-arguments.
- "Frontend": Made a clear distinction between "Redraw()" and "Ping()"
- "Frontend": Added "RedrawAndPing()"-method first calling "Redraw()", then "Ping()"... probably an important use case... :D
PLFrontendQt:
- Implemented correct application lifecycle and "Ping()"-method (by the way, just noticed Qt's "QCoreApplication", so, "PLCore::CoreApplication" is probably really a decent name)
- Instead of performing an immediate hard-coded repainting of the frontend within "FrontendMainWindow::timerEvent()", Qt is now asked politly to update (and repaint) the widget.
  This way, the main window stays always responsive - but now I had "white flickering" due to some Qt overdraw. After using same settings as in Qt's QGLWidget, the "white flickering"
  had gone... but now there's "black flickering" from time to time. When debugging, it's clear that Qt still draws something into the window. After over a hour of research
  I wasn't able to figure out what's going on. The concept is ok, drawing only within Qt's "paintEvent()" and a redraw-timer only asks Qt politly to update (and repaint) the widget
  instead of directly draw (which wasn't working that well, messed up Qt's event processing). Time to stop working on this "detail" for now in order to finish the frontend work.
- ... I wasn't able to stop thinking about the "black flickering"-issue... and found a solution:
  -> Set "Qt::WA_OpaquePaintEvent"-attribute
  -> Overwrite "QPaintDevice::paintEngine()"-method and just return a null pointer
  ... the flickering is now gone and the whole main window is responding and behaving quite fine...



>> 04.08.2011
[CO]
- Renamed "ConsoleApplication" into "CoreApplication" so that one can guess the name of this class by just knowing the component name it's in
  (it's also the base/core class of the application framework, so "core" maybe more suitable then "console")
- "AbstractFrontendLifecycle" really solved some nasty design issues when it comes to application lifecyle control. Time that also "CoreApplication"
  is using this interface so that frontends can control the applications in a proper way (e.g. deactivating input control as soon as the application gets
  paused because it e.g. lost the focus). For this, renamed "AbstractFrontendLifecycle" into "AbstractLifecycle".
- Derived "CoreApplication" from "AbstractLifecycle". When possible, I try to avoid using multi-inheritance but in this case I see no other decent option -
  sadly C++ has no Java like "implements". :/
  -> Renamed "CoreApplication::Init()" into "CoreApplication::OnStart()", the "AbstractLifecycle" equivalent called as soon as something is started (not same as instanced)
  -> Renamed "CoreApplication::DeInit()" into "CoreApplication::OnStop()", the "AbstractLifecycle" equivalent called as soon as something is stopped (not same as destroyed)
- "FrontendPixelLight" is now calling all "AbstractLifecycle"-methods of it's petted application
- "Frontend": Added "Ping()"-method to give the frontend a chance to process OS messages. There are situations (like current load screen implementations) were an application
  may do some heavy work without letting the frontend a chance to process OS messages. In such situations, it may be wise to call this method from time to time to give the
  frontend a chance to do some message processing. Whenever possible, don't use this method, do heavy work within e.g. threads.
PLFrontendPLGui:
- Moved "ModTrapMouse", "PreviewWidget", "RenderWidget", "RenderWindow" and "WindowConnection" from "PLEngine" into "PLFrontendPLGui"
- Implemented correct application lifecycle and "Ping()"-method
PLFrontendOS:
- The application lifecycle is now handled within the OS dependent implementation (e.g. "OSWindowWindows") instead of within "Frontend"... I hope this way the order is
  always correct... hopefully... eventually... *g*
- When moving/sizing the window, the application will also be paused during this period (WM_EXITSIZEMOVE/WM_ENTERSIZEMOVE MS Windows events)... it's just annyoing when you move
  or size a window and the controlled scene camera is spinning around while you do so...



>> 03.08.2011
[CO]
PLFrontend:
- "PLFrontendNull", "PLFrontendOS", "PLFrontendPLGui", "PLFrontendQt" and "PLFrontendActiveX" (testing it within the MS Internet Explorer) are now up and running
  ("PLFrontendMozilla" is still broken)
- Added "PLFrontend::Frontend::Run()" to start an application inside a frontend. This is only required for executables and not if an application is running e.g. within
  a browser. When using it, it looks like this:
    int PLMain(const PLCore::String &sFilename, const PLCore::Array<PLCore::String> &lstArguments)
    {
        return PLFrontend::Frontend::Run("PLFrontendOS::Frontend", "Application", sFilename, lstArguments);
    }
- When the work on the frontend stuff is complete, PixelLight applications are usually "frontendless", meaning when compiling it as an executable, you as application developer
  choose the frontend to use (or not if you just don't care about GUI). Additionally, in the future it should be possible to just recompile the application as shared library in
  order to be able to embed it within other applications like a browser. To make this as easy as possible, I added the macro "pl_module_application_frontend" (yeah, too long
  name, again... but it's only required once within a project and therefore a speaking name is fine) and when using it, the main C++ file usually looks like this:
    #include <PLFrontend/FrontendMain.h>
    pl_module_application_frontend("50RendererTriangle", "Application", "PLFrontendPLGui::Frontend")
        pl_module_vendor("Copyright (C) 2002-2012 by The PixelLight Team")
        pl_module_license("GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version")
        pl_module_description("PixelLight triangle sample")
    pl_module_end
  ... should be quite handy to use ("pl_module" is usually already used, so not much additional work, it's even less work!). :D
  There's also a shorter macro:
    "pl_module_application("50RendererTriangle", "Application")
  Which will use the frontend "PLFrontendOS::Frontend" as default. This totally primitive frontend is sufficient for many applications.
PLFrontend<>PLCore
- Merged PLFrontend into PLCore... another new project which didn't make it long on it's own. :D
  Just like PLScript, PLFrontend was started as a separate project to see whether or not the idea/concept is working and then to see how it's integrating into the system as a whole.
  The PLFrontend concept turned out to be the key in making PixelLight really easy runnable within other applications like browsers. As such, it feels just right to put it directly
  into PLCore - it doesn't introduce new dependencies and is also not really a huge component.



>> 02.08.2011
[CO]
PLFrontend:
- Added "FrontendApplication" & "AbstractFrontendLifecycle" and started on the frontend design
PLFrontendPLGui:
- Moved "SNGui" from "PLEngine" to "PLFrontendPLGui" because it's using PLGui



>> 01.08.2011
PLFrontend:
[CO]
- Started the PLFrontend project (kind of "PLPlugin"-project successor)... now that scripting is working, it's finally time to attack another big design task.
  When we started the development of the PixelLight engine on 16 September 2002, we just had one single project: "PLEngine"
  This project just used a quite simple OS window to render stuff into it. Back then, the world was more simple regarding to required supported platforms.
  Providing support to be able to render into multiple OS windows was really a cool feature because most engines were just able to render into a single
  OS window. Over the years, the GUI stuff was moved into an own, platform independent, GUI library called PLGui. All other PixelLight projects were build
  on the top of it. PLGui is currently already within it's third (!) reincarnation.
  In the last past 9 years, the world has dramatically evolved regarding to the platforms one should really support and the current PixelLight design regarding
  to GUI handling does no longer really completely satisfies the changed needs. Now those are the requirements to be fulfilled:
  -> Be able to have absolutely no GUI at all, e.g. for server side applications or applications rendering just into a buffer *currently there's always a PLGui dependency*
  -> A quite primitive OS window for applications requiring no GUI handling, except for the OS window it's running in *PLGui is an overkill for this use case*
  -> "PLGui": PixelLight own GUI system (OS & ingame) perfectly integrated into the complete system, stuff like scripting doesn't need wrappers, it just works out of the box *currently used way*
  -> Be able to just use third party GUI systems like Qt for front-ends *currently there's always a PLGui dependency*
    -> The PixelLight editor will be Qt based because getting PLGui to the point were it's possible to write such an complex editor is just impossible with a team of two
       active spare-time developers (we already tried it years ago *PixelLab* and it was a total failure :/)
  -> Be able to embed an PixelLight application into another application, meaning another GUI system has the control and we're just a slave
    -> Be able to run in a web browser (e.g. by using "Java Web Start"/"JNLP" or/and by writing special browser plugins)
    -> Be able to run on mobile devices, e.g. Android based
    -> Be able to use ActiveX under MS Windows to embed 3D stuff into e.g. a MFC dialog (we already had to do this for a project some years ago)
    ... scripting is especially useful for the first two mentioned embed-points. This way, an application developer doesn't need to care about the target platform and is just
        writing some scripts...
  Ok, as you can see, a whole bunch of new requirements since the start of the PixelLight engine. In "Docs\Diagrams\PixelLight_PackageDiagram.png" I outlined how it will probably
  look when PLFrontend is up and running.
  Please note that the PLFrontend approach doesn't mean that I abandon the PLGui project, but having the whole system be dependent of a GUI system is not working any more with
  the changed requirements. Also, while the third reincarnation of Stefans PLGui is really cool and can be used for OS and ingame and has, by using the PL RTTI, automatic support
  for scripting and therefore integrates itself perfectly into the whole system... PLGui is still missing some features and fine-tuning. Sadly, such a GUI system is a huge task
  and currently, as already mentioned, there are only two active spare-time developers. Personally, I finally want to get PixelLight to the point were it's possible to create
  simple prototype applications in a matter of minutes by using e.g. a Lua script to load in a scene and adding some interaction - and then be able to run this on multiple
  platforms/targets. So, my focus is on that instead of taking over the development of Stefans PLGui (I already ruined the previous second reincarnation and don't want to repeat
  this experience). I really hope that in the future there's someone continuing the development of PLGui because especially the scripting-argument is a really cool argument for PLGui!
  (connecting e.g. libRocket or Qt to the PL RTTI and scripting system will be probably lot of work while it's no work at all with PLGui!)
  ... enough introduction and explanation why there's need for the PLFrontend project. Let's go to work...
- Added the (currently empty) frontend plugins
  - "PLFrontendNull": The usual dummy project doing nothing at all
  - "PLFrontendOS": Just a totally primitve OS window
  - "PLFrontendPLGui": PLGui connection
  - "PLFrontendQt": Qt connection (the new "PLQt")
  - "PLFrontendActiveX": ActiveX connection (the new "PLPluginActiveX")
  - "PLFrontendMozilla": Mozilla connection  (the new "PLPluginMozilla")
  ... while "PLFrontendNull", "PLFrontendOS", "PLFrontendActiveX" and "PLFrontendMozilla" are intended to be 100% loose dynamic plugins, "PLFrontendPLGui" and "PLFrontendQt" are
  of course also such plugins, but one is usually going to also use those libraries directly within an application (meaning linking aginst them).
- Copied the diaries of "PLPlugin", "PLPluginActiveX" and "PLPluginMozilla" into this diary because PLFrontend will be the successor of the "PLPlugin"-project... which is not limited
  to "PixelLight application as a plugin for e.g. a browser" but will also cover the "PixelLight application as executable" use case. Meaning, in the future it will be possible to just
  recompile a C++ PixelLight as shared library and then be able to use it in any available frontend.
- Using "PLPlugin::Plugin" as start point for the class "Frontend"
- Renamed "PLPluginActiveX" (still working, just tested it :) into "PLFrontendActiveX"
- Renamed "PLQt" into "PLFrontendQt"
- Renamed "PLPluginMozilla" into "PLFrontendMozilla", when testing it with Firefox 5.0 the browser didn't want to load it (sayed something about corrupt... before I did the changes...)...
  I'll check it later when PLFrontend is working as a whole...
- Removed "PLPlugin", it's been replaced by "PLFrontend"



>> 02.07.2011
[CO]
PLQt:
- Added empty project "PLQt". In the next steps, PLQt (https://sourceforge.net/projects/pixellight/) from Stephan Wezel will be integrated directly into the PixelLight
  Git repository and SDK because e.g. the editor will be Qt based. I currently use Qt 4.7.0 and I know that there's already a newer version available... but I already
  had Qt 4.7.0 compiled for VisualStudio 2010 (to avoid using VC 2008 within the PL SDK) a while ago and right now I don't want to spend time in recompiling Qt, again.
- Moved "QtStringAdapter" from PLGeneral into PLQt
- Integrated PLQt, I'am sure it's not yet final and that over time, there will be multiple simplifications



>> 31.07.2011
[CO]
- Exposed "ConsoleApplication::Exit()" to the RTTI



>> 30.07.2011
[CO]
- "PLScriptLua::RTTIObjectSignalMethodPointer::EventCallback": "TypeRef" was missing



>> 27.07.2011
[CO]
- Using PLCore to check whether or not "override" from C++0x (see e.g. http://www2.research.att.com/~bs/C++0xFAQ.html#override) will cause any problems
  -> By using "override", the compiler found the following: "Constructor" implemented the virtual method "GetDesc()" and a comment stated that it's a
     "DynFunc"-method. Ok, the name is a "DynFunc"-method, but the signature is "const FuncDesc *DynFunc::GetDesc() const" while the other signature is
     "const ConstructorDesc *Constructor::GetDesc()". "ConstructorDesc" is not derived from "DynFunc". To be fair, to the compiler would also have found it without "override"
     if "Constructor::GetDesc()" would have been declared as constant as well, but it wasn't. So, "override" really did the trick and exactly such errors are the reason
     why I'am so interested in this language feature in the first place. I'am sure that there are some more of such errors in the hundred thousends lines of code... :D
     If I'am not totally wrong and missed something, "Constructor::GetDesc()" is a dead method. Removed it.
  -> In the dungeon demo, I found at once an error using this new language feature: The "Application::LoadScene" signature had changed, but the dungeon demo wasn't updated...
     I'am starting to really like "override" :D
- PixelLight was already using "extern templates" which are part of C++0x (http://www2.research.att.com/~bs/C++0xFAQ.html#extern-templates)... added comments to avoid confusion...



>> 26.07.2011
[CO]
- "LoadableType::AddLoader()" fixed log messages ("[Info]: Loader 'PLAssimp::SceneLoader3DGameStudio': Format 'mdl' is already used by loader 'PLAssimp::SceneLoader3DGameStudio")
- "Loadable::Load()"/"Loadable::Save()": Moved the "IsDerivedFrom()" security check into "LoadableManager::RegisterClasses()"
- Renamed "LoadableType::GetLoader(uint32 nIndex)" into "LoadableType::GetLoaderByIndex(uint32 nIndex)"
- Renamed "LoadableType::GetLoader(const String &sExtension)" into "LoadableType::GetLoaderByExtension(const String &sExtension)"
- Renamed "LoadableManager::GetLoader(uint32 nIndex)" into "LoadableManager::GetLoaderByIndex(uint32 nIndex)"
- Renamed "LoadableManager::GetLoader(const String &sExtension)" into "LoadableManager::GetLoaderByExtension(const String &sExtension)"
- Renamed "LoadableManager::GetType(uint32 nIndex)" into "LoadableManager::GetTypeByIndex(uint32 nIndex)"
- Renamed "LoadableManager::GetType(const String &sName)" into "LoadableManager::GetTypeByName(const String &sName)"
- Added "LoadableType::GetLoaderForLoadingByFile()" which currently is using, as before, just the filename extension to find the proper loader
- "LoadableType::GetLoaderForLoadingByFile()": If there's no loader for the given file extension, the complete file extension is checked as well (file format extensions like
  "mesh.xml" can now be used as well)
- Added "System::GetSeparator()" returning the directory separator used by the operation system (e.g. '/' on Linux, '\' on Windows)... interesting that such a method was still
  missing...
- Added "File::CFileModeToAccessFlags" translating a given C file mode ("r", "r+", "w", "w+", "a", "a+", "t", "r+t" etc. used for e.g. "fopen") into access flags



>> 25.07.2011
[CO]
- "Url": "GetTitle()" and "GetExtension()": For a filename like "archive.tar.gz" the method "GetTitle()" returns "archive.tar" and "GetExtension()" returns "gz". While this is
  ok/standard for some use cases, there are also situations were "archive" as title and "tar.gz" as extension is desired/standard. I checked other libraries/frameworks like Qt
  in order to see how they deal with this topic. In Qt, they offer the following methods:
    "QFileInfo::baseName()"="archive"
    "QFileInfo::completeBaseName()"=archive.tar"
    "QFileInfo::suffix()"="gz"
    "QFileInfo::completeSuffix()"="tar.gz"
  This naming convention sounds reasonable and at least "suffix()" is handled the same way as PL's "GetExtension()".
  -> Added some more comments to avoid confusion (or at least reduce it) when dealing with filenames like "archive.tar.gz"
  -> Renamed "GetTitle()" into "GetCompleteTitle()" returning "archive.tar"
  -> Added "GetTitle()" returning "archive"
  -> Added "GetCompleteExtension()" returning "tar.gz" and also added "CutCompleteExtension()"



>> 21.07.2011
[CO]
- PLGeneral->PLCore - done



>> 19.07.2011
[CO]
- Merged PLGeneral (started before 25.11.2003) into PLCore (started: 05.02.2008) because both are completely fundamental and it's not that clear which project was for which
  components. When looking e.g. at the PixelLight component diagram one can see that every other project is already using PLCore and not even the most primitive sample within
  the SDK is using just PLGeneral. This may be a sign that this is in fact one component which was just splitted into two projects. A year ago or so, there were already
  discussions whether or not e.g. the log should be part of PLGeneral and PLCore. In the end, the log was moved into PLGeneral although the log formater classes are in fact
  loose dynamic plugins, but were now not able to be implemented in this way because the RTTI was introduced within PLCore. Of course, that's nothing dramatic, but on the other
  hand it would be cool to e.g. write a special log formater within a loose plugin and then select it within a configuration file. While modulation is a really useful thing,
  PixelLight now consists of 13 of primary modules and loose plugins and when looking at user feedback it looks like that some people have some issues with this. I'am not going to
  merge everything into a single "PixelLight"-project as seen in several engines out there. There was a reason for this individual modules: To make everything as flexible as
  possible which is especially nowadays really important due to the mass of available target platforms. But it seems to be reasonable to simplify PixelLight were ever possible
  to avoid comments like "PixelLight is a monster" in the future. This was one reason why I moved weeks ago the 100% dynamic plugin projects into the "Plugins"-directory so everyone
  can see at once that those are optional and nothing build in. The core of PixelLight is in fact slim and most features are just plugged-in! (which may be one of the reasons why
  there are people thinking that PixelLight is really complicated because they seem to be used to have everything thrown statically together in one huge blob)
  -> The PixelLight base now consists of 12 modules as well as 38 optional modules aka plugins aka extensions aka addons, this should still be more then enough modularisation.
  -> Due to the current examines at university, I'am pretty sure that I will need several days to update the rest of PixelLight...



>> 10.07.2011
[CO]
- Moved PLIRC and PLJabber from the PLNetwork directory into the PLPlugins directory because it's nothing the PixelLight core is
  using and in fact, until now it isn't used at all. So, this is definitively a plugin/extension/addon.
- Removed PLNetwork project. It has now been empty since "23.10.2009" and there are no signs that this will change in the near feature.
  The basic stuff like sockets were already within the PLGeneral project and even some more hight level constructs like server-client
  classes. Since the public release of PixelLight, there were several user questions asking why PLNetwork is empty, and why there's an empty
  project at all. So, to avoid this confused (but understandable) question in the future, PLNetwork is now gone. If there's really
  need for an individual network component in the future, the project can be added in no time.
-> Moved the entries of the PLNetwork diary into the PLGeneral diary



>> 03.07.2011
[CO]
PLCore:
- Within "Rtti.h", "__NT__" ("#define __NT__	PLCore::NullType") was defined... which usually stands for "Windows NT" in system headers. Until now, there were
  no problems with that, but today this changed when using Qt to compile something under Linux.
  Within the Qt header file "qglobal.h" there's the following line
    "#elif !defined(SAG_COM) && (defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__))"
  ... and now, when including a PixelLight header using the RTTI before a Qt header is included, Windows headers are included inside Qt. I thought about renaming
  "#define __NT__	PLCore::NullType" into "_PLNT_" or so, but on the other hand, maybe there's an OS header using "_PLNT_" or another definition as well? To avoid
  any further troubles in here, I just removed this definition.



>> 02.07.2011
[CO]
- Moved "QtStringAdapter" from PLGeneral into PLQt



>> 27.06.2011
[CO]
PLCore:
- "PLScriptLua::RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()": Added some quotation mark checks. If the string content is "Name="Bob"" the resulting parameter
  string will be "Param0="Name="Bob""" and the parser will have troubles with it and will take "Name=" instead of "Name="Bob"" for the value of "Param0". After this change,
  the resulting parameter string is now "Param0='Name="Bob"'".



>> 21.06.2011
[CO]
PLCore:
- When testing the Dungeon demo under Linux, I noticed that the "Object" RTTI methods (but only those?) were not exported correctly when using GCC. Found the "bug" within my
  change from "04.06.2011" when I removed the per instance cost of RTTI methods... the RTTI method instantiation was wrong. I still think that this is the right way because
  tons of those methods will come in the future!
  After a look into how Stefan did it with the RTTI constructors I was able to fix the issue, more or less. It looks like now, that more stuff is connected to the RTTI the
  template instantiation issue strikes back (we already had it multiple times under Linux). Interesting that everything runs that smoothly under MS Windows.
  Maybe it's better to do as many RTTI related definitions as possible in the cpp files instead of the header files? As far as I can see, for constructor and method definitions
  this wouldn't be problem - except that the RTTI stuff would be more scattered over two files (although there's already "pl_implement_class" in the cpp files...).   
  This would probably also make the life of the compiler a little bit easier... the more complex derived classes from derived classes get, the more work for the compiler
  (the slow down is really notable when compiling). Right now, I don't want to work too much on the RTTI - I already did way more changes as I wanted. It's not
  really my field and I'll have other stuff on my TODO-list (but I really had to do something about the most important issues to be able to go on with other parts in a decent way).
  So a kind of patchwork has do to the job for now: In important RTTI classes, I'll added a define around the constructor and method definitions so that they are only considered
  when compiling the project they are in. This solved my current template instantiation issue under Linux - for now.
  Ps. By the way, I just noticed that the Windows version of the Dungeon executable is after this change only 230 KiB instead of 395 KiB... I assume that this massive template
  instantiation within the header files really has a notable impact on everything. :/



>> 18.06.2011
[CO]
PLCore:
- Added "DynSignature"-interface and derived "DynEvent", "DynEventHandler", "DynFunc" and "DynParams" from this new interface. Previously, those interfaces had
  only a "GetSignature()"-method in order to request the signature description as string. With the introduction of script support there was a need to get concrete
  type ID information of return and parameters for proper exchange of data between script and C++. Of course, it would have been possible to just parse the already
  available signature-string, but this would have been a little bit uncomfortable.
- PLScriptLua: Added new static method "RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()" which returns the current Lua function parameters on the Lua
  stack as string. This was my motivation for the "DynSignature"-interface because this new method is used by "RTTIObjectMethodPointer" and "RTTIObjectSignalPointer"
  and type ID information is used internally.
- PLScriptLua: Solved another reference issue. Well, not directly an issue with references in general, more an issue about their usage in scripts with strings.
  Strings are somewhat of a special case, at least within their usage. It's possible that there's a RTTI method with a "Object*(const PLGeneral::String&)"-signature
  meaning that the parameter is a reference. Within scripts, strings are fundamental and therefore it should be possible to use such a RTTI method by writing for instance
    this:GetSceneNode():GetByName("Soldier")
  so that the script programmer doesn't need to care whether or not the required RTTI method parameter is in fact a reference instead of a string. Of course, a real
  reference a parameter should still also be possible as well. To solve this issue, whenever the script programmer provides a string, but a RTTI method is expecting
  a reference or a pointer, this given string is stored within a string-list on the heap during the function call. By doing so, the reference/pointer has a valid address.
  -> Some weeks ago, I was afraid that we can't keep the "const PLGeneral::String&"-concept and had to change it into "PLGeneral::String" in order to use such methods
     within scripts. But the solution within PLScriptLua solves this issue and the PixelLight interfaces don't need to be rewritten. The solution also introduces no
	 extreme runtime overhead because the string class is quite optimized internally and is using e.g. the "copy-on-write"-concept. So, those temporary strings on the
	 runtime stack don't really hurt much.
- "PLScriptLua::RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()": If a RTTI signature demands more parameters as the script programmer provided, we need to add
  the missing parameters because if there's a reference parameter it really needs a valid address
- "Script": Added namespace support for global variables. By using namespaces, one can e.g. define that all script variables an editor is able to show have to be
  within a "public"-Namespace (just an example, there's no such thing fixed build in within PLCore!). In this editor-example, the user is then able to get and set script
  variables just like RTTI attributes, but the other script variables which are e.g. within the global namespace are hidden.
  Currently, this namespace support is only implemented within PLScriptLua... the next scheduled PixelLight release is near and so I really have to work focused.
- "Script": Due to namespace support for global variables, I had to change the "GetGlobalVariables()"-signature. This method no longer returns a list of found global variables,
  instead a list to be filled up has to be provided as parameter.
- "Script": Added support for global script functions which are inside a namespace. Currently, this namespace support is only implemented within PLScriptLua.
- "pl_class_internal"-macro: Added "__pl_rtti_export(PLCORE_RTTI_EXPORT)" within the RTTI macro to make it possible to expose "Object"-methods to the RTTI
- "Object": Renamed "IsInstanceOf(const Class &cClass)" into "IsInstanceOfByReference(const Class &cClass)" to make it possible to expose the
  "IsInstanceOf(const PLGeneral::String &sClass)" method to the RTTI (this version of the method is the more often used one)
- "Object": Exposed several methods to the RTTI... this makes it for instance possible to construct the names of methods/attributes etc. to be called from inside a script
   dynamically inside the script...



>> 17.06.2011
[CO]
PLCore:
- "Script": Added support for "Object&"
- "DynEvent": "Connect()" and "Disconnect()" required a pointer as parameter, but there was no documentation whether or not a null pointer was allowed.
  When providing a null pointer, the implementation crashed because there was no test for a null pointer. Before I start adding pointless pointer
  checks, I just change the methods so their using references as parameters as done in other PixelLight parts. By the way, connecting event handlers
  looks now also the same as when doing the same in Lua scripts. *g*



>> 16.06.2011
[CO]
PLCore:
- There was an issue when using a reference type as RTTI method result... this was the reason why I hadn't yet exposed methods like
    SceneNode &GetSceneNode() const;
  to the RTTI. It took me several hours to wrap my head around the type traits Stefan wrote (no critics, the system is really genial... but the topic is just not really
  my expertice, I'am more the graphics programmer type :) and several more hours for attempts and experiments to get reference types as return values up and running.
  When I finally had an working solution, I reduced my number of code changes to the bare minimum in order to reduce the risk to introduce new bugs or to mess everything
  up. I really had to do a change in order to be able to continue exposing methods to the RTTI... the alternative to just forbid the usage of pointers wasn't a real
  solution for me.
  The problem was the following: The internal system stores within the parameters class the parameters, and also copies them around like
    cP.Return = (*this)(cP.Param0);
  as long as the type is no reference, everything is just fine. But as soon as there was a reference type hell broke loose because a when copying one reference into another,
  not the address of the referenced object is copied but instead the value. Within the system, this reference behaviour results in another behaviour as the desired one. My
  solution is the introduction of a "storage" type within the type definitions. Usually, meaning for 99% of all types, the storage type is identical to the real type. For
  reference types, the real type is a reference (as before) - but the storage type is a pointer. This way it's possible to internally copy around the parameter in the correct
  way. There are also the two new type methods "ConvertRealToStorage()" and "ConvertStorageToReal()" which are used to convert the types when necessary. I hope the compiler
  is clever enough to notice when this results in copying one variable into itself without any further change - in this case, this change would introduce no new additional work
  to be done. The example code from above now looks like this
    cP.Return = Type<R>::ConvertRealToStorage((*this)(Type<T0>::ConvertStorageToReal(cP.Param0)));
  and from the outside, as long as not accessing "Return", "Param0" etc. directly, the user will not notice that his reference is internally handled as pointer. With this change,
  it's now possible to expose methods with a reference type as result to the RTTI - meaning to also enable it's usage within scripts.
  ... the last days were really exhausting because due to university, I had to get into the topic and solve the issue at night and during lectures. But I really wanted to have this
  issue solved within the upcoming PixelLight 0.9.7 release because it's quite fundamental for scripting. Now that it's up and running, I think it was worth the effort. :D
- PLScriptLua: Added "TypeRef" support for method results
- ... now that I have GCC 4.6.1 installed, removed the following hack within Event.h
    // [HACK] This is currently necessary to avoid the following strange compiler error:
    //		    undefined reference to `vtable for PLCore::Functor<void, PLCore::Module const*, ...>
    #ifdef GCC
        static Functor<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> DummyFunctor;
    #endif
  in order to check whether or not this is still the case... made a fresh build without the hack and there were no more problems. :)
  So, I let the hack out... there's no point in supporting buggy old compilers. For example in GCC 4.5.2 the nullptr emulation was no longer working due to a GCC bug. So, if you
  encounter any compiler issues, just use an up-to-date compiler (if there's one :) instead of spending time to hack around compiler bugs.
- "Func.h": Removed debug-output in case of a signature mismatch. The "new" RTTI 2 is now working since over a year within PixelLight and does really a fantastic job. I assume it's
  about time to remove this scaffold (which, over the time caused some debug/release include issues).
- Minor "SignatureString::GetSignatureID()" implementation change to make the life of the string class a little bit more comfortable. I know, this doesn't really have a directly
  measurable impact... but when I see something that can be optimized without messing everything up (especially when it's within the core), I do it because in the end, all sums up...
- Removed
    typedef Func<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> _Func;
  etc. in e.g.
    FuncFunPtr<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> : public Func<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> {
  because it really looks like dead code (wasn't able to find any usage of it).



>> 14.06.2011
[CO]
PLCore:
- "ConsoleApplication": The "Init()"-method documentation stated that it's calling "OnInit()", and the "DeInit()"-method documentation stated that it's calling
  "OnDeInit()"... but those two methods are actually called by the "ConsoleApplication::Run()"-method. I had a look into this diary to see the intended behaviour
  and found the description within the "06.08.2010"-entry from Stefan Buschmann (I'am really glad that we're writing diaries :). The implementation is correct,
  but the documentation wasn't. Fixed that.
- "Script:" Added "IsGlobalFunction()" so one can check whether or not there's a certain global script function before calling it. Background: When calling a global
  script function, the script backend usually writes an error into the log when the given global script function wasn't found. I still think that this behaviour is
  useful. When using optional global script functions, it's a good idea to check whether there's such a global script function by using "IsGlobalFunction()".
- PLScriptBindings: Changed the default value of "UpdateFunction", containing the name of the script function to be called, from "Update" into "OnUpdate"
 (same name as in "PLEngine::ScriptApplication")
- "PLEngine::ScriptApplication" and "PLScriptBindings::SNMScript" have now both the script entry points "OnInit()", "OnUpdate()" and "OnDeInit()".
  The name of the optional script function called by C++ by one of these entry points is an RTTI atribute, meaning that e.g. a scipt can manipulate
  it's own entry points! Wow, the script-stuff is getting pretty flexible. *g*



>> 12.06.2011
[CO]
PLCore:
- Merged PLScript into PLCore. When starting PLScript on "25.04.2011" I had no real idea were the script voyage would end. Back then, I decided to
  create an own project for script support - this has proven to be useful when starting a new component. Now that the Lua backend of PLScript has
  nearly all features I wanted I start to play around with it a little more... and it's a little bit annoying to add PLScript to the VC project solutions.
  Right now, PLScript consists just of a handful of classes and it doesn't look as if a lot more script classes will come. The "magic" happens in the RTTI
  system and within the general PLCore infrastructure. Scripts exist to make the world a little bit less complex, so, it's probably a good idea to make using
  scripts within the PixelLight C++ API less complex as well by directly adding the scripting-feature into PLCore. The PLScript documentation will still be an
  own document because the PLCore documentation is already comprehensive and contains more advanced stuff which will probably shock many people which are just
  looking for e.g. "How to use Lua within PixelLight". *g*



>> 11.06.2011
[CO]
PLCore:
- PLScriptLua: A Lua script can now connect a RTTI signal with a Lua function



>> 10.06.2011
[CO]
PLCore:
- "DynParams": Added "GetReturnTypeID()", "GetNumOfParameters()" and "GetParameterTypeID()" in order to make it possible to get some more
  information about parameters if one has just access to the "DynParams" interface
- Added "FuncGenFunPtr" and "FuncGenMemPtr" using functions/methods with the signature "Signature<void, DynParams&, void*>". There are situations were it's not
  possible to, e.g. create a typed event handler because the types are unknown to compile time. Those two new functor implementations are using a generic
  function/method and pass the parameters by using "DynParams".
- "DynParams": Added "GetPointerToReturnValue()" and "GetPointerToParameterValue()" to make it possible to set a return value or to get a parameter if one has
  just access to the "DynParams" interface. It's of course no good idea to use generic void* pointers to access the data and whenever possible typed access should
  be used instead... but there are situations were it's really required to be generic because the types are not known to compile time.
  Here's an example of a generic function:
    void GenericFunction(DynParams &cDynParams, void *pUserData)
    {
        // Get the value of the first parameter
        String sMessage = (cDynParams.GetParameterTypeID(0) == TypeString) ? *((String*)cDynParams.GetPointerToParameterValue(0)) : "";

        // Set return value
        if (cDynParams.GetReturnTypeID() == TypeInt32)
            *((int*)cDynParams.GetPointerToReturnValue()) = 42;
    }
  This function can then be used in the following way:
    FuncGenFunPtr<int, String> cFunctor(&GenericFunction);
    int nResult = cFunctor("He ho!");
  As you can see, using a generic function is just like using any other functor, except that the target function has a generic signature. The user
  data pointer enables the user to pass on additional data... this is a quite common approach (although it also has to be used with precaution).
- "DynEvent": Added "CreateGenericEventHandler()" which creates a generic event handler which is compatible with the dynamic event. Sadly this is only
  possible for global functions and not for class methods because we don't have any class type information available. But for my use-case it will do the job.
  Here's an example of a generic function:
    void GenericFunction(DynParams &cDynParams, void *pUserData)
    {
        // Get the value of the first parameter
        String sMessage = (cDynParams.GetParameterTypeID(0) == TypeString) ? *((String*)cDynParams.GetPointerToParameterValue(0)) : "";
    }
  And here's an example of how the new "DynEvent::CreateGenericEventHandler()"-method can be used:
    Event<String> cMyEvent;
    DynEventHandler *pDynEventHandler = cMyEvent.CreateGenericEventHandler(&GenericFunction);
    if (pDynEventHandler) {
        cMyEvent.Connect(pDynEventHandler);
        cMyEvent("He ho!");
        delete pDynEventHandler;
    }
  ... this means that if one has just access to the "DynEvent" interface, it's now possible to create an event handler which is informed when the event
  is emitted.
- PLScriptLua: RTTI signals now have some build in methods. When writing e.g.
    object.MySignal.Connect(object.OnMyEvent)
  the RTTI slot "OnMyEvent" of our RTTI class instance "object" is connected with the RTTI signal "MySignal" of our RTTI class instance "object".
  To disconnect, just use "Disconnect" instead of "Connect".



>> 09.06.2011
[CO]
PLCore:
- Until now, the constructor of RTTI signals was demanding a pointer back to their owner object. When looking at the "pl_slot_<x>"-macros, one could
  see that this provided constructor parameter was not used and I have no glue why it's there - because signals are internally just events (as also stated
  within the documentation). If there's need to know where an event came from, this information has to be provided in the event definition. Events should be as
  lightweight as possible, so storing e.g. an additional pointer within the event instance would probably not be the best idea. 
- PLScript: Lua is now an recommended external dependency and will be the script backend which is within the official PixelLight SDK. The answer for "Why Lua
  and not Python, JavaScript or AngelScript?!" is quite simple: Right now, the Lua backend is the most advanced one because Lua and it's C-API is mostly
  intuitively to use and there are tons of useful information all over the net how to integrate Lua into a "game engine". Lua is also the most compact
  of all of those mentioned script languages - the Windows dll is only 124 KiB while v8 (used for JavaScript) is 2,354 KiB! The syntax of Lua is also
  good to read and something like OOP can be done without totally unreadable tricks as required for JavaScript (did some OOP experiments within "44ScriptOOP").
- PLScript: Added "ScriptManager::GetScriptLanguageExtension()" which returns the filename extension of a given script language
- PLScriptNull: The null backend has no load and runnable scripts -> removed the "null" and "NULL" formats



>> 06.06.2011
[CO]
PLCore:
- PLScriptLua: Something like "sceneNode:SetActive(true)" is now handled correctly, meaning the boolean value "true"



>> 05.06.2011
[CO]
- *breaking change* "ElementManager": Renamed "Get(uint32 nIndex)" into "GetByIndex(uint32 nIndex)" and "Get(const String &sName)" into
  "GetByName(const String &sName)". There were already situations were the compiler wasn't able to distinguish between these two methods
  and upcoming changes/features would cause even more problems.
PLCore:
- Exposed "ConsoleApplication" to the RTTI
- Until now, C++ methods exposed to the RTTI had to be non-constant. Due to the script support, RTTI methods will now be heavily used and it's not that
  comfortable to be forced to change a method signature just to be able to expose it to the RTTI. So, within the "__pl_method_meth"-macro I cast away the
  const within the method pointer using a good old C-style cast to be as flexible as possible in here. I don't think that this introduces any security risks
  because the RTTI method just points to the real C++ method, and in there the const is still there and the compiler will blame you as usual if a non mutable
  member attribute is changed within a constant method.
- *breaking change* "ResourceManager": Renamed "Get(uint32 nIndex)" into "GetByIndex(uint32 nIndex)" and "Get(const String &sName)" into
  "GetByName(const String &sName)" (same change as in "PLGeneral::ElementManager")
- PLScriptBindings: Added "ScriptBinding_PL"
- PLScript: Removed experimental "ScriptBindingScene" because it's no longer needed. Write e.g.
      PL.GetApplication():GetScene():GetByName("Soldier")
  within a Lua script to get the scene node "Soldier". Something like
    PL.GetApplication():GetScene():GetByName("MySubscene"):GetByName("Soldier")
  will work of course as well... WOW! Stefans RTTI is *really* powerful and most script bindings will come practically
  for free... I just added
      pl_method_1(GetByName, SceneNode*, PLGeneral::String, "Returns a scene node by using the given name, can be a null pointer", "")
  within the RTTI class interface of "PLScene::SceneContainer" in order to be able to access the C++ method from inside a script.
  To avoid issues when exposing C++ methods to the RTTI I'am afraid we need to change something like
     void SetFilename(const PLGeneral::String &sValue)
  into
     void SetFilename(PLGeneral::String sValue)
  because "const PLGeneral::String &" is of course a reference, and the RTTI is using it this way (which is correct!). This is becoming a problem
  when there's no real "PLGeneral::String" instance on the method calling side... which is true for scripting. Before I start to hack around, I probably
  just change it as seen above... there's no real need for passing in a string reference anyway because the string class internally just shares
  a string buffer and therefore "copying" one string into another is blazing fast.
  -> I'am sure the "PL.GetApplication()" way is the right one for PixelLight. It results in only a few global functions (they introduce script
     initialization costs!) and the rest is completely dynamic by just using RTTI class instances (they introduce no script initialization costs!).
	 Exposing new features to script languages only requires a single, simple line of C++ code, and this line is even not just there for scripting,
	 it's generic. So, there's no need for thousands of "script proxies"/"script wrappers" in order to expose C++ stuff to scripting languages as seen
	 in many other engines with script support.
  -> In the next few days I should really spend more time on university stuff, but then I probably will start exposing the most important C++ methods
     to the RTTI (exposing this stuff doesn't blow up the memory footprint of RTTI class instances). 
	 When I'am done with it, the Lua support should already be quite usable... as for the Python, JavaScript and AngelScript support ... well,
	 I first have to figure out how to access RTTI objects in a decent way using those script APIs. The strongly typed AngelScript already produced some
	 headaches. For now, it's important to me that at least one scripting language is usable, so I focus on this point.
- PLScript: Removed experimental "ScriptBindingSceneRendererTool" because it's no longer needed. Write e.g.
      PL.GetApplication():GetSceneRendererTool():SetPassAttribute("DeferredDOF", "Flags", "Inactive")
  within a Lua script.
- PLScriptBindings: Renamed "ScriptBindingLog" into "ScriptBinding_PL_Log", "ScriptBindingTiming" into "ScriptBinding_PL_Timing" and
  "ScriptBindingSystemConsole" into "ScriptBinding_PL_System_Console" so one can directly see the resulting script namespace (I'am not sure whether or
  not the current solution will stay this way)



>> 04.06.2011
[CO]
PLCore:
- Adding a RTTI class method came with the cost of 8 bytes (32 bit build) per RTTI class instance. While e.g. RTTI class attributes really require
  per RTTI class instance data, RTTI class methods don't need per RTTI class instance data... at least as long as such a method is not called. When
  calling a RTTI class method, the RTTI class instance is required, but only then.
  One may say: "8 bytes - who cares about a few bytes?", but considering that those 8 bytes are per method and per class instance this really sums up.
  Until now, RTTI class methods were not used that often within PixelLight, so, this wasn't a real problem. For the script support, those RTTI class
  methods play an important role and I'am quite sure that all over the place a lot of RTTI class methods will be added in order to use RTTI class
  instances e.g. within scripts. With this in mind, those 8 bytes really hurt.
  So, before I start to add a lot of RTTI class methods for script support, I stopped and had a look into how to reduce the RTTI class method per
  instance memory costs. RTTI class methods are now static, meaning they only introduce a memory cost for the RTTI class itself which is not critical
  because there's only one such class instance per class. :D
  When requesting a callable RTTI class method, an instance of such an object is created on the fly. In short, memory was traded for additional memory
  allocation/deallocation - but I really think it's ok and maybe there will be more internal optimisations later.
  -> This change means, that something like
       "cMyObject.MethodTest()" or "cMyObject.MethodTest.Call(PLCore::Params<void, int, float>(20, 1.1f))"
     for calling the method "Test" though it's RTTI wrapper is no longer possible. But that's not really a loss because in those situations it's possible
     to directly call the C++ method anyway.
  -> This change also means that within constructors, it's no longer required to initialize RTTI class methods by writing e.g. "MethodLoad(this)". This makes
     exposing methods to the RTTI easier because it's only required to add e.g.
       pl_method_2(Load, bool, Chunk&, PLGeneral::File&, "Load method", "")
     within the RTTI class definition in order to access the method "Load" though the RTTI.
  -> And the most important meaning of this change: Add as many RTTI class methods as you want, your RTTI class instance won't grow into the kilobytes through that. :D
- "Object::GetMethod()" returns now "DynFuncPtr" instead of "DynFunc*"
- "Object::GetMethods()" no longer returns a list instance, instead a list instance to be filled has to be provided as parameter.
  This change avoids unnecessary copying around. Because the RTTI stuff is fundamental, it really has to be as performant as possible...
  even if this means that the interface of "Class::GetMethods()" is not identical to "Object::GetMethods()".
- Stephan found a cleanup bug within my delayed shared library loading implementation... in the case that a class dummy can't be registered because there's
  already a class dummy or even the real class, no one destroyed the created dummy class instance. This is now handled within "ClassManager::RegisterClass()".
  Uff, simple principle, that many implementation bugs - not that I had expected it otherwise... but I really hope that was the last one.
- The type ID of "TypePtr" and "TypeRef" was set to -1 instead of an unique value
- PLScriptLua is now able to deal with RTTI class instances derived from "PLCore::Object" instead of just direct pointers
  to "PLCore::Object". The current solution is not really a good one, but for now it works. I hope I'am able to figure out
  a more waterproof solution.



>> 03.06.2011
[CO]
PLCore:
-> Stephan Wezel made a PLProject refactoring (see PLProject diary for details), delayed shared library loading is now also working under Linux
   because PLProject adds the class information into the plugin-file
- PLScriptBindings: Added "ScriptBindingSceneRendererTool"... The "making of" of the dungeon demo is now done via a
  Lua script. Still experimental, but the wires begin to tie up.



>> 02.06.2011
[CO]
PLCore:
-> After an university lecture etc. maraton of two weeks and some non script related PixelLight work, back to the script stuff. :)
- PLScript: "Script::SetGlobalVariable()" has now as parameter the more generic "PLCore::DynVar" instead of "PLGeneral::String"
- PLScript: Renamed "Script::GetGlobalVariableType()" into "Script::GetGlobalVariableTypeID()" so that it's similar to e.g. "PLCore::Var::GetTypeID()"
- PLScriptLua: "Script::SetGlobalVariable()" now also supports "PLCore::Object*" and is able to add new global variables
  (one can use e.g. "Script::IsGlobalVariable()" to check whether or not there's such a variable before setting one to avoid adding a new
  global variable if this is not desired)
- "PLScriptBindings::SNMScript" now adds the global variable "this" to the script so that it's able to access "this" RTTI class instance,
  meaning the script scene node modifier
- PLScriptV8 & PLScriptPython: "Script::SetGlobalVariable()" is now able to add new global variables



>> 29.05.2011
[CO]
- Added "Stopwatch::Stopwatch(bool bStartAtOnce)" to make it possible to use the stopwatch in a more compact way
- "StringBufferManager::ReleaseStringBuffer()": Activated the string buffer management under MS Windows because, especially when
  debugging, this adds a real performance boost like e.g. 2 sec instead of 20 sec to start an application in debug mode.
  (so, this string management is nothing optional - without it, it's just painful to debug more complex applications)
  Under Linux, I currently just get a segment fault when starting an application with enabled string buffer management - so it's deactivated
  under Linux for now because I don't have the time to do intensive debugging at the moment, but I really need to be able to do decend debugging
  under MS Windows...
- Ok, "StringBufferManager::ReleaseStringBuffer()" is now working under Linux as well... there was a really stupied bug which caused the UTF8
  string buffer to lie about it's type...
PLCore:
- Added parameters to the plugin relevant "ClassManager"-methods to make it possible to e.g. disable delayed shared library loading
- Added an option to "ConsoleApplication" to make it possible to configure whether or not it's allowed to perform delayed shared library loading to
  speed up the program start ("DelayedPluginLoading" within the configuration file)
- The "ClassManager"-destructor has to destroy the class implementation dummies, the real classes are destroyed automatically by the RTTI system
  (see "pl_class" -> "__pl_guard"). Stephan Wezel helped me in identifying those (hopefully) last bugs in the refactored "Class"-class and helped
  testing the stuff under Linux as well as fixing some details, a huge thank's for the motivating support. :D
-> It looks like the delayed shared library loading is really working quite fine and it's finally fun again to do debugging because the program start
   doesn't take half a minute. I hope I'am now able to focus back to complete the scripting stuff and fix some general bugs like the one described at
   http://dev.pixellight.org/forum/viewtopic.php?f=6&t=48&p=153#p153
   ... the time until the next planned PixelLight release is running, but it was really important to me to speed up the program start time in order
   to be able to debug in a resonable way.



>> 28.05.2011
[CO]
PLCore:
- Continued "Delayed shared library loading"-refactoring: Currently, "LoadableManager" forces many plugins to be loaded in order to register
  loader instances. To delay the plugin loading, "Loader" is now just a proxy and "LoaderImpl" the real loader implementation. This way, the available
  loader implementations are registered correctly, but the actual loader implementations which require to load in the shared library are only
  created when really required.
- The RTTI interface for "Object" was defined as
    pl_class_internal(Object, "PLCore", "", "Object base class")
  and the result was that the base class of "Object" was "" instead of <no base class>, meaning an empty string. I changed it to
    pl_class_internal(Object, "PLCore", , "Object base class")
  ... although it looks somewhat strange, it's correct this way.
- "ClassImpl::GetBaseClass()" is no longer calling "InitClass()" to enhance the chance that a RTTI class is never initialized



>> 26.05.2011
[CO]
PLCore:
- Started "Class" refactoring... There are now a lot of PixelLight plugins within the Git repository and by default, they are all loaded within
  "ConsoleApplication::OnInitPlugins()" so that it's possible to create RTTI class instances. While this behaviour is quite comfortable
  because plugins can be used automatically by just throwing the loose plugins into a scanned directory, it's also quite slow at program start.
  (although there are already several internal optimizations in place like delayed RTTI class initialization!)
  Usually only a few plugins are really used during runtime, but in order to be able to create RTTI class instances it's required that the system
  knows which RTTI classes are actually available. Currently, this requires to load in the shared library which may cause the loading of other
  shared libraries. (domino effect) Due to the increasing number of loose PixelLight plugins, the program start time starts to get annoying long
  - especially in debug mode. My plan was to focus on the script implementation, but I'am not able to try out and debug stuff in reasonable time
  because each program start takes several seconds, even if there's actually not happening much in an application. Of course, it would be possible
  to just "deactivate" plugins, but such hacking around would cost time as well and would be error prone. So, it's probably time to add another
  RTTI initialization speed up optimization: Delayed shared library loading
  This was actually planned for several years, but there were always more important things to do - like getting the RTTI to the point were it's
  really cool and powerful. Stefan accomplished that. The "new" RTTI system is now several months in use and works really well, so, it's now probably
  really time to implement this delayed shared library loading thingy to speed up the program start when there are a lot of optional loose plugins
  available. (which is now the case)
  The delayed shared library loading should be transparent to the user, meaning that it should happen automatically on the fly so that the user don't
  need to care about it. So, as the first refactoring step I applied the bridge design pattern to "Class" and moved the previous implementation
  into the implementor "ClassReal". The RTTI system still creates automatically class instances, but they are now derived from "ClassReal" instead
  of "Class" which is now just a class implementation wrapper. Looks like everything is still working as before. This change makes it possible to
  secretly change the internal class implementation... the next step is to add class metadata into the "plugin" file and when loading a plugin,
  this metadata is used to create dummy class instances without actually loading the shared libraries the RTTI classes are implemented in. The real
  RTTI class instance is only created by loading in the shared library when really required, e.g. when an instance of the RTTI class has to be created.
  In this case, the internal class implementation is changed - but the "Class" instance the user is working with will be still the same. This should
  speed up the program start.
- Added "pl_module_delayed()"-macro and the plugin file option "Delayed" which is "true" by default
- Renamed "ClassManager::LoadPluginLibrary()" into "ClassManager::LoadModule()" and made it public
- Add RTTI class metadata within the XML plugin file
- Wow, already done! Delayed shared library loading is working! The startup time of e.g. "01Application" is now better.
  (it's of course only faster when not all available plugins are used)
-> I'll do some more testing before I upload this change (although the next two days I'am quite busy with university, again :/)



>> 24.05.2011
[CO]
- The "DynLib" implementations were not unloading the dynamic OS library automatically. I thought about this issue to figure out whether
  it's acutally a "feature", but this really looks like an adverse behaviour because e.g. something like "File" is closing the opened file
  automatically.
PLCore:
- "ClassManager": Moved plugin file format version 1 loading code from "LoadPlugin()" into a separate method "LoadPluginV1()"
- "ClassManager": Moved plugin library loading code from "LoadPluginV1()" into a separate method "LoadPluginLibrary()"
- "ClassManager": There was a memory leak during plugin library loading: The ownership of the created instance of the dynamic
  library was given to the created "Module" instance, but "Module" never destroyed the given instance of the dynamic library.
- "ClassManager": No one was destroying the module instances, so this is now done within the "ClassManager"-destructor
- Made the "Module" constructor and destructor private because only the class manager is responsible for managing the modules
- The "Module" destructor was virtual, but there's no reason for that



>> 22.05.2011
[CO]
PLCore:
- PLScript: Woho, the demo "Scripts.scene" comes to live... "ScriptsScene.lua" is already up and running and is manipulating a scene
  node by using a Lua script. It's still everything experimental to see what's possible and how it may work as a whole
  system.
- Added PLScriptBindings plugin which exposes certain parts of PixelLight to script languages. This means that the script bindings
  are a 100% loose plugin and are not within the core. First I thought about adding some basic script bindings directly into PLScript and
  other script bindings into the PLEngine project which brings together the individual components to an easy usable framework. But
  this way the standard PixelLight script bindings would be scattered over multiple projects and there would also be the risk that the
  completly optional script support may accidentally grow into the core over the time. This way, it will probably also easier for other
  people to contribute to the script bindings part.



>> 21.05.2011
[CO]
PLCore:
- "TypeObjectPtr" & "TypePtr" & "TypeRef": "ConvertFromVar()" is now using "GetUIntPtr()" instead of "GetInt()" (this was a [TODO] point)
- PLScript: Worked on "PLCore::Object*" support



>> 19.05.2011
[CO]
PLCore:
- DynEvent: Added "void Emit(const PLGeneral::String &sParams)" and "void Emit(const PLGeneral::XmlElement &cElement)" to make it possible to emit
  events when one just has a DynEvent pointer
- Added "GetNumOfParameters()" and "GetParameterTypeID()" to "DynEvent" to make it possible to request some more information about the dynamic function
- Warning, breaking event change: I had to change "void Emit(_T0 t0, _T1 t1)" into "void operator ()(_T0 t0, _T1 t1)" etc. because when not doing so, the compiler
  failed to see the difference between e.g. "Emit(String)" and "Emit(String)", ok, maybe there isn't one. This issue has to do with the
  "void Emit(const PLGeneral::String &sParams)" change above - but those non typed call methods are really required. I don't wanted to rename those methods
  into e.g. "void EmitString(const PLGeneral::String &sParams)" because it felt unnatural to me and by the way, "DynEvent" is quite similar to "DynFunc" -
  at least within the usage. Whenever possible I try to avoid such breaking changes, but sometimes they are required to avoid that stuff gets uggly.
  So, to call e.g. an event named "MyEvent" call "MyEvent()" (if you have ever used boost, you are already familiar with this way :) instead of "MyEvent.Emit()".
- PLScriptLua: Calling RTTI object methods within Lua scripts is working... currently only slow progress because the university is using most of my available
  time. But I still try to get the script support up and running until the next scheduled PixelLight release. :D
- PLScriptLua: Calling RTTI object signals within Lua scripts is working



>> 17.05.2011
[CO]
PLCore:
- PLScript: Added "Script::PushArgument(PLCore::Object *pObject)" and an experimental Lua implementation to get an idea how to access RTTI objects
  directly within scripts *work in progress*



>> 16.05.2011
[CO]
- Removed "long" methods within the "String" and "Tokenizer" classes to avoid compiler issues with 64 bit data types
  (a compiler may actually define a 64 bit data type as long, and then there's no way to distinguish long from long *g*)



>> 13.05.2011
[CO]
- "String": Added "int64"-support
PLCore:
- "PLCoreDefinitions.h": Added "TypeInvalid"
- PLScript: "Script:" Added support for global variables. At first I thought about adding "GetGlobalVariable()" & "SetGlobalVariable()" versions
  for the supported primitive data types - but this would result in a total copy'n'past overkill within the internal implementations. Those
  string methods should do the job (the internal implementations try to don't change the script variable type).
- PLScript: Renamed "Script::AddDynamicFunction()" into "Script::AddGlobalFunction()" and "Script::RemoveAllDynamicFunctions()" into "Script::RemoveAllGlobalFunctions()"



>> 12.05.2011
[CO]
PLCore:
- Added "GetNumOfParameters()" and "GetParameterTypeID()" to "DynFunc" to make it possible to request some more information about the dynamic function
- Added "PLScriptLua::Script::LuaStackDump()" which writes the current Lua stack content into the log



>> 11.05.2011
[CO]
PLCore:
- PLScript: The "ScriptManager" creates now instances of all found "ScriptBinding" classes
- PLScript: Added "Script::AddBindings()" to bind all available "ScriptBinding" instances at once
- PLScript: By default, "ScriptManager::Create()" and "ScriptManager::CreateFromFile()" binds all available "ScriptBinding" instances at once



>> 08.05.2011
[CO]
- A while ago, Stephan reported me an issue with double slashes within filenames - finally I found some time to have a look into it.
  Something like "PLGeneral::File("e:\\1//Test.jpg").Exists()" failes. Because I wasn't sure whether or not this behaviour is "correct"
  (the filename looks kinda messy) I first tested the same with boost by writing "boost::filesystem::exists("e:\\1//Test.jpg")" and with
  Qt by writing "QFile("e:\\1//Test.jpg").exists()" and "QUrl("e:\\1//Test.jpg").isValid()". For boost and Qt a filename like
  "e:\\1//Test.jpg" is totally fine.  	
  Next I tried to find a description which behaviour is "correct". As usual, found first information at Wikipedia:
    "http://en.wikipedia.org/wiki/URL_normalization" (from 2011-05-08)
      "Removing duplicate slashes Paths which include two adjacent slashes should be converted to one. Example:
       http://www.example.com/foo//bar.html  http://www.example.com/foo/bar.html "
  I wasn't able to find this in standards like RFC 3986 (http://tools.ietf.org/html/rfc3986#section-6) - but I was searching only a few
  minutes. After this research I "assume" that removing duplicate slashes is fine, at least this way there's within PixelLight the same
  behaviour as in boost or Qt.
  -> Made a minor change within the "Url::SetValue()" implementation.
PLCore:
- PLScript: The AngelScript add on source codes are now within "External\Optional\AngelScript\add_on" directory instead within the to download external package.
  CMake told me that it wasn't able to find those add on source codes... because it was checking BEFORE downloading and extracting the external package. Maybe
  it's possible to change the CMake script... but that's somewhat too dangerous for me and usually really time consuming to get it right.



>> 07.05.2011
[CO]
PLCore:
- Implemented "PLScriptPython::Script::AddDynamicFunction()" namespace by using Python dictionaries... probably not the best solution but for
  now I just want to have it up and running to get an idea of concepts multiple scripting languages are sharing. Maybe I'll replace "namespace"
  later by "module".
- Implemented "PLScriptV8::Script::AddDynamicFunction()" namespace by using V8 object template
- Implemented "PLScriptAngelScript::Script::AddDynamicFunction()" namespace. It looks like that AngelScript (2.20.2) has currently no support
  for namespaces... so right now I'am doing an ugly hack: e.g. "PL.Timing.GetTimeDifference()" is written within scripts as "PL_Timing_GetTimeDifference()". :/
-> Ok, the namespace support for global functions is now implemented within all script backends... although I'am really not happy with the current
   AngelScript solution (e.g. "PL_Timing_GetTimeDifference()" instead of "PL.Timing.GetTimeDifference()") and Python solution
   e.g. "PL[Timing][GetTimeDifference]()" instead of "PL.Timing.GetTimeDifference()"). It's really time consuming to do the research into multiple script
   API's at the same time and on those two issues I already spend several hours without a decent solution. So, if there's someone who knows a better solution...
-> Right now my candidates for the "recommended PixelLight script language" are JavaScript and Lua. Lua is quite compact while JavaScript is a web-standard which
   could be somewhat beneficial for PixelLight, especially regarding to the browser plugin. AngelScript looks somethat unfinished although I like the API in
   general. Python is just a monster. *g*
- PLScript: "Script": Added string versions of "PushArgument()" and "GetReturn()". Adding support for this within PLScriptAngelScript was some hard work because unlike
  JavaScript (V8), Python and Lua, within AngelScript strings are just "add_on" and not everything is documented as detailed as I wished for and I wasn't able
  to find real help via google as well. So I had to guess, review the AngelScript source codes and perform some debugging... I really hope that I didn't miss
  anything...



>> 06.05.2011
[CO]
PLCore:
- PLScript: Added "ScriptBinding" which is actually a blank RTTI class. RTTI classes which are only used for "script binding" should be
  derived from this class. This doesn't mean that it will be impossible to bind any other RTTI class instance to a script - but usually
  it's useful to have such an abstract base class...
- PLScript: "Script::AddDynamicFunction()": Added namespace as last optional parameter (backend implementations will follow)
- PLScript: Added "Script::AddBinding()" which adds a script binding to connect the given RTTI class instance with this script (currently only RTTI
  methods are used)
- Implemented "PLScriptLua::Script::AddDynamicFunction()" namespace by using Lua tables



>> 02.05.2011
[CO]
PLCore:
- "DynFunc": Added "GetReturnTypeID()" to make it possible to figure out the return type (e.g. "TypeNull" for "void()" or "TypeInt" for "int()")
  of a dynamic function
- Python backend: Implemented "AddDynamicFunction()" and "RemoveAllDynamicFunctions()"
- V8 (JavaScript) backend: Implemented "AddDynamicFunction()" and "RemoveAllDynamicFunctions()"
-> The Lua, Python, AngelScript and JavaScript backends are now equal in the implemented behaviour. It's possible to call script functions
   from the C++ side, and it's also possible to call C++ functions from the script side. I'am quite sure that this isn't everything one
   requires when working with script engines, but it's a start. I have to take a break for a couple of days due to university stuff, then
   I continue working on PLScript.



>> 01.05.2011
[CO]
PLCore:
- AngelScript backend: Implemented "AddDynamicFunction()" and "RemoveAllDynamicFunctions()"
- Python backend: Calling Python functions is working



>> 30.04.2011
[CO]
- "String": Added pointer constructor "String(void *pValue)"
PLCore:
- "Functor"-Templates: Added "Clone()"-Implementation
- "DynFunc": Added protected copy constructor and copy operator to avoid misuse, made the default constructor protected as well to avoid confusion
- "DynFunc": Added "PLGeneral::String" and "PLGeneral::XmlElement" parameter versions of "CallWithReturn()". When using
  "DynFunc::Call(const PLGeneral::String &sParams)" or "DynFunc::Call(const PLGeneral::XmlElement &sParams)" there's absolutely no chance to get any
  function return values because there's no type information. Currently I'am using "DynFunc::Call(const PLGeneral::String &sParams)" within the work
  in progress PLScript to let a script call a given C++ function/method and really need at least a string representation of the result which I can give
  back to the script API. I really hope that those "CallWithReturn()" template methods don't backfire... right now it appears that there are no side
  effects during template instantiation. I could have added the string return directly into the already existing methods, but I wasn't comfortable
  with that.
- PLScript: Added script support for functors/functoids so that it's possible to call C++ functions or member methods from inside scripts...
  as well as other script functions because the functors are hiding this detail.
  The method "Script::AddDynamicFunction()" is used to register functors while "Script::RemoveAllDynamicFunctions()" can be used to remove
  all registerd functors. The Lua implementation is already working. Please note that this is still highly experimental and I don't know
  whether or not the script interfaces are completly changed later.



>> 29.04.2011
[CO]
- Added "File::GetContentAsString()"
PLCore:
- Moved "OpenFile()" from "Loader" into "LoadableManager" because it's kind of universal
- Moved "LoadStringFromFile()" from "PLRenderer::EffectPass" into "LoadableManager" because it's kind of universal
- "SignatureString": "PLGeneral::String GetSignatureID()" constructed internally the signature string on every call. But during runtime, this
  must only be done once and then the signature can just be reused. So, the internal signature string is now static to enhance performance. I
  double-checked the change, used the debugger a few times on it to see and think through the performed steps and tested the existing PixelLight
  projects as well. It looks like that this change has no side effects.
- PLScript: Added "GetScriptLanguage()", "GetSourceCode()" and "SetSourceCode()" to "Script" (similar to "PLRenderer::Shader")
- PLScript: Added "FuncScriptPtr" which is a version of "PLCore::FuncFunPtr"/"PLCore::FuncMemPtr" for script functions. This means that script functions
  can be called in the same way as all other functions/methods (e.g. RTTI methods) can be called. This template is using
  the "Script" methods "BeginCall()", "PushArgument()", "EndCall()" and "GetReturn()" to call script functions. Calling Lua and AngelScript
  functions is already implemented and working. Those mentioned script function calling methods are currently public although it's not recommended
  to call them without using "FuncScriptPtr", but currently I see no change to hide those methods from the user. But this is just my first attempt to
  get things up and running... next stop: Implementing the same for Python and JavaScript. (calling C/C++ methods from scripts will follow as well)
- PLScript: Calling JavaScript functions is working... although the implementation is currently somewhat poor... having some issues getting into the V8-API...



>> 28.04.2011
[CO]
- "FileWindows::GetSize()" is now using the MS Windows API functions "_filelength" and "_fileno"
PLCore:
- PLScript: As requested within the PixelLight forum at: http://dev.pixellight.org/forum/viewtopic.php?f=3&t=45
  ... I'll also added a script backend for AngelScript (like the others, just a skeleton right now!). Ok, four script languages should really
  be enough to get a good script interface.



>> 26.04.2011
[CO]
PLCore:
- PLScript: Compiled 32 bit versions of Lua, Python and V8 (JavaScript engine) for Windows and Linux. Configurated everything so that the script
  projects can be compiled and are able to run.
  Next stop: Concrete script implementations :D



>> 25.04.2011
[CO]
PLCore:
- Started the PLScript project. As usual there's a null backend and I'll implement backends for Lua, JavaScript and Python in parallel.



>> 19.04.2011
[CO]
- Removed "_DEBUG" preprocessor tests within the String and String Buffer class



>> 15.04.2011
[CO]
- Premier: First entry within the tracker ("Bugs"-category) at http://sourceforge.net/tracker/?group_id=507544
  -> Bugfix (ID: 3286541): "PLGeneral::XmlElement::GetLastAttribute()" was returning the first instead of the last attribute



>> 10.04.2011
[CO]
PLCore:
- "ConsoleApplication::OnInitData()" is now using English as the default language instead of the current system locale, this makes things more predictable



>> 08.04.2011
[CO]
PLCore:
- Added "ResourceManager::EventResourceRemoved"-event which is called when a resource is going to be removed



>> 09.03.2011
[CO]
- Url-class: Nearly over a year ago, a client reported that a client reported (jap :) that UNC (Uniform Naming Convention aka Universal
  Naming Convention) support was not working. At this time, I never had heard of UNC before and there was not really time to look into it
  in more detail - so, a hack on the client side had to do the job. Today, why ever, I was really curious what's the issue with UNC.
  After looking what exactly UNC is all about (I usually don't have to do anything with network related stuff), I made some experiments
  (also with "QUrl" from Qt) and figured out, that the only problem seemed to be within the "Url::SetValue()"-method while parsing the
  given URL. After spending some hours to get into regular expressions again and looking for pitfalls that may occur, I added UNC parsing
  support to the Url-class. Now, the following works for me
    System::GetInstance()->SetCurrentDir("\\\\COFENBERG-PC\\Users\\COfenberg\\UNC_Test");
  As well as
    File cFile("\\\\COFENBERG-PC\\Users\\COfenberg\\UNC_Test\\Test.txt");
    if (cFile.Open(File::FileRead|File::FileText)) {
        String sText = cFile.GetS();	// -> sText = "Hello" :D
    }
  I don't know whether or not my change within "Url::SetValue()" is perfect... in general, I wanted to keep the required implementation change 
  as compact as possible.



>> 02.03.2011
[CO]
- As noticed by a PixelLight user, the data type returned by "System::GetMicroseconds()" was "uint32" which is critical for the stored data
  and "unsigned long" is commonly used instead. So, methods like "System::GetMicroseconds()" are now using "uint64" instead of "uint32".
  It's really cool to get feedback on how to improve PixelLight, keep up providing feedback! :D



>> 26.02.2011
[CO]
- StringBufferASCII is now using "memcpy" instead of "strncpy" because "memcpy" is usually slightly faster as "strncpy"
  (checked usual implementations of those functions). Within this class, it's guaranteed that the values are correct, so there's no security
  risk in using "memcpy". I know, the difference is not really measurable, but I always try to squish out everything possible out of such
  basic implementations.
- StringBufferUnicode is now using "memcpy" instead of "wcsncpy"
- Added some more String constructors to make it easier and "more intiutive" to create a string out of a number
- Had a look into "sprintf" (a variation is used within "String::Format()") and "itoa" (non-standard extension to the standard C). In certain
  situations, "sprintf" has no chance to come near to the performance of "itoa" - which is obvious because "sprintf" is more universal and powerful.
  The following example took 880 ms
    for (int i=0; i<100000; i++)
        String sMyString = String::Format("The number %d is fantastic!", 42);
  while the following example took 129 ms
    for (int i=0; i<100000; i++)
        String sMyString = String("The number ") + 42 + " is fantastic!";
  after using "itoa" in the internal String implementation. I think there's a notable performance difference in the second version which is worth to
  talk about. :D



>> 25.02.2011
[CO]
PLCore:
- "ConsoleApplication": Moved "Write some general information into the log"-step from "OnInit()" to "OnInitLog()". It was a little bit
  confusing that initial information like "Log-system started" was written somewhere at the end of the initialization phase.



>> 22.02.2011
[CO]
PLCore:
- "ConsoleApplication::OnInitPlugins()": The PixelLight runtime directory is now also scanned non-recursively for plugins. This is quite useful
  for projects which can be used completely dynamically, but can also be used in other C++ projects to access certain features. This behaviour is
  also symmetric to the application directory scan.



>> 17.02.2011
[CO]
- Program entry point within "Main.h": Removed "setlocale(LC_ALL, "");" because I don't think that it's a good idea to use "setlocale".
  This is up to the user and the user is also responsible for the consequences when changing the current locale...
- String internals: Sadly, the current set locale is of course also an issue on all operation systems. It would be fantastic if we never
  ever would come into contact with "setlocale" at all, but sadly, the user can and possibly WILL change the current set locale and then
  hell breaks lose because e.g. "42.21" will be written as "42,21" and possibility written e.g. into a XML file... on another side "42,21"
  is read from the same XML file and boom, invalid floating point number due to the use of another locale. To be honest, I really hate this
  topic but sadly, I can't just completely ignore it forever.
  Today I was remembered, again, why we decided to wrap EVERYTHING within PixelLight so more complex projects can use a consistent framework...
  Just an example: MSVC has some cool string functions like "_sprintf_l", on Linux there are some similar functions allowing you to directly
  provide the locale to use as a parameter (other systems like Android OS, don't offer such stuff, of course!), instead of using an ugly global
  setting. But sadly, there's no standard for that. So I backup the current set locale by using "strdup" before changing it (evil dynamic memory
  management, but currently I see no other simple solution)... but wait, now VC tells me the following:
    "warning C4996: 'strdup': The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strdup. See online help for details."
  Cool, the VC compiler tells me "Do NOT use POSIX, it's evil!". Because I don't like dozens of "#ifdefs" either, I just
  suppressed this stupid warning. Low level C/C++, one just must love it! *gruml*
  Sadly I'am afraid that the locale changes from today are no real solution, and something like a locale class is required... but for now, I
  just have enough of this topic...



>> 01.01.2011
[CO]
- Renamed the method "Mutex::Lock()" with a timeout as parameter into "Mutex::TryLock()" so one can see that it's really wise to
  check whether or not a lock was actually received
- Added "PLGeneral::MutexGuard" helper class using the really cool "Scoped Locking"-idiom which can make the code more compact while
  also increasing the maintainability
- Renamed the method "Semaphore::Lock()" with a timeout as parameter into "Semaphore::TryLock()" so one can see that it's really wise to
  check whether or not a lock was actually received...



>> 29.12.2010
[CO]
- Removed "String::Unknown"-definition, it was only used once internally and less variations are usually the better choice
- Removed "String::UTF8"-definition
- Removed "utf8" data type
- "String": Refactoring of the UTF8 support, in fact reduced the support to the two methods "GetUTF8()" and "SetUTF8()"
- "QtStringAdapter" is now using UTF8 instead of wchar_t to avoid the need to recompile Qt or PixelLight with other compiler settings



>> 18.12.2010
[CO]
- "PLGeneralWindows.h": If "_MSC_VER" (VisualStudio) or "_WCHAR_T_DEFINED" is not defined, "wctype.h" will be included for
  "wchar_t". Now PLGeneral can be used within for example QtCreator at once.
- Added a static adapter class within PLGeneral for mapping Qt strings to PixelLight strings and vice versa



>> 17.12.2010
[CO]
- Added unicode support to "FileLinux", "FileSearchLinux", "ConsoleLinux", "DynLibLinux", "SystemLinux", "FileStdStream", "Log",
  "ConsoleWindows" and "Process"



>> 12.12.2010
[CO]
PLCore:
- Loadable-System: At the PixelLight mailing list (pixellight@lists.pixellight.org), a discussion about case-sensitive file-extensions
  came up. In general, while for instance UNIX like systems have case-sensitive file systems, MS Windows does not. At the
  beginning of the development of PixelLight, we made the design decision that PixelLight should be case-sensitive in general
  to avoid porting problems across multiple-platforms. Naturally, for MS Windows only users, this leads to confusion when
  they try to load in, for example an image named "MyImage.JPG", and nothing happens although the jpg file format is supported.
  The reason behind this is, that the file extension is used to figure out which loadable implementation is responsible for
  loading the concrete data. In this case, "jpg" tells the (plugin based) system to use "PLGraphics::ImageLoaderJPG" to load
  in the data. The extension string test is case-sensitive, and as such, "JPG" is unknown to the system.
  Ideas came up to add an option to make the extension case handling configurable, or to make file extensions in general case-insensitive.
  I did some research on the topic to see how other developers handle this situation or think about this - as expected, there are a lot
  of different opinions about "what's best".
  I thought about the issue, and I see the point that this can be a problem using a lot of content - to be honest, from time to time
  I have some "problems" with this as well. For example, "The Compressonator" (http://ati.amd.com/developer/compressonator.html) from ATI (ok,
  AMD nowadays *g*) always wants to write "DDS" instead of "dds" as file extension.
  In my opinion, I still think that it's no good idea to weaken the "PixelLight is in general case-sensitive" design decision and adding a huge
  comment that this is the one and only place within PixelLight were it's handled by using strategy A instead of strategy B. I really think that, on
  the long term, this will cause more problems than solving them.
  Fortunately, the loadable system already supports multiple aliases for one and the same file format. For example "PLGraphics::ImageLoaderJPG"
  can be addressed by using "jpg", "jpeg", "jpe", "jif", "jfif" or "jfi" as jpg file extension. So, why not add "JPG", "JPEG", "JPE", "JIF", "JFIF"
  and "JFI" as well? Of course, something like "JpG" will still not be recognized, but I can't remember a program using this case convention... and
  as a computer scientist, I love orderliness and don't really want to support spelling chaos intentionally. I saw that some other developers are
  using this solution as well, and I think it's a good compromise - it doesn't weaken a general system design decision by adding an exception, but
  it allows to use for example "JPG" instead of just "jpg", too.




/*********************************************************\
 *  The entries below are in German only
\*********************************************************/



>> 06.12.2010
[CO]
PLCore:
- DynEvent um "GetNumOfConnects()"-Methode erweitert, bei z.B. Profiling ist es hin und wieder interessant zu
  erfahren wie viele Connections gerade vorhanden sind



>> 04.12.2010
[CO]
- Beim 端ber die Codes "schweifen" (hin und wieder passiert mir soetwas unbeabsichtigt *g*) vielen mir in der String Klasse ein
  paar Stellen wie z.B. "if (pszFormat && strlen(pszFormat))" auf. Sinn ist hier eigentlich nur rauszufinden ob direkt das erste
  Zeichen im String eine terminierende Null ist - die String l辰nge braucht man hier gar nicht. nderte diese Stellen daher in
  "if (pszFormat && pszFormat[0] != '\0')" - spart einen Funktionsaufruf und 辰ndert die komplexit辰t hier von n zu 1 da nicht mehr
  im String nach '\0' gesucht werden muss. Interessant das mir das noch nicht vorher ins Auge gestochen ist. *g*



>> 29.11.2010
[CO]
- "Stopwatch::Stop()"-Bugfix: Wenn die Stopuhr gerade nicht l辰uft, und man "Stop()" aufruft sollte nat端rlich "0" als gemessene
  Zeit zur端ckgegeben werden...
-> Die im Tagebucheintrag vom "30.10.2010" angesprochenen String Optimierungen angepackt...
- StringBuffer: "Append()" hinzugef端gt, wenn immer m旦glich wird in der String-Implementation nun "Append()" verwendet da dessen
  Implementation einfacher gehalten ist (wodurch Optimierungen und bessere Performance leichter zu realisieren sind)
- StringBuffer um "m_nMaxLength"-Variable erweitert, damit ist es nun m旦glich, dass ein String Buffer intern gr旦er ist als der
  tats辰chlich gespeicherte String. Hintergrund ist, das Speichermanagement teuer ist und derzeit die String Klasse f端r ein paar
  Dinge performancem辰ig leider unbrauchbar ist. Da wir meist nur ASCII nutzen, konzentriere ich mich erstmal auf Optimierungen
  f端r ASCII Strings - aufgrund des Umfangs der String Klasse, wird es sicherlich nen bischn dauern bis alles etwas flotter geht.
  Oft werden mehrere Strings konkateniert, hier zeigte die String Klasse performance m辰ig deutliche schw辰chen. Sinnfreies aber
  einfaches Beispiel:
    String sString;
    for (int i=0; i<100000; i++)
      sString += 'a';
  Vor dem Beginn der Performance optimierungen dauerte das im Release Modus unglaubliche 2995 ms. Nach dem einbauen von "Append()"
  noch 2757 ms, und sobald bei "Append()" intern Speicher f端r zuk端nfige Zeichen reserviert und dann genutzt wurde nur noch
  47 ms. Das zeigt denke ich, dass es Sinnvoll ist diese Optimierung weiterzuverfolgen da es doch schon ein deutlicher Unterschied ist -
  gerade bei groen Datenmengen! (der Code wird dadurch aber leider nicht einfacher oder gar weniger :/)
- StringBufferManager hinzugef端gt. Zuk端nftig sollten StringBuffer-Instanzen nur noch hier端ber erfragt, und sobald nicht mehr ben旦tigt
  hierhin zur端ckgegeben werden. Sobald man einen StringBuffer ben旦tigt, fragt man einfach den StringBufferManager nach einer StringBuffer
  Instanz die eine bestimmte String l辰nge halten kann... es obliegt dann dem StringBufferManager zu entscheiden ob man einen Buffer
  mit GENAU der l辰nge zur端ckbekommt, oder einen Buffer der *mehr* halten kann. Es ist ebenfalls dem StringBufferManager 端berlassen ob
  er gerade nicht ben旦tigte StringBuffer Instanzen buffert statt sofort zu l旦schen, um dann diese wiederverwenden zu k旦nnen um dynamisches
  Speicher anlegen/freigeben zu reduzieren. Durch den StringBufferManager wurde hier und da die Implementation der String Klasse etwas einfacher. :D
  Die StringBuffer-Klasse hat eine statische Instanz von StringBufferManager und StringBufferManager speichert gerade nicht ben旦tigte
  StringBuffer Instanzen zwischen - das ist momentan eher noch Experimentiell und sicherlich definitiv nicht optimal (u.a. weil die statische initialisierungs
  und deinitialisierungs Reihenfolge ja nicht festgelegt werden kann), l辰uft aber bereits halbwechs ordentlich und reduziert das dynamische anlegen
  und freigeben von Speicher zur Laufzeit.
-> Uff, das waren nun fast 14 Stunden am St端ck mit Strings jonglieren, aber ich denke es ist schonmal besser als vorher, vorallem wurde die Implementation
   an einigen Stellen deutlich 端berschauberer. Das mit Strings intern mehr Speicher geben + StringBufferManager wollte ich nun schon seit Jahren mal
   ausprobieren... und da mir wiedermal aufviel wie laaaam die String Klasse stellenweise ist/war, hatte ich mich nun endlich einfach mal drangesetzt und
   es durchgezogen. Ich merke hier bei mir nun eine allgemeine leichte Performance verbesserung... wie gehofft. :D
   Morgen mal noch etwas weitertesten, aber bisher siehts so aus als ob sich durch das interne String-Refactoring (das Interface nach Auen hin hat sich
   nicht ver辰ndert!) keine total 端blen Bugs eingeschlichen h辰tten die sofort alles zum Crashen bringen.



>> 14.11.2010
[SB]
- String::Format(): Hier gab es einen Bug, da nicht darauf geachtet wurde, dass laut Dokumentation die Funktion
  _vscprintf (und alle anderen Funktionen dieser Art) das Handle f端r die Argumentenliste "zerst旦rt". Daher muss
  nach dem Aufruf von _vscprintf die Argumentenliste beendet und dann wieder neu ge旦ffnet werden. Unter 32 Bit Linux
  sowie unter Windows gab es hier niemals irgendwelche Probleme, aber unter 64 Bit Linux st端rzte das ganze hier auf
  mysteri旦se Art und Weise ab. W辰re schon nett, wenn solche Dinge dann vielleicht nicht nur irgendwo in der Doku versteckt
  w辰ren, sondern auch verl辰sslich abst端rzen w端rden, damit sowas nicht v旦llig unentdeckt bleiben kann ;-)
  Zu diesem Fehler: http://bytes.com/topic/c/answers/572931-segmentation-fault-vsnprintf-lib64-tls-libc-so-6-a



>> 04.11.2010
[SB]
- XmlAttribute: Die Funktion sscanf_s ist eine Microsoft-Erweiterung und daher
  unter anderen Systemen nicht vorhanden. Habe das daher erstmal in sscanf()
  umgewandelt, vielleicht k旦nnte man hier nat端rlich auch eine von unseren
  bereits vorhandenen Varianten verwenden, um Strings in Zahlen zu konvertieren?
  Die String-Klasse hat soetwas ja schon, alleine schon daher w端rde ich daher
  empfehlen, in Zukunft m旦glichst auf low-level String-Funktionen zu verzichten.



>> 30.10.2010
[CO]
- Wie mit Stefan besprochen: TinyXML Abh辰ngigkeit entfernt. Das hatten wir nun bereits seit etlichen Jahren angedacht... TinyXML ist zwar
  wirklich super, aber unsere eigenen Anspr端che ver辰ndern sich 端ber die Zeit so das immer mehr nderungen in TinyXML n旦tig wurden um es in
  PL noch richtig nutzen zu k旦nnen. Die XML Wrapper Schicht an sich war auch noch nie sooo toll da diese Overhead hinzuf端gte. Nachdem Stefan
  nun probleme beim Einladen groer XML Dateien hatte, entschlossen wir uns dazu, die TinyXML Abh辰ngigkeit nun zu entfernen um mehr Kontrolle
  端ber die XML Implementation zu haben und z.B. einfacher Problemen nachgehen zu k旦nnen. Der Kern des XML Parsers basiert auf TinyXML damit ich
  nicht ganz bei 0 anfangen musste und auf einen 端ber viele Jahre hinweg ausgereiften XML Parser aufbauen kann, ich denke das die Implementation
  auf Dauer allerdings immer weiter von TinyXML abdriften wird.
  Das war nun zwar ca. 2 Tage Arbeiten an Grundlagen-Klassen, aber ich denke es hat sich gelohnt da unsere grundliegenste Komponente nun von
  einer externen lib weniger Abh辰ngt was das Cross-Compiling etwas einfacher macht. Die erzeugte PLGeneral dll ist bei mir um 10 KB kleiner geworden
  da weniger Redundanter Code vorhanden ist (mehrere String Klassen etc. da jede lib das nochmal selbst implementiert).
  -> Weis noch nicht ob Unicode XML Dateien schon korrekt funktionieren, da m端sste man etwas testen und gegebenenfalls ausbessern
  -> Das XML Laden (XmlDocument::Load) ist im Augenblick etwas langsamer als vorher da unsere String Klasse bei z.B. "sMyString +=" immer einen internen
     neuen String erzeugt... hier sollte man wohl demn辰chst kleinere Optimierungen machen so das der interne String immer etwas mehr Speicher belegt
     als eigentlich n旦tig ist, was dann aber ein performanteres anh辰ngen von weiteren Zeichen oder kurzen Strings erm旦glicht.
  -> Am XML Interface hat sich zwar nicht wirklich was groartig ver辰ndert, unter der Haupe gabs allerdings einiges an nderungen... darum w辰re es gut
     wenn jemand das nochmal kritisch durchgeht (auch z.B. die Copy-Operatoren) und testet.



>> 24.10.2010
[SB]
- Time: Wenn man Zeiten als String abspeichert, m旦chte man diese manchmal auch gerne wieder einlesen. Da das Format
  hier ja sehr strikt ist, d端rfte dies auch ohne weiteres m旦glich sein, daher habe ich FromString() so implementiert,
  dass es die von ToString() ausgegebenen Time-Strings parsen kann und somit Zeiten auch als Strings 端bergeben
  werden k旦nnen.



>> 11.10.2010
[CO]
- String: < und > Operatoren f端r ASCII waren fehlerhaft Implementiert. StringBuffer::IsLessThan() und StringBuffer::IsGreaterThan()
  wurden, warum auch immer, mit einer String l辰nge von 0 aufgerufen... interessant das dies bisher noch nicht aufgefallen war, und das
  obwohl die String-Tests die umfangreichsten aller Tests sind. :/ (ok, die ASCII, UTF8 und Unicode kombinationsm旦glichkeiten machen
  es nicht einfacher das m旦glichst Wasserdicht zu testen)



>> 20.09.2010
[SB]
- HttpServer: Methoden zum Senden von Daten nach HttpServerConnection verschoben, wo sie auch hingeh旦ren.
  Eine Server-Klasse sollten eigentlich nur Connections verwalten, die eigentliche Kommunikation
  zwischen zwei Hosts passiert aber immer in einer Connection, daher sollte die Funktionalit辰t dieser
  Kommunikation auch dort definiert werden. Dies macht auch die Verwendung und den Zugriff auf eine Connection
  einfacher, ansonsten gibt es immer Probleme mit der Sichtbarkeit und der Vererbung von der Server-Klasse.



>> 16.09.2010
[CO]
- "PLGeneralWindows.h" um MinGW Support erweitert



>> 22.08.2010
[CO]
- Huch, die "FileWindows::CopyTo"-Implementation war fehlerhaft, die Windows Funktion "CopyFile" erwartet als zweiten Parameter,
  die Ziel URL inklusive Dateiname, 端bergeben wurde allerdings URL ohne Dateiname...
- "FileLinux::CopyTo" war noch nicht implementiert... selbst nach l辰ngeren Suchen konnte ich allerdings keine c-Funktion f端r Dateien
  kopieren finden, per Hand eine neue Datei erzeugen und dann die Daten selbst umkopieren war mir etwas zu doof...
  die jetztige Implementation 端ber "system" ist allerdings genauso doof :/ (aber wenigstens l辰ufts)



>> 16.08.2010
[SB]
PLCore:
- ConsoleApplication: Basispfad f端r Daten, die direkt im Runtime-Verzeichnis liegen, korrigiert.
  Das mit den Paketen ist ja sch旦n und gut, aber es ist super unpraktisch, damit zu arbeiten, wenn man z.B. gerade
  an den darin enthaltenen Daten selbst arbeiten will, da man dann st辰ndig alles entpacken und wieder packen m端sste.
  Darum sollte es zumindest die M旦glichkeit geben, die Daten aus einem Zip-File einfach an Ort und Stelle zu entpacken,
  und danach sollte noch alles so laufen wie mit dem Zip-File. Da aber die Zip-Files selber im Unterverzeichnis "Data"
  liegen, musste dieses nat端rlich noch dem Runtime-Pfad hinzugef端gt werden, damit das klappt.



>> 15.08.2010
[SB]
PLCore:
- Core: Unter Linux wird nun die Umgebungsvariable PL_RUNTIME ausgelesen.
  Wenn diese gesetzt ist, wird das darin enthaltene Verzeichnis als
  PixelLight-Runtime verwendet, ansonsten wird in /usr/ und /usr/local gesucht.
  Um dies m旦glichst einfach zu machen, gibt es ausserdem das Script profile,
  welches dieses Verzeichnis ausgehend vom aktuellen Verzeichnis setzt.
  Nat端rlich kann man auch in seiner .profile oder .bashrc-Datei im
  Homeverzeichnis diese Variable automatisch beim Systemstart setzen lassen,
  damit man dies nicht immer wieder per Hand ausf端hren muss.
  Somit ist es nun wieder m旦glich, einfach so aus den Sourcen heraus zu
  arbeiten, ohne immer mittels "make install" das SDK im System installieren
  zu m端ssen.



>> 12.08.2010
[SB]
PLCore:
- Core: Unter Linux wird nun erst geschaut, ob "/usr/local/share/pixellight/Runtime" existiert, wenn ja, wird dieses
  als Runtime-Directory verwendet, ansonsten wird angenommen, dass ein global installiertes Runtime im Pfad
  "/usr/share/pixellight/Runtime" zu finden ist. Bei mir hat das damit schonmal geklappt, dass die Plugins aus
  diesem lokalen Runtime verwendet wurden, die konnten dann aber nicht geladen werden, weil wohl die automatisch
  geladenen dynamischen Bibliotheken, welche sich entsprechend in /usr/local/lib/ befinden, nicht automatisch
  geladen werden konnten. Dies l辰sst sich aber durch ausf端hren des Befehls "ldconfig /usr/local/lib" beheben.
  Momentan besteht dann noch das Problem, dass jetzt die dynamischen Abh辰ngigkeiten wie Cg, Newton oder OpenAL
  nat端rlich nicht gefunden werden k旦nnen.



>> 07.08.2010
[SB]
PLCore:
- ConsoleApplication: OnDeInit() wird wie OnInit() nun auerhalb aufgerufen, damit es sicher als letztes aufgerufen wird.



>> 09.08.2010
[CO]
- "UTF8Tools::GetNumOfStringBytes" um "nCount" erweitert
- "StringBufferUTF8::LastIndexOf(const char szString[]..." war fehlerhaft implementiert, daher erstmal eine funktionierende
  L旦sung eingebaut, die allerdings sicherlich nicht die Effizienteste ist
- "StringBufferUTF8::GetSubstring" implementiert
-> Nun geht "Url(sFilename).GetExtension()" wenn "sFilename" ein UTF8-String ist
- "String::Compare" & "String::CompareNoCase" & "String::Insert" um UTF8 Support erweitert
- "FileWindows::Open(" um Unicode-Support erweitert
- UTF8Tools Warnungen beseitigt wo ich halbwechs sicher bin das die Beseitigung keine Seiteneffekte hat



>> 06.08.2010
[SB]
PLCore:
- ConsoleApplication: OnInit(), also die f端r die eigentliche Applikation bestimmte lokale Init-Methode, wird nun
  nicht mehr im Rahmen von Init() aufgerufen, sondern ist fest in der Run-Methode verdrahtet. Hintergrund ist,
  dass diese Methode als aller letztes aufgerufen werden muss, damit sie einen Sinn ergibt, alle Basisklassen
  m端ssen also die Chance haben, sich vorher komplett inizialisiert zu haben. Das w端rde aber heien, dass niemand
  einfach Init() von der Basisklasse aufrufen kann, sondern immer alles neu implementieren m端sste, damit die
  Reihenfolge stimmt. Darum musste OnInit() verschoben werden, damit dies nicht mehr n旦tig ist.



>> 05.08.2010
[CO]
PLCore:
- LoadableManager ist kein Loadable mehr, Kopie der alten Version liegt im Archive (Removed_LoadableFromLoadablaManager_05082010)



>> 05.08.2010
[SB]
PLCore:
- ConsoleApplication: LastCrashed und Speichern/Laden von LoadableManager-Pfaden entfernt.



>> 04.08.2010
[SB]
- System: GetDataDirName() hinzugef端gt. Diese Methode wandelt den 端bergebenen Namen f端r das Unterverzeichnis im
  User-Data-Dir in ein f端r das OS typisches Format um. Aus "PixelLight" wird dann unter Linux ".pixellight", unter
  Windows wird der Name nicht ver辰ndert und bleibt bei "PixelLight".
PLCore:
- ConsoleApplication: Behandlung von Log- und Config-Dateien implementiert. Die Schwierigkeit hierbei ist es,
  gleichzeitig ein vern端nftiges Standardverhalten zu implementieren, und es trotzdem dem Applikationsprogrammierer
  m旦glichst einfach zu machen, sp辰ter alles abzu辰ndern oder ganz auszuschalten, ohne dass er daf端r groe Teile
  komplett neu schreiben muss. Es gibt daher f端r das meiste jetzt Optionen in ConsoleApplication, die verwendet
  werden k旦nnen, um Standardeinstellungen abzu辰ndern:
  - MultiUser: Gibt an, ob Config und Log im User-Verzeichnis gespeichert werden sollen
  - AppDataSubdir: Gibt das Unterverzeichnis im DataDir an (wenn leergelassen, wird es in Run() auf der Applikationsnamen gesetzt)
  - LogName: Dateiname f端r Log (wenn leergelassen, wird Applikationsname mit '.log' verwendet)
  - ConfigName: Dateiname f端r Config (wenn leergelassen, wird Applikationsname mit '.cfg' verwendet)
  Hier端ber kann man also ziemlich einfach z.B. den Dateinamen von Log oder Config ab辰ndern, ohne gleich die
  gesamte Main-Methode neuschreiben zu m端ssen. Wenn z.B. LogName oder ConfigName auf "" gesetzt werden, heit das,
  dass diese Datei 端berhaupt nicht verwendet werden soll. Zus辰tzlich gibt es auch noch die Kommandozeilen-Optionen,
  die in jedem Fall vorrang haben (will jemand auch das nicht, sollte er die Option im Konstruktor entfernen).
- ConsoleApplication: Es wird nun alles bereits im Konstruktor gesetzt, damit es m旦glichst einfach wird, das Verhalten
  zu ver辰ndern, indem man einfach im Konstruktor alles so setzt, wie man das haben will. Der einzige dadurch notwendig
  gewordene Hack besteht darin, dass beim Sp辰teren Aufruf von SetName() auch noch automatisch die Dateinamen f端r Log
  und Config angepasst werden, falls diese so aussehen, als w辰ren sie noch auf ihren Default-Wert gesetzt.
- ConsoleApplication: Wenn die Konfigurationsdatei nicht geladen werden konnte, wird jetzt in einem zweiten Schritt
  dennoch der Dateiname gesetzt, damit eine neu erzeugte Config sp辰ter gespeichert werden kann. Hierbei wird es wieder
  erst mit dem User-Data-Dir versucht, dann mit dem Applikationsverzeichnis. Wenn der ConfigName auf "" steht, wird
  gar keine Config verwendet. Ein auf der Kommandzeile 端bergebener Pfad hat immer Vorrang, und wenn er nicht
  existiert oder fehlerhaft ist, so werden trotzdem keine Standardpfade mehr versucht. Analog zur Config auch die
  Log-Methode angepasst, nur dass hier kein Dateiname gesetzt wird, wenn das Log nicht zu 旦ffnen ging (ergibt hier
  keinen Sinn).
- ConsoleApplication: Option 'UseRuntime' hinzugef端gt, die bestimmt, ob automatisch nach einer installierten
  PixelLight-Runtime gesucht werden soll, von der dann die Plugins und Datenpakete verwendet werden. Wie bisher
  kann das auch 端ber die Config-Option eingestellt werden, wenn diese gefunden wird, wird diese Flag entsprechend
  gesetzt.
- ConsoleApplication: Weitere virtuelle Methoden eingebaut, um dem Programmierer m旦glichst viele M旦glichkeiten zu
  geben, das Standardverhalten der Applikation abzu辰ndern:
  - OnInitCmdLine() wird nach dem Parsen der Kommandozeile aufgerufen und ist daf端r da, die gesetzen Optionen abzufragen
  - OnInitPlugins() wird nach dem Laden der Config aufgerufen und ist zum Laden der Plugins da
  - OnInitData() wird nach OnInitPlugins() aufgerufen und ist zum Setzen der Datenpfade da
- Methode ScanPackages() aus GuiApplication direkt nach LoadableManager verschoben. Da diese Funktion recht universell
  ist und sicherlich auch ausserhalb des Application-Frameworks verwendet werden kann, sollte sie auch gleich im
  LoadableManager vorliegen, auf dem sie ja auch operiert. Name und Kommentar analog zu ClassManager::ScanPlugins()
  angepasst.
- Core: Der Runtime-Pfad unter Linux ist nun erstmal festgelegt auf "/usr/share/pixellight/Runtime". Sp辰ter k旦nnte
  man hier vielleicht noch anhand der aktuell verwendeten Bibliothek oder deren Version unterscheiden... (k旦nnten
  ja theoretisch mal mehrere Runtimes gleichzeitig installiert sein)
- Folgende Config-Items von EngineGeneralConfig nach CoreConfigGroup verschoben, da sie universell f端r alle
  Applikationen wichtig sind: UsePixelLightRuntime, FirstRun, LastCrashedMessage, LastCrashed, Language.
  Dabei LoadLibsFromRuntime in UsePixelLightRuntime umbenannt, da es hier nicht nur um die Libs geht (wobei man hier
  genauer von Plugins sprechen sollte), sondern gleichzeitig auch um die Daten im Runtime-Verzeichnis.
- Alles wichtige von GuiApplication nach ConsoleApplication verschoben.



>> 03.08.2010
[SB]
- System: GetCurrentDir() gibt das aktuelle Verzeichnis nun im Native-Format zur端ck statt wie bisher im URL-Format.
- System: Zus辰tzlich zu GetUserHomeDir() gibt es nun auch noch GetUserDataDir(). Hier wird das Verzeichnis zur端ckgegeben,
  in das die Konfiguration der Applikation geschrieben werden soll. Unter Linux sind Home- und Data-Dir identisch,
  unter Windows wird hier der Ordner "Anwendungsdaten" im Home-Verzeichnis zur端ckgegeben.
PLCore:
- Application 端berarbeitet. Statt "About" gibt es nun "Version", welches man bei den meisten Applikationen als
  Kommandozeilenoption finden kann (-a f端r about eher nicht). Die eigentliche Funktionalit辰t wurde von Run()
  in die virtuellen Methoden Init(), Main() und DeInit() verschoben, da es ansonsten f端r abgeleitete Klassen
  nicht m旦glich ist, das Verhalten der Applikation zu modifizieren (z.B. wenn 端berhaupt kein Log ge旦ffnet oder
  die Kommandozeile nicht geparsed werden soll - das ist in der bisherigen L旦sung nicht zu verhindern).
  Die Idee dabei ist, dass in den drei Methoden Init(), Main() und DeInit() das eigentliche Ger端st f端r die
  Ausf端hrung der Applikation implementiert wird, dies wird also von der jeweilige Basisklasse (z.B. Application,
  GuiApplication oder SceneApplication) entsprechend modifiziert. Konkrete Programm-Applikationen dagegen sollten
  diese Methoden dagegen m旦glichst nicht mehr ver辰ndern m端ssen, sondern statt dessen nur einzelne Schritte ver辰ndern,
  welche in zus辰tzlichen virtuellen Methoden bereitgestellt werden (z.B. OnRun(), OnInitLog() etc.). Diese
  Methoden werden von den Basisapplikationen aus aufgerufen. Nur wenn man wirklich grundlegend die Arbeitsweise
  der Applikation 辰ndern will, muss man dann Main() etc. anpassen.
- Neue Application-Klasse in ConsoleApplication umbenannt. Diese nderung wollte ich sowieso machen, damit man nicht
  mehr st辰ndig das Problem mit gleichen Namen hat, da wir die Klassen in konkreten Programm ja auch immer "Application"
  nennen, und das daher immer in Konflikt ger辰t. Ausserdem wird es so leichter, die Klassen nach und nach umzustellen,
  da erstmal beides nebeneinander existieren kann.
- ConsoleApplication: Option m_bMultiUser hinzugef端gt, mit der bestimmt wird, ob das Multi-User-Environment des Systems
  verwendet werden soll, oder nicht. In dem Falle wird immer zuerst versucht, z.B. Config oder Log-Dateien im
  entsprechenden User-Verzeichnis abzulegen, erst dann wird als Fallback z.B. das Application- oder das aktuelle
  Verzeichnis verwendet. Diese Option ist standardm辰ig eingeschaltet und sollte wohl nur noch in Sonderf辰llen
  ausgeschaltet werden, da alle aktuellen Systeme mittlerweile darauf ausgelegt sind.



>> 02.08.2010
[SB]
- SystemLinux: GetProgramName() implementiert, so dass nun genauso wie unter Windows der absolute Pfad zur Bin-Datei
  zur端ckgegeben wird, gleichg端ltig von wo das Programm aufgerufen wurde. Der in args[0] 端bergebene Pfad ist leider
  relativ zur aktuellen Position und hilft daher nicht wirklich weiter, wenn es darum geht, den Pfad zu extrahieren
  um dann z.B. relativ dazu Datenpfade herausfinden zu k旦nnen. Mittels der PID kann aber der absolute Pfad einer
  Applikation relativ leicht abgefragt werden. Daf端r wurde nun SetProgramName() entfernt, da dies nur eine Notl旦sung
  war, damit den Wert aus arg[0] 端bergeben zu k旦nnen.
- SystemLinux: GetUserHomeDir() scheint richtig zu funktionieren, daher eingebaut und TODO entfernt.
- System: GetProgramName() in GetExecutableFilename() umbenannt, da dies wesentlich eindeutiger ist.
- Log: ConsoleOutputActive in Verbose umbenannt. "Keep it simple" darf ruhig auch mal auf Namen angewendet werden :-)
- Log: Kommentare etwas 端berarbeitet.
PLCore:
- ApplicationContext hinzugef端gt. Damit die Application-Klasse m旦glichst 端bersichtlich bleibt, sollten hier nicht
  so viele Daten und Methoden auf einem Haufen sein, denn das macht es immer gleich um einiges schwerer, den
  Aufbau einer Klasse zu verstehen. Die Laufzeit-Informationen der Klasse, also z.B. die wichtigen Verzeichnisse
  sowie die 端bergebenen Parameter, wurden daher in die neue Context-Klasse verschoben. Die Daten, die dagegen die
  Applikation selber bestimmen (wie z.B. Name und Titel) bleiben aber in der Klasse selbst.
- Application: Name hinzugef端gt. Bisher gab es nur den Titel, der Name einer Applikation sollte aber auch noch
  gesetzt werden, da dieser meist k端rzer ist als der ausgeschriebene Titel. Wenn kein Name angegeben wird, so wird
  der Name aus dem Dateinamen der Applikation extrahiert (z.B. "TestApp.exe" -> "TestApp").



>> 01.08.2010
[SB]
- Eigene Versionsnummer von PLGeneral entfernt.
[SB]
PLCore:
- Config-Klassen in eigenes Verzeichnis "Config" verschoben. Bitte die Application-Verzeichnisse nicht immer mit
  zus辰tzlichen Klassen belasten, insbesondere, wenn diese ganz locker auch f端r sich selber stehen k旦nnen.
- Timer-Klassen entfernt, da veraltet und zur Zeit sowieso nicht mehr verwendet. In PLGui liegen ja schon Timer-Klassen
  bereit, wenn man das also mal braucht, m端sste man sich nur noch einmal vern端nftig 端berlegen, wie man darauf ausserhalb
  von PLGui am besten zugreifen k旦nnte.



>> 24.07.2010
[SB]
- ConsoleLinux: Wenn Dateibefehle verwendet werden, um auf die Konsole zu schreiben, sollte der Dateipuffer immer geleert werden, damit die
  Ausgabe sofort erfolgt. Habe daher hier fflush(stdout) hinzugef端gt.



>> 17.07.2010
[CO]
- "XmlNode::GetNextSiblingElement" & "XmlNode::GetFirstChildElement": R端ckgabetyp sollte XmlElement und nicht XmlNode sein
PLCore:
- XML basierendes Chunk PixelLight Dateiformat hinzugef端gt, Dateiendung ist "xchunk" statt "chunk" f端r Bin辰re Dateien



>> 15.07.2010
[CO]
- Bugfix in verschiedenen Projekten: Verwendung von XmlNode GetFirstChild/IterateChildren war Fehlerhaft da oft auf XmlElement
  gecasted wurde ohne vorher zu pr端fen ob es 端berhaupt XmlElement ist, im Falle von XmlComment bekam man so dann einen Crash
PLCore:
- Nachdem ich die letzten Stunden damit verbrachte die Projekte und Daten entsprechend anzupassen... Suchpfade wie besprochen
  aus dem Loadable Manager entfernt. Zuk端nftig muss man also z.B. "Data/Textures/MyTexture.dds" statt "MyTexture.dds" schreiben.



>> 07.07.2010
[CO]
- "String::GetUInt32()": Statt "atol" wird nun "strtoul" verwendet da sich scheinbar das Verhalten von "atol"
  unter Linux/Windows unterscheidet und z.B. unter Linux das umwandeln in uint32 nicht klappte wenn die Zahlen
  zu gro waren



>> 06.07.2010
[SB]
- Bug in FileLinux::IsFile() behoben.



>> 08.06.2010
[CO]
PLCore:
- LoadableManager::OnClassLoaded: Hier darf die Klasse wirklich nur in eine Liste eingetragen werden, da man noch nichtmal
  davon ausgehen kann das "IsDerivedFrom" immer funktioniert da z.B. eine ben旦tigte Basisklasse erst etwas sp辰ter registriert
  werden k旦nnte... das war bei mir unter Linux nat端rlich gerade der Fall, und dann war einfach der Loadable Type "Scene"
  unbekannt und es konnten keine Szenen eingeladen werden.



>> 02.06.2010
[SB]
PLCore:
- Bei der Verwendung von Enums im RTTI wird nun nicht mehr stur der Basistypus verwendet, da dies dazu f端hren w端rde,
  dass z.B. bei Methoden auch die Signatur so ver辰ndert wird, dass 端berall der Basistypus erwartet wird (Bsp.: Wird eine
  Methode, oder ein Event z.B. mit der Signatur(void, EnumType<EEnum>) angemeldet, so w端rde f端r die tats辰chliche Methode
  die Signatur (void, int) erwartet). Das ist verwirrend, daher wurde die Behandlung von Enums nun so ver辰ndert, dass
  jetzt 端berall der tats辰chliche Enum-Typus verwendet wird.
- Neuer Typ-Wrapper EnumTypePlain<> eingebaut, der f端r direkte Enum-Typen verwendet wird, also solche, die nicht am
  RTTI angemeldet wurden. Wenn man nun bspw. Type<EEnum> schreibt, wird intern Type< EnumTypePlain<EEnum> > verwendet,
  welches es erm旦glicht, dieses als Typus im RTTI zu verwenden (dann hat man nat端rlich z.B. keine Umwandlung in Strings
  unter Verwendung der Enum-Namen, kann aber ansonsten diesen Typus wie gewohnt verwenden).
- RTTI-Makros f端r Enums angepasst: Normale enums werden nun ohne den Basistypus deklariert, also z.B. pl_enum(EEnum)
  statt pl_enum(EEnum, int). Nur in dem speziellen Fall, dass "unechte" Enums z.B. mit floats erzeugt werden sollen,
  muss auch der Basistyp mit angegeben werden, hierf端r kann nun das Makro pl_enum_direct() verwendet werden.
  Es ist zu beachten, dass der Name in enums nun nicht mehr v旦llig frei gew辰hlt werden kann, sondern immer der angegebene
  Typus unter dem exakten Namen auch existieren muss (also entweder ein echtes enum oder z.B. eine leere Klasse). Damit
  sind einige beabsichtigte oder unbeabsichtige Unstimmigkeiten, die es bisher gab (z.B. Enum hie EFlag wurde aber
  als EStyle angemeldet) nicht mehr m旦glich.



>> 01.06.2010
[SB]
PLCore:
- RTTI: Bei der Verwendung von Enums z.B. in Events kam es bislang noch zu Fehlermeldungen durch den Compiler.
  Der Grund daf端r war, dass noch nicht 端berall konsequent die tats辰chlichen Typen verwendet wurden, welche von
  Type::_Type ermittelt werden (bei Var<T> war dies schon der Fall, aber bei allen Functoid- und Event-Typen noch nicht).
  Wenn bspw. ein Enum verwendet wird, ist der Typus ja EnumType<T> - dies ist aber nur ein Pseudo-Typus, der nicht wirklich
  verwendet werden darf (EnumType<T> als Parameter in einer Funktion ergibt keinen Sinn). Daher wird in Type::_Type der
  Typus auf den jeweiligen tats辰chlichen Typus gemappt, dieser Typus muss dann verwendet werden.
  Als Faustregel kann festgehalten werden: In Template-Parametern sollte immer der Eingabetyp unver辰ndert weitergereicht
  werden, erst wenn es zur Verwendung kommt (z.B. als Variable oder als Funktionsparameter), muss dann der jeweilige
  korrekte Typ verwendet werden.



>> 30.05.2010
[SB]
PLCore:
- RTTI: Beim Einbinden von RTTI-Klassen in andere Projekte, kam es zu dem Problem, dass diese Klassen dann mehrfach
  am System angemeldet wurden, weil die entsprechenden Template-Klassen vom Compiler dann mehrfach instanziiert werden
  (in jedem Projekt, in dem die Klassen eingebunden werden, also nicht nur in dem Projekt, das sie exportiert).
  Aufgrund der RTTI-Makros ist es leider nicht einfach m旦glich, diese Templates dann zu exportieren, darum wurden die
  RTTI-Makros nun so erweitert, dass man wie bei DLL-Exports eine Definition daf端r verwendet, um festzustellen, ob die
  jeweilige Klasse gerade importiert oder exportiert wird. F端r solche Projekte, die niemals in andere Projekte eingebunden
  werden (z.B. reine Plugins, die nur dynamisch 端ber das Plugin-System eingeladen werden, oder Applikation, die gar nicht
  in andere Projekte eingeladen werden), kann das Makro pl_rtti_export verwendet werden. Alle anderen Bibliotheken sollten
  im Header-Datei 辰hnlich zu PLXXX_API ein Makro definieren, das jeweils auf 1 oder 0 gesetzt wird f端r Import oder Export.
  Die Projekte wurden entsprechend umgestellt.



>> 27.05.2010
[SB]
PLCore:
- Workaround f端r Linux bzw. GCC eingebaut, da es leider sonst folgenden, ziemlich dubiosen Linker-Fehler gibt:
    ../../../PLBase/PLCore/libPLCoreStat.a(ClassManager.cpp.o):
    In function `PLCore::Event<PLCore::Module const*, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType>::Emit(PLCore::Module const*) const':
    ClassManager.cpp:(.text._ZNK6PLCore5EventIPKNS_6ModuleENS_8NullTypeES4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_E4EmitES3_[PLCore::Event<PLCore::Module const*, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType>::Emit(PLCore::Module const*) const]+0x1a):
    undefined reference to `vtable for PLCore::Functor<void, PLCore::Module const*, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType>'
  Dieser Fehler ist wirklich sehr eigenartig, weshalb ich annehme, dass es sich um einen Fehler im Compiler handeln k旦nnte:
    - Der Fehler tritt z.B. mit Event<Module*>, Event<int> und allen anderen Typen auf
    - Der Fehler tritt *nicht* mit Event<Class*> auf, den Grund hierf端r konnte ich aber nicht finden
    - Der Fehler tritt auf, sobald der Operator () vom Functor aufgerufen werden soll
    - Sobald der entsprechende Functor<T> in der Klasse Event oder in einer Methode instanziiert wird, verschwindet der
      Fehler. Es muss aber eine richtige Instanz sein, eine Typendeklaration, ein Zeiger oder eine Referenz reichen hier
      nicht aus, was wirklich eigenartig ist
    - Wenn statt des Functor()-Aufrufes eine neue Methode im EventHandler eingebaut wird, die wiederum Functor()
      aufruft, tritt der Fehler ebenso auf und kann ebenso behoben werden, indem dann in der neuen Methode innerhalb von
      EventHandler der Functor instanziiert wird. Komischer Weise reicht hier aber eine Instanziierung innerhalb der Klasse
      dann nicht mehr aus (zumal hier ja der Functor auch bereits instanziiert wird!).
  Es scheint also so, als ob unter bestimmten Voraussetzungen die Template-Klasse vom Compiler nicht richtig instanziiert
  wird, weshalb es dann zu dieser wenig hilfreichen Fehlermeldung kommt (diese Fehlermeldung wird normaler Weise darauf
  zur端ckgef端hrt, wenn z.B. eine virtuelle Methode, meist z.B. ein virtueller Destruktor, nicht implementiert wurde. Dies
  scheint mir hier aber nicht der Grund zu sein, zumal hier der Zusammenhang mit Templates besteht. Darum und aufgrund
  der unlogisch wirkenden Verhaltensweisen des Fehlers, halte ich einen Compiler-Bug f端r m旦glich).
  -> Als Workaround wird nun der Functor in der Emit-Methode einmal statisch instanziiert. Habe daf端r im CMake-Projekt
  auch gleiche eine neue Pr辰prozessor-Definition eingef端gt, die mitteilt, wenn der GCC zum Compilieren verwendet wird
  (ifdef LINUX w辰re hier eigentlich falsch, darum lieber ifdef GCC, zumal man theoretisch auch den GCC f端r Windows
  verwenden kann).
- CMake-Projekt so angepasst, dass PLCoreStat nur noch von PLGeneralStat abh辰ngig ist, und nicht mehr wie bisher von
  PLGeneral.
- ClassManager::GetClasses() gibt nun keine Liste mehr zur端ck, sondern f端llt eine 端bergeben Liste, um unn旦tige Kopier-
  operationen zu vermeiden.



>> 27.05.2010
[CO]
- Log liegt wieder in PLGeneral. Diesmal allerdings in einem eigenen "Log" Verzeichnis und nicht ans RTTI angeschlossen.
  "LogFormaterConsole" entfernt, das Log kann auf Wunsch nun direkt in die Standard OS Konsole schreiben.
PLCore:
- Log liegt wieder in PLGeneral
- "Application::Run": Hier wird nun das Log anhand von Kommandozeilen Parametern initialisiert, ich denke es ist das beste das
  direkt hier zu machen statt z.B. erst in "PLGui::GuiApplication"
- "Application::OnPrintVersion()" in "Application::OnPrintAbout()" umbenannt damit es keine Konflikte mit "v" als Kommendozeilen
  Parameter f端r "Verbose" gibt (uh, "v" scheint nen Standard-Parameter zu sein http://de.wikipedia.org/wiki/Verbose :)



>> 25.05.2010
[SB]
- String::GetUInt64(): _wtoi64 gibt es leider unter Linux nicht. Habe da nun statt dessen wcstoumax() verwendet,
  welches hoffentlich die richtige Funktion daf端r ist. Leider gibt es die wiederum unter Windows nicht, jedenfalls
  konnte ich das nicht finden, obwohl es eigentlich zum ISO-Standard geh旦ren sollte, und musste darum hier leider
  eine Fallunterscheidung einbauen.



>> 24.05.2010
[CO]
- Bugfix: "ElementManager<AType>::SetElementName": Umbenannte Elemente sollten nur in m_mapElements eingef端gt werden, wenn
  diese kurz zurvor ausgetragen wurden
PLCore:
- Bugfix: "ResourceManager<AType>::SetResourceName": Umbenannte Elemente sollten nur in m_mapResources eingef端gt werden, wenn
  diese kurz zurvor ausgetragen wurden



>> 23.05.2010
[CO]
- Da der Typ "handle" als "unsigned int" definiert ist, ist es unter 64 Bit 端bersetzt, 64 Bit statt 32 Bit gro.
  "INVALID_HANDLE" wird daher nun 32/64 Bit abh辰ngig definiert. (scheinbar nur f端r Windows n旦tig)



>> 22.05.2010
[CO]
- String Klasse um Operatoren f端r uint32 und uint64 erweitert. Unter Windows nutzte ich daf端r die Erweiterungen "I32"
  und "I64", unter Linux einfach nur "u" und "llu" - habe im Code f端r Linux als Kommentar alternativen eingef端gt die
  man eventuell noch testen k旦nnte.
PLCore:
- "Type<T*>", "Type<T&>" und "Type<Object*>": ConvertToString/ConvertFromString arbeitet nun mit uint32/uint64.
  ber die Definition "X64_ARCHITECTURE" wird bei uns festgelegt das es 64 Bit ist, "X64" war mir dann Namenskonflikt
  m辰ig doch etwas zu Riskant. :D



>> 21.05.2010
[SB]
PLCore:
- TypeInfo: Neben IsEnumType() gibt es nun ebenfalls IsFlagType(), um Flags von Enums unterscheiden zu k旦nnen.
  Im Falle von Flags gibt IsEnumType() nun dort auch 'false' zur端ck - das scheint mir ein wenig logischer, nat端rlich
  muss man hier aber wissen, dass auch bei IsFlagType() == 'true' die Methoden zum Auslesen der Enums nat端rlich
  funktionieren. Mann k旦nnte das auch anders herum machen, so dass IsEnumType() in beiden F辰llen 'true' zur端ckgibt, dann
  w端rde man "Flag" sozusagen als Sonderfall von "Enum" ansehen. Momentan habe ich es aber wie oben beschrieben gel旦st.
- Class: ClassName (Name mit Namespace) wird nun noch gesondert als String gespeichert, damit beim Zugriff darauf nicht
  immer dynamisch neue Strings zusammengestellt werden m端ssen.
- Log, LoadableManager und Localization: Template-Instanz so ver辰ndert, dass es sich auch mit gcc compilieren l辰sst.
  Bei so einer expliziten Instanziierung von Templates ist zu beachten, dass es nicht erlaubt ist, diese innerhalb
  eines fremden Namespaces vorzunehmen. Da Singleton zum namespace PLGeneral geh旦rt, muss also eine Spezialisierung
  innerhalb von PLGeneral oder ausserhalb aller Namespaces vorgenommen werden, aber *nicht* z.B. innerhalb von PLCore.
  Wie so oft geht dies zwar unter VC, unter z.B. dem gcc aber nicht, daher sollte hier in Zukunft darauf geachtet werden,
  Template-Instanziierungen immer ausserhalb fremder Namespaces vorzunehmen.



>> 20.05.2010
[CO]
- Das alte RTTI aus PLGeneral entfernt... manohman, das waren 2 verdammt heftige Wochen. Im groen und ganzen l辰uft nun alles
  wieder, nat端rlich steht nun noch weiteres Bugfixing an bis alles wieder so rund l辰uft wie vor der groen Umstellung. Interessant
  ist, dass es am Ende nun wirklich 2 Wochen Arbeit waren, so wie am Anfang pi*daumen gesch辰tzt. *g*
PLCore:
- LoadableManager: Neue Klassen werden erst dann, wenn diese ben旦tigt werden korrekt Eingetragen. Tr辰gt man sofort bei
  erhalten des ClassManager::EventClassLoaded Ereignisses ein, so kann es sein das eine Klasse noch nicht vollst辰ndig
  initialisiert ist und dann die Loader Registierung nicht klappt.
- LoadableType speichert nun ebenfalls die RTTI Klasse von der alle Loader Implementationen dieses Types abgeleitet sein
  m端ssen. Diese Klasse wird z.B. in Loadable verwendet um zu sehen ob der Loader Typ, der 端ber eine Dateiendung ermittelt
  wurde, wirklich zum Loadable Typ passt der gerade eingeladen werden soll... sonst k旦nnte man einem Mesh sagen es solle
  sich doch bitte aus diesem Bild hier laden - klar, probieren kann ich es als Benutzer immer noch, das System grinst mich
  in dem Fall aber nur d辰mlich an. *g*



>> 19.05.2010
[CO]
PLCore:
- Loadable System von "PLGeneral::Parameters" befreit. Gestern Abend schwierte mir im Kopf eine Loader-L旦sung herum die mit
  RTTI Methoden arbeitet, heute in aller fr端h setzte ich das mal um und passte entsprechend alle Loader an. Das Ergebnis
  gef辰llt mir sogar... Die einzelnen Loader-Basis Klassen wie z.B. "ConfigLoader" sind nun superschlank, ja praktisch leer.
  Die konkreten Loader-Implementationen wie z.B. "ConfigLoaderPL" sind nun ebenfalls etwas schlanker da dort keine Dynamischen
  Parameter mehr geparst werden. Es gibt nun einfach 旦ffentliche Load/Save Methoden, die man also auch ganz ohne RTTI nutzen kann.
  Ebenfalls kann es LoadParams/SaveParams Methoden geben - wenn ein Format noch besondere Optionen anbietet, wie z.B. welche
  Kompression beim Speichern verwendet werden soll. Wenn man es ganz wild treiben will, kann man die Methoden Namen auch frei
  w辰hlen, beim Resourcen-Laden muss man dann allerdings die Methoden Namen angeben. Es stehen nun also deutlich mehr Nutzungsm旦glichkeiten
  zur Verf端gung und die Implementationen sind schlanker geworden + man kann in den RTTI Methoden Kommentaren nachlesen was es
  f端r weitere besondere Format abh辰ngige Parameter gibt und was die machen.



>> 17.05.2010
[CO]
- PixelLight ist nun soweit auf das neue RTTI umgestellt, nun folgen nur noch Aufr辰umarbeiten & Bugfixing
- "Log" von PLGeneral nach PLCore verschoben
PLCore:
- "Log" von PLGeneral nach PLCore verschoben



>> 16.05.2010
[SB]
PLCore:
- ClassManager: GetClasses() kann nun auch nur Klassen aus einem bestimmten Modul zur端ckgeben. Damit ist diese Methode
  nun immer mehr zur zentralen Such-Funktion f端r Klassen geworden, was ich auch ganz sinnvoll finde. Kommentare an
  anderen Stellen eingef端gt, um auf diese zentrale Suchfunktion hinzuweisen.



>> 16.05.2010
[CO]
PLCore:
- PLCore::Object::IsInstanceOf in der Art erweitert das ebenfalls "true" zur端ckgegeben wird wenn die beiden zu testenden
  Klassen identisch sind



>> 15.05.2010
[SB]
PLCore:
- RTTI: Ein mit ModifyAttr 端berschriebenes Attribut setzt nun den Default-Value in Abh辰ngigkeit vom Storage-Type
  des Basis-Attributes. Wenn das Basis-Attribut also den GetSet-Storage gesetzt hat, wird auch im 端berschriebenen
  Attribut der Default-Wert *nicht* mehr gesetzt, so dass es nicht mehr zu Problemen im Konstruktor kommen sollte.
  Ist dagegen DirectValue als Basis-Storage gesetzt, so wird der Default-Wert gesetzt, da es hier keine Probleme gibt.
  Ich habe es zwar noch nicht ausprobiert, aber das ganze sollte auch 端ber beliebig viele Ebenen funktionieren,
  da der StorageType der Basisklasse hier jeweils durchgereicht wird :-)
- Constructor: IsDefaultConstructor() eingebaut
- Class: HasConstructor() und HasDefaultConstructor() eingebaut
- Class: IsDerivedFrom() gibt nun bei der eigenen Klasse "false" zur端ck, damit der Name exakt stimmt
- ClassManager: GetDerivedClasses() akzeptiert nun mehrere Parameter, mit denen man bestimmten kann, ob die Basisklasse
  selbst mit aufgef端hrt werden soll, ob rekursiv oder nicht rekursiv gesucht wird, sowie ob abstrakte Klassen, also solche
  ohne Konstrukturen, mit aufgef端hrt werden sollen oder nicht.
- Class und ClassManager: Das Auflisten der abgeleiteten Klassen wurde noch einmal gr端ndlich 端berarbeitet. Es ist nun die
  von Christian eingebaute L旦sung, die nur auf den Namen operiert, verwendet worden, da mir aufgefallen ist, dass das
  InitClass()-Schema in Bezug auf abgeleitete Klassen ja gar nicht richtig funktionieren kann. Denn wenn die Klasse
  initialisiert wird, tr辰gt sie sich zwar in die Liste ihrer Basisklasse ein, aber damit kann man ja noch nicht sicherstellen,
  dass die eigenen abgeleiteten Klassen bereits initialisiert wurden. Die Liste an abgeleiteten Klassen bleibt also leer,
  da man die entsprechenden Klassen vorher initialisieren m端sste, womit sich die Katze in den Schwanz beit ;-)
  Darum wurde die Liste von abgeleiteten Klassen nun aus Class entfernt, statt dessen wird die Suchmethode aus
  ClassManager verwendet, um an die Liste von abgeleiteten Klassen zu kommen, wenn diese abgefragt wird.
- ClassManager: GetDerivedClasses() in GetClasses() umbenannt.



>> 14.05.2010
[SB]
PLCore:
- NullType nach TypeTraits.h verschoben
- InvalidType in TypeTraits.h hinzugef端gt. Dies ist ein Template, das alle nicht unterst端tzten Typen repr辰sentiert
- TypeTraits: Einige Templates hinzugef端gt, um den Typus eines, 辰h, Typus festzustellen:
  - IsConvertible, mit dem man feststellen kann, ob zwei Typen ineinander konvertierbar sind.
  - IsEnum, mit dem man feststellen kann, ob es sich bei einem Typen um ein enum handelt
  - TypeClassification, welches Informationen 端ber den Typus in Form von bools in einer Klasse speichert
  - CheckType, welches den geeigneten Typus f端r nicht-standard-Typen ausw辰hlt (z.B. <int> f端r enums)
  - IsBaseClass, welches ermittelt, ob eine Klasse eine Basisklasse einer anderen Klasse ist
  - CheckBaseClass, welches einen Compiler-Fehler hervorruft, wenn eine Klasse nicht von einer Basisklasse abgeleitet ist
- Type und DefaultValue: Es werden nun die neuen Templates verwendet, um neben den Standardtypen weitere, nicht-standard-Typen
  zu unterst端tzen. So werden nun z.B. auch enums unterst端tzt, in diesem Falle wird der Typus einfach wie ein int behandelt.
  So etwas wie Event<EEnum> sollte daher nun verwendet werden k旦nnen.
- RTTI: Es wird nun ein Compilerfehler erzeugt, wenn im RTTI-Makro nicht angegebene Klasse nicht von der angegebenen
  Basisklasse abgeleitet wurde. Damit werden nun Fehler leichter entdeckt, z.B. wenn die Klasse selbst als Basisklasse
  angegeben wurde etc. Was allerdings noch nicht entdeckt werden w端rde, w辰re z.B., wenn zwar eine korrekte Basisklasse
  angegeben wurde, dazwischen aber noch weitere Klassen sind (z.B. A->B->C, und es wird angegeben, C sei von A abgeleitet!).



>> 11.05.2010
[CO]
PLCore:
- Bis auf SceneNode und SceneNodeModifier ist nun alles auf das neue PLCore2 umgestellt, also Klassenm辰ig Halbzeit :D
- Wie in einer EMail besprochen: "type_flag" in "pl_flag_type", "type_enum" in "pl_enum_type" und "ret_type" in "pl_ret_type" umbenannt



>> 08.05.2010
[SB]
PLCore:
- TypeTraits.h hinzugef端gt: Hier wird es einige generelle templates geben, um Abfragen auf Typen zur Compile-Time
  zu erm旦glichen.
- Rtti.h: Es waren noch einige nderungen notwendig, damit das Projekt wieder mit gcc zu compilieren ist. Die
  erzeugten Storage-Templates f端r ein Attribut sind so geschrieben, dass sie nur valide sind, wenn der entsprechende
  Storage-Type auch wirklich ausgew辰hlt wurde (es gibt z.B. keine Methoden GetMyVar()/SetMyVar(), wenn MyVar nicht
  mit dem Storage-Typus GetSet deklariert wurde). Im template-code wurde jedoch f端r jedes Attribut das entsprechende
  Template verwendet, wenn auch nur als Typus f端r andere Templates, wo es sp辰ter verworfen wurde. F端r den gcc reicht
  dies jedoch aus, um das Template zu spezialisieren, was nat端rlich zu einem Fehler f端hrt. Aus diesem Grunde wird
  nun das template SpecializeIfEqual<> verwendet, welches eine Template-Class nur dann spezialisiert, wenn eine
  bestimmte Bedingung erf端llt ist. Damit l辰sst sich PLCore2 nun auch unter Linux wieder compilieren.
- IntegralType nach TypeTraits.h verschoben
- Traits.h entfernt



>> 07.05.2010
[CO]
- "Chunk" und "Localization" samt dazugeh旦rigen Klassen von PLGeneral nach PLCore verschoben da hier RTTI Funktionalit辰t
  ben旦tigt wird die zuk端nftig erst ab PLCore zur Verf端gung steht. Habe das erstmal in einem "Tools"-Unterordner gelassen.
- "Loader"/"Loadable" von PLGeneral nach PLCore verschoben
- "Resource" von PLGeneral nach PLCore verschoben
PLCore:
- "Chunk" und "Localization" samt dazugeh旦rigen Klassen von PLGeneral nach PLCore verschoben da hier RTTI Funktionalit辰t
  ben旦tigt wird die zuk端nftig erst ab PLCore zur Verf端gung steht. Habe das erstmal in einem "Tools"-Unterordner gelassen.
- "Loader"/"Loadable" von PLGeneral nach PLCore verschoben
- "Resource" von PLGeneral nach PLCore verschoben
- Wie schon bei PLGeneral, hat nun auch PLCore eine statische Version da z.B. PLProject und der 3ds Max Exporter nun PLCore
  ben旦tigen, aber nicht von einer dll abh辰ngig sein sollten. Hoffentlich hab ich "CMakeLists.txt" korrekt erweitert, naja
  werds sp辰testens beim n辰chsten PL SDK 端bersetzen merken. *g*



>> 06.05.2010
[CO]
PLCore:
- Umstellung von PixelLight auf PLCore2 begonnen
- "Core", "ThreadTimer", "Timer", "TimerImpl", "TimerWindows", "Config", "ConfigLoader", "ConfigLoaderPL", "CoreConfigGroup"
  vom alten PLCore ins neue kopiert damit sich die Umstellarbeiten auf das neue RTTI Konzentrieren k旦nnen.
- Params um Copy-Constructor und Copy-Operator erweitert da ansonnsten an einigen Stellen der VisualStudio Team Edition Compiler
  Warnungen ausgab, w辰hrend der *normale* VisualStudio Compiler nix sagte



>> 05.05.2010 (PLCore2)
[SB]
- RTTI: pl_enum_end() in pl_enum_end ge辰ndert
- RTTI: Fehler in pl_enum() behoben - wenn der Wert 0 definiert war, funktionierte die Umwandlung von Name->Wert nicht
  mehr, da hier eine Abfrage fehlte.
- RTTI: Die Behandlung von Flags und Enums musste noch einmal gr端ndlich 端berarbeitet werden, da es bspw. so nicht
  m旦glich war, Enums in einer Klasse zu definieren und in der gleichen Klasse auch gleich zu verwenden. Daher habe
  ich die interne Verwaltung von Enums nun so ver辰ndert, dass das enum nicht mehr durch eine Spezialisierung
  von PLCore2::EnumType<> definiert wird, sondern statt dessen eine einfache Klasse erzeugt wird, die dann als
  Template-Parameter weitergereicht wird. Das vereinfacht vieles und bedeutet letztlich f端r die Anwendung:
  - pl_enum() kann nun prinzipiell 端berall verwendet werden. Auch in Namespaces, und auch in Klassen :-)
  - pl_enum_value_namespace() wurde deswegen wieder entfernt, da es nicht mehr ben旦tigt wird
  - pl_enum_value_direct() wurde hinzugef端gt, dies kann verwendet werden, wenn der zu definierende Enum-Typ kein echter
    C++-Enum-Typ ist - letztlich kann dies verwendet werden, um beliebige Definitionen zu machen. Anwendungsfall sollte
    vor allem sein, wenn man enum definieren will, die nicht den Datentyp 'int' haben (z.B. float)
  - berall, wo man auf ein enum zugreifen will, muss man nun zwangl辰ufig auch das Makro type_enum() verwenden,
    da dies jetzt nicht mehr nur ein PLCore2::EnumType< > um den Namen legt, sondern auch den Namen so ver辰ndert,
    dass auf die erzeugte RTTI-Enum-Klasse verwiesen wird.
  - F端r den direkten Zugriff auf RTTI-Enums ist jetzt die Klasse PLCore2::EnumType< > zust辰ndig. Wie eben erw辰hnt muss
    hier immer type_enum() verwendet werden, um also z.B. die Anzahl an Elementen eines enums abzufragen, benutzt man
    also: type_enum(EnumName)::GetNumOfEnumValues();
- Bespiele f端r Enums erweitert: U.a. Verwendung von Enums in Klassen und Definition von float-enums.
- RTTI: Die Basisklasse muss in pl_class() nun ohne Anf端hrungszeichen angegeben werden.
- VarAccess und VarStorage noch einmal gr端ndlich 端berarbeitet und ein wenig 端berschaubarer gemacht. Der zugrunde
  liegende Storage-Typ (z.B. StorageDirectValue oder StorageGetSet) wird nun so weit wie m旦glich mitgereicht,
  damit dann an letzter Stelle das jeweilige Template anhand der Klasse entscheiden kann, was zu tun ist. Auch
  der StorageChoose wurde entsprechend umge辰ndert.
- Neben StorageDirectValue und StorageGetSet gibt es nun noch einen weiteren Storage-Typ: StorageModifyAttr.
  Dieser Typus kann verwendet werden, um Variablen in abgeleiteten Klassen zu 端berschreiben, und dabei in die gleiche
  Variable zu schreiben. Es wird also eigentlich die Variable der Basisklasse verwendet, jedoch im RTTI die Daten aus
  der abgeleiteten Klasse verwendet (z.B. Default-Value, Enum etc.). Wenn dies verwendet werden soll, muss daher der
  Typus der Variablen in der Basisklasse und in der abgeleiteten Klasse identisch sein. Wenn statt dessen StorageDirectValue
  verwendet wird, ist es zwar auch m旦glich, Variablen zu 端berschreiben und dabei den Typus zu 辰ndern, dies sind dann
  jedoch in Wirklichkeit zwei Variablen, die nur den gleichen Namen haben.
- Beispiel f端r das berschreiben von Variablen hinzugef端gt.
- RTTI: Auf vielfachen Wunsch einer einzelnen Person kann nun bei Enums zu jedem Wert auch noch eine Beschreibung
  mit angegeben werden. Diese kann bei statischem Zugriff 端ber EnumType<T>::GetEnumDescription(sName), oder bei
  dynamischem Zugriff 端ber DynTypeInfo::GetEnumDescription(sName) abgefragt werden.
- Var: Methode Default() hinzugef端gt. Die Methode gibt direkt den Default-Wert zur端ck, benutzt also direkt den
  jeweiligen Datentyp. Wie bei Get() und Set() ist diese Methode nur vorhanden, wenn man direkten Zugriff auf die
  Variable hat. ber DynVar gibt es die Methode GetDefault(), welche den Default-Value als String zur端ckgibt (ist
  nicht anders m旦glich, da hier der tats辰chliche Datentyp noch nicht bekannt ist).



>> 04.05.2010 (PLCore2)
[SB]
- Var: Es kann jetzt auch der Default-Konstruktor verwendet werden.
- RTTI: 'pl_enum'-Makro erweitert, so dass die dadurch erzeugte EnumType-Klasse ein wenig mehr Komfort bietet.
- RTTI: 'pl_enum_base' eingebaut. Mit diesem Makro k旦nnen bei der Deklaration eines Enum-Typs alle Werte eines anderen
  Enums 端bernommen werden, hiermit k旦nnen also Datentypen "erweitert" werden.
- RTTI: Neben 'pl_enum_value' gibt es nun auch 'pl_enum_value_namespace', das verwendet werden kann, wenn der enum-Typ
  innerhalb eines Names (oder auch einer Klasse) liegt. RTTI-Enums m端ssen immer im globalen Scope deklariert werden,
  also auch ausserhalb von namespaces, hiermit k旦nnen jedoch dann auch solche Enums angemeldet werden, die selbst
  innerhalb eines namespaces liegen.
- Neue Klassen DynTypeInfo und TypeInfo erstellt. Diese sind im Gegensatz zu den Type<>-Klassen nicht statisch, sondern
  haben ein virtuelles Interface und k旦nnen daher dynamisch (polymorph) verwendet werden. Dies wird wohl so aussehen,
  dass man von einer Variable per GetTypeInfo() eine Referenz auf ein solches TypeInfo-Objekt zur端ckbekommt, und
  davon dann noch einmal die wichtigsten Typen-Informationen abfragen kann. Hier noch einmal die ganzen Konvertierungs-
  funktionen einzubauen, scheint mir nicht sinnvoll, zumal man dies auch direkt innerhalb von Var machen kann, und
  es ausserdem hier schwierig wird, da der tats辰chliche Typ ja nicht bekannt ist. Deshalb kann man hier erstmal nur
  noch einmal Typ-ID und Namen abfragen.
- Var: GetType() hinzugef端gt, welche eine statische Instanz von TypeInfo<T> f端r den jeweiligen Daten zur端ckgibt.
- DynTypeInfo: Es kann nun neben dem eigentlichen Datentyp auch abgefragt werden, ob es sich um einen Enum-Datentyp
  handelt (Enum und Flag ist auf dieser Ebene das gleiche). Falls ja, kann abgefragt werden, welche Enum-Werte es gibt,
  hier bekommt man dann eine Liste von Namen zur端ck. Es ist leider nicht m旦glich, hier auch gleich die Werte f端r
  die Enum-Namen abzufragen, aus dem Grunde, dass hierf端r ja der Datentyp bekannt sein m端sste. Um das zu erreichen,
  muss man also entweder Zugriff auf den jeweiligen Header haben und EnumType<ENUM> verwenden, oder den Umweg 端ber
  eine Variable gehen, da man ja nun die Namen kennt, die man setzen kann.
- DynTypeInfo: Methode GetEnumValue() hinzugef端gt, mit der man nun doch auf den Wert eines Enum-Names zugreifen kann,
  allerdings nur als String (s.o., der Typus ist hier nicht bekannt). Das sollte jedoch helfen, um z.B. in einem Dialog
  neben dem Enum-Namen auch dessen Wert anzeigen zu k旦nnen.
- Object: Umbenennung der Methoden, um mehrere oder alle Attribute eines Objektes gleichzeitig setzen oder auslesen
  zu k旦nnen in SetValues()/GetValues() und SetValuesXml()/GetValuesXml(). Auch wenn man hier letztlich auf Attribute
  zugreift, sind diese Methoden mehr als reine zugriffsmethoden auf Attribute und stellen den Kern des RTTI dar. Daher
  sollten diese Methoden von den anderen Attribut-Methoden getrennt sein und zudem einen m旦glichst einfachen und gut
  zu merkenden Namen haben :-)
- Object: Methoden SetAttributeDefault() und SetDefaultValues() hinzugef端gt. Diese Methoden setzen einen bzw. alle
  Attribute auf ihren jeweiligen Default-Wert.



>> 29.04.2010 (PLCore2)
[SB]
- Klassen k旦nnen nun noch zus辰tzliche Properties haben, also Key/Value-Pairs, die an einer *Klasse* (!) dranh辰ngen
  und zur Laufzeit abgefragt werden k旦nnen. Dies dient dazu, zus辰tzliche Infos zu einer Klasse bereitzuhalten, bspw.
  k旦nnen Loader so bekannt geben, welche Dateitypen sie unterst端tzen oder eine Klasse kann beliebige andere Infos
  端ber sich preisgeben. Properties k旦nnen in abgeleiteten Klassen 端berschrieben werden. Definiert werden Properties
  端ber das neue Makro pl_property. Leider m端ssen alle Properties innerhalb von pl_properties und pl_properties_end
  eingeklammert werden - anders war das mit den RTTI-Makros leider nicht zu l旦sen, ohne dass es unn旦tig kompliziert
  geworden w辰re.
- RTTI: Analog zu 'pl_properties' und 'pl_properties_end' heit es nun 'pl_class_end' anstelle von 'pl_class_end()',
  da es so einfach irgendwie netter aussieht.



>> 24.04.2010 (PLCore2)
[CO]
- Im "pl_module"-Makro "Unknown" Initialisierungen eingebaut da ansonnsten durch "ClassManager::RegisterModule" die
  Module Initialisierungen komplett 端berschrieben werden und am Ende wieder leere Strings vorhanden waren :/



>> 23.04.2010 (PLCore2)
[CO]
- Params: "DefaultValue<x>::Default();" eingef端gt + R端ckgabewert im Konstruktor initialisiert



>> 23.04.2010 (PLCore2)
[SB]
- DynFunc, Func: Call(DynParams &cParams) erwartet ein Params-Objekt, welches nicht const ist. Unter Windows wird dies
  scheinbar auch akzeptiert, wenn man z.B. Call(Params<int, int>(10)) aufruft - zwar geht hier nat端rlich z.B. der
  R端ckgabewert verloren, aber der Aufruf findet dennoch statt, und theoretisch kann man das auf dem Stack befindliche
  Params-Objekt wohl auch manipulieren, auch wenn man davon nat端rlich im Nachhinein nichts mehr hat, weil man es nicht
  wieder auslesen kann :-) Unter Linux mit dem aktuellen gcc klappt dies allerdings nicht, hier wird ein so 端bergebener
  Parameter wohl grunds辰tzlich als const angesehen. Aus diesem Grund musste ich leider zus辰tzlich noch eine zweite
  Methode hinzuf端gen: Call(const DynParams &cParams). Die macht nat端rlich das gleiche wie im nicht-const Fall, mit
  dem Unterschied, dass hier keine R端ckgabewerte geschrieben werden. Deswegen musste diese Methode nicht nur in DynFunc,
  sondern auch in allen 34 Spezialisierungen von Func<T> implementiert werden :-( Sollte jemandem hier eine einfachere
  L旦sung einfallen, bitte Bescheid sagen...
- DynEvent, Event: Gleiche Problematik wie bei DynFunc, Func. Da Events jedoch niemals einen R端ckgabewert haben k旦nnen,
  reicht es hier aus, wenn die Parameter immer als const 端bergeben werden. Emit(DynParams&) wurde also 端berall zu
  Emit(const DynParams&) gemacht.
- Constructor: Auch hier die gleiche Problematik. berall wo n旦tig wurde daher Create(DynParams&) in Create(const DynParams&)
  ge辰ndert. Auch an allen anderen Stellen, z.B. Object und Class, wurden nun wenn n旦tig zweite Varianten der jeweiligen
  Methoden hinzugef端gt, damit man 端berall Parameter sowohl const als auch nicht-const 端bergeben kann.
- Func: Bei den nderungen gab es noch einige kleinere Fehler, wo einfach von const nach non-const gecastet wurde, was
  hier definitiv nicht erw端nscht ist. Nun habe ich hoffentlich alles erwischt (bitte nochmal dr端ber schauen!)
- Constructor: Hier gab es sogar ein noch gr旦eres Problem, weil zwar der Aufruf im Prinzip nur ein const-Parameters
  ben旦tigt, jedoch der R端ckgabewert in diesem Fall ja intern verwendet wird. Ich habe das nun so gel旦st, dass an einen
  Constructor immer const-Parameters 端bergeben werden, diese intern aber kopiert werden und somit ein non-const
  Parameters-Objekt entsteht, welches an den Functoid weitergegeben wird. Dort ist dann der R端ckgabewert, also der Zeiger
  auf das neu erstellte Object, als Return-Value gespeichert, welches dann wiederum zur端ckgegeben werden kann. Nach
  meinen bisherigen Tests scheint das auch zu funktionieren, besonders sch旦n ist die L旦sung nat端rlich nicht.
- ClassManager und Class: Methode GetModule() eingebaut.
- ClassManager: Es wird nun bei duplizierten Klassennamen (Konflikten zwischen zwei Klassen gleichen Namens und
  Namespaces) eine Warnung ins Log geschrieben.
- Module: Name, Beschreibung usw. werden nun alle mit "Unknown" initialisiert. Sollte ein Projekt also nicht die Makros
  nutzen, um Infos 端ber das Modul zu setzen, wird dieses in der Liste und z.B. im Log als "Unknown" auftauchen
- RTTI: Makro pl_current_module_id() hinzugef端gt als Shortcut, um die ID des aktuellen Modules abzufragen.
- RTTI: Slots werden nun, genauso wie Methoden, beim Anmelden am RTTI umbenannt. F端r den Slot "OnMyEvent" wird also
  jetzt ein Objekt namens 'SlotOnMyEvent' angelegt, daf端r wird der aufgerufenen Methode kein automatisches "On" mehr
  vornangestellt. Dies ist nun konsistent mit den Methoden, man gibt also einfach auch beim Slot den Namen der Methode
  an, die aufgerufen werden soll, und erh辰lt ein Feld mit 'Slot' davor. Als Konvention f端r uns w端rde ich vorschlagen,
  dass alle Slots immer der Konvention "On[EventName]" folgen sollten.



>> 22.04.2010 (PLCore2)
[SB]
- Functor: Einige Fehler in den partiellen Spezialisierungen behoben (R statt void)
- DefaultValue: Fehlende Datentypen nachgetragen.
- Class, Object, RTTI: Wie Christian richtig anmerkte, war die Verwendung von Event/Signal und EventHandler/Slot noch
  nicht konsequent umgesetzt. Habe das nun behoben, es sollte nun also v旦llig analog sein zu Attributes und Methods.
- DynEvent: virtual void Emit(DynParams&) war nicht als const deklariert - in den abgeleiteten Klassen aber schon, wodurch
  die virtuelle Funktion nicht korrekt 端berschrieben wurde (sondern das nat端rlich als neue Funktion galt).
- Class: GetAttribute(), GetMethod() etc. geben nun const-Zeiger auf die jeweiligen Descriptoren zur端ck. Zwar geschehen
  dann zwischenzeitlich const-casts, da man letztlich von dem Descriptor ja auch wieder auf das jeweilige Member-Objekt
  kommen kann, aber ich denke, das ist hier ok. Das mit const ist nicht immer so ganz sauber hinzubekommen, f端rchte ich.



>> 21.04.2010 (PLCore2)
[SB]
- Fehler behoben, die beim bersetzen mit gcc unter Linux aufgedeckt wurden.
- PLCore2 l辰sst sich nun unter Linux 端bersetzen.



>> 15.04.2010 (PLCore2)
[SB]
- Class: Die Namen etc. m端ssen nun direkt im Konstruktor 端bergeben werden, da ansonsten die Klasse bereits
  angemeldet wird, bevor ihre Daten gesetzt wurden, der Name ist also leer. Makros etc. entsprechend angepasst.
- Func: Einige Warnungen behoben
- Object: Wir nun auch beim RTTI angemeldet



>> 14.04.2010 (PLCore2)
[SB]
- RTTI-Makros: Probleme behoben, die auftraten, sobald das RTTI 端ber mehr als eine Bibliothek hinweg verwendet wurde.
  Dies f端hrte zu unaufgel旦sten externen Referenzen, diese Probleme wurden nun durch leichte nderungen im RTTI behoben
  (hoffentlich auch f端r andere Compiler zu gebrauchen).
- RTTI-Makros: Die Basisklasse kann nun auch mit angegeben werden (*hust*)
- Basisklasse Config erstellt (noch leer).
- Basisklasse Application erstellt (noch leer).



>> 13.04.2010 (PLCore2)
[SB]
- Klasse Module erstellt, welche die Informationen 端ber ein Modul speichert. F端r jedes Module (Applikation/Bibliothek) wird
  automatisch eine Instanz von Module erstellt und beim ClassManager angemeldet. Ein Module beinhaltet dann bspw. auch eine
  Liste aller Klassen, die zu diesem Modul geh旦ren.
- Funktionalit辰t zum Laden und Verwalten von Plugins hinzugef端gt.
- Type-Wrapper f端r Pointer-Typen hinzugef端gt.
- ClassManager: Events hinzugef端gt f端r das Anmelden/Abmelden von Klassen und Modulen. Dies kann z.B. verwendet, wenn eine
  Komponente dar端ber informiert werden muss, wenn es neue Klassen von einer bestimmten Basisklasse gibt etc.
- RTTI: Eine Makros hinzugef端gt, die zwar nicht notwendig sind, aber die Definitionen besser zu lesen machen.
  ret_type() markiert einen R端ckgabewert und sollte f端r die Deklaration von Methoden verwendet werden, um den R端ckgabetyp
  von den Argument-Typen zu unterscheiden. type_enum() und type_flag() sind Wrapper-Makros, die anstelle der ansonsten
  recht langen und un端bersichtlichen Templates verwendet werden sollten.
- Weitere statische Datentypen zum RTTI hinzugef端gt: double, int8, int16, int32, uint8, uint16, uint32



>> 12.04.2010 (PLCore2)
[SB]
- Klassen-Template ModuleID hinzugef端gt, welches daf端r zust辰ndig ist, jedem Modul (z.B. eine Applikation oder Bibliothek)
  eine eindeutige Modul-ID zu beschaffen.
- ModuleMain.h hinzugef端gt. Dieser Header sollte genau einmal in einem Projekt eingebunden werden und die darin enthaltenen
  Makros verwendet werden, um das Modul zu beschreiben (Name, Beschreibung etc.).
- Makros und Klassen f端r die Deklaration und Registrierung von Modulen hinzugef端gt.



>> 11.04.2010 (PLCore2)
[SB]
- Einige Fehler in Type<EnumType> behoben.
- Type<FlagType> implementiert (Flag-Types sind wie Enums, erlauben aber die Kombination von Werten).
- EnumTypes kann jetzt auch bei der Deklaration von Attributen verwendet werden (hier gab es noch kleinere Fehler, die
  das bisher verhinderten).
- Object, Class: Methoden hinzugef端gt, um den Typus von Objekten abzufragen und z.B. zu erfragen, ob eine Klasse von
  einer anderen abgeleitet ist oder ein Objekt von einem bestimmten Typus ist.



>> 10.04.2010 (PLCore2)
[SB]
- Klasse ParamParser erstellt und implementiert. Diese Helfer-Klasse kann verwendet werden, um Parameter-Strings
  zu parsen, wie z.B. "Param0=\"Hello\" Param1=10". Die Klasse bietet dann ein einfaches Interface, um 端ber die
  gefundenen Parameter sowie ihrer Werte zu iterieren und diese auszulesen. Da diese Funktionalit辰t an sehr verschiedenen
  Stellen ben旦tigt wird, sollte es hier eine wiederverwendbare Klasse geben :-)
- Params: Statische Funktion FromString hinzugef端gt, welche ein Params-Objekt mit den im String angegebenen Parametern
  erzeugt und zur端ckgibt. Damit ist es m旦glich, bspw. eine Funktion mit den Parametern als String aufzurufen:
    cFunc.Call(Params<int, float>::FromString("Param0=10 Param1='1.5'")); // Parameter names are not important
- DynFunc, Func: Neue virtuelle Methode Call(const String&) hinzugef端gt, die es erlaubt, eine Methoden mit einem
  Parameter-String aufzurufen, ohne im Vorfeld die Signatur der Funktion kennen zu m端ssen.
- Klasse ParamParserXml erstellt und implementiert. Diese arbeitet analog zu ParamParser, lies die Parameter aber
  im XML-Format ein, z.B.:
    <?xml version=\"1.0\" ?>
    <Call Param0=\"1\" Param1=\"2.5\"/>
- Params: Statisch Funktion FromXML hinzugef端gt (analog zu FromString).
- DynFunc, Func: Neue virtuelle Methode Call(const XmlElement&) hinzugef端gt (analog zu String&).
- Var, Type: Werte k旦nnen nun auch gesetzt werden, indem ein Pointer auf eine andere dynamische Variable gegeben wird,
  anstelle eines statischen Typs (辰quivalent zu Func, wo DynParam 端bergeben werden kann). Neben z.B. pVar->SetInt()
  gibt es nun also auch pVar->SetVar(pVar2).
- Objekt: Interface um einige Komfort-Funktionen erweitert, z.B. SetAttribute(), CallMethod() etc (Abk端rzungen f端r
  den l辰ngeren Weg :-))
- Objekt: Methoden hinzugef端gt, um alle Variablen zu laden oder zu speichern (per String oder XML).



>> 08.04.2010 (PLCore2)
[SB]
- Neue Klasse MemberDesc erstellt. Dies ist die Basisklasse f端r alle Member einer Klasse wie z.B. Attribute, Method etc.
  Dies erleichtert es beispielsweise, 端ber alle Member einer Klasse zu iterieren, ohne f端r jeden Member-Typus eine eigene
  Schleife schreiben zu m端ssen.
- Class: Methodik implementiert, um Member von Klassen in abgeleiteten Klassen zu vererben, die (hoffentlich) sowohl
  simpel als auch m辰chtig ist. Zun辰chst werden alle Member einer Klasse 端ber Selbst-Initialisierung nur bei der Klasse
  selbst registriert und dort in einer Liste "eigener Member" gespeichert. Da hier das Static-Initialization-Dilemma
  einsetzt, die Reihenfolge in der sich die Member registrieren also nicht vorhergesehen werden kann, muss damit gerechnet
  werden, dass sp辰ter noch weitere Member der eigenen Klasse oder einer Basisklasse hinzukommen k旦nnen. Um dieses Problem
  zu l旦sen, gilt die Klasse zun辰chst so lange als nicht initialisiert, bis versucht wird, auf die Member der Klasse
  zuzugreifen. Erst dann wird die Klasse initialisiert, was dazu f端hrt, dass sie alle ihre Member aufz辰hlt und internen
  Listen von Attributen, Methoden etc. aufbaut, welche dann f端r den Zugriff auf die Member verwendet werden. Dabei werden
  auch die Member der Basisklassen mit aufgez辰hlt, wodurch auch die Reihenfolge der Member die richtig ist. Wenn nun sp辰ter
  noch Member zu einer Klasse hinzugef端gt werden, die bereits initialisiert wurde, f端hrt dies dazu, dass diese Klasse sofort
  wieder de-initialisiert wird und dann wieder als nicht initialisiert gilt, bis ein Zugriff auf die Klasse erfolgt, der
  wieder zu einer Initialisierung f端hrt (wodurch dann auch wieder alle Member korrekt aufgelistet werden). Auf diese Weise
  sollte sichergestellt sein, dass immer alle Member bekannt sind, auch wenn diese sich erst sp辰ter angemeldet haben. Auch
  ist zu hoffen, dass eine Klasse nicht zu h辰ufig initialisiert und wieder de-initialisiert werden muss, da dies eigentlich
  nur dann passieren kann, wenn eine Klasse zu fr端h initialisiert wird (auf das RTTI sollte also m旦glichst erst ab der
  Main-Funktion zugegriffen werden). Zudem f端hrt dieses System dazu, dass Klassen, auf die 端berhaupt gar nicht zugegriffen
  wird im Laufe des Programmes, auch niemals ihre Member initialisieren m端ssen, was ein zus辰tzlicher Gewinn ist :-)
- Class, Object: Methoden f端r den Zugriff auf alle Member hinzugef端gt (sowohl Listen aller Member sowie einzelne Member).



>> 07.04.2010 (PLCore2)
[SB]
- Klasse FuncDesc hinzugef端gt, welche einen Descriptor f端r Funktionen und Methoden innerhalb einer Klasse darstellt.
- RTTI-Makros f端r die Deklarations von Methoden hinzugef端gt.
- Klasse EventDesc hinzugef端gt, welche einen Descriptor f端r Events und Signals innerhalb einer Klasse darstellt.
- Klasse EventHandlerDesc hinzugef端gt, welche einen Descriptor f端r EventHandler und Slots innerhalb einer Klasse darstellt.
- RTTI-Makros f端r Events und EventHandlers hinzugef端gt. 
- Klasse Constructor wurde in FuncConstructor umbenannt, da dies auch nur ein spezieller Funtoid ist, der ein Objekt
  erzeugt.
- Neue Klassen Constructor und ConstructorDesc implementiert, welche sich analog zu Attributen und Methoden um die Deklaration
  von Konstruktoren in Klassen k端mmern. Constructor kann hier allerdings nicht komplett Analog zu den anderen genannten
  Klassen sein, da im Gegensatz zu Attributen und Methoden ein Constructor bei Class und nicht bei Object angesiedelt sein
  muss (ein Konstruktor wird von einer *Klasse* aufgerufen und gibt ein Objekt zur端ck, ein Constructor auf ein schon
  bestehendes Objekt anzuwenden, ergibt dagegen keinen Sinn). Daher unterscheidet sich die Klasse ConstructorDesc hier etwas
  von den anderen Konstruktoren, indem sie z.B. nicht nur den Konstruktor beschreibt (Name etc.), sondern gleichzeitig
  auch die Instanz des eigentlichen Konstruktor-Functoids beinhaltet. 
  so speichert bspw.
- RTTI-Makros f端r Konstruktoren hinzugef端gt.
- Methoden hinzugef端gt, um Instanzen von Klassen zu erzeugen:
  - ConstructorDesc stellt die Methode Create() zu verf端gung, welche den jeweiligen Konstruktor aufruft
  - Class hat drei weitere Create()-Methoden, mit denen alle Konstruktoren einer Klasse aufgerufen werden k旦nnen.
    Hier kann entweder der Default-Konstruktor aufgerufen werden, oder es wird entweder per Namen oder per Signatur nach
    einem bestimmten Konstruktor gesucht.



>> 06.04.2010 (PLCore2)
[SB]
- Event und EventHandler implementiert. Ein Event-Handler verh辰lt sich zun辰chst einmal genau so wie ein Funktor, stellt
  aber zus辰tzliche Funktionalit辰t bereit, die es erlaubt, Events und EventHandler miteinander zu verkn端pfen. Wenn ein
  Event ausgel旦st wird, werden automatisch alle angemeldeten EventHandler aufgerufen. Events und EventHandler wissen
  端ber gegenseitige Verbindungen bescheid, so dass Verbindungen automatisch entfernt werden, wenn eine der beiden Seiten
  beispielsweise gel旦scht wurde.
- Klassen Event und EventHandler so ver辰ndert, dass hier immer der R端ckgabetypus void festgelegt ist. W辰hrend bei generellen
  Functoiden und Functoren ein beliebiger R端ckgabetypus verwendet werden kann, ergibt dies bei Events nicht so richtig
  viel Sinn. Was soll beispielsweise ein Event zur端ckgeben, wenn mehrere EventHandler aufgerufen wurden und jeder davon
  einen anderen R端ckgabewert zur端ckgeliefert hat? Der Einfachheit halber haben daher nun alle Events und EventHandler den
  R端ckgabetyp void.
- Kommentierung f端r RTTI-Makros erweitert.



>> 05.04.2010 (PLCore2)
[SB]
- Statische Funktions-Pointer (FuncFuncPtr) und Memberfunktions-Pointer (FuncMemPtr) als Ableitung von Func implementiert.
  Diese Funktions-Pointer, welche die Basis f端r Functoren sind, verhalten sich also genau so wie andere Functoide, tragen
  intern aber einen Zeigen auf eine Funktion mit sich herum :-)
- Functor implementiert. Ein Funktor ist ein spezieller Typus eines Functoids, der einen Zeiger auf eine andere
  Funktion beinhaltet. Wenn der Functor aufgerufen wird, ruft er die jeweils gespeicherte Funktion auf, stellt damit
  also eine Art generischen Funktionspointer dar.
- Func: Virtuelle Methode Clone() hinzugef端gt, die ben旦tigt wird, wenn eine Kopie eines Functoids angefertig werden soll.
  Dies wird von Functor verwendet, wenn eine Funktion einem Functor zugewiesen oder ein Functor kopiert werden soll.
- Basisklasse Constructor von ClassConstructor entfernt, statt dessen ClassConstructor in Constructor umbenannt.



>> 04.04.2010 (PLCore2)
[SB]
- Attributen m端ssen nun immer mit einen Zeiger auf das Object initialisiert werden. Das w辰re zwar eigentlich nur f端r
  die Attribute notwendig, welche Get/Set-Methoden verwenden, aber dann w辰re das ganze inkonsistent, weil manche Attribute
  initialisiert werden m端ssten, andere aber nicht. Es scheint mir daher sinnvoller, dies bei allen Attributen einheitlich
  zu gestalten, zumal man manchmal auch aus anderen Gr端nden den Zeiger auf das Object gebrauchen kann.
- Variablen: Alle Klassen noch einmal durchgesehen und die Dokumentation 端berarbeitet.
- Functor: Basisklasse DynFunc erstellt, diese Klasse steht allgemein f端r alle typisierten Funktionen bzw. Funktionsobjekte.
- Functor: Basisklasse DynParams erstellt, diese Klasse stellt die Basis f端r typisierte Parameter dar.
- "Functor" in "Func" umbenannt und alle Klassen und Ordner angepasst.
- Funktions-Objekte (Functoide) und Konstruktoren implementiert.



>> 29.03.2010 (PLCore2)
[SB]
- Type: Es werden nun keine Funktions-Templates, sondern statt dessen normale Funktionen mit festgelegten Namen verwendet.
  Jeder Typ muss hier die Umwandlungs-Funktionen f端r alle bekannten statischen Typen zur Verf端gung stellen (ConvertToInt(),
  ConvertFromInt() etc.). Dies ist notwendig, da es ansonsten nicht m旦glich w辰re, Standardtypen wie z.B. int in nicht-standard
  Typen umzuwandeln, da es ja bspw. kein Type<int>::ConvertToMyType() gibt. 
- Klasse Types entfernt, welche zuvor verwendet wurde, um zwischen Type-ID und Type-Name umzuwandeln. Leider sind diesem
  Mapping nat端rlich die nicht-standard Typen unbekannt, weshalb das ganze System nicht sehr sinnvoll ist. Statt dessen hat
  nun jeder Typus die entsprechenden Methoden GetTypeID() und GetTypeName() zur Verf端gung zu stellen.
- Klasse Attribute in Var umbenannt.
- Klasse TypedVarDesc entfernt, da diese nicht wirklich notwendig ist zwischen VarDesc und VarDesc_VARNAME.
- Enumerations zum RTTI Typensystem hinzugef端gt.



>> 28.03.2010 (PLCore2)
[SB]
- Tools: Klasse CompileError erstellt. Dies ist ein Template, das verwendet werden kann, um Compiler-Fehler zu erzeugen.
  Hierbei gibt es zwei Versionen, das eine Mal wird der Fehler in jedem Fall erzeugt, das andere Mal h辰ngt dies noch
  von einer Kondition ab (es wird nur dann ein Fehler generiert, wenn eine bestimmte Aussage zutrifft).



>> 27.03.2010 (PLCore2)
[SB]
- Die Helferklassen f端r Access und Storage wurden umbenannt und in eigene Header-Dateien verschoben: TypedAttrAccess.h and TypedAttrStorage.h
- Template Signatur erstellt (dieses stellt den 'Typus' von Funktionen dar)
- Basisklasse f端r Functoide und Konstruktoren erstellt (noch lange nicht einsatzbereit)



>> 26.03.2010 (PLCore2)
[SB]
- Klassen, in denen keine Attribute definiert wurden, werden nun auch korrekt am System angemeldet.
- Attribute k旦nnen nun Default-Werte haben.
- Attribute k旦nnen nun als read/write oder read-only definiert werden.
- Attribute haben nun Zuweisungs- und Conversion-Operatoren. Man kann daher nun z.B. direkt
  'AttrInt = 3' oder 'int nValue = AttrInt' schreiben.
- Helferklassen eingebaut, um den Storage-Type eine Attributes festzulegen:
  - StorageDirectValue speichert den Wert eines Attributes direkt innerhalb einer privaten Variable.
  - StorageGetSet ruft zum Setzen oder Abfragen des Wertes die jeweilige Get- oder Set-Methode des Objektes
    auf, hier wird der Wert also nur indirekt gesetzt und keine eigene Variable instanziiert.
  Bis jetzt ist nur StorageDirectValue implementiert.
- Externer Storage-Type wurde implementiert. Hierf端r muss eine externe Klasse angegeben werden, welche die
  notwendigen Get()/Set()-Methoden f端r das jeweilige Attribut zur Verf端gung stellt. Diese Klasse wird dann
  vom Attribut verwendet, um auf den Inhalt der Variablen zuzugreifen, die eigentliche Speicherung der Daten
  kann innerhalb dieser Klasse also beliebig implementiert werden.



>> 25.03.2010 (PLCore2)
[SB]
- RTTI makros f端r Klassen und Attribute erstellt.
- Attr: GetDesc() wurde nun als virtuelle Funktion innerhalb der Basisklasse implementiert, somit ist es nun immer
  m旦glich, an den Descriptor zu gelangen, sobald man einen Zeiger auf ein Attribut hat.
- Class: Namespace und Description hinzugef端gt.
- ClassManager hinzugef端gt.



>> 24.03.2010 (PLCore2)
[SB]
- Erste einfache template-basierte RTTI Funktionalit辰t implementiert. Es ist bereits m旦glich, Attribute von Klassen
  zu definieren und auf diese zuzugreifen. Alles ist komplett template-basiert, bisher wurden noch keinerlei Makros
  verwendet (nat端rlich werden sp辰ter auch wieder Makros zur Verf端gung gestellt, um die Verwendung der Templates
  hinter einfacheren Konstrukten zu verstecken, aber die eigentlich Funktionalit辰t wird hoffentlich nur auf
  Templates basieren und keine Makro-Tricks mehr beinhalten wie z.B. Pointer-Arithmetik zum Ausrechnen von
  Speicheradressen o.辰.).
- Auflisten und Abfragen von Attribute-Descriptoren (bei der Klasse) und Attributen (beim Objekt) wurde implementiert.



>> 23.03.2010 (PLCore2)
[SB]
- Mit neuem System angefangen, daher erst einmal wieder in einem separaten Projekt (PLCore2), damit das alte PLCore
  zun辰chst einmal parallel erhalten bleiben kann, ohne dass es Konflikte gibt.
- Mit neuem RTTI begonnen, welches dieses Mal zum Groteil auf C++ templates basieren soll:
  - Type eingebaut als statischen Wrapper f端r die C++ Datentypen
  - Types ist eine statische Helfer-Klasse, die es bspw. erlaubt, Type-IDs in Strings umzuwandeln u.辰.
  - TypedAttr ist ein Class-Template f端r typisierte Attribute (also Variablen, die direkt einen Wert besitzen)
  - Attribute ist eine virtuelle Basisklasse f端r Attribute



>> 21.03.2010
[SB]
- HttpClient: Fehler bei der HTTP-Authentification behoben: Benutzername und Passwort wurden falsch 端bermittelt, wodurch
  eine Anmeldung nat端rlich nicht m旦glich war. Ausserdem wird nun auch das HTTP-Verb "DELETE" unterst端tzt.



>> 14.03.2010
[CO]
- "Config", "ConfigLoader" und "ConfigLoaderPL" nach PLCore ins Application-Verzeichnis verschoben (siehe PLCore-Tagebuch
  f端r mehr Informationen)
PLCore:
- "Config", "ConfigLoader" und "ConfigLoaderPL" von PLGeneral nach PLCore ins Application-Verzeichnis verschoben. Zuk端nftig
  sind "Konfigurationen" ausschlielich in Verbindung mit Application-Instanzen zu sehen. Ich konnte keinen Grund finden,
  wieso z.B. die Renderer-Klasse ein Konfigurations-Objekt haben sollte - daf端r kann man genauso gut einfache Funktionen
  und oder das RTTI nutzen! "Konfiguration" sind eigentlich ja nur dann Interessant wenn man als Anwendungs-Programmierer Einstellungen
  "von Auen" 端ber eine Text-Datei einstellbar haben will, oder Programm-Einstellungen wegspeichern und wiederherstellen will.
  Was es jedoch an relevanten Programm-Einstellungen gibt, weis eigentlich nur ein Anwendungs-Programmierer. Man kann schlecht
  *alles* was die einzelnen Komponenten an Variablen haben wegspeichern, das w端rde auch gar keinen Sinn machen. Als Anwendungs-Programmierer
  kann das sogar total l辰stig und unerw端nscht werden wenn die "Engine" von sich aus Dateien rausschreibt - denn es kann sehr wohl
  auch mal Anwendungen geben die sich rein passiv zu verhalten haben, also nur von einer Festplatte lesen sollen, aber nix schreiben
  oder gar neue Dateien anlegen.
  Das Application-Framework bring nat端rlich wieder so Konfigurations-Objekte rein, aber das ist ja alles als Vereinfachung gedacht so
  das man sich nicht mehr um alles k端mmern muss. Dies ist allerdings nicht fest in *PL verwurschtelt*, sondern man kann auch gut ohne
  diese Framework arbeiten und hat dann volle Kontrolle.
- "Config" ist kein Singleton mehr
- "Application" besitzt nun eine "Config"-Instanz. Das Konfigurations-System als solches ist also momentan noch so wie gehabt, nur das
  es kein Singleton mehr ist, sondern jede Application-Instanz eine eigene Konfigurations-Instanz besitzt. Des Weiteren nutzen nur noch
  Application-Instanzen Konfiguration und nicht mehr alle m旦glichen PixelLight-Komponenten. Dies stellt daher denke ich schonmal
  eine Verbesserung da.



>> 22.01.2010
[SB]
PLCore:
- Application::GetApplication(): Export in DLL hinzugef端gt.



>> 19.01.2010
[SB]
- ThreadLinux: Wie es aussieht, ist die Thread-Implementation unter Linux noch so gut wie unbrauchbar. Leider kenne ich
  mich mit dem Threading ja auch so gut wie nicht aus, und m端sste mich da nun enorm einarbeiten, um das irgendwie brauchbar
  zu machen. Die schlimmsten Fehler habe ich nun aber erstmal korrigiert bzw. umgangen:
  - pthread_kill(m_nThreadID, SIGKILL) ist *nicht* geeignet, um einen Thread zu beenden. Das Signal beendet immer den
    gesamten Prozess, auch wenn es an einen bestimmten Thread eines Prozesses gesendet wird. Daher wurde nun bei uns jedes
    Mal das gesamte Programm beendet, wenn nur ein Thread oder z.B. ein Timer beendet werden sollte. Zum Beenden eines
    Threads verwende ich nun pthread_cancel(). Diese Fehler hat nat端rlich dazu gef端hrt, dass das Programm st辰ndig "abst端rzte",
    nun macht das alles schon einen deutlich stabileren Eindruck unter Linux :-)
  - Es gibt keinen timed-join Befehl in pthreads, also einen Befehl der bis zu einem bestimmten Timeout darauf wartet, dass
    ein Thread beendet wurde. Statt dessen hatte ich hier bisher einfach join verwendet, also ohne Timeout zu warten, was dann
    aber zu einem Einfrieren der Applikation f端hrt, wenn sich ein Thread nicht freiwillig beendet. Daher lasse ich diese
    Funktion nun erst einmal komplett fehlschlagen, damit das zumindest nicht mehr passieren kann, hier m端sste dann eine
    timed-join Operation implementiert werden, wof端r ich auch schon ein Beispiel gefunden habe.



>> 30.11.2009
[SB]
- Neue und umfangreiche HTTP-Implementation erstellt. Dies umfasst sowohl einen HTTP-Client, als auch einen minimalen
  Http-Server. Der Client ist um einiges umfangreicher als die alte HttpHandle-Klasse und kann HTTP/1.0 sowie HTTP/1.1.
  Damit ist auch die "Download fortsetzen"-Funktion m旦glich, bzw. das auslesen beliebiger Teile einer Datei, sofern der
  Server das zul辰sst, was die Verwendung der File-Klassen und Seek() einfacher und vor allem deutlich schneller machen
  sollte. Auch ist die Klasse ansonsten umfangreicher, z.B. werden alle HTTP-Fehlercodes verstanden und k旦nnen entsprechend
  abgefragt werden etc. Daneben gibt es noch einen sehr minimalistischen HTTP-Server, der dazu verwendet werden kann, aus
  einem Programm heraus z.B. eine kleine Weboberfl辰che zur Verf端gung zu stellen. Die Server-Klasse ist dabei eine reine
  Basisklasse, die HTTP-Anfragen entgegennimmt und weiterleitet, von sich aus aber erstmal nur eine statische Seite
  anzeigt. Die eigentliche Funktionalit辰t muss also in der abgeleiteten Klasse implementiert werden, z.B. was f端r
  Seiten auf welche URLs hin generiert werden sollen. Auch ist dies kein HTTP-Server in dem Sinne, dass er Dateien von
  der Festplatte lesen und auf HTTP bereitstellen w端rde, da der Anwendungsfall eher auf dynamisch generierte Web-Applikationen
  abzielt (z.B. als Weboberfl辰che f端r einen Spiele-Server). Allerdings w辰re es recht einfach, dies in einer abgeleiteten
  Klasse zu implementieren :-)



>> 29.11.2009
[SB]
- Time: Die Monate werden nun von 1 an gez辰hlt, statt wie bisher von 0. Es ist einfach v旦llig unintuitiv, wenn nur die
  Monate ungewohnt bei 0 anfangen, der Rest aber wie gewohnt von 1 an gez辰hlt wird. Habe das nun daher ver辰ndert und hoffe,
  dass ich alle Verwendungen in PL entsprechend korrekt angepasst habe (-1 entfernt wo n旦tig und +1 hinzugef端gt wo n旦tig).
  Allerdings wurde die Time-Klasse zum Gl端ck bisher nicht so h辰ufig verwendet, es d端rften also wohl nicht allzu viele
  m旦gliche Fehlerstellen jetzt vorhanden sein.



>> 25.10.2009
[SB]
- Base64-Funktion nach Tools verschoben, da man diese Funktion sp辰ter noch einmal brauchen k旦nnte.



>> 24.10.2009
[SB]
- Connection: Mir ist gerade aufgefallen, dass es nicht unbedingt immer erw端nscht ist, dass eine Connection automatisch alle
  Daten ausliest, die man ihr zuschicken will. Beispielsweise bei einem HTTP-Client w端rde man wohl erst den Header lesen,
  und dann entscheiden, ob man die Daten ausliest oder nicht (k旦nnten ja auch groe Dateien sein). Aus diesem Grund kann
  nun per Option eingestellt werden, ob eine Connection automatisch alles liest, was ihr geschickt wird, oder ob dies
  manuell aufgerufen werden muss. Daf端r die Option EReceiveMode sowie die Methoden Receive() und ReadLine() eingebaut.
  ReadLine liest Text-Daten vom Stream und gibt diese Zeilenweise zur端ck. Dabei wird das EOL-Zeichen nicht automatisch gel旦scht,
  da dies in manchen Kontexten wichtig ist, dies muss daher ebenfalls manuell geschehen. Ebenso wird nun beim Senden von
  Strings (Send()) nicht mehr automatisch CRLF angeh辰ngt, da dies auch nicht immer erw端nscht ist. F端r Zeilenenden ist nun
  also die jeweilige Anwendung selbst verantwortlich.
- Buffer: Einige Fehler behoben. Beim zeilenweisen Auslesen werden nun sowohl CRLF als auch nur LF als Zeilenenden akzeptiert.
  Zus辰tzliche Methode GetData() eingebaut, damit man auch auf den Inhalt des Buffers zugreifen kann.



>> 23.10.2009
[SB]
- Network: Habe die Basisklassen aus PLNetwork nach PLGeneral verschoben und noch einmal gr端ndlich 端berarbeitet.
  Es scheint mir sinnvoll, diese Basisklassen bereits in PLGeneral zu haben, denn mit Sockets alleine zu arbeiten
  ist ziemlich m端hsam und nicht sinnvoll, deswegen sollten immer diese Basisklassen verwendet werden, wenn es darum
  geht, Netzwerkfunktionalit辰t einzubauen. Daher ergab die Trennung hier nicht viel Sinn, und eine weitere Bibliothek
  zu verwenden stellt immer eine zus辰tzliche H端rde dar, daher ist es besser, diese Klassen gleich in PLGeneral verf端gbar
  zu haben. Die Netzwerk-Basisklassen bieten selber nur ein minimales Framework um Socket herum an, und durch die
  berarbeitung wurde auch alles noch einmal deutlich schlanker und eleganter, so dass letztlich nur 5 zus辰tzliche
  Klassen herausgekommen sind, die PLGeneral daher auch nicht unn旦tig aufbl辰hen sollten :-)
PLNetwork:
- Netzwerk-Basisklassen nach PLGeneral verschoben. Dieses Projekt ist damit zwar erstmal leer, bleibt jedoch erhalten,
  da ich mir sicher bin, das man daf端r sp辰ter noch Verwendung haben wird. Beispielsweise k旦nnten hier Basisklassen
  f端r typische Netzwerk-Komponenten erstellt werden (z.B. Messenger, Chat, ...), welche dann von spezialisierten Backends
  wie PLIRC oder PLJabber implementiert werden. Auch wird es nat端rlich Basisklassen f端r die Netzwerksynchronisation brauchen,
  welche sp辰ter die Grundlage f端r die tats辰chliche Netzwerkfunktionalit辰t in der Engine bieten wird. Daher ist es denke
  ich sinnvoll, dieses Projekt gleich beizubehalten, wenn es auch derzeit nicht genutzt wird.



>> 22.10.2009
[SB]
- String: Neue Methode RemoveLineEndings() eingebaut, die Markierungen f端r das Zeilenende ("\r" oder "\r\n") am
  Endes des Strings l旦scht. Das ist insbesondere dann wichtig, wenn in einem Netzwerkprotokoll die Zeilenenden
  entscheidend sind und daher Strings nicht gleich "bereinigt" werden sollten.
PLNetwork:
- Buffer: Option m_bRemoveDelimiters hinzugef端gt. Damit kann festgelegt werden, ob die Zeilenenden in einem
  Protokoll automatisch entfernt werden sollen, oder in den zur端ckgegebenen Strings drin bleiben sollen. In manchen
  Protokollen ist es wichtig, dass diese Zeichen nicht entfernt werden, da z.B. eine Leerzeile eine besondere
  Bedeutung hat. Wenn die Zeilenenden aber entfernt werden, k旦nnte nicht mehr zwischen eine leeren Zeile ("\r\n") und
  einem leeren String ("") unterschieden werden, der zur端ckgegeben wird um anzuzeigen, dass noch keine weitere Zeile
  gelesen wurde.



>> 20.10.2009
[SB]
- Time: Neue Methode GetDaysPerMonth() spendiert, um die Anzahl an Tagen in einem Monat abzufragen.



>> 18.10.2009
[SB]
- Habe meine alte Klasse 'HMLTParser' vom letzten Jahr wieder ausgegraben und reaktiviert :-) Diese Klasse hatte ich
  geschrieben, damit man eine HTML-Datei parsen und als Ergebnis einen XML-Syntaxbaum herausbekommen kann. Zwar hatte
  ich dann die gesamte HTML-Anwendungsidee verworfen und in dem Zusammenhang auch den Parser wieder gel旦scht, aber
  da ich nun wieder einmal merke, wie praktisch es ab und zu w辰re, HTML-Dateien einlesen zu k旦nnen, habe ich die
  Klasse nun wiederhergestellt und noch ein wenig erweitert sowie ein paar Fehler behoben. Der Parser selbst sollte
  nun relativ robust sein, allerdings besteht nat端rlich immer noch keine Garantie daf端r, dass er in der Lage ist, eine
  beliebige HTML-Seite fehlerfrei einzulesen. Daf端r ist der HTML-Syntax viel zu un端bersichtlich und es gibt zu viele Arten
  von Erweiterungen 端ber eingebettete Scripte etc. Nun werden allerdings Kommentare und einige andere Tags von vornherein
  ignoriert, daher d端rften einiger Maen wohlformatierte Seiten jetzt eigentlich problemlos eingelesen werden k旦nnen. Also
  falls man mal in irgendeinem Zusammenhang HTML-Seiten einlesen bzw. parsen muss, gibt es daf端r nun eine Klasse, die man
  als Basis daf端r verwenden kann.



>> 16.10.2009
[SB]
- FileObject und Url: Methoden f端r den Zugriff auf URLs 端berarbeitet. GetUrl_() in GetUrl() umbenannt, da denke ich die
  Verwendung und Bedeutung dieser Methode inzwischen klar festgelegt ist. In FileObject alle "Abk端rzungen" entfernt,
  um direkt auf den Dateinamen zuzugreifen, es muss nun also immer GetUrl() verwendet werden und von dort aus weitere
  Methoden, um die URL als String zu erhalten. Ich bin mittlerweile ein Freund davon, keine unn旦tigen doppelten Funktionen
  irgendwo einzubauen, sondern lieber klar nur eine M旦glichkeit zur Verf端gung zu stellen. Das sieht zwar manchmal nicht so
  h端bsch aus, ist daf端r aber verst辰ndlicher und leichter nachzuvollziehen. Schlielich GetWindow(), GetLinux() etc. wieder
  in GetWindowsPath(), GetLinuxPath() etc. umbenannt, denn der Name sollte schon irgendwie darauf hindeuten, was dort
  zur端ckgegeben wird (auch wenn "Path" nicht ganz korrekt ist, aber hier fehlt es halt an einem eindeutigen berbegriff f端r
  Pfade, URLs etc.).



>> 03.09.2009
[CO]
PLCore:
- "Event::Emit()": Der Zeiger auf den n辰chsten Event Handler wird nun auf dem Stack zwischengespeichert bevor der Functor
  aufgerufen wird... da man damit rechnen muss das innerhalb des Functors der aktuelle Event Handler gel旦scht wird sollte
  man diesen dann nach dem Functor nicht mehr nutzen. Damit ist es nun m旦glich in Functoren soweit problemlos Event Handler
  w辰hrend eines Emits zu l旦schen - neue hinzuf端gen wird nat端rlich je nach Situation immer noch f端r Anomalien sorgen.
  (aber wohl weniger wahrscheinlich welche die in Crashs resultieren :)



>> 26.08.2009
[CO]
PLCore:
- "TimerWindows::TimerFunction()": Ich hatte hier gerade das Problem das ein "einmalig Feuern Timer" mehrmals feuerte...
  kann mir das noch nicht richtig erkl辰ren, aber wenn ich in der Callback Funktion hier ZUERST den Timer stoppe und dann
  das Event abgebe geht das hier momentan. Seltsam seltsam...



>> 06.08.2009
[CO]
- "uint32" wird nun mit "__int32" definiert, das gleiche gilt f端r alle 辰hnlichen Typen
- "HashFunction" & "CompareFunction" um 64 Bit Datentypen erweitert... ansonnsten gibts Probleme wenn man in einer
  HashMap als Schl端ssel z.B. "UINT_PTR" unter 64 Bit nutzen will, dann weis der Compiler nicht was er nehmen soll



>> 02.08.2009
[CO]
- "RegEx": Neue Funktion: "WildcardToRegEx()": Wandelt einen gebenen String mit Wildcard in einen String mit Regul辰ren
  Ausdruck um
- "Map": "GetKeyIterator()", "GetConstKeyIterator()", "GetEndKeyIterator()" & "GetConstEndKeyIterator()" hinzugef端gt
  damit man bei "Map" ebenfalls durch die Schl端ssel iterieren kann
- "HashMapKeyIterator" & "SimpleMapKeyIterator" hinzugef端gt



>> 20.06.2009
[SB]
PLCore:
- CMakeFiles.txt: TimerWindows darf aber bittesch旦n auch nur unter Windows eingebunden werden :-)



>> 17.06.2009
[CO]
PLCore:
- "Timer", "TimerImpl", "TimerWindows" und "ThreadTimer" von PLGui3 hierhin kopiert, aber in PLGui3 noch genauso drinnen
  gelassen. Habe die Klassen erstmal in den Grundordner gelegt da mir kein brauchbarer Name f端r einen Unterordner einfiel
  - da kommen ja noch einige Klassen bei Zeiten hinzu und dann findet sich sicherlich ne nette Gruppe der sich der Timer
  anschlieen kann. :D
  Da "ThreadTimer::Run()" in einem Thread l辰uft kann der Timer allerdings zu jeder Zeit feuern... etwas das sicherlich
  schnell Problematisch werden kann. Eventuell w辰re ne art von "TimerManager"/"TimerScheduler" Klasse nett 端ber die
  man die Timer Synchronisieren kann... also quasi in der Art "So Leute, wer bereit ist - FEEEUER!". *g*
  Was beim Threaded Timer auch noch ein Problem ist, ist das "Stoppen" da die genutzte "Sleep()" nicht unterbrochen
  wird und der Timer erstmal ablaufen muss.
- "ThreadTimer::StartTimer()" und "ThreadTimer::StopTimer()": Der Thread wird hier gestartet und "abgew端rgt", damit
  wird der Timer bei stop sofort angehalten. Damit verh辰lt es sich wie "TimerWindows". Ich hatte mir zuerst die
  Windows Funktion "QueueUserAPC()" angeschaut aber irgendwie wurde das zuviel des guten.



>> 03.06.2009
[CO]
PLCore:
- "Application": Neue Funktion "IsRunning()" gibt zur端ck ob die Anwendung gerade l辰uft



>> 10.05.2009
[CO]
- "ZipHandle::ReadCurrentFileInfo()": Autsch, hier hatten wir ein 端bles Speicherleck wenn "m_cCurFile.m_nSizeFilename"
  0 war... denn hier muss noch ein Zeichen f端r \0 angeh辰ngt werden. Die String Klasse 端bernimmt dann die Kontrolle
  端ber den Speicher, bekommt aber die Original Speicherl辰nge ohne +1 und denkt sich dann "hopala, leerer String!"
  und 端bernimmt dann nat端rlich nicht die Speicherkontrolle da der Speicher ja scheinbar leer ist. Und dann m端llt
  sich der Speicher langsam mit Herrenlosen fr端hlich frei herumschwirrenden 1 Bytes voll.
- "ClassManager::LoadPlugin()" sollte auch mehrmals aufgerufen werden k旦nnen ohne das es bereits vorhandene
  Module erneut hinzuf端gt, baute daher einen entsprechenden Test ein.



>> 07.05.2009
[CO]
- "BinaryHeap", "BinominalHeap" und "FibonacciHeap" hatten Fehler so das der Compiler einem kryptische Fehler nur
   so um die Ohren schlug wenn man versuchte den "Comparer" durch einen eigenen zu ersetzen



>> 01.05.2009
[CO]
- "Bitset"-Konstruktor: Beseitigte eine Inkonsistenz zu "Array" und "Resize()": Die Standardeinstellungen von
  "bAdded" und "bInit" sind nun identisch. "Bitset" wird bis jetzt zum Gl端ck sehr selten eingesetzt so das es
  nur wenige Stellen waren die einer Pr端fung bedurften. (nderung dieser Art sind ja immer sehr heikel :/)
- "Bitset" um superkomplexe "Reset()"-Funktion die es ebenfalls auch in "Array" gibt erweitert... setzt einfach
  die aktuelle Anzahl an Elementen auf null so das es einem "Clear()" gleichkommt, aber deutlich schneller ist da
  der angelegte Speicher erhalten bleibt. (hin und wieder sehr praktisch soetwas :)



>> 26.04.2009
[CO]
- "SystemWindows::GetOS()" erkennt nun auch Windows 7



>> 22.04.2009
[CO]
- nderte einige Methoden der String-Klasse minimal so das die heute von Stefan festgestellten unsch旦nheiten beseitigt sind



>> 22.04.2009
[SB]
- RegEx: Workaround eingebaut, da String::Copy() mit der L辰nge 0 den gesamten String zur端ckgibt anstelle der leeren Strings ("").
  Ich denke dies sollten wir dringend 端berarbeiten, denn dieses Verhalten ergibt zwar Sinn, wenn man 0 nur als Defaultwert,
  sprich als "nicht angegeben" betrachtet, verhindert aber, dass man den Wert 0 als tats辰chliche L辰nge eines Substrings angeben
  kann. Und dies f端hrt zu einem sehr ungew旦hnlichen Verhalten, denn wenn ich z.B. alle Prefixes alles Strings mit sowas wie
  for (int i=3; i>=0; i--) sPrefix = sString.GetSubstring(0, i); abfrage, w端rde ich wohl eher ["abc", "ab", "a", ""] erwarten
  als ["abc", "ab", "a", "abc"] (siehe Test99).



>> 22.04.2009
[CO]
- "File": Neue Funktion: "GetMemoryBuffer()": Falls die Datei "im Speicher liegt" kann man sich hiermit direkt einen Zeiger auf
  den Speicher geben lassen. Ist zwar irgendwie "unsch旦n" aber "praktisch" da man dadurch in einigen F辰llen die Performance
  in Anwendungen verbessern kann... denn wenn man "weis" das eine Datei bereits komplett im Speicher liegt und man die Datei im
  Speicher braucht um diese mit anderen Funktionen weiterzuverarbeiten - dann muss man nun nicht mehr einen "Zwischenbuffer"
  erzeugen, die ganze Datei "einlesen", Arbeit erledigen und "Zwischenbuffer" wieder freigeben... sondern man nutzt direkt
  den bereits die bereits im Speicher liegende Datei. :D



>> 16.04.2009
[SB]
PLPlugin:
- Fehlende Abh辰ngigkeiten in der CMakeLists.txt hinzugef端gt.



>> 15.04.2009
[CO]
- Spendierte der "File"-Klasse einen weiteren Konstruktor dem man einen Buffer 端bergeben kann... was hin und wieder
  ziemlich praktisch ist da "Dateien" dann nicht zwanghaft direkt von der Festplatte kommen m端ssen.
- "Base::SetVars()": In meinem Regul辰ren Ausdruck war noch ein b旦ser Fehler drinnen so das beim Wert ' am Ende stehen konnte...
  generell hab ich hier noch etwas Probleme mit " und ' richtig erkennen und habe das momentan etwas umst辰ndlich gel旦st -
  Stefan... falls du ne Idee hast wie man das alles zusammen in einem netten Ausdruck vereinen k旦nnte... :D



>> 12.04.2009
[SB]
- System: Exit() hinzugef端gt, um die Applikation sofort beenden zu k旦nnen. Dies ist nat端rlich nur ein Wrapper f端r die jeweilige Systemfunktion.
PLCore:
- Application: Neue Methode OnKill() hinzugef端gt, die aufgerufen wird, wenn das Betriebssystem versucht, die Applikation zu beenden. Standardm辰ig ist
  diese Methode so implementiert, dass sie sofort Exit() aufruft und die Applikation damit zwangsweise beendet. Durch berschreiben dieser Methode kann
  aber z.B. daf端r gesorgt werden, dass erst einmal die aktuelle Aufgabe zu Ende gebracht wird und sich die Applikation hinterher ordentlich beendet.
- Application: Unter Linux wird nun das Signal SIGTERM aufgefangen und dann die Methode OnKill() aufgerufen.
- Application: Zugriffsmethoden f端r die Versions-Variable hinzugef端gt.
- Application: Einen statischen Pointer auf die aktuelle Application-Instanz hinzugef端gt. Wenn es anders geht, sollte dies zwar nicht unbedingt verwendet
  werden, aber solange man darauf achtet, immer nur *eine* Application zur Zeit zu haben, bietet dies nun eine sehr einfach Methode, um schnell an diese
  wichtige Application-Instanz und damit auf alle anderen Dinge darin heranzukommen :-)



>> 11.04.2009
[SB]
- CommandLine erweitert, um m旦glichst viele der 端blichen Kommandozeilen-Optionen abzudecken. Ich hoffe mal, mit dieser
  aufgebohrten Klasse kommt man weit genug und kann auch komplizierte Kommandozeilen-Optionen definieren, damit man da
  m旦glichst nicht st辰ndig wieder einen eigenen Parser schreiben muss. Es g辰be nat端rlich noch viel mehr M旦glichkeiten, aber
  alles abzudecken w辰re wirklich zu kompliziert und daher nicht mehr sinnvoll. Auch ist zu beachten, dass diese Klasse nun
  zwar vieles erlaubt, aber nicht alles auch auf Plausibilit辰t pr端ft (z.B. beim Festlegen von ben旦tigten und optionalen
  Parametern). Hier muss der Programmierer also noch selber darauf achten, dass er nicht unsinnige oder wiederspr端chliche
  Angaben macht. Die nderungen im Detail:
  - Es gibt nun drei Typen von Optionen: Flags, Parameter und Argumente.
  - Ein Flag besteht nur aus einer Option (z.B. '-a' oder '--optiona') ohne weiterem Argument dahinter und
    kann einen kurzen sowie einen langen Namen haben.
  - Ein Parameter besteht aus einer Option und einem Argument dahinter (z.B. '-n <name>' oder '--name <name>').
    Die M旦glichkeit, dass dieses Argument optional ist, besteht *nicht* (ich finde aber auch nicht, dass man das braucht).
  - Ein Argument wird ohne ohne Option davor angegeben (z.B. "app.exe <name>"). Hierbei werden die registrierten Argumente
    der Reihe nach durchgez辰hlt, das erste angegebene Argument entspricht dem ersten in der Liste usw. Alle weiteren
    端bergebenen Argumente werden in einer zus辰tzlichen Liste gespeichert und k旦nnen 端ber GetAdditionalArgument() abgefragt
	werden.
  - Alle Optionen k旦nnen nun einen logischen Namen bekommen, z.B. "Name" f端r "-n" oder "--name". Das macht das Abfragen
    der Optionen einfacher und erlaubt es auch, die Flags sp辰ter zu ver辰ndern aber den logischen Namen dabei beizubehalten,
    wodurch man weniger im Code 辰ndern muss. Bei Parametern wird dieser Logische Name auch in der Hilfe mit angezeigt
    (z.B. --name <name>).
  - Optionen k旦nnen nun zus辰tzlich noch als "Required" definiert werden. In diesem Fall wird es als Fehler gewertet, wenn
    die jeweilige Option beim Starten des Programmes nicht angegeben wurde, weshalb dann das Programm nicht gestartet und
	statt dessen der Hilfetext ausgegeben wird.   
  - CommandLine::ShowHelp() an die nderungen angepasst und erweitert. Alle Parameter werden geordnet angezeigt, unterteilt
    in Argumente und Optionen. Habe mich dabei an m旦glichst 端bliche Darstellungen gehalten, z.B. steht <arg> f端r ein
    ben旦tigtes Argument, [arg] f端r ein optionales. Am Anfang wird eine kurze Zusammenfassung (Synopsis) ausgegeben, hierbei
    wird auch der Dateiname des Programmes mit ausgegeben.
PLCore:
- Application: An nderungen von CommandLine angepasst.



>> 10.04.2009
[CO]
- "Loader::OpenFile()"-Implementation etwas ge辰ndert so das weniger "File::IsFile()" aufrufe gemacht werden
 (langsam da Datei zugriff)
- "RegEx" etwas optimiert: "m_lstGroups" ist nun ein "Array", dadurch kann man von der schnellen "Reset"-Methode
  profitieren
- "Base::SetVars()" arbeitet nun mit Regul辰ren Ausdr端cken statt mit dem Tokenizer... und ist laut meinen intensiven
  Benchmarks die ich momentan betreibe sogar deutlich flotter. ("246 ms" statt "356 ms" Ladezeit in einem Projekt
  mit gr旦erer Szene :)
  "static RegEx ..." mag zwar nicht Thread-Safe sein, aber das ist PixelLight in seiner Gesammtheit derzeit ohnehin
  nicht und das Beschleunigt die Sache. (ohne "static" beim Projekt von oben "280 ms"... und hier kommts wirklich
  knadenlos auf jede Millisekunde an :/)



>> 08.04.2009
[CO]
- Da das RTTI so grundliegend ist und sehr intensiv genutzt wird machte ich ein paar vorsichtige Optimierungen um
  soviel Performance wie m旦glich rauszuholen. (muss leider sein :/) Die nderungen hab ich einige male durchdacht
  und genau gepr端ft damit ich blos nix klaput mache... Stefan, bitte zur Sicherheit auch nochmal 端berfliegen.
- "ClassManager::RegisterClass()": Das langsame durchgehen der 'm_lstClasses'-Liste ob die Klasse schon
   Registriert ist kann man sich sparen, 'm_mapClasses'-Test reicht v旦llig... + der Listen-Test brachte in
   meinen Tests immer das gleiche Ergebniss (nicht in Liste)
- "Class::HasBaseClass()": Hier braucht man keine Klassen-Namen vergleichen sondern kann direkt Klassen-Zeiger
   vergleichen, in der "String"-Variante wird der Test direkt Implementiert um einen Funktionsaufruf zu sparen
- "Base::IsInstanceOf()": Hier braucht man keine Klassen-Namen vergleichen sondern kann direkt Klassen-Zeiger
   vergleichen, in der "String"-Variante wird der Test direkt Implementiert um einen Funktionsaufruf zu sparen



>> 05.04.2009
[CO]
- "Tokenizer::StreamIsString()" nach "BufferedReader::IsString()" verschoben, dadurch kann man ein internes
  'GetSubstring()' nur f端r String vergleichen vermeiden (... performance...)
- "Tokenizer::StreamRead()": "m_nPosition++" aus der Schleife gezogen und zu "m_nPosition += nCount" gemacht
- "Tokenizer": "EndOfLine"-Definition f端r "\n" hinzugef端gt damit man statt 'm_sEndTag = "\n"' einfach
  "m_sEndTag = EndOfLine" schreiben kann was um einiges Effizienter ist da keine dynamische Speicherbehandlung :D
- "String": Das zuweisen von "char" oder "wchar_t", sprich einzelnen Zeichen optimiert so das wenn die Situation
  es zul辰sst man keine dynamische Speicherbehandlung braucht
- "String": "GetChar()", "GetWideChar()", "GetInt()", "GetLong()", "GetFloat()" und "GetDouble()" Implementation
  端berarbeitet damit so effizient wie m旦glich (keine xxx Funktionsaufrufe etc.)
- "StringBufferUnicode" & "StringBufferUnicode" & "StringBufferUTF8": Entfernte die "GetString()"-Methode da im
  grunde nur ein Umweg (= balast) in einem String-System das 'sehr eng verdrahtet' ist



>> 27.03.2009
[CO]
- "Bitset": Neue Funktion: "GetNumOfSetBits()": Gibt die Anzahl der auf "true" gesetzten Bits zur端ck



>> 25.03.2009
[CO]
- "Loader::OpenFile()" muss es nat端rlich auch erlaubt sein Dateien beim Speichern neu zu erzeugen, hm, merkw端rdig das dies
  bis jetzt noch nicht aufgefallen war...
- "Loader::OpenFile()" sollte nat端rlich auch ohne eingetragene "Basis Pfade" funktionieren, tat es aber bis jetzt nicht



>> 11.02.2009
[CO]
- Bitset: 'GetNumOfIntegers()' & 'GetIntegers()' hinzugef端gt damit man an die interne Datenrepr辰sentation rankommt...
  was hin und wieder hilfreich sein kann...



>> 06.02.2009
[CO]
- 'DynLib': Neue Funktion 'GetAbsPath()' -> Gib den absoluten Pfad der geladenen Dynamischen Bibliothek zur端ck



>> 30.01.2009
[CO]
- 'Singleton': 'DestroyInstance()'-Funktion hinzugef端gt mit der man manuell die Zerst旦rung der Singleton-Instanz
  'befehlen' kann. Da das Singleton normalerweise erst 'gaanz am Ende automatisch' zerst旦rt wird kann es zu
  problemen kommen wenn man eine Anwendung schreibt die in eine andere Eingebettet ist... + so kann man nie die
  von VC angebotenen Speicherleck Tests nutzen da dann immer angemeckert wird es g辰be ein Speicherleck da die
  Singletons erst nach dem Test freigegeben werden. Auf dauer sollten wir versuchen soweit m旦glich komplett auf
  Singletons zu verzichten... (einfach weil man nicht wirklich Kontrolle 端ber erzeugung und l旦schung hat :/)



>> 26.01.2009
[SB]
- ChunkLoaderPL: Fehler behoben, wodurch sich das Projekt unter Linux nicht mehr 端bersetzen lie.
  Statische Member einer Klasse m端ssen *immer* in einer .cpp Datei definiert werden, da diese als
  Symbol exportiert werden. Nur im Header einf端gen reicht nicht aus, da dann ein "undefined external
  symbol"-Fehler ausgel旦st wird, wenn von ausserhalb der Projektes versucht wird, auf dieses Symbol
  zuzugreifen. Also bitte bei statischen Members immer eine Definition in einer .cpp Datei hinzuf端gen
  (einzige Ausnahme sind Templates, da der Compiler das hier automatisch macht), oder statt dessen enums
  verwenden.



>> 25.01.2009
[CO]
- 'GetHexValue()' aus einem von Stefans Projekten nach 'ParseTools::ParseHexValue()' verschoben da man das durchaus 旦fters mal brauchen kann



>> 22.01.2009
[CO]
- 'Chunk'-Klasse hinzugef端gt die z.b. zum speichern von Keyframes genutzt werden kann



>> 14.01.2009
[SB]
- FileLinux: Die Klammerung war hier falsch, weshalb Verzeichnisse nicht mehr richtig erkannt wurden. Darum funktionierte PLProject nicht
  mehr richtig. Habe hier gleich die Fehlermeldungen ein wenig erweitert. Keine Ahnung, warum das noch nicht fr端her aufgefallen ist ...



>> 01.01.2009
[CO]
- 'Timing::CheckUpdate()': Hier kann man nun optional einen Parameter 端bergeben der im Falle eines FPS Limits zur端ckgibt wie lange man noch
  warten muss bis es Zeit f端r das n辰chste Update ist. So kann man direkt diesen Wert f端r 'Sleep' nutzen anstatt '1'.
- 'Timing::Update()': FPS Limit wird nun auch ausgef端hrt wenn gerade 'freezed' aktiv ist



>> 03.12.2008
[SB]
PLCore:
- Neue Config-Klasse f端r PLCore hinzugef端gt und erst einmal nur die Einstellung "LoadLibsFromRuntime" aus PLEngine hierher verschoben.
  Ansonsten hat man das Problem, dass eine Applikation, die noch nicht von PLEngine abh辰ngig ist, auch diese Option nicht kennt und daher
  nicht die Plugins im PL-Runtime sucht. Daher muss diese Einstellung so fr端h wie m旦glich kommen, damit ist das Problem erstmal behoben.
  Jetzt m端ssen wir m旦glichst schnell die ganze Config-Problematik nochmal sauber angehen, ansonsten haben wir bald ein echtes Problem ...
PLPlugin:
- BasicSceneApplet entfernt. Dies w辰re eine totale Verkomplizierung, wenn man hier nochmal eine extra Ableitungshierarchie
  aufmacht. Und damit k旦nnte dann immer noch nicht eine Applikation zwischen Plugin und Exe 'geteilt' werden.
- Statt dessen hat PluginPixelLight nun direkt einen Zeiger auf eine Applikation, die dann eingebettet wird. Dank der
  nderungen am Application-Framework kann nun generell jede Applikation (ab GuiApplication) in fremde Fenster eingebettet
  werden, dies wird hier nun einfach verwendet. Es wird eine Application wie gewohnt instanziiert, dann wird aber nicht
  Run() aufgerufen, sondern die Applikation in das Plugin-Window eingebettet. Als Test habe ich die Teapot-Application
  verwendet, die Application kann aber jetzt ganz einfach ausgetauscht werden.



>> 03.12.2008
[CO]
PLCore:
- "64 Bit 'Bugfix': Core::GetRuntimeDirectory()" vom "25.08.2008" r端ckg辰ngig gemacht da Windows das
  'normalerweise' Automatisch macht.
  Im 3ds Max Scene Exporter muss der alte Hack drinnen bleiben da man auf einem 64 Bit OS ein 32 Bit PL SDK
  Installieren kann... und dann ein 64 Bit 3ds Max nutzt, das sucht dann nach dem Registry Eintrag um automatisch
  feststellen zu k旦nnen wo der PLSceneViewer liegt - und findet das dann nat端rlich nicht da es in einem
  "Magischen" 'Wow6432Node'-Unterordner abgelegt wurde. :D
PLPlugin:
- 64 Bit VC Projekt Einstellungen hinzugef端gt
PLPluginMozilla:
- 64 Bit VC Projekt Einstellungen hinzugef端gt



>> 29.11.2008
[CO]
- Var: 'GetFlagsFromString()' & 'GetStringFromFlags()' public gemacht da man diese Funktionalit辰t auch von auen brauchen kann
- Da wir 端berall 'PL_VAR_FLAGS' als 'uint32' handhaben stellte ich die paar Stellen die 'int' nutzten hier auch auf 'uint32' um... macht nicht
  wirklich einen unterschied da beides 32 Bit, aber so ists konsequent. :D



>> 16.10.2008
[CO]
PLPlugin:
- Projekt ist wieder 端bersetzbar, aber noch nicht wirklich wieder lauff辰hig. 'PL::Init()' etc. gibts nun nicht mehr, habe erstmal
  BasicSceneApplet angelegt - eine Klasse von 'BasicSceneApplication' abgeleitet die als 'Applet' fungieren soll.



>> 29.09.2008
[SB]
PLCore:
- Application: Verwaltung von Kommandozeilen-Optionen durch eine Instanz von CommandLine hinzugef端gt. Es werden ausserdem gleich
  einige Standardoptionen hinzugef端gt: "--version" zeigt Programmname und Version an, "--help" zeigt alle zur Verf端gung stehenden
  Optionen an. Das Verhalten dieser Kommandos kann wie 端blich 端ber virtuelle Funktionen 端berschrieben werden.
  Ich m旦chte es hier dem Programmierer so einfach wie m旦glich machen und ausserdem daf端r sorgen, dass PL-Applikationen
  gleich so viel Komfort wie m旦glich bieten. Oftmals st旦t man auf Programme, wo alles gut gemacht ist, aber dann fehlen solche
  Standarddinge wie "--version" oder Kommandozeilenoptionen 端berhaupt. Bei PL ist das nun gleich standardm辰ig drin, es sei denn
  ein Programmierer baut dies bewusst wieder aus, was nat端rlich auch m旦glich sein sollte (CommandLine.Clear()). 



>> 28.09.2008
[SB]
- CmdLineParser durch die neu implementierten Klassen CommandLine und CommandLineOption ersetzt. Das Prinzip bleibt zwar
  das gleiche, die Schnittstelle von CommandLine entspricht jedoch mehr unserem 端blichen PL-Style als dies bei CmdLineParser
  der Fall war. So k旦nnen bspw. die einzelnen Optionen 端ber die Methoden AddOption und AddFlag hinzugef端gt werden, anstatt wie
  bisher alles in einen recht kryptischen String zu packen, der erst einmal geparsed werden musste. Optionen, die sowohl einen
  kurzen als auch einen langen Namen haben, geh旦ren nun auch direkt zusammen. Zus辰tzlich wird noch eine Beschreibung zu jeder
  Option gespeichert, was dazu benutzt wird, um automatisch einen Hilfetext auszugeben, in dem alle vorhandenen Optionen
  aufgez辰hlt werden. In Verbindung mit dem Application-Framework k旦nnen damit nun sehr einfach Kommandozeilenoptionen
  verwaltet werden, was ingesamt einen sehr guten Eindruck machen sollte, wenn jede PL-Applikation solche Standardfunktionen
  schon bietet, ohne das der Programmierer sich gro darum k端mmern muss. 
PLCore:
- Application: Der Executable-Dateiname und die Argumente werden jetzt nicht mehr im Constructor sondern bei Run 端bergeben.
  Alle Projekte wurden entsprechend angepasst. Da bei dieser Reihenfolge ChangeIntoAppDirectory() nicht mehr vern端nftig von
  Aussen aufgerufen werden kann, habe ich dies nun erstmal in GuiApplication::OnInit() eingebaut. Dies sollte auf jeden Fall
  von der Application selbst entschieden werden, und nicht von Aussen aufgerufen werden.



>> 05.09.2008
[CO]
PLCore:
- Application: "GetName()" in "GetTitle()" umbenannt
- Application: "GetFilename()" in "GetExecutableFilename()" umbenannt
- Application: "OnHelp()" in "OnPrintHelp()" umbenannt
- Application: "OnVersion()" in "OnPrintVersion()" umbenannt
- Application: GetExitCode(), SetExitCode(), IsShutDown(), ShutDown(), OnShutDown() in PLGui::Application verschoben
- Application: Neue Funktion: GetStartupDirectory(), gib das aktuelle Verzeichniss zur端ck das beim aufruf des Applikation
  Verzeichnisses eingestellt war
- Application: 'OnInit()' in 'GuiApplication' verschoben
- Application: 'Title' muss nun 端ber 'SetTitle()' gesetzt werden und kann nicht mehr direkt im Konstruktor 端bergeben werden



>> 25.08.2008
[CO]
PLCore:
- 64 Bit 'Bugfix': Core::GetRuntimeDirectory(): Macht ein 32 Bit Programm bei einem 64 Bit OS in der Registry herum, so landen dessen
  Eintr辰ge in einem 'Wow6432Node'-Unterordner. Also statt 'SOFTWARE\\PixelLight\\PixelLight-SDK' dann
  'SOFTWARE\\Wow6432Node\\PixelLight\\PixelLight-SDK' ... nicht das es zu einfach wird. *g*



>> 24.08.2008
[CO]
- System: GetPlatform() gibt wieder 'Win32' oder 'Win64' zur端ck statt 'Windows' da hier eine feinere Unterscheidung z.B. beim Plugins laden
  hilfreich ist. Unter Linux wird derzeit wie gehabt 'Linux' zur端ckgegeben, ob wir hier dann auch 32/64 Bit unterscheidungen brauchen m端ssen
  wir uns sp辰ter mal genauer anschaun.



>> 23.08.2008
[CO]
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da f端r 32 Bit als auch f端r 64 Bit
PLNetwork:
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da f端r 32 Bit als auch f端r 64 Bit
PLCore:
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da f端r 32 Bit als auch f端r 64 Bit



>> 22.08.2008
[CO]
- Der 64 Bit Support von PLGeneral funktioniert nun. CMake Dateien schau ich mir als n辰chstes an + ein paar Dinge m端sste man
  wohl umbenennen damit es 'Sauber' ist. 'SystemWin32' z.B. zu 'SystemWindows' da es f端r 'Win32' und 'Win64' nutzbar ist. :D



>> 21.08.2008
[CO]
- Fing an mich mit 64-Bit Support auseinander zu setzen. 'WIN64' wird zus辰tzlich als Precompiler Definition hinzugef端gt.
  Bei zumindestens schonmal einer Stelle, und zwar in SystemWin32::GetCPUMhz() muss man nun mit 'WIN64' eine Fallunterscheidung machen.



>> 20.08.2008
[SB]
- HTMLParser wieder entfernt, da mir das alles nicht robust genug ist. Um Texte anzuzeigen, wird nun ein eigenes
  XML-Format verwendet, da muss man nicht die ganzen HTML-Probleme mit sich herumschleppen und das war auch relativ
  schnell und einfach implementiert. F端r "echtes" HTML kann man dann evtl. sp辰ter auf vern端nftige Bibliotheken setzen.



>> 12.08.2008
[CO]
- Ich entschloss mich dazu die "SimpleList"-Implementation noch ein St端ck radikaler zu machen... und hier auch keine virtuellen Funktionen
  einzusetzen so das nochmal 4 Byte f端r die Virtuelle-Tabelle wegfallen. Eine leere "SimpleList" Instanz ist nun also nur noch 4 Byte gro.
  "Iterable" und "Container" Funktionen sind wie gehabt da und lassen sich genauso nutzen, auch sind weiterhin Funktionen drinnen die
  Daten von "Container" 端bernehmen k旦nnen - nur kann man "SimpleList" nicht mehr auf "Container" oder gar "Iterable" casten. Da Sinn
  und Zweck dieser Implementation jedoch ist "so Speichereffizient wie irgend m旦glich sein", kann man das denke ich rechtfertigen
  das diese Klasse etwas aus der "Container"-Reihe tanzt.
- Die internen Daten von "SimpleList" sind nun von auen Zugreifbar f端r maximale Optimierungs m旦glichkeiten. Das ist zwar sehr unsch旦n
  und Riskant - aber diese Klasse sollte man eh nur nutzen wenn man genau weis was man will und warum. Die Vorteile 端berwiegen hier
  wie man in PLCore::Event sehen kann die Nachteile finde ich.
PLCore:
- Dadurch das "SimpleList" von PLGeneral nun keine Virtuelle-Tabelle mehr besitzt wurden Event und EventHandler Instanzen noch
  kompakter. Vorher:
    Event        = 12 Byte
    EventHandler = 20 Byte
  nun
    Event        = 8 Byte
    EventHandler = 12 Byte
  ... ich denke NOCH weiter runter mit dem Speicherverbrauch ohne coole Funktionalit辰t einb端en zu m端ssen k旦nnen wir nicht mehr.
  Event ist nun dank "SimpleList" also nur noch halb so 'gro' wie vorher, EventHandler sogar nur noch ein drittel so gro. :D
- Entfernte 'm_nNumOfHandlers' im Event, dadurch ist ein Event nun nur noch 4 Byte gro - mal schaun ob man da noch irgendwo
  reduzieren kann... *g*
  Das entfernen wurde m旦glich da ich Zugriff auf die internen "SimpleList" Daten nun public machte - so kann man 'sehr Performant'
  端ber die Daten iterieren - genau das was man hier ssseeeeehr oft macht, und daher w辰re das 端ber einen Iterator gehen der intern
  Dynamsich erzeugt werden muss nicht zumutbar gewesen.



>> 11.08.2008
[CO]
- Bugfix: Directory::CreateRecursive(): Hier muss auf jedenfall noch 'GetRoot()' (zur Sicherheit f端gte ich auch noch 'GetProtocol()' ein)
  beim Pfad vorne eingef端gt werden - sonst kann es schnell zu Problemen kommen wenn ein absoluter Pfad 端bergeben wurde. Viel mir
  gerade im 3ds Max Scene Exporter auf als 'neben' den gew端nschten Verzeichnissen auch noch 'sollten nicht da sein'-Verzeichnisse
  erzeugt wurden.



>> 10.08.2008
[CO]
- "SimpleList" angelegt. Da "List" einige Daten speichert um diverse Operationen zu beschleunigen, aber in ein paar Situationen
  man diese Operationen nicht braucht und lieber eine 'super Speicherschonende' Liste h辰tte gibts nun "SimpleList". Startpunkt
  war "List" das ich schrittweise Umformte:
  - 'm_nNumOfElements' raus
  - 'm_pLastElement' raus
  - 'ListElement::pPreviousElement' raus
  -> dadurch ist SimpleList 8 Byte wenn leer im gegensatz zu "List" 16 Byte leer.
PLCore:
- Event und EventHandler Klassen von "List" auf das neue "SimpleList" umgestellt. Vorher
    Event        = 16 Byte
    EventHandler = 36 Byte
  jetzt
    Event        = 8 Byte (+ 4, siehe unten)
    EventHandler = 20 Byte
  -> nderte an ein paar Stellen die Verwendung der Liste damit m旦glichst keine 'ineffizienten' Operatoren genutzt werden.
  Spendierte Event 'm_nNumOfHandlers' das 'GetNumOfElements()' aufrufe bei SimpleList vermeitet - denn diese Operation ist nun
  langsam. Es lohnt denke ich hier aber 4 Byte f端r bessere Performance zu investieren, denn 'GetNumOfElements()' w辰re sonst
  'sehr h辰uftig' aufgerufen worden. Event ist nun also 12 Byte, aber immer noch 4 Byte kleiner als vorher (davon k旦nnen wir uns
  ein Eis kaufen gehen *g*)... und bei jedem EventHandler den man einh辰ngt spart man nochmal durch die schlankere "SimpleList"
  Implemenation. Lohnt sich also denke ich.



>> 09.08.2008
[CO]
- "PLGeneralStat.vcproj": Gib seine Objekt-Dateien nun in ein eigenes Build-Verzeichniss aus. Ich hatte in letzter Zeit st辰ndig
  Linker fehler beim 端bersetzen - jetzt weis ich auch warum. :D
- MODULE_LICENSE() hinzugef端gt f端r die Angabe der Lizenz. Mir war es wichtig das diese Information allerdings auch direkt im Modul
  Abrufbar ist - z.B. damit man 端ber ein Plugin-GUI dann das dort auch bequem sehen kann.
- In Funktionen wie z.B. "ModuleID<T>::SetModuleName()" war der 'berlaufschutz' nicht korrekt Implementiert, so m端sste das nun
  korrekt sein



>> 09.08.2008
[SB]
PLCore:
- Events: Mittels ConnectBind() k旦nnen nun auch EventHandler an Events eines anderen Typs gebunden werden, wobei die
  Parameter analog zu bind() gebunden werden. Intern wird hier einfach ein EventHandler vom richtigen Typ erzeugt und
  mit dem Event verbunden. Damit dieser dynamisch erzeugte EventHandler auch wieder gel旦scht wird, brauchte es leider
  eine Klasse mit virtuellem Destruktor, die in eine Liste beim EventHandler eingetragen wird. Dies wird aber nur dann
  ben旦tigt, wenn wirklich mal ein Event 'umgebogen' wird, im Normalfall bleibt die Liste leer. Ich hoffe, dass dies so
  am besten ist und damit 端bereinstimmt, wie Events und Handlers gr旦tenteils benutzt werden. Sollte sich herausstellen,
  dass man die meiste Zeit ConnectBind benutzt, sollte man sich vielleicht eine andere L旦sung 端berlegen, die 'teurer' ist
  f端r den Normalfall, daf端r aber 'billiger' f端r den Bind-Fall. Bitte beachten, dass die Functors und Events zur Zeit noch
  getestet werden, einiges ist noch nicht so stabil wie es sein soll (z.B. wenn man mal die falsche Anzahl Parameter 端bergibt).
  Das 端berarbeite ich gerade nochmal, die Funktionalit辰t sollte aber so bleiben wie sie ist.



>> 08.08.2008
[CO]
- Loadable::Reload(): Funktionierte unter umst辰nden nicht korrekt da direkt eine Referenz auf einen 'internen' String 端bergeben
  wurde der w辰hrend des Ladevorgangs ver辰ndert werden kann - und schon klappte das Neuladen nicht mehr. (altbekanntes "Problem" :)



>> 06.08.2008
[CO]
PLCore:
- 'ShutDown()' und 'IsShutDown()' Methoden in die 'Application'-Klasse eingebaut. Dies ist identisch zu dem was in
  der alten 'PLEngine::PL'-Klasse ist und das wie ich finde schon immer sehr gut funktionierte. F端gte desweiteren
  eine virtuelle 'OnShutDown'-Methode hinzu die innerhalb 'ShuwDown()' aufgerufen wird.
- 'Application'-Klasse: "OnRun()" Implementationen geben im 'normalfall' "GetExitCode()" zur端ck, nur im Fehlerfall was
  eigenes wie z.B. "-1" - so kann ein User der nur die Application Klassen nutzt 端ber "SetExitCode()" einen Error Code
  setzen der zur端ckgegeben werden soll



>> 03.08.2008
[CO]
PLCore:
- 'Application'-Klasse um 'Name' erweitert, dies ist recht n端tzlich da man dann z.B. direkt anhand dieses Namens z.B.
  den Standard-Titel eines Fensters setzen kann.
- 'Base'-Verzeichniss mit alter Event und Functor Implementation gel旦scht



>> 02.08.2008
[SB]
PLCore:
- Bind-Funktionalit辰t f端r Funktoren hinzugef端gt. Damit ist es m旦glich, Parameter eines Funktors zu binden, also
  auf einen festen Wert zu setzen und damit die Signatur einer Funktion zu ver辰ndern. Diese Implementation erlaubt
  es auch, Eingabeparameter und gebundene Werte frei festzulegen und damit die Reihenfolge, Anzahl und Art
  der Parameter des neu erzeugten Funktors fast beliebig bestimmen zu k旦nnen. Ergebnis der Bind-Funktion ist
  ein Funktor, dessen Signatur durch die verwendeten Parameter komplett festgelegt ist und der daher selbst
  wieder typensicher ist.

  Anwendung:
    Beispielsweise kann man auf diese Weise einen weiteren Parameter hinzuf端gen, um z.B. bei Events noch
    einen Zeiger auf das Objekt mitzuliefern, das dieses Event erzeugte (z.B. Window* oder SceneNode*).
    Durch die Verwendung von bind wird ein Funktor erzeugt, der wieder kompatibel zum Event des jeweiligen Objektes
    ist.

  Verwendung:
    bind(f, t0, t1, ...)
    - f: Eingabe-Funktor, der letztlich mit ge辰nderten Parametern aufgerufen wird
    - t0: Wert f端r Parameter 0
    - t1: Wert f端r Parameter 1
	- etc.

    Anstelle von echten Werten f端r Parameter k旦nnen Platzhalter verwendet werden, um die Parameter
    des erzeugten Funktors durchzureichen:
	- _0: Platzhalter f端r Parameter 0
	- _1: Platzhalter f端r Parameter 1
	- etc.

  Beispiele:
	// Define a test functor of type void(int, float)
	Functor<void, int, float> f(Function);

	// Call directly
	f(1234, 0.25f);

	// Bind first parameter -> getting functor of type void(float)
	bind(f, 1234, _0)(0.25f);

	// Bind second parameter -> getting functor of type void(int)
	bind(f, _0, 0.25f)(1234);

	// Bind both parameters -> getting functor of type void()
	bind(f, 1234, 0.25f)();

	// Exchange parameters -> getting functor of type void(float, int)
	bind(f, _1, _0)(0.25f, 1234);

	// Just to show the resulting functor's type
	Functor<void, float> f2 = bind(f, 100, _0);
	f2(0.1f);



>> 29.07.2008
[SB]
PLCore:
- FunctorTools hinzugef端gt und Funktionen erstellt, um einen Funktor zu erzeugen. Das dient vor allem der
  bersichtlichkeit, damit man nicht st辰ndig die ganzen Template-Parameter schreiben muss, gerade wenn man
  sp辰ter mit bind etc. die Funktoren noch ineinander schachteln muss. Ich habe mich dabei an die 端blichen
  Benennungen gehalten, die man in den meisten anderen Signal/Slot Implementationen findet: ptr_fun()
  erzeugt einen Funktor f端r eine statische Funktion, mem_fun() erzeugt einen Funktor f端r eine Memberfunktion.
- 'Types' in 'Traits' umbenannt, was eine 端bliche Bezeichnung f端r solche Typendefinitions-Klassen ist. Die Klasse
  heisst nun FunctorTraits und wurde ausserdem in eine eigene Headerdatei ausgelagert, die allerdings "Traits.h" heit.
  Zus辰tzlich wurde auch noch Functor selbst in die Klasse aufgenommen, damit man alle ben旦tigten Datentypen dort beisammen hat.
- Analog zum Functor auch bei den Events Types in Traits umbenannt.
- Weitere Klassen umbenannt:
    FuncImpl   -> FunctorImpl (Dateiname ist trotzdem "Impl.h" und nicht "FunctorImpl.h", damit alle Impl's beisammen stehen)
    FuncTyped  -> ImplTyped
    FuncPtr    -> ImplFunPtr
    FuncMemPtr -> ImplMemPtr
  sowie
    FunctorTools -> Tools



>> 28.07.2008
[SB]
PLCore:
- Functor und Events nochmal 端berarbeitet und 端bersichtlicher gestaltet (mehrere Dateien).
- Beide Klassen sind nun erstmal so einfach wie m旦glich gestaltet, dass heit m旦glichst wenig Ableitungen und
  dadurch auch weniger virtuelle Destruktoren. Mal schauen, ob es f端r das neue RTTI notwendig ist, diese Klassen doch
  noch einmal aufzubohren (und dadurch evtl. doch wieder einiges virtuell machen zu m端ssen), ich f辰nde es aber sch旦n,
  wenn die Klassen so bleiben k旦nnten, wie sie jetzt sind.
- ManagedEventHandler entfernt, da mir das nie wirklich gefallen hat (leicht unsicher, falls das falsch benutzt worden w辰re).
  EventHandler sollten lieber als direktes Attribut einer Klasse instanziiert werden statt 端ber new, und falls es doch
  jemand dynamisch braucht, muss er eben selber daf端r sorgen, dass die erzeugten Objekte auch wieder gel旦scht werden.
- Sowohl Functor als auch EventHandler haben nun wieder einen Default Konstruktor. Es ist zwar sch旦n, wenn es keine Probleme
  gab ohne Default-Konstruktor, jedoch nimmt uns das die M旦glichkeit, Funktoren oder EventHandler beispielsweise in einer
  Liste zu speichern oder in anderen Situationen, wo es notwendig ist, zun辰chst einmal das Objekt 端ber den Default-Konstruktor
  zu initialisieren und den wirklichen Wert erst sp辰ter zuzuweisen. Da beide Klassen so gestaltet sind, dass es problemlos
  m旦glich ist, zun辰chst einmal ein leeres Objekt zu erzeugen und erst sp辰ter einen Zeiger auf eine wirkliche Funktion zu setzen,
  sollten wir uns diese M旦glichkeit nicht unn旦tig verbauen. Abgesehen davon hat das Entfernen des Default-Konstruktors
  von EventHandler das Problem nicht wirklich gel旦st, weil das eigentliche Problem im Functor lag und nicht im EventHandler,
  ein leerer Functor h辰tte daher immernoch zum Crash gef端hrt. Das wurde nun behoben, da ein leerer Functor jetzt eine Null-Funktion
  aufruft, anstatt wie bisher einfach abzust端rzen :-)
- Ein EventHandler kann nun auch auf mehrere Events h旦ren, womit es gr旦tenteils wirklich unn旦tig sein sollte, EventHandler dynamisch
  zu erzeugen. Christian: Bitte nochmal genau meine Implementation durchschauen, da bei so etwas leicht Fehler passieren (NxM Beziehung,
  beide Objekte m端ssen sich im Destruktor aus der Liste des jeweils anderen Objektes austragen, das wird leicht ganz sch旦n kniffelig).



>> 23.07.2008
[CO]
- Neue System-Funktion: 'GetUserHomeDir()' liefert das 'Home Directory' des aktuellen Benutzers zur端ck - dort kann/sollte
  man dann immer Dinge wie Konfigurationen, Screenshots etc. speichern so das dort wo das eigentliche Programm gespeichert
  ist NICHTS dynamisches gespeichert wird. Das ist unter Unix scheinbar so g辰ngig + unter Vista wird da wie es aussieht
  auch Wert drauf gelegt... jedenfalls muss man dort dann erst Verzeichnissattibute 辰ndern bevor Logs etc. im Programm
  Verzeichniss geschrieben werden k旦nnen...
  -> PLGeneral ist dadurch nun auch von 'Userenv.lib' Abh辰ngig, das sollte aber kein Problem sein. Man h辰tte sicherlich
     auch irgendwie in der Registry herumfummeln k旦nnen, was aber nicht ganz so prall sein soll - dann lieber gleich
     Funktionen die das OS daf端r bereitstellt nutzen. :D
  -> Linux Implementation 'm端sste so passen', aber da ich es nicht testen konnte ist es Auskommentiert.



>> 21.07.2008
[SB]
- HTMLParser implementiert. Diese Klasse liest eine HTML-Datei ein und erzeugt daraus ein XML-Dokument. Besonders robust ist
  der Parser sicherlich nicht, allerdings habe ich versucht, viele typische Fehler in HTML-Dateien (z.B. falsch geschlossene Tags
  oder gemischter HTML und XML-Syntax) zu ber端cksichtigen, so dass die Datei dennoch eingelesen werden kann. Die Klasse ist
  aber ein reiner Parser und beinhaltet keinerlei HTML-Semantik (was heit, dass semantische Regeln, wie z.B. <li> kann nur in
  Listen vorkommen oder <tr> nur in Tabellen, nicht 端berpr端ft werden k旦nnen). 



>> 18.07.2008
[CO]
- ClassManager::LoadPlugin(): Um Format Versions Informationen erweitert ('plugin'-Dateien)



>> 10.07.2008
[CO]
- ConfigLoaderPL & LocalizationLoaderPL: Um Format Versions Informationen erweitert



>> 09.07.2008
[CO]
- LoadableManagerLoaderPL: Um Format Versions Informationen erweitert. So wird es Zuk端nftig dann in all unseren XML Formaten gehandhabt.
- Loader: Ein paar 'Standard Strings' hinzugef端gt



>> 08.07.2008
[SB]
- Statische Version von PLGeneral hinzugef端gt. Ich denke, PLGeneral und evtl. sp辰ter noch PLGui sollten erstmal als statische
  Bibliotheken ausreichen, damit man kleine Tools auch ohne Abh辰ngigkeit von der PixelLight-Runtime schreiben kann (gerade
  auch wichtig f端r unsere internen Tools).



>> 04.07.2008
[CO]
PLCore:
- EventHandler: Standard Konstruktor entfernt da es ansonnsten einen Crash gibt wenn man einen nicht Initialisierten
  EventHandler nutzt - eine Situation die es auf jedenfall zu vermeiden gilt. Habe bei mir diesen Konstruktor schon seit
  Wochen auskommentiert und es gab keine Probleme.



>> 29.06.2008
[SB]
PLPluginMozilla:
- PLPluginMozilla implementiert.
- Anbindung an unsere abstrakte Plugin-Klasse vorgenommen und PixelLight-Plugin erfolgreich im
  Mozilla ausgef端hrt.



>> 28.06.2008
[SB]
PLPlugin:
- Projekt gestartet. PLPlugin stellt eine Schnittstelle zur Verf端gung, um PixelLight als Plugin in andere
  Umgebungen/Applikationen einzubinden. Also PixelLight als Plugin f端r z.B. Browser, nicht Plugins f端r PixelLight :-)
  Dazu wird eine abstrakte Plugin-Klasse bereitgestellt, die von konkreten Wrappern f端r verschiedene Plugin-Schnittstellen
  angesprochen wird. Von dieser Plugin-Klasse werden dann konkrete Plugins abgeleitet, z.B. das standard PixelLight-Plugin,
  das wir letztlich im Browser oder sonstwo sehen wollen.
- Basisklasse Plugin implementiert, die das abstrakte Plugin-Interface darstellt.
- Basisklasse PluginImpl implementiert, die nach dem Backend-Prinzip das Interface
  f端r konkrete Backends bereitstellt.
- PluginOpenGL als Testplugin implementiert, in dem eine minimale OpenGL Szene angezeigt wird.
- PluginPixelLight erstellt f端r das standard PixelLight-Plugin. 
- Das Triangle-Sample genommen und als vorl辰ufiges PixelLight-Plugin implementiert :-)
PLPluginActiveX:
- PLPluginActiveX implementiert. Diese konkrete Implementation von PluginImpl
  stellt das ActiveX Backend f端r unsere eigene Plugin-Klasse dar.
- Den Wrapper auf die Verwendung unseres abstrakten Plugin-Interfaces umgestellt.
- Den OpenGL-Test hier entfernt und daf端r als PluginOpenGL in PLPlugin implementiert.
- Das PixelLight-Plugin l辰uft nun zum ersten Mal korrekt im Browserfenster :-)



>> 24.06.2008
[SB]
PLPluginActiveX:
- Projekt gestartet. PLPluginActiveX ist ein Container und Wrapper f端r ActiveX, 端ber den das PLPlugin-Interface unter
  ActiveX verwendet werden kann.
- ActiveX control erstellt und an unsere Projektstruktur angepasst. Einstellungen
  gefunden, die zur Einbindung von OpenGL erforderlich sind.
- Kleines OpenGL Testplugin implementiert.



>> 22.06.2008
[CO]
- System Klasse um 'GetCurrentThread()' erweitert - das nutzen wir in verschiedenen Vorlesungen des 旦fteren mal und kann ganz hilfreich sein.
  Rauszufinden wie man diese Funktion intern realisieren kann war allerdings etwas - knifflig. Leider scheint es weder bei Windows
  noch bei Linux m旦glich zu sein an die Funktions Parameter zu kommen die man einem Thread beim erzeugen gegeben hat. Daher muss man
  das leider etwas umst辰ndlicher anpacken um an die PixelLight Thread Instanz des aktuellen Threads zu kommen:
  - Unter Windows l辰sst sich das mit 'Thread Local Storage' (TLS) realsieren, bis auf die unsch旦ne Globale Variable ganz ok w端rd ich sagen
  - Unter Linux kann man daf端r denke ich 'pthread_getspecific()' nutzen (fand das zuerst, und schaute dann obs unter Windows etwas
    辰hnliches gibt :)
  Ich habe das direkt mal in 'PLPhysics::WorldThread' ausprobiert, klappt ganz wunderbar. :D
  Sobald die Linux Variante Implementiert ist w端rde ich gerne 'System::Sleep()' wieder nach 'Thread::Sleep()' verschieben da es f端r mich
  einfach dorthin geh旦rt und man es in 'neuen Sprachen' wie Java oder C# ebenfalls in der Thread Klasse findet was ich sehr nett finde. Zwar
  ist 'System::GetInstance()->Sleep(100)' 'kompakter' zu schreiben als 'System::GetInstance()->GetCurrentThread()->Sleep(100)', aber irgendwie
  ist das einfach eine Thread Verwaltungs Funktion die f端r mich nix in der 'allgemeinen System'-Klasse zu suchen hat, auch wenn man diese auf
  dem aktuell laufenden Thread ausf端hrt. Bei Zeiten w端rde ich dann auch noch gerne eine 'Thread::Yield()'-Funktion hinzuf端gen damit wir die
  meisten g辰ngigen Thread Funktionen haben.
- Threads k旦nnen nun auch einen von Menschen lesbaren Namen haben, gerade beim Debugging oder Thread Experimenten ist das sehr hilfreich
- Neue System Funktion: 'Yield()' -> veranlasst im Normallfall den aktuellen Thread den Prozessor aus der Hand zu geben, ebenfalls eine g辰ngige
  Funktion. Habe das erstmal in die System Klasse eingebaut da dort auch die 'Sleep()'-Funktion ist. Hier m端ssten wir uns wie gesagt nochmals
  端berlegen ob wir das wirklich in der System Klasse lassen wollen oder nicht lieber in die Thread Klasse schieben damit die Thread Dinge
  beisammen sind... auch wenn diese Funktionen auf den 'aktuell laufenden Thread' arbeiten und nicht auf die Thread Instanz was ein klein wenig
  verwirrt, aber das ist auch bei Java und C# so. (im aktuellen Semester habe ich wie gesagt sehr viele Vorlesungen die sich mit Threads in
  verschiedensten Sprachen befassen :) Wir m端ssen uns das nicht sofort nochmal anguckn ob wir das in der System Klasse haben wollen oder das so
  machen wie es mittlerweile viele API's handhaben und das den "Umstieg auf PixelLight" etwas einfacher machen k旦nnte. :)



>> 21.06.2008
[SB]
PLCore:
- Neue Klasse Core hinzugef端gt, die statische Funktionen bereitstellt, um Informationen 端ber die gesamte
  PixelLight-Installation abzufragen (z.B. Installationspfad, Versionsnummer etc.). GetRuntimeDirectory
  wurde von PLEngine hierher verschoben, und 端berall, wo der Installationspfad abgefragt wurde, wird nun
  diese Funktion verwendet (sowas sollte wenn m旦glich immer zentral an einer Stelle sein und nich dupliziert
  werden).
- Die Informationen 端ber das aktuelle SDK werden nun aus der Datei PixelLight.h genommen, die im Verzeichnis
  /PixelLight zu finden ist (siehe PLSDK)



>> 01.06.2008
[SB]
- RTTI: Es war immer noch ein Fehler beim Registrieren von Klassen vorhanden. Wenn die Liste der auf ihre Basisklassen
  wartenden Klassen durchgegangen wird, mu die Suche neugestartet werden, damit alle abgeleiteten Klassen auch initialisiert
  werden k旦nnen. Hier war ein saubl旦der fehler drin, wodurch die Klassen meistens nicht initialisiert wurden.
  Aus irgend einem Grund ist die Reihenfolge der Initialisierungen unter VC anscheinend ziemlich optimal, so dass dieser
  Fehler da nicht wirklich aufgefallen ist - solange die Klassen in der richtigen Reihenfolge initialisiert werden
  (z.B. erst SceneNode, dann SceneContainer, dann SCPhysics) funktioniert ja alles korrekt. Beim bersetzen mittels
  CMake ist die Reihenfolge, in der compiliert und gelinkt wird, jedoch eine andere, deswegen fiel der Bug hier ins Gewicht
  und beim Ausf端hren konnten Klassen nicht gefunden werden, da diese nicht richtig am RTTI angemeldet wurden.
  Ich habe jetzt keine Probleme mehr feststellen k旦nnen, auch wenn ich mit CMake das bersetzen starte, funktionieren hinterher
  alle Samples korrekt und das dubiose Problem, dass z.B. "SceneNode" nicht gefunden wird, ist nicht mehr vorhanden. Ich hoffe
  mal, dass dies auch meine Probleme unter Linux l旦st (dort wurden die Loader nicht gefunden, d端rfte ziemlich sicher das
  gleiche Problem gewesen sein). 
- RTTI: Da es sehr bl旦d ist, das RTTI zu debuggen, wenn es aus irgend einem Grund nicht richtig funktioniert, und man hier
  auch nicht einfach ins Log schreiben kann, da dies ebenfalls schon ein funktionierendes RTTI voraussetzt, habe ich ein neues
  Makro eingebaut, um das RTTI zu debuggen. Normaler Weise ist das deaktiviert, wenn man es aber aktiviert, werden RTTI-Aktivit辰ten
  mit einfachen stdio-Methoden in einer festgelegten Datei (C:\rtti.txt) geloggt. Das d端rfte es etwas vereinfachen, Problemen
  mit dem RTTI auf die Schliche zu kommen.



>> 22.05.2008
[CO]
- 'Informer' und 'Listener' Templates entfernt da wir zuk端nftig wie von Stefan vorgeschlagen auf das 'Event'-Konzept setzen das ich mittlerweile
  auch sehr nett finde. Diese zwei Templates wurden nur von 'SceneNode' und 'SceneQuery' innerhalb von 'PLEngine' verwendet, hier werden nun
  'Events' genutzt.



>> 16.05.2008
[CO]
- Wie besprochen liegen System Konsolen Funktionen nun in einer eigenen Klasse die man 端ber 'System::GerInstance().GetConsole()' bekommt
- XML-Klassen: Interessant. Mir viel gerade als ich Stefans nderungen durchschaute zum ersten mal das 'XmlDocument::SetTabSize()' beim speichern
  端berhaupt keine Auswirkung hat da intern immer direkt "    " geschrieben wird. Als ich in den TinyXML Codes nachschaute sah ich das die
  das ebenfalls vergessen haben... oder es warum auch immer gewollt ist. Bei uns ist das jedenfalls nicht gewollt da ich keinen Grund finden
  kann warum die 'XmlDocument::SetTabSize()'-Einstellung ignoriert werden sollte. Darum ging ich die Funktionen die speichern nochmal durch
  und korrigierte das + nutzte '' anstatt "" wo nur ein Zeichen genutzt wird. (die String Klasse kann damit etwas Effizienter arbeiten :)
- XmlNode::GetDocument(): Auch hier war noch ein fieser Bug drinnen. Wow, Respekt, dieses Kerlchen hat sich aber ziemlich lange tapfer im
  Code halten k旦nnen. *g*



>> 17.04.2008
[CO]
- SystemWin32::GetCurrentDir(): Gab das Verzeichniss 'Native' zur端ck. Da in der Dokumentation nix steht und in Programmen normalerweise
  wenn immer m旦glich nicht mit 'Native' gearbeitet werden sollte 辰nderte ich das. Dies merkte ich durch 'LoadableType::GetRelativeFilePath()'
  das nicht mehr korrekt ging da alle Basis-Pfade im LoadableManager ein Protokoll vorne haben, aber das von 'System::GetCurrentDir()'
  keines hatte was hier nicht wirklich hilfreich ist. :D
- 'LoadableType::GetRelativeFilePath()': Da 'SystemWin32::GetCurrentDir() & CO' am Ende keinen Slash haben musste hier nun an einer Stelle
  '+1' eingef端gt werden. Nun arbeitet diese Funktion wieder korrekt.



>> 05.04.2008
[SB]
- PLMain so umge辰ndert, dass man nun immer den Dateinamen und die Parameter 端bergeben bekommt. Das wird so auch
  an die Application-Klasse weitergegeben, so ist das einheitlich und man braucht sich nicht mehr zu fragen, ob
  Parameter[0] jetzt der Dateiname ist oder der erste Parameter. Damit dies unter allen System vern端nftig funktioniert,
  waren noch ein paar Anpassungen n旦tig. Man k旦nnte nun 端berlegen, die Funktion GetProgramName() aus System herauszunehmen,
  damit man das nicht doppelt hat. Nat端rlich k旦nnte man das dann nur noch nutzen, wenn man auch die Application-Klasse
  nutzt (was man allerdings tun sollte, da es nur Vorteile bringt).
PLCore:
- Mit der Arbeit am Application-Framework begonnen. Die Klasse Application ist die Basisklasse und wrappt
  die Hauptfunktion des Programmes. Alles weitere wird durch Spezialisierungen in anderen Projekten (z.B. PLGui)
  hinzugef端gt.



>> 05.04.2008
[CO]
- ThreadLinux: Speichert intern das vom Benutzer gesetzte 'PriorityClass' und 'Priority' damit sich das rein von den R端ckgabewerten
  her wie unter Windows verh辰lt. Linux selbst hat eine Funktion Namens 'pthread_setschedparam' zum setzen der Thread Priorit辰t - allerdings
  ist 'SCHED_OTHER' als Default-Strategie gesetzt und in dem Fall sind keine Thread Priorit辰ten zul辰ssig da dies komplett der Kernel
  端bernimmt. Damit hat sich das mit den Thread Priorit辰ten unter Linux also erledigt.



>> 05.03.2008
[SB]
- Mute die Verwendung des Null-Objektes noch etwas ver辰ndern: In (Standard-)C++ ist es nicht erlaubt, statische Member
  端ber Objekte anzusprechen. So etwas wie m_lstObjects->Null geht also nicht, es mu List<Object>::Null heien. Leider
  scheint Visual C++ immer noch nicht standardkonform zu sein, da es hier keinerlei Fehler oder Warnungen gab. F端r den
  gcc dagegen ist m_lstObjects->Null ganz einfach unbekannt. Habe alles angepat und hoffe, dass es nun so unter beiden
  Compilern funktioniert.



>> 05.03.2008
[CO]
- Wie besprochen geben nun die Container Referenzen statt Zeiger zur端ck... die Klassen waren schnell ver辰ndert, das hatte
  ich gestern bereits fertig -  alle Projekte entsprechend anzupassen war allerdings 'etwas' mehr Aufwand der sich allerdings
  definitiv gelohnt hat. Stellen wo Zeiger genutzt werden m端ssten unproblematisch sein da soetwas wie 'if (!...)' oder nur
  'if (...)' weiterhin klappt. Sollte allerdings in den Containern ohne Zeiger gespeichert sein, so k旦nnen diese Abfragen
  teils immer noch 端bersetzt werden - aber das was abgefragt wird ist dann nicht mehr ob das zur端ck bekommene Element g端ltig
  ist, sondern dann wird direkt der Wert dieses Elements getestet. Bei soetwas wie 'int' gespeichert meckert das dann nat端rlich
  der Compiler nicht an - das kann ganz b旦se nach hinten losgehen. Eine solche Stelle fand ich bereits, aber um 'alle' zu finden
  m端ssen wir 端berall wo Container genutzt werden ohne Zeiger nochmal suchen und durchschauen. :/
  Bin schon schwer gespannt was ich so alles 端bersehen habe... entweder findet es Stefan oder die Zeit. *g*



>> 03.03.2008
[SB]
- Neuer PLGeneral-Datentyp 'handle'. Es ist irgendwie bl旦d, st辰ndig auf uint32 casten zu m端ssen oder gleich
  void-Pointer zu 端bergeben, wenn es um System-Handles geht. Meistens sind diese auf einem System immer vom
  gleichen Datentyp, bei Windows wird HANDLE (DWORD) verwendet, bei Linux ist es meistens int. Daher definiere
  ich das nun in einem PLGeneral-Datentyp 'handle', der f端r alle Systemhandles verwendet werden soll. Ebenfalls
  wird auch INVALID_HANDLE je nach System f端r ung端ltige Handles definiert. Dieser Datentyp sollte nicht h辰ufig
  Verwendung finden, aber manchmal braucht man eben auch die M旦glichkeit, 端ber unsere Datentypen wieder an
  System-Handles heranzukommen. Das k旦nnen wir nun 端ber diesen Datentyp machen, anstatt das v旦llig undefiniert
  zu lassen oder f端r verschiedene Situationen unterschiedliche Datentypen zu definieren (wie fr端her MODULE_HANDLE).
- FileStdStream erweitert: Es kann nun entweder ein beliebiger Stream-Pointer 端bergeben werden (FILE*),
  oder ein File-Handle des jeweiligen Systems (int unter Linux, HANDLE unter Windows). Falls ein File-Handle
  端bergeben wird, mu hinterher die Datei noch ge旦ffnet werden, wobei die bekannten Flags (Read/Write/Text/etc.)
  verwendet werden k旦nnen. Im Falle eines FILE*-Pointers m端ssen die Access-Flags, die verwendet wurden um die Datei
  zu 旦ffnen, mit 端bergeben werden. Somit ist es m旦glich, eine beliebige bereits ge旦ffnete oder sonstwie zur端ckgegebene
  Datei trotzdem 端ber unseren File-Wrapper anzusprechen. Die Standard-Streams (in/out/err) sind da nur ein Beispiel,
  es k旦nnen jetzt aber auch beliebige andere Dateien oder Pipes so verwendet werden.
- Statt void* wird nun FILE* 端bergeben, da dieser Datentyp feststeht und sich auch nicht je nach System unterscheidet.

  Da dadurch jetzt leider schon in File <stdio.h> ben旦tigt wird, habe ich die FILE-Vordefinition in eine eigene
  Headerdatei ausgelagert, wo nach Windows und Linux unterschieden wird. Damit wird <stdio.h> wirklich nur da
  eingebunden, wo es unbedingt n旦tig ist, ohne die Includes 端berall mit #ifdef's zu verunstalten :-)
- File: Konstruktoren zum ffnen schon vorhanderer Streams/FileHandles via FileStdStream eingebaut bzw.
  旦ffentlich gemacht.
- File: IsOpen() hinzugef端gt
- berall Writeable durch Writable ersetzt. Es scheint zwar beides richtig zu sein, aber writable ist mir irgendwie
  gel辰ufiger - und in meinem Dictionary ist diese Variante fettgedruckt :-)
- Neue Klasse Pipe eingebaut, 端ber die System-Pipes (named und unnamed) erstellt und angesprochen werden k旦nnen.
- Neue Klasse Process eingebaut, die benutzt werden kann, um externe Prozesse zu starten. Dabei kann die
  Ein- und Ausgabe umgeleitet werden und hinterher 端ber unsere File-Klasse ausgelesen/geschrieben werden. Das ist
  eine Funktionalit辰t, die man immer mal wieder braucht, und die mit OS-Funktionen ein absoluter Krampf ist. Darum
  m旦chte ich gerne PLGeneral soweit vollst辰ndig haben, dass man alles sowas sch旦n einfach und komfortabel damit machen
  kann :-)



>> 02.03.2008
[CO]
- nderte in den Container-Klassen 'AType' zu 'ValueType' damit das hier 端berall gleich geschrieben ist und somit
  Doxygen bei z.B. dem Iterator eine 'komplette' Klassenhierarchie zeigt und nicht nur die 'Container' Klassen
- Bugfix: Directory::CreateRecursive(): Trotz meiner bei der Implementation merkw端rdigerweise erfolgreichen Tests
  (eventuell nicht sonderliche pralle Test Situation erzeugt :) war die Implementation noch nicht ganz ok... Stefan
  hatte ja schon die korrekte Funktionsweise angezweifelt, so 'm端sste' es nun aber klappen.



>> 29.02.2008
[CO]
- "ConstIterator" hinzugef端gt, bin mir allerdings nicht sicher ob das den 'Todo'-Punkt
  "Const_Iterator (currently we can't return some lists)" korrekt behandelt. Hoffentlich geht das so halbwechs,
  w辰hre heftig wenn wir nochmal komplette Iterator Implementationen f端r 'const' schreiben m端ssten. :/
  Wenn das passt, w辰re es sicherlich ne gute Idee bei 'Iterable::GetIterator()' und 'Iterable::GetEndIterator()'
  das 'const' hinten heraus zunehmen + die m旦glichkeit einen Iterator einem ConstIterator zuzuweisen.
  (anderst herum nat端rlich nicht *g*)



>> 28.02.2008
[CO]
Alle Projekte:
- Nahm wie besprochen 端berall dort wo 'inline' genutzt wird die Export Makros heraus. (siehe Eintrag 24.02.2008
  von Stefan) Damit man an diesen Stellen sehen kann das es absicht ist das hier kein Export Makro ist habe ich
  dort dann jeweils 'inline' reingeschrieben. (ist also nix 'funktionales', sondern als Hilfe/Ged辰chtnissst端tze
  gedacht)
PLGeneral:
- 'SubString' und 'Sub-String' in 'Substring' umbenannt da man diese Schreibweise heute am h辰ufigsten antrifft
- String::String(const utf8 *pnValue) muss nat端rlich raus da der Compiler hier nicht zwischen den zwei entsprechenden
  Konstruktoren unterscheiden kann (dank Default Einstellungen sieht das dann f端r ihn gleich aus :)
- String: "String operator +(utf8 nValue) const;" macht nat端rlich nicht wirklich viel Sinn da dies eigentlich immer
  ein 'Array von utf8' ist, nahm es heraus. Das gleiche bei "String::operator +=(utf8 nValue)" und
  "friend String operator +(utf8 nValue, const String &sString)" und "GetUTF8Char()" und "Replace(utf8 nOld, utf8 nNew)".
  "SetCharacter()" mit UTF8 braucht nat端rlich einen Zeiger.
- Bugfix: "String(const utf8 *pszString, bool bCopy, uint32 nLength, uint32 nNumOfBytes)": "UTF8Tools::GetNumOfCharacters()"
  sollte man nat端rlich auch die Anzahl der Bytes mitgeben...
- "Functions.cpp": "HashFunction::Hash(const String &sKey)": Hier sollten Fallunterscheidungen f端r die verschiedenen
  Formate gemacht werden... das k旦nnte allerdings schnell zu problemen f端hren wenn man Formate mischt und sich dann
  wundert wieso man 'bei doch eigentlich scheinbar gleichem String' unterschiedliche Schl端ssel bekommt. Das sollte
  man sich also dann eventuell nochmal genauer anschaun.
- RegEx: 'Mode' zu etwas universelleren Flags gemacht in denen 'Match' und 'Encoding' gespeichert wird, so braucht
  man f端r 'Encoding' keine weiteren Parameter. Setzt man kein spezielles 'Encoding'-Flag, so wird das interne
  String Format (ASCII oder UTF8) des 端bergebenen Ausdrucks verwendet. 'Subject' bei 'Match()' wird in dieses
  interne RegEx Format 'gezw辰ngt'. 'Meistens' macht man sich 端ber 'Encoding' keine Gedanken und nutzt nur ASCII,
  in dem Fall kann man das auch hier wie gehabt als Benutzer ignorieren. :D
  UTF8 Support in RegEx Implementation eingebaut, allerdings funktioniert das noch nicht richtig da u.a.
  "UTF8Tools::Unescape()" noch Probleme mit soetwas wie "\\s*(\\w+)\\s*" hat was es dann zu z.B. "s*(w+)s*" umformt +
  einige entsprechenden Funktionen in der String-Klasse noch nicht richtig Implementiert sind. Aber der Anfang w辰re
  gemacht, taste wir uns also mal voran bis das alles korrekt auch mit UTF8 l辰uft...



>> 27.02.2008
[SB]
- Linux-Implementationen der Konsolen- und Memoryfunktionen getestet und wo n旦tig angepasst. Die Datei /proc/meminfo
  sieht bei mir v旦llig anders aus als offenbar in dem Beispiel, da sollte man sich also offenbar nicht drauf verlassen,
  dass der x-te Wert das und das bedeutet. Deswegen Parse ich nun nach den entsprechenden Strings. Worauf ich mich allerdings
  verlasse ist, dass der Wert immer in Kilobyte angegeben ist - hoffe, das ist auch so, ansonsten m端sste man auch noch nach
  "kB|MB|B" parsen.
- System::ConsolePrint hinzugef端gt, damit alle Konsolenfunktionen beisammen sind und man nicht nur, um eine kleine
  Konsolenausgabe t辰tigen zu k旦nnen, auch noch File einbinden muss. So wird die Funktion auch gefunden, ansonsten w端rde
  man sich wohl wundern, dass zwar alle m旦glichen Konsolenfunktionen in System zu finden sind, nur ein simples Print fehlt.



>> 27.02.2008
[CO]
- Bugfix: "XmlBase::XmlBase(void *pData)", "((XmlBase*)m_pData)"... autsch, das sollte nat端rlich
  "((TiXmlBase*)m_pData)" heien, muss irgendwann einmal durcheinander gekommen sein... gab nat端rlich ein
  Speicherleck + ein Test wie 'GetFirstChild() == GetLastChild()' um zu sehen obs nur ein Kind gibt ging nat端rlich
  nicht da jedesmal ein anderer PL XML Knoten zur端ckgegeben wurde.
- Iteratoren: berarbeitete die Implementation nochmal so das Iteratoren beliebig 'kopiert' werden k旦nnen. Intern
  wird 辰hnlich wie bei bei den Strings gearbeitet - Implementationen werden gemeinsam genutzt so lange das m旦glich
  ist und erst wenn sich etwas 辰ndert muss 'geklont' werden. Ansonnsten h辰tte man einen ziemlichen Overhead in der
  'Standard Anwendung' z.B. "Iterator<int> cIterator = lstMyList.GetIterator()" da intern dann mehrmals dynamisch
  Speicher angelegt und wieder freigegeben werden m端sste.
- Neue Funktion: System::SetConsoleCursorPosition(): Wie von Stefan gew端nscht eine Funktion zum setzen des
  Konsolen Cursors. F端gte auch 'GetConsoleCursorPosition()' hinzu damit das vollst辰ndig ist.
  Die Linux Implementationen von 'ClearConsoleScreen() & SetConsoleCursorPosition()' m端sste man noch testen - hab
  hier mal den Weg 端ber ANSI Sequenzen gew辰hlt, diese L旦sung findet man im Internet recht h辰ufig. F端r
  'GetConsoleCursorPosition()' konnte ich auch nach l辰ngerem Suchen keine einfache akzeptable L旦sung finden.
- SystemWin32: 'GetComputerName()' und 'GetUserName()' ermitteln den n旦tigen Speicher nun automatisch passend.
  'GetProgramName()' hat leider weiterhin eine 'feste' gr旦e die ich allerdings von '1024' auf 'MAX_PATH' setzte
  da ich f端r 'GetModuleFileName()' nix finden konnte das einem zur端ck gibt wieviel Speicher man denn nun eigentlich
  wirklich braucht.
- System-Klasse um einige Funktionen erweitert 端ber die man Informationen 端ber den Speicher bekommen kann. Dies d端rfte
  praktisch f端r Resource Manager sein da diese solche Informationen nutzen k旦nnen um rauszufinden wann es sinnvoll
  ist etwas l辰nger nicht mehr genutzte Resourcen 端ber Bord zu werfen. Diese Funktionen 'k旦nnte' man auch in
  'MemoryManager' halten, allerdings passt es doch am Ende etwas besser in die 'System'-Klasse. Habe in der
  'MemoryManager'-Klasse allerdings ein kleines Kommentar eingef端gt falls jemand dort zuerst nach diesen Funktionen
  suchen sollte. Die Windows Implementation ist 'sehr' einfach, bei der Linux Implementation ist es ein 'wenig'
  mehr (wie irgendwie fast immer...) aber immer noch im bereich des ertr辰glichen. Den Linux Code m端sste man noch
  testen ob das so korrekt l辰uft.
  Da es recht viele Funktionen f端r Speicher Informationen sind 端berlegte ich zuerst ob man diese Informationen nicht
  besser gesammelt in einer Struktur speichert, entschloss mich dann aber dagegen da es 端ber Funktionen irgendwie
  'sch旦ner' zu nutzen ist.



>> 26.02.2008
[CO]
- CmdLineParser::CmdArrayToString(): "int argc, const char **argv"-Parameter zu "const Array<String> &lstArray"
  gemacht... das ist universeller so herum. Ansonnsten h辰tte man etwas f端r 'wchar_t' und 'utf8' hinzuf端gen m端ssen...
  "#include <string.h>" hinterherwink *g*



>> 24.02.2008
[SB]
- Seit den letzten nderungen lie sich die Engine bei mir unter Windows nicht mehr compilieren, da es beim
  Linken unresolved references auf Tools::FloatToUInt32 und Tools::UInt32ToFloat gab. Das Problem konnte
  durch das Entfernen von PLGENERAL_API vor diesen Funktionen behoben werden. Ich nehme an, dass das
  deswegen erst jetzt auftritt, weil in PLGeneral nun der Header selbst nicht mehr eingebunden wird und
  der Compiler diese Funktionen daher nicht mehr sieht und somit auch nicht compilieren und exportieren kann.
  Da die Funktionen als inline deklariert sind, sollte hier aber sowieso nichts export werden, sondern erst
  beim Einbinden durch den Compiler an die entsprechende Stelle eingesetzt werden. Damit da nichts durcheinander
  kommt (und das inline dadurch nutzlos wird), sollte bei Inline-Funktionen also k端nftig kein Export-Makro
  mehr verwendet werden.



>> 23.02.2008
[CO]
- PLMain(): 'MODULE_HANDLE hModule' ersatzlos heraus genommen da wir selbst es noch nirgends verwendet haben
  und ich im Augenblick auch nicht w端sste wof端r wir das noch brauchen - zumal es dies unter Linux scheinbar
  erst gar nicht gibt. Sollte ein Windows Nutzer es mal f端r etwas spezielles brauchen, muss er einfach die
  entsprechende Windows Funktion nutzen um an den Module/Instanz-Handle zu kommen... in dem Fall macht er dann
  eh etwas Platform spezifisches. :D
  "PLGeneralLinuxIncludes.h" k旦nnte man nun herausnehmen da komplett leer.
- Habe in PLMain() 'lstArgs' zu 'lstArguments' gemacht, 'args' ist zwar 'gel辰ufig'... aber das muss hier nicht
  sein diese zwanghafte Abk端rzung. Wird eh nur selten genutzt und daher ist "Schreibaufwand" kein Argument,
  lesbarkeit aber schon. :D
- ParseIntegerArray(), ParseFloatArray(), ParseDoubleArray(), GetFlagsFromString() und GetStringFromFlags() von
  der 'Tools'-Klasse in eine neue 'ParseTools'-Klasse verschoben die sich im 'String'-Ordner befindet
- 'Tools::FlipRB3()'-Funktion in 'PLGraphics::Color3' verschoben + dieses Funktion heit dort nun 'SwapRB'
- 'Tools::FlipRB4()'-Funktion in 'PLGraphics::Color4' verschoben + dieses Funktion heit dort nun 'SwapRB'
- Ein paar Copy-Operators und Copy-Constructors hinzugef端gt
- Ein paar Copy-Operators und Copy-Constructors entfernt da unn旦tig, sprich, die automatische erzeugten sind
  v旦llig ausreichend. Klassen: Version, Time



>> 18.02.2008
[CO]
- Directory::CreateRecursive() Implementation nochmal 端berarbeitet so das nur Url-Funktionen genutzt werden



>> 17.02.2008
[SB]
- PLGeneral l辰t sich nun wieder unter Linux 端bersetzen. Und manchmal frage ich mich wirklich, wozu ich
  Dinge dokumentiere ...
  Aus FileWin32.h:
    // Hmmmpf, not nice. But better than to include <stdio.h>, and as it must only work on Windows, it might be ok :-)
    struct _iobuf;
   typedef struct _iobuf FILE;
  Hier habe ich doch explizit geschrieben, dass dieser Hack *nur unter Windows* funktionieren wird. Deswegen steht
  da auch "as it must only work on Windows". Und darum war auch im Linux-Header entsprechend <stdio.h> eingebunden,
  weil das da nunmal leider nicht so geht (evtl. kann man es dort anders vordefinieren, aber da die Header da zig
  if's und defines enthalten, wird dies wohl auf jedem System anders aussehen). Und nun wird einfach dieser Kommentar
  kopiert, "Windows" durch "Linux" ersetzt und geglaubt, so ginge das.
  Entschuldigung, aber sowas verstehe ich einfach nicht. Kann man nicht bitte mal vor dem ndern davon ausgehen, dass
  andere Programmierer (ich, in diesem Falle) sich auch etwas *dabei denken*, was sie schreiben, und es somit wohl einen
  *Grund* hat, wenn die Forward-Declaration zwar im Windows-Header drin ist, aber im Linux Header nicht? Und wenn man dann
  trotzdem meint, dass das alles Quatsch ist und man das 辰ndern muss, dann *muss* man das bitte auch unter Linux 端bersetzen
  und dort ausprobieren, und nicht einfach davon ausgehen, dass das schon gehen wird (insbesondere dann, wenn ich im Kommentar
  extra darauf hingewiesen habe, dass dies so nur unter Windows geht).
- Var.cpp: Habe ebenfalls die nderung mit PLGeneralLinuxWrapper.h wieder r端ckg辰ngig machen m端ssen, da es eben
  '_atoi64' unter Linux leider nicht gibt. Wo die Information herkommen soll, dass es diese Funktion unter Linux
  nun auch in stdlib.h geben 'm端sste', ist mir schleierhaft, eine Suche per Google gibt jedenfalls nur zig mal die
  Information, dass es das unter Linux eben nicht gibt. Vielleicht k旦nnten wir das nun einfach mal so lassen, und
  nicht in einem halben Jahr wieder behaupten, dass es nun gehen m端sste, ohne auszutesten, dass das auch wirklich so ist.



>> 17.02.2008
[CO]
- LogFormaterConsole: Nutzt wieder 'printf' direkt anstatt 'File::StandardOutput' da es ansonnsten dank der statischen
  De-initialisierungs Reihenfolge in PLSampleChat einen Crash beim beenden geben kann :/
PLNetwork:
- Copy-Operators und Copy-Constructors hinzugef端gt



>> 16.02.2008
[CO]
- File: ESeek andere Werte vergeben damit diese mit SEEK_CUR, SEEK_END, SEEK_SET aus 'stdio.h' zusammenpassen, das ist sicherlich
  eine gute Sache... in z.B. 'PLSoundFMOD/SoundManagerFMOD.cpp' musste man extra 'stdio.h' einbinden 'nur' um an diese Definitionen
  zu kommen was ich irgendwie d辰mlich fand. ("Mit Kanonen auf Spatzen schieen")
- Var.cpp: Nahm den speziellen Linux Include '#include "PLGeneral/PLGeneralLinuxWrapper.h"' heraus, auch dort 'm端sste' '_atoi64'
  in 'stdlib.h' definiert sein
- System: Neue Funktion: GetConsoleCharacter(): Liest ein einziges Zeichen von der Konsole, f端r die Linux Fassung musste ich mal
  wieder Code 'aus dem Internet' nehmen... das so einfache Dinge so kompliert und nicht Plattform unabh辰ngig sein m端ssen. *gruml*
  Wie 端blich wieder ausf端hrlich dazu geschrieben woher das kommt.
- System: Neue Funktion: ClearConsoleScreen(): 'L旦scht' den Inhalt der Konsole, ebenfalls etwas sehr praktisches... aber auch wieder
  etwas das obwohl so Grundliegend, nicht wirklich so einfach ist daher auch hier wieder 'gefundener Code' sammt woher er kommt...
- FileHttp genauso wie die anderen File Implementationen alles private gemacht da man da von auen nicht mehr rankommen k旦nnen sollte
  (es sprichts nichts dagegen, oder?)
- SystemWin32::GetEnvironmentVariable(): Nahm das [TODO] heraus und erweiterte das Kommentar 'etwas' damit man nachvollziehen kann
  warum das so 'merkw端rdig' aussieht... das ist eine reine Optimierung. (nicht Performance 'kritisch', aber wenns m旦glich ist...)
  W端rde man nur "GetEnvironmentVariableW(sName.GetUnicode(), NULL, 0)" schreiben, m端sste 'sName' intern zwanghaft in Unicode
  konvertiert werden auch wenn das 端berhaupt nicht n旦tig ist da ASCII gegeben ist und eine solche Umgebungs Variable nicht
  existiert, existiert diese muss dann nat端rlich konvertiert werden da wir nicht vorher feststellen k旦nnen ob f端r den Wert
  ASCII reicht oder nicht. (w端rd ich also gerne so lassen auch wenns 'Erbsenz辰hlerei' ist, das zeigt das man da mit liebe
  f端rs Detail rangeht :)
- Directory::CreateRecursive() Implementiert. Weis nicht ob das mit "System::GetInstance()->GetCurrentDir()" so prall ist, w端sste
  aber im Augenblick nicht wie man das anderst machen sollte, auf jedenfall funktioniert es recht gut.
- 'Directory.h': "PLGeneral/File/FileSearch.h" durch 'Forward declaration' ersetzt. Ich erw辰hne es da ich mir gerade nicht sicher
  bin ob das so absicht war oder nicht. (Regel sollte sein 'Forward declaration' wo geht, das h辰lt die Compile dauer + das neu
  Compilieren bei Header nderungen sch旦n niedrig was die Produktivit辰t steigert, bei der Sache bin ich wirklich stark hinterher
  da es sich wirklich auszahlt *g*)



>> 15.02.2008
[CO]
- Klassen im 'Container'-Ordner nochmal durchgeschaut (haupts辰chlich nur Zeilen umbr端che)
- Heap & Map und Implementierungen um Copy-Operator und Copy-Constructor erweitert, auch wenn diese erstmal nicht Implementiert
  und daher private sind. Diese Operationen sind nicht ganz ohne... man k旦nnte zwar einen Iterator nutzen, aber dann h辰tte man
  nur 'Werte' aber ohne die dazu geh旦renden 'Schl端ssel' - da muss ich mir noch etwas Einfallen lassen.
  Aber so ist's schonmal besser als 端berhaupt nix drinnen zu haben... dadurch viel sofort ein Bug im 'FileAccess' Copy-Constructor
  auf der bereits eifrig den nicht vorhandenen HashMap Copy-Constructor nutzte. :/
- SimpleMap: Speziellen Copy-Operator hinzugef端gt, im grunde w端rde der automatische reichen wie beim automatischen Copy-Constructor,
  aber der R端ckgabewert sollte hier ein universelles 'Map' sein
- HashMap: Speziellen Copy-Constructor und Copy-Operator hinzugef端gt, wird bereits von 'FileAccess' verwendet
- File: "Standard Stream"-Dateien, n辰chster Anlauf nach Stefans Idee - klappt denke ich so recht gut und ist 端berschaubar.
  Habe dies als File Implementation Namens 'FileStdStream' realisiert damit das sauber Implementiert ist und es nicht zu viele
  Sonderf辰lle gibt die man st辰ndig Abfragen muss.
- System: GetTime(), GetMilliseconds() und GetMicroseconds() Funktionen runter zu Sleep() verschoben damit Funktionen mit gleichen
  oder zumindestens sehr 辰hnlichen Jobs 'r辰umlich' beisammen sind
- System: Neue Funktion: IsConsoleKeyHit(): '_kbhit()' Funktion die bei Konsolen Anwendungen recht praktisch sein kann. PLSoundTest
  nutzt diese Funktion bereits. Dort wurde bisher 'im Internet gefundener' Code direkt verwendet - forschte etwas nach woher dieser
  Code stammte und es stellte sich heraus das dieser Code auf flipcode (es ruhe in Frieden) ver旦ffentlicht wurde und recht bekannt
  ist. F端gte beim Linux Port ausf端hrliche Copyright Informationen hinzu. (nutzen 'm端sste' man es k旦nnen)



>> 14.02.2008
[CO]
- SystemLinux::GetCurrentDir(): Ist nun nicht mehr auf 'MAXPATHLEN' beschr辰nkt sondern ist Dynamisch
- Ging die System und XML Klassen nochmal ganz genau durch und f端gte wo n旦tig Copy-Constructor und Copy-Operator
  hinzu. In z.B. 'DynLibLinux' ist dies jedoch nicht wirklich n旦tig da der User da nicht rankommt. (oder sollen wir
  hier dann trotzdem soetwas hinzuf端gen?)
  Schaute auch das jede Anweisung in einer eigenen Zeile steht - das machts einfacher wenn man mal einen Break-Point
  setzen will auch wenn das die Anzahl der Zeilen etwas aufbl辰ht, die Vorteile 端berwiegen.
- File-Klassen nochmal genau durchgeschaut
- FileSearchImpl: 'm_pSearch' herausgenommen (bin mir zu 99% sicher das dies noch ein alter berbleibsel war :)
- FileSearch: Copy-Operator hinzugef端gt... hier erw辰hne ich es da es etwas umfangreicher ist, auch im Copy-Constructor
  辰nderte ich eine kleinigkeit. (sah etwas merkw端rdig aus, funktionell nat端rlich kein Unterschied)
- FileObject: Destruktor virtuell gemacht
- FileAccess: 'NullEntry' zu einer 旦ffentlichen Klassenvariable gemacht damit man von auen testen kann ob das als Ergebniss
  zur端ck kam + FileAccess braucht weniger Speicher (das erste Argument war ausschlag geben *g*)
- SocketAddress: "SocketAddress::SocketAddress(const String &sHost, uint32 nPort)" auskommentieren Code entfernt, schien mir
  wirklich 'tot' zu sein (sprich Nutzlos :)
- 'CmdLineParser' vom 'Tools'- in den 'String'-Ordner verschoben da es dort viel besser reinpasst, ist ja nur ein einfaches
  String Parsing. (also w端rde ich wohl auch genau in diesem Ordner danach suchen :)
  Wollte auch zuerst die 'Localization'-Klassen in den 'String'-Ordner verschieben da diese ebenfalls 'nur' dazu da sind um
  einen String von einer Sprache in eine andere zu bringen... aber da diese Klassen bereits das Loadable-System nutzen das
  zuk端nftig wie es aussieht in PLCore liegen wird, wird das Localization-System wohl auch mit in PLCore wandern m端ssen. Bei
  Zeiten sollten wir mal f端r das Localization-System ein Loader Plugin schreiben das die Sprachen/bersetzungen aus einer
  Datenbank ausliest. *g*
PLNetwork:
- 'SocketAddress' und 'Socket' heraus genommen da diese mittlerweile in PLGeneral liegen. (oder gabs einen speziellen Grund wieso
  das auch dort noch lag?) Wenn ich das richtig sehe gibts kein 'Socket::Create()' mehr und das wird inter automatisch erzeugt,
  darum entfernte ich die entsprechenden Funktions aufrufe.



>> 13.02.2008
[CO]
- File: Um "Standard Stream"-Dateien erweitert... das bot sich direkt an das "Dinge auf Konsole ausgeben"  hier端ber zu
  realisieren anstatt seperate Funktionen z.B. in die System-Klasse zu stecken. (k旦nnten wir nat端rlich immer noch, aber ich denke
  das ist erstmal unn旦tig) Intern ist das sowieso so realisiert + damit kommen andere Dinge wie man im Punkt unten sehen kann
  'for free'... hat also durchaus seine Vorz端ge. *g*
  Erweiterte daf端r "EAccess" in der File Klasse damit das ohne groe nderungen ins Interface passt. In "File::Open()",
  "FileWin32::Open()" und "FileWin32::Linux()" musste etwas Code eingef端gt werden - Stefan, schau dir das bitte genau an, nicht
  das diese nderung 端berhaupt nicht ins Konzept passt und alles durcheinander bringt. Hatte mir schon 端berlegt ob eine extra
  "StandardStream"-Datei Implementation angebracht w辰re... aber irgendwie war mir das dann mit Kanonen auf Spatzen geschossen.
- "Print()"-Funktion aus den XML Klassen genommen da sich dies nun 端ber eine "Standard Stream"-Datei realisieren l辰sst.
  In der PLBaseTest Funktion "XmlTest::Test()" kann man sehen wie das Schreiben 'in die Konsole' dar端ber zu realisieren ist.
- XmlDocument: "LoadFile()" und "SaveFile()" Funktionen in "Load()" und "Save()" umbenannt damit das konsistent zu den anderen
  Funktionen ist.



>> 12.02.2008
[CO]
- Iteratoren wie besprochen umgeschrieben so das diese problemlos immer auf dem Stack liegen k旦nnen damit man kein 'delete' mehr
  nutzen muss was man ja leider schnell mal vergisst. Alle Projekte entsprechend angepasst und darauf geachtet das die Iteratoren
  immer im kleinst m旦glichen Bereich genutzt werden damit so wenig wie m旦glich schief gehen kann. Daf端r habe ich hier und da auch
  extra Bl旦cke hinzugef端gt was ich allerdings nicht 'schlimm' finde da es f端r mehr 'Sicherheit' sorgt, (Thematik ver辰nderung der
  Datenstruktur auf die der Iterator gerade arbeitet) das ersetzt praktisch das 'delete'. :)
  Im Iterator Copy-Constructor ist momentan noch ein kleiner Hack drinnen der den konstanten Parameter auf nicht Konstant umbiegt
  damit dort die Iterator Implementation zur端ck gesetzt werden kann - macht man den Parameter nicht Konstant erh辰lt man tonnenweise
  Compiler Warnungen... momentan weis ich noch nicht wie man das anderst l旦sen k旦nnte. (bei nicht konstant kann man ein Tempor辰res
  Objekt 辰ndern das der Compiler nicht mag da Seiteneffekte m旦glich)
  Aber die Bedienung der Iteratoren ist so nun auf jedenfall 'deutlich' Eleganter und weniger Speicherleck anf辰llig. :D



>> 09.02.2008
[CO]
Gelaber:
- Nachdem ich gestern meine letzte Pr端fung im total 端berf端llten 3'ten Semester geschrieben habe kann ich nun
  ENDLICH wieder mehr an PL machen. Am 17.03.2008 gehts dann weiter mit dem 4'ten Semester das hoffentlich nicht
  mehr so heftig wird wie das aktuelle. Bis dahin nur noch PL und daher wieder mehr Tagebuch Eintr辰ge meinerseits. :D
Alle Projekte:
- Auf Visual Studio 2008 umgestellt damit man 'relativ problemlos' auch unter Vista arbeiten kann ohne erstmal
  die Entwicklungsumgebung mit x Vista-Patches vollzudr旦hnen die dann doch nicht gehen (zumindestens bei mir nicht)
- In den 'sln'-Dateien hat sich nix gro ge辰ndert, nur die Versionsnummer:
      Microsoft Visual Studio Solution File, Format Version 9.00
      # Visual Studio 2005
  wurde zu
      Microsoft Visual Studio Solution File, Format Version 10.00
      # Visual Studio 2008
  In den 'vcproj'-Dateien hat sich zum Gl端ck auch nicht wirklich viel ver辰ndert. In "<VisualStudioProject"
      Version="8,00" wurde zu Version="9,00"
  und
      TargetFrameworkVersion="131072"
  kam neu hinzu.
-     <Tool
          Name="VCWebDeploymentTool"
      />
  Wurde automatisch entfernt da "Web deployment to the local IIS server is no longer supported", f端r was auch
  immer das gut war, nicht mehr unterst端tzt wird - wir werden es sicher nicht vermissen. *g*
- Bei "<Tool Name="VCLinkerTool"" gibts zwei neue Optionen die automatisch hinzugef端gt wurden:
      RandomizedBaseAddress="1"
      DataExecutionPrevention="0"
- "Data Execution Prevention (DEP)" auf "Image is compatible with DEP (/NXCOMPAT)" gestellt, das ist eine gute Sache
  und sollte bei uns keine Probleme geben (konnte jedenfalls keine feststellen)
- Folgende Warnung erschien nun 旦fters mal:
      "Command line warning D9035 : option 'Wp64' has been deprecated and will be removed in a future release"
  Da diese Meldung leider wie es aussieht nicht Deaktivierbar ist und das 'etwas' st旦rrend ist deaktivierte
  ich "/Wp64 (Detect 64-Bit Portability Issues)". 64 Bit Compilieren ist momentan bei uns kein Thema... und falls
  man das doch mal ausprobieren will muss sich einer von uns erstmal ein 64 Bit Windows Installieren (zum Testen)
  + den 64 Bit VC Compiler. (sehe momentan aber keinen Grund das zu tun, gibt wichtigeres momentan :)
- Ging die Projekt-Abh辰ngigkeiten (Menu bar -> Project -> Project Build Order... -> Dependencies)
  nochmal durch und korrigierte wo n旦tig. Damit geht das komplett bersetzen wieder beim ersten mal sauber durch
  ohne das Fehlermeldungen kommen das z.B. 'PLGeneral.lib' nicht gefunden werden konnte da z.B. PLNetwork vorher
  'fertig wurde' mit dem bersetzen. (Multi-Threading sei dank *g*)
- "LINK : warning LNK4224: /OPT:NOWIN98 is no longer supported;  ignored" -> "Optimize for Windows98"
  auf Default gesetzt... das Unterst端tzen wir eh nicht. (selbst MS hat mittlerweie den Support daf端r
  fallen gelassen)
PLGeneral:
- "LIBCMT,MSVCRT" zu den zu ignorierenden Bibliotheken hinzugef端gt um Linker Warnungen zu beseitigen
- "PLGeneralWin32Includes.h": WINVER und _WIN32_WINNT werden, falls bereits Definiert, 'undefiniert' - ansonnsten
  bekam ich hier unter Vista mit VC 2008 Warnungen
- TinyXML: Neuste Version 2.5.3 (intern steht bereits 2.5.4) aus dem Repository genommen und mit VC 2005 端bersetzt.
  "TiXmlBase::PutString()" wurde mittlerweile in "TiXmlBase::EncodeString()" umbenannt und 旦ffentlich gemacht - darum
  haben wir nun nur noch 3 anstatt 4 eigene nderungen in TinyXML. :D
  F端r Linux und VC7 m端sste man das noch 端bersetzen.
PLNetwork:
- Warnung "warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead.
  To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details." beseitigt indem ich 'strncpy'
  durch 'MemoryManager::Copy' ersetzte - da wird nicht lange gez旦gert *g*



>> 05.02.2008
[SB]
PLCore:
- Auf Basis der Funktoren ein Event-System im Signal/Slot bzw. Event/Delegate Stil erstellt.
  Das ganze funktioniert so:
    void TestEvent(int nParam) { /* do something here */ }
  Event<int> cEvent;
  EventHandler<int> cHandler1(TestEvent);
  cEvent.Connect(&cHandler1);
  cEvent.Emit(1);
  Dabei ist zu beachten, dass ein EventHandler nat端rlich ein ganz normales Objekt ist, das dementsprechend verwaltet werden mu.
  Wenn man also z.B. ein EventHandler per new erzeugt, mu man diesen auch wieder l旦schen. Um das zu vereinfachen, gibt es
  die Basisklasse EventObserver und die spezialisierte Klasse ManagedEventHandler. Wann immer ein ManagedEventHandler f端r eine
  Memberfunktion einer Klasse erzeugt wird, die von EventObserver abgeleitet ist, k端mmert sich diese automatisch um das sp辰tere
  L旦schen des Handlers:
    class Test : public EventObserver {
      Test() {
        // Diese Instanz wird automatisch sp辰ter gel旦scht
        g_pMainWindow.OnAlienEvent.Connect(new ManagedEventHandler<int>(&Test::OnAlien, this));
    }
    void OnAlien(int nParam) {
    }
  }
- Projekt PLCore begonnen und zun辰chst Functor und Event dorthin verschoben.



>> 04.02.2008
[SB]
WOW. Mit den C++ Templates kann man echt viele tolle Dinge machen - man mu nur aufpassen, auf dem Weg dahin
nicht Amok zu laufen ;-)
- Habe meinen ersten Test von Funktionsobjekten entfernt und durch eine neue Implementation ersetzt. Es ist jetzt
  nicht mehr n旦tig, die Anzahl der Parameter beim Template mit anzugeben - das merkt das Template nun von selbst.
  Auch kann man jetzt die Klasse Functor direkt verwenden, und der einfach einen beliebigen g端ltigen Zeiger
  auf eine Funktion hineingeben - egal ob statisch oder Memberfunktion einer Klasse. Beispiel:
  Functor<int, int> cFunc(TestFunction);
  Functor<int, int> cFunc(&Class::TestMethod, &cObject);
  int nRes = cFunc(10);
  Dank vieler verr端ckter Template-Tricks m端te das ganze Typensicher sein - man kann die Klasse also nicht austricksen
  und z.B. einen Zeiger auf ein Objekt falschen Typs hineingeben oder aus einem int(int) ein int(float) machen.
  Es war jetzt auch nicht mehr n旦tig, noch Makros zu verwenden - das ganze geht komplett nur mit Templates. Allerdings
  steht zur Zeit noch der Test aus, ob auch alle Compiler die wir verwenden das ganze m旦gen (VC8 mag es jedenfalls).
  Da der ganze Template-Mechanismus beim Compilieren abl辰uft braucht 端brigens auch keine Angst zu entstehen, dass das
  ganze ein zu groer Overhead w辰re und daher die Performance beeintr辰chtigen k旦nnte. Die ganzen Hilfsklassen sind nur
  daf端r da, damit der Compiler die richtigen Typen zur richtigen Zeit findet, da sie aber weder Daten beinhalten noch
  jemals Instanzen davon erzeugt werden, bleibt davon zur Laufzeit nichts mehr 端brig :-) Das ganze reduziert sich
  dann auf das Dereferenzieren zweier Pointer :-) 



>> 22.01.2008
[CO]
Alle Projekte:
- berall den Style der Konstruktor Initialisierer-Liste wie vor geraumer Zeit besprochen angepasst



>> 22.01.2008
[CO]
- ClassManager::LoadPlugin(): Hier hatte sich ein Fehler eingeschlichen so das manche Plugins nicht gefunden
  werden konnten. Man kann innerhalb der '.plugin'-Datei auch absolute dll-Pfade nutzen, z.b. zu Testzwecken -
  ansonnsten sind die dll's IMMER relativ zum Verzeichniss in dem sich die '.plugin'-Datei befindet.



>> 19.01.2008
[CO]
- F端gte wie von Stefan gew端nscht eine 'Set'-Funktion zur 'Map'-Klasse + deren Implementationen hinzu. Lies die 'Add'
  und 'Remove' Funktionen jedoch drinnen da ich finde das diese durchaus ihre Existenzberechtigung haben. (sonst h辰tten
  wir wohl schon vvviiiiel fr端her die 'Set'-Funktion eingebaut :)
  Z.B. kann man 端ber 'Add' mehrmals den gleichen Schl端ssel einf端gen, das verh辰lt sich im Grunde dann wie ein 'Stack' +
  'Replace' ersetzt wirklich nur einen Wert wenn dieser bereits in der Map war, ansonnsten wird nix gemacht.
- PLMain: Unicode-Support f端r die Kommandozeilen-Parameter hinzugef端gt, f端r Linux k旦nnte ich nix spezielles finden...



>> 18.01.2008
[CO]
Alle Projekte:
- berall "Predefinitions" durch "Forward declarations" ersetzt
- Ein paar unn旦tige Includes entfernt ("Include-Sparsamkeit" ist mir extrem wichtig :)
- "uint32 HashFunction::Hash(const char szKey[])" und "uint32 HashFunction::Hash(const String &sKey)":
  Variable 'g' in die Schleife gezogen + die Zuweisung in der Abfrage entfernt
- Alle 'doxyfile'-Dateien an die 'Doc'-Ordner verschiebung angepasst
- "Config/" in Dateinamen beim Laden/Speichern von Konfigurationen entfernt, das regelt das Loadable System
  intern selbst wo diese Dateien standardm辰ig landen
PLGeneral:
- Bugfix: Fand gerade den Grund daf端r das es z.B. beim laden der Szene 'PhysicsPlayground.scene' Crashte:
  "FileWin32::Open()": Hier konnte es eine Situation geben in der 'szMode' nicht Initialisiert wurde. In dieser
  kombination muss 'ung端ltig' zur端ck gegeben werden. ("FileLinux" nat端rlich das gleiche)
    (!(nAccess & File::FileWrite) && !(nAccess & File::FileCreate) && !(nAccess & File::FileAppend))
- Bugfix: "FileWin32::Open()": Bei folgender Kombination klappte das noch nicht wie erwartet:
    (nAccess & File::FileWrite) && !(nAccess & File::FileCreate) && !(nAccess & File::FileAppend)
  Wenn man nicht "FileRead" gesetzt hatte gab die Funktion 'ung端ltig' zur端ck obwohl eine Datei bereits
  existierte in die man h辰tte schreiben k旦nnen. Daher wird hier nun erstmal gepr端ft ob die Datei bereits
  vorhanden ist, wenn ja kann man den "w"-Modus nutzen, ansonnsten wird 'ung端ltig' zur端ckgegeben.
  ("FileLinux" nat端rlich das gleiche)
- "File::Open(uint32 nAccess = 0)" zu "File::Open(uint32 nAccess)" gemacht da '0' eine ung端ltige Flag-Kombination ist
- Loader::OpenFile(): Muss Dateien auch korrekt erzeugen k旦nnen beim Speichern, das m端sste so nun hoffentlich
  passen... nach den oberen nderungen konnte ich keine Probleme mehr feststellen
- LoadableManagerLoaderPL: 'FileSystemSettings' entfernt und 'BaseDirectories' nach 'LoadableManagerSettings'
  verschoben
- "Loader::OpenFile()": Kennt nun 'nur' noch Basis Verzeichnisse, also kein '-1 = das aktuelle Verzeichniss'... dies
  war h旦chst Problematisch da dies nicht mit den 'Priorit辰ten' der Basis Verzeichnisse zusammen passte. War etwas im
  aktuellen Verzeichniss, also standardm辰ig wo das Programm selbst liegt, wurde diese Datei 'immer' genommen, auch
  wenn man z.B. im Falle des Scene Viewers dem Verzeichniss in dem die aktuelle Szene liegt die h旦chste Priorit辰t geben
  wollte damit 'zuallererst' geschaut wird ob die gesuchte Datei dort liegt.
- LoadableManager: "", also ein leerer String ist nun ebenfalls ein g端ltiger Basis-Pfad und steht f端r das
  'aktuelle Verzeichniss'
- LoadableManager:SetBaseDirPriority(): Bei den URL-Umstellungen hatte sich hier ein kleiner Fehler eingeschlichen
  so das die Priorit辰ten nicht korrekt ge辰ndert wurden



>> 14.01.2008
[SB]
- Beim Lesen aus Archiven mit dem Flag FileMemBuf gab es Probleme, weil die Zeilenenden auch dann konvertiert wurden,
  wenn die Datei als Binary ge旦ffnet wurde. Nachdem ich dieses Problem behoben hatte, scheinen auch wieder alle Daten
  richtig geladen zu werden :-)
- Habe das Flag FileBinary komplett gel旦scht, da dieses nur Probleme machte. Generell werden Dateien im Bin辰rmodus ge旦ffnet,
  wenn dies nicht gew端nscht ist, muss FileText angegeben werden.
- Registry-Klasse in einen eigenen Ordner verschoben.
- Url::Collapse: Hier gab es einige Probleme, wenn ein ".." am Ende des Pfades stand. Diese sind nun hoffentlich behoben ...
- nderungen aus dem Rewrite-Branch in den Trunk 端bertragen. Gab so weit ich sehen kann keinerlei Probleme - die einzige
  Datei mit einem Conflict war "Diary.txt" :-))



>> 13.01.2008
[CO]
- Ein paar Mini-nderungen an der "Registry"-Klasse



>> 12.01.2008
[SB]
- Wrapper f端r die Registry hinzugef端gt. Ich m旦chte einfach *nirgendwo* mehr direkt auf die Windows-API zugreifen m端ssen,
  da das immer total nervt und meist extrem un端bersichtlich ist. Auch mu man dann ja meist wieder direkt mit irgendwelchen
  String-Buffern hantieren, Speicher allozieren etc. *brrr*. Die Klasse Registry bietet also Zugriff auf die Windows-Registry
  und wrappt einfach die API-Funktionen in eine h端bsche Klasse. Sp辰ter k旦nnte man das evtl. noch erweitern, um auch auf andere
  Registry-Systeme zugreifen zu k旦nnen (z.B. Gnome hat ja auch so etwas). Allerdings w端rden dann nat端rlich auch die ganzen Pfade
  darin vollkommen anders aussehen, das mu man also mal sehen, ob das 端berhaupt sinnvoll w辰re. In jedem Fall kann man nun auch
  端ber die Registry-Klasse abfragen, ob 端berhaupt eine Registry auf dem System vorhanden ist, falls nein kann man dann auf andere
  Methoden zur端ckgreifen und sich so ein #ifdef sparen :-)



>> 11.01.2008
[SB]
- Einige kleinere Fehler in RegEx behoben.



>> 10.01.2008
[SB]
- Neue Toolklasse Version eingebaut. Diese speichert die Versionsnummer eines Projektes und kann diese z.B. als
  String ausgeben. Auch k旦nnen Versionsnummern miteinander verglichen werden. Dies soll sp辰ter verwendet werden,
  um die Versionen der einzelnen Komponenten zu verwalten.



>> 21.12.2007
[SB]
- Neue Klasse RegEx zum Parsen regul辰rer Ausdr端cke eingebaut. Diese sollten wir verwenden, um uns ansonsten schnell
  kompliziert werdende Parsing-Aufgaben zu erleichtern. Ich denke, dass wir damit an manchen Stellen das Parsen
  von Text deutlich vereinfachen k旦nnen, z.B. f端r Vektoren, Listen usw. (a b c) . Der Tokenizer ist zwar recht leistungsf辰hig,
  aber selbst damit ist es immer noch sehr aufwendig, so etwas zu parsen, und die entsprechenden Stellen werden meist
  sehr gro und sind schwer zu lesen. Regul辰re Ausdr端cke d端rften hier weiterhelfen und sind sowieso an vielen Stellen sehr
  n端tzlich :-) Das ganze benutzt den Perl-Syntax f端r regul辰re Ausdr端cke und darf noch kr辰ftig erweitert werden, im Moment
  k旦nnen nur einfache Vergleiche ausgef端hrt werden. Die Klasse ist ein Wrapper f端r die PCRE Library (Perl Compatible
  Regular Expressions), die unter einer BSD-Lizenz steht.
- SearchFilterRegEx: Neuer Suchfilter zum Suchen mit regul辰ren Ausdr端cken.



>> 15.12.2007
[CO]
- Loadable System nderung vom 08.12.2007 im Main-Branch wieder r端ckg辰ngig gemacht da nicht alles wieder ging wie vorher
  und Stefan das im seperaten Branch komplett 端berarbeitet. So haben wir zumindestens wieder eine voll lauff辰hige Version.



>> 09.12.2007
[SB]
- Einige Unklarheiten beseitig, die beim Umstellen auf das neue FS deutlich wurden.
- Url: Die Methoden zum Zur端ckgeben der URL etwas umsortiert und umbenannt, damit deren Verwendung verst辰ndlicher wird.
  Man sollte eigentlich immer Url::GetNative() verwenden, denn dies gibt den Pfad im nativen Format zur端ck, sofern dies
  ein lokaler Pfad ist, ansonsten als URL, wenn es sich z.B. um http:// handelt. Das scheint mir der nat端rlichste Weg zu
  sein, weil der Pfad f端r den User "normal" angezeigt wird, und nur dann z.B. ein Protokoll hinzugef端gt wird, wenn das
  auch wirklich n旦tig ist. GetUrl() dagegen gibt in jedem Fall file:// heraus, was man aber normaler Weise nicht haben
  m旦chte und auch nicht braucht. Als Faustregel w端rde ich daher sagen:
  - Zur bergabe von URLs (z.B. zum Laden/Speichern): GetUrl()
  - Zur Ausgabe von URLs an den Benutzer: GetNative()
- Url: Zugriff auf die einzelnen Teile einer Url etwas ver辰ndert und Funktionen f端r die h辰ufigsten Zugriffsformen
  hinzugef端gt (z.B. nur Pfad oder Dateiname ohne Endung) 
- FileObject, File, Directory: GetUrl() gibt *immer* eine URL ohne "/" am Ende zur端ck. Dies ist wichtig zu wissen, denn
  dann kann man z.B. ohne Bedenken cDir.GetUrl() + "/filename.txt" schreiben, ohne noch selbst auf "/" testen zu m端ssen.
  Einzige Besonderheit: Beim Mounten von ZIP-Dateien mu das "/" angegeben werden, damit das FS 端berhaupt wei, dass diese
  ZIP-Datei als Verzeichnis angesprochen werden soll und nicht einfach die Datei ge旦ffnet werden soll. Das 辰ndert aber nichts
  an der Regel, dass GetUrl() auch in diesem Fall ohne "/" zur端ckgegeben wird!
- FileObject: Erweiterte die Funktionen zum Zugriff auf die URL, damit man die h辰ufig ben旦tigten Funktionen direkt zur
  Hand hat und nicht st辰ndig Url's daf端r erzeugen muss. Die Funktionen sind analog zur Url-Klasse und wrappen diese:
  GetUrl() gibt nun das Url-Objekt zur端ck, damit dieses nicht unn旦tig neu erzeugt werden mu
  GetPathUrl() gibt die Url als String zur端ck
  GetPathNative() gibt den Native-Path als String zur端ck
  GetPathWindows() gibt den Windows-Path als String zur端ck
  GetPathUnix() gibt den Unix-Path als String zur端ck
  GetFilename() gibt nur den Dateinamen zur端ck
- Threads etwas umgebaut und GetMainThread() in System eingebaut.
- File: FileBinary und FileText vertauscht, damit ist FileBinary nun wieder der Standard.
- Die Engine auf das neue FS umgestellt. Dabei sind mir einige Stellen aufgefallen, die noch deutlich 端berarbeitet werden
  sollten, z.B. werden noch viel zu Oft irgendwelche Dateipfade auseinandergebr旦selt, hier sollte zumindest versucht werden,
  das m旦glichst transparent nur an einer Stelle zu tun. Manche Dateitypen suchen dann wieder selbst die Basispfade durch
  oder geben einen festen Pfad vor (z.B. "data/sounds"), das sollte auf jeden Fall raus. Viele Dinge habe ich nur blind
  umstellen k旦nnen und f端rchte, dass das nicht mehr richtig funktionieren wird. Dies war aber schlecht anders m旦glich, da
  mir teilweise die Funktionsweise der entsprechenden Funktion nicht wirklich klar wurde und ein komplettes Neuschreiben
  on-the-fly zu aufwendig w辰re.
- Es l辰t sich nun wieder alles compilieren, allerdings funktionieren die Loader noch nicht wieder richtig, weshalb viele
  Dateien noch nicht gefunden werden k旦nnen. Als n辰chstes werde ich daher die f端r sp辰ter geplanten Arbeiten vorziehen und
  das Config- und das Loader-System 端berarbeiten. Es d端rfte sinnvoller sein, dies nun gleich neu zu machen, als erstmal
  das alte wieder m端hselig zum Laufen zu bringen um es dann hinterher doch noch neu zu schreiben.



>> 08.12.2007
[SB]
- PLGeneral/System 端berarbeitet: Globale Manager entfernt, direkte Instanzen der Klassen sind jetzt m旦glich und
  Impl-Klassen nach dem gleichen Pattern wie in File 端berarbeitet.
- Folgendes Pattern f端r Implementationsklassen soll nun 端berall m旦glichst identisch verwendet werden:
  - Eine plattformunabh辰ngige Klasse besitzt einen Zeiger auf eine (versteckte) Implementationsklasse
  - Diese wird im Konstruktor (oder evtl. erst sp辰ter, wie in FileObject) erzeugt, aber innerhalb dieser Klasse
  - Die Implementationsklasse besitzt keinen Zeiger zur端ck auf die plattformunabh辰ngige Klasse!
  - Das gesamte Interface der Implementationsklasse sollte protected sein, auch die virtuellen Funktionen.
  - Mittels friend darf die plattformunabh辰ngige Klasse darauf zugreifen.
  - Konkrete Implementation werden abgeleitet, auch diese mit protected-interface.



>> 08.12.2007
[CO]
- Base Path Dinge von FileSystem in LoadableManager verschoben. Ist noch nicht wirklich Prall realsiert, sollte so aber
  erstmal reichen. Nachdem das 端berarbeitet FS drinnen ist sollte man sich das hier nochmal anschaun.



>> 05.12.2007
[SB]
- Map: Auf die Values einer Map kann nun auch nicht-const zugegriffen werden. Dies ist n端tzlich, wenn es sich um abstrakte
  Datentypen (z.B. Klassen) handelt, von denen man nur ein Attribut 辰ndern m旦chte und nicht das gesamte Objekt per
  Replace austauschen m旦chte. 
- SearchFilter implementiert. Beim Auflisten von Dateien wird 端ber die Klasse SearchFilter getestet, ob der gefundene
  Dateiname dem Filter entspricht. Als Standard wird ein WildCard-Filter verwendet, es k旦nnen aber auch individuelle
  Filter implementiert werden.
- GetCurrentDirectory und SetCurrentDirectory in PLGeneral::System implementiert.



>> 04.12.2007
[SB]
- HttpHandle und ZipHandle: Beide Klassen besitzen nun nur noch einen leeren Konstruktor und 旦ffnen zun辰chst keine
  Datei bzw. Verbindung. Daf端r gibt es nun jeweils eine Funktion Open(). 
- Habe mal etwas mit den Ideen herumgespielt, wie man beim FS den Zugriff auf z.B. passwortgesch端tzte Inhalte
  realisieren k旦nnte. Die bisherige Methode, Open(Name, Passwort) gef辰llt mir aus folgenden Gr端nden nicht:
  - Die Signatur von Open wird um einen Parameter erweitert, den vermutlich die meisten User zun辰chst nicht verstehen
  - Es wird nur von einem Passwort ausgegangen, in vielen F辰llen kann es aber noch mehr Parameter geben
    (Username/Passwort, Crypto-Keys u.v.m.)
  - Wenn man z.B. eine Datei "http://www.pixellight.org/test.zip/dir/test.txt" laden m旦chte, kann man an verschiedenen Stellen
    einen Zugriffsschutz haben, z.B. einmal f端r den http-server (username/passwort), und dann noch einmal f端r die Zip-Datei.
    Mit dieser L旦sung ist es aber nicht m旦glich, mehrere Passw旦rter zu 端bergeben, ausserdem vermittelt Open(Name, Passwort)
    in diesem Falle den Eindruck, dass das Passwort f端r test.txt ben旦tigt wird, was aber gar nicht der Fall ist.
  Es sollte also die M旦glichkeit geben, mehrere Authentifizierungsdaten gleichzeitig anzugeben, falls die Dateisysteme wie
  im obigen Beispiel verschachtelt sind. Ausserdem w辰re es nett, noch weitere Daten 端bergeben zu k旦nnen, z.B. dass bestimmte
  Zugriffsflags verwendet / nicht verwendet werden sollen (z.B.: Zip-File nicht memory-buffered 旦ffnen), oder weitere
  unbestimmte Informationen (annotation like).
- FileAccess implementiert, dies soll so funktionieren wie oben angegeben. Kleines Beispiel:
  FileAccess sAccess;
  sAccess["www.pixel-light.de"].SetAuth("username", "password");                // Username und Passwort f端r HTTP
  sAccess["http://www.pixellight.org/test.zip"].SetPassword("password");        // Passwort f端r die ZIP-Datei
  sAccess["http://www.pixellight.org/test.zip"].SetFlags(File_::FileMemBuf, 0); // ZIP-Datei ohne FileMemBuf 旦ffnen
  File cFile("http://www.pixellight.org/test.zip/dir/test.txt", sAccess);
  Etwas problematisch ist es zur Zeit noch die Frage, welcher Name f端r welche Zugriffsoptionen verwendet werden soll.
  FileZip sucht nach dem exakten Namen der Zip-Datei, also z.B. "http://www.pixellight.org/test.zip",
  FileHttp sucht dagegen nach der Domain, also z.B. "http://www.pixel-light.de". Gerade im Falle von HTTP ist das schwierig,
  da man ja nicht genau weiss, wo auf dem Server der Passwortschutz eingerichtet ist.
- FileAccess um bCaseSensitive erweitert. Dies wird von FileZip ausgelesen, somit kann man bestimmen, ob eine Zip-Datei
  case-sensitive behandelt werden soll oder nicht. Standardwert ist jetzt 'true', da wir dies anderswo auch meist so behandeln!
- Ebenfalls pr端ft FileZip nun, ob ein Wert f端r FileMemBuf angegeben wurde. Ist dies der Fall, wird dieses Flag 端bernommen,
  damit kann also das automatische Buffern von Zip-Dateien ausgeschaltet werden. Das Prinzip der Flags in FileAccess funktioniert
  so: Alle Flags, die in FlagsMask angegeben werden, gelten als "gesetzt" (egal ob 1 oder 0). Deren Wert wird dann in FlagsValue
  bestimmt. Beispiel: (Mask = Read | MemBuf, Value = Read) bedeutet, dass Read = 1 gew端nscht ist und MemBuf = 0. Alle anderen
  Werte sind nicht weiter bestimmt. Allerdings sind die ganzen Angaben in FileAccess nur "W端nsche", die ber端cksichtigt werden
  k旦nnen aber nicht m端ssen. Im Moment wird also nur bei Zip-Dateien auf MemBuf geachtet, alle anderen Flags werden ignoriert.
  Man kann dies also nciht nutzen, um z.B. eine Zip-Datei auch zum Schreiben zu 旦ffnen oder 辰hnliches.
- Mir ist aufgefallen, dass man auf die Values einer HashMaps nur noch als const zugreifen kann, man also die Werte sp辰ter
  nicht mehr 辰ndern kann. Gerade beim FileAccess brauche ich aber auch die M旦glichkeit, die Objekte sp辰ter noch zu 辰ndern.
  Habe das daher erst einmal eingehackt, Christian sag bitte mal bescheid ob das so ok ist oder ob ich das anders l旦sen
  sollte.



>> 03.12.2007
[SB]
- HttpHandle: Beim Lesen von Daten 端ber das Netz kann es h辰ufig vorkommen, dass noch nicht gen端gend Daten im Stream
  vorhanden sind, in dem Fall gibt Socket.Read() einfach so viel zur端ck, wie bereits vorhanden ist, auch wenn dies
  weniger ist als angefordert. Dies ist so ok und sollte denke ich auch nicht ge辰ndert werden, wenn man mit Sockets
  arbeitet muss man dies einfach einplanen. Beim Arbeiten mit Dateien wird jedoch davon ausgegangen, dass Read() genau
  so viel liest wie angefordert, wenn weniger gelesen wird, ist dies ein Fehler. Daher habe ich dies in HttpHandle::Read()
  so ge辰ndert, dass so lange immer wieder vom Socket gelesen wird, bis die gew端nschte Datenmenge erreicht wurde, es
  kann also hier nicht mehr vorkommen, dass zu wenig gelesen wird. Bei grossen Dateien k旦nnte dies also einen Moment
  lang dauern :-) 
- HttpHandle: Fehler behoben, es muss die gesamte URL 端bermittelt werden, damit ein Webserver, der mehrere Domains hostet
  (wie bei uns) wei, welche gemeint ist.
- HttpHandle: Es wird nun auch Http-Auth (Basic) unterst端tzt, damit kann also per Username und Passwort auf gesch端tzte
  Webseiten zugegriffen werden.
- Memory buffered files implementiert: Wird eine Datei mit dem Flag FileMemBuf ge旦ffnet, so wird der gesamte Inhalt der
  Datei eingelesen und im Speicher behalten, alle weiteren Lesezugriffe finden dann nur noch auf diese Buffer statt.
  Ich habe mich f端r die Bezeichnung "Memory Buffered" entschieden, da "Memory Mapped" viele unterschiedliche Bedeutungen
  hat (z.B. auf OS-Ebene, um mittels gemappter Dateien IPC zu betreiben), da scheint mir "Memory Buffered" eindeutiger
  und daher leichter verst辰ndlich. Der Buffer und der Zugriff darauf befindet sich in der Klasse File, und kann nur zum
  Lesen verwendet werden.
- ZipHandle: Das Zip-File wird nun mittel FileMemBuf geladen. Hier sollten wir uns noch 端berlegen, ob man das evtl. von
  der Dateigr旦e abh辰ngig machen sollte, oder irgendwie eine M旦glichkeit geben sollte, dies wenn gew端nscht zu deaktivieren.



>> 02.12.2007
[SB]
- Habe die Basisklassen von PLNetwork nach PLGeneral/Network verschoben, da Sockets und Netzwerkkommunikation eigentlich
  zu den System-Basisklassen geh旦ren. Alles weitere, also die Struktur der Netzwerkkommunikation in PL, wird wie geplant
  in PLNetwork implementiert werden, die Basisklassen k旦nnen jedoch auch an anderen Stellen n端tzlich sein. 
- Netzwerk-Basisklassen 端berarbeitet und wo m旦glich vereinfacht.
- HTTP-Client hinzugef端gt. Analog zu den ZIP-Dateien gibt es eine Klasse HttpHandle, die benutzt werden kann, um eine
  HTTP-Verbindung mit einem Server aufzumachen und Dateien zu 端bertragen. Diese Klasse kann bislang nur das n旦tigste, also
  nur das bertragen einer Datei per HTTP/1.0 sowie das auslesen der wichtigsten Header-Informationen. Alles andere kann
  sp辰ter erweitert werden.
- HTTP-Implementation f端r das FS hinzugef端gt. Damit kann per HTTP auf Dateien aus dem Netzwerk zugegriffen werden, was ich mir
  sehr n端tzlich vorstelle, um z.B. News von der Webseite zu laden (oder auch Updates). Dank der Schachtelung ist nat端rlich auch
  etwas wie "http://www.pixellight.org/test.zip/test.txt" m旦glich, was auch gut funktioniert, allerdings nicht zu empfehlen ist :-)
- Linux-Implementation f端r das FS hinzugef端gt.
- Generische Funktionen f端r das Kopieren und Verschieben von Dateien hinzugef端gt. Zun辰chst wird versucht, die systemspezifische
  Implementation f端r die entsprechende Funktion zu verwenden, wenn dies fehlschl辰gt, wird es mit der generischen Variante
  versucht: Wenn man z.B. eine Datei aus einer Zip-Datei irgendwo hin kopieren m旦chte, wird dies mit der Systemfunktion
  nat端rlich nicht gehen. Das Herunterladen einer Datei aus dem Netz kann man nun also z.B. so erledigen:
    File("http://www.pixellight.org/test.zip").Copy("C:\\test.zip")



>> 01.12.2007
[SB]
- Funktionalit辰t von ZipHandle vervollst辰ndigt.
- FileZip und FileSearchZip unter Verwendung von ZipHandle wieder implementiert und getestet. Das Verhalten je nach
  Lesemodus (Binary oder Text) an die Systemfunktionen angepasst.
- Beim ffnen einer Datei wird die Implementationsklasse automatisch ermittelt: Entweder mittels des Protokolls,
  oder durch Suche nach ".zip/" oder ".pak/" im Dateinamen. Dadurch mu eine Zip-Datei als Verzeichnis so ge旦ffnet
  werden: Directory("test.zip/"), da "test.zip" an sich auch eine valide Datei w辰re. Innerhalb der Zip-Datei sind aber
  z.B. "test.zip/test" und "test.zip/test/" identisch.
- Eine Problematik beim Verwenden von Zip-Dateien: Mir ist aufgefallen, dass in einer Zip-Datei nicht unbedingt alle
  Unterverzeichnisse auch aufgelistet werden. Wenn ich unter Windows direkt oder mit TugZip eine Zip-Datei packe, gibt es
  z.B. die Eintr辰ge "test/dir1/test1.txt" und "test/dir1/test2.txt", aber weder "test/dir1/" noch "test/". Je nachdem,
  welches Programm man verwendet, ist dies mal so und mal so, aber offensichtlich kann man sich nicht darauf verlassen,
  dass alle Verzeichnisse auch direkt aufgelistet werden. Dieses Problem in den Zip-Klassen zu l旦sen w辰re denke ich etwas
  aufwendig, da man die Pfade auseinandernehmen und eine eigene Liste erstellen m端te, anstatt einfach nur alle Eintr辰ge
  in der Zip-Datei durchzugehen. Sp辰ter sollte man dies wohl tun, damit es keine Probleme mit "schlechten" Zip-Dateien gibt,
  im Moment w端rde ich aber einfach darauf achten, dass die Zip-Dateien vern端nftig sind - zip unter Linux tr辰gt beispielsweise
  alles korrekt ein :-)



>> 21.11.2007
[SB]
- bertragen der Zip-Implementation begonnen.
- Neue Klasse ZipHandle erstellt, welche auf einer Zip-Datei arbeitet. Vereinigt die Funktionalit辰t von StreamZip und IteratorZip,
  denn diese getrennten Klassen arbeiteten letztlich beide auf dem File-Handle von DirectoryZip, was ich sehr undurchschaubar
  finde. Weitere Zip-Funktionalit辰t war auch noch innerhalb von DirectoryZip und FileZip verstreut, das wurde ebenfalls in diese
  Klasse 端bertragen. ZipHandle besitzt nun selber den File-Handle f端r die Zip-Datei und soll als generelles Interface dienen, um
  den Inhalt der Zip-Datei aufzuz辰hlen und anschliessend z.B. auf den Anfang einer Datei zu springen und diese auszulesen.
- Neue eingebettete Klasse ZipHandle::ZipEntry hinzugef端gt. Diese Klasse enth辰lt die Informationen zu einem Eintrag
  innerhalb der Zip-Datei. Damit sind diese Informationen nicht mehr direkt in ZipHandle (端bersichtlicher), auerdem kann so
  leichter eine Liste von Zip-Entrys erstellt werden, was man z.B. innerhalb der FS-Abkapselung machen k旦nnte, um den Zugriff
  auf das Directory schneller zu machen. 
- Da die verteilten Zip-Funktionen recht verwirrend waren, bin ich mir nicht 100% sicher, ob ich alles richtig 端bertragen habe.
  Christian: Bitte schau nochmal genau dr端ber und teste wenn m旦glich ZipHandle etwas, ob noch alles richtig funktioniert.
- ZipHandle 端berarbeitet und versucht, das Interface sowie die Variablennamen verst辰ndlicher zu machen. Diese Klasse soll f端r
  sich alleine genommen schon leicht verwendet werden k旦nnen, um auf eine Zip-Datei zuzugreifen und diese auszulesen. Die weitere
  Abstraktion 端ber FileZip und FileSearchZip dient dann nur noch dazu, Zip-Files auch transparent 端ber das FS-Interface nutzen
  zu k旦nnen. Es soll aber auch ganz ohne gehen, die gesamte Zip-Funktionalit辰t soll also in ZipHandle vorhanden sein.  
- Kleinen Test implementiert, der den Zugriff auf Zip-Dateien nur 端ber ZipHandle demonstriert testet. Konnte bisher keine Fehler
  feststellen, das Verzeichnis eines Zip-Files sowie der Inhalt der enthaltenen Dateien werden mir korrekt angezeigt. 



>> 20.11.2007
[SB]
- Basisklassen und Win32-Implementation f端r das Dateisystem sind weitgehend vollst辰ndig (bis auf Suchfilter).
  Das Klassenlayout wurde stark vereinfacht und gleichzeitig teilweise erweitert, so ist das Erstellen, L旦schen,
  Umbenennen, Verschieben usw. nun direkt 端ber ein File- oder Directory-Objekt m旦glich. Dabei gibt es nun auch
  ein Muster, welches wir sonst selten haben: Gleichnamige Funktionen in abgeleiteten Klassen, die *nicht* virtuell
  sind. File::Create erstellt eine neue Datei, w辰hrend Directory::Create ein Verzeichnis erstellt. In der Basisklasse
  gibt es diese Funktion nicht, daher d端rfte dies kein Problem darstellen, und 端ber das verwendete Interface legt
  der Programmierer deutlich fest, was von beidem er tun m旦chte, das ganze scheint mir so also auch am intuitivsten zu sein.
- Mittels Assign kann das Datei-Objekt auf einen neuen Dateinamen gelenkt werden. Dabei werden automatisch vorher
  ge旦ffnete Dateien geschlossen, das Objekt "zeigt" also dann auf eine andere Datei (diese mu nicht mal vorhanden sein).
  Beispielsweise kann so eine Datei oder ein Verzeichnis angelegt werden: Directory("test").Create();
- Dateiflags vervollst辰ndigt und in hoffentlich 端blicherer Weise verwendet (z.B. gibt es nun neben FileWrite auch FileRead,
  ebenso gibt es FileBinary und FileText).
- Die Url-Klasse wird nur noch intern eingesetzt, im Interface werden dagegen nur noch Strings 端bergeben. Ansonsten m端te
  man st辰ndig Methoden doppelt machen, obwohl der User wohl meist sowieso Strings 端bergeben wird. Ausserdem sollte Url
  sowieso so selten wie m旦glich eingesetzt werden, um unn旦tiges Parsen des Dateinamens zu verhindern.



>> 19.11.2007
[SB]
- Klasse Url 端berarbeitet und vereinfacht. Ein Pfad wird nun *immer* intern in URL-Form gespeichert, d.h. mit Protokoll
  und mit '/' als Trennzeichen. Beim Umwandeln werden auch nicht mehr unterschiedliche Url-Instanzen kopiert, sondern
  direkt die Strings wie gewollt umgewandelt. Dies scheint mir am einfachsten und ist in der Benutzung konsistent, da
  es keine Unterschiede mehr geben kann, in welcher Form verschiedene Url-Instanzen ihre Werte vorliegen haben. Im allgemeinen
  m旦chte man eine Url meist im einheitlichen Url-Format angeben, dieser Zugriff ist daher auch immer der schnellste, da nur
  ein String zur端ckgegeben werden muss. Will man dagegen in ein spezielles Format umwandeln, ist dies etwas aufwendiger, daf端r
  macht man dies meist nur einmal (z.B. beim Erzeugen einer FileWin32-Instanz). Da diese dann nur als String und nicht mehr
  als Url gespeichert wird, entf辰llt daf端r aber auch der Overhead, noch einmal die umgewandelte Url in ihre Bestandteile
  zu zerlegen.
- FileObject: Die URL eines jeden Objektes wird jetzt immer ohne ein abschlieendes '/' gespeichert. Damit ist der Dateiname
  eines FileObject immer korrekt, und man kann sich sicher sein, wie dieser verwendet werden mu (z.B. kann der Suchpfad
  eines Verzeichnisses jetzt immer korrekt durch Hinzuf端gen von /*.* erzeugt werden). Eine URL kann aber weiterhin Pfade
  speichern, die mit / enden, da dies f端r eine URL von Bedeutung sein kann.



>> 13.11.2007
[SB]
- Rewrite des Dateisystems begonnen.
- Globale Klasse FileSystem entfernt.
- Die Klassen FileObject, File und Directory bleiben von der Funktionsweise sehr 辰hnlich, werden nun aber direkt verwendet,
  m端ssen also nicht mehr dynamisch erzeugt werden und beinhalten auch keine virtuellen Funktionen mehr.
- Die systemspezifischen Implementationen werden von der Klasse FileImpl abgeleitet und kapsel sowohl die Datei- also auch
  die Verzeichnisoperationen ab. Ein FileObject erzeugt eine Instanz einer von FileImpl abgeleiteten Klasse und verwendet
  diese.
- Das Auflisten/Suchen von Dateien wird wie bisher 端ber eine eigene Klasse gehandhabt, wobei SearchHandle in FileSearch
  umbenannt wurde. Diese Klasse verwendet ebenfalls das Backend-Schema, zu einer Instanz von FileSearch geh旦rt daher
  immer eine systemspezifische Implementation welche von FileSearchImpl abgeleitet ist.
- Alle Dateifunktionen sollen 端ber die Klassen FileObject/File/Directory zu verwenden sein, z.B. auch das Erstellen
  neuer Dateien oder Verzeichnisse ebenso wie das L旦schen. Dies sollte einfacher zu verwenden sein als vorher, wo manche
  Funktionen nur 端ber das globale Filesystem-Interface ausgef端hrt werden konnten.



>> 12.11.2007
[SB]
- Rewrite begonnen. Ziel ist es, die Basisklassen deutlich zu vereinfachen und zu verschlanken, wobei folgende Ziele
  verfolgt werden:
  * Alle Klassen sollten m旦glichst direkt instanziiert werden k旦nnen, damit es dem Programmierer frei steht, ob er eine
    Klasse direkt verwendet oder dynamisch erzeugt, was auch eine effizientere Nutzung erm旦glicht. Es sollte daher nicht mehr,
  wie bisher, eine dynamische Erzeugung von Objekten erzwungen werden, da dies auch die Problematik der sp辰teren
  Speicherfreigabe beinhaltet und generell komplizierter in der Verwendung ist.
  * M旦glichst keine globalen Manager mehr, welche alle Instanzen einer oder mehrerer Klassen verwalten. Dies ist zwar manchmal
    sinnvoll (z.B. f端r Ressourcenmanager), aber oftmal auch komplett unn旦tig (z.B. Dateisystem, Systemklassen allgemein).
  * Die Basisklassen sollten m旦glichst schlank sein, also direkt m旦glichst einfach zu verwenden sein und dabei m旦glichst
    wenig Overhead erzeugen. Dies bedeutet vor allem, dass die Basisklassen vom RTTI unabh辰ngig sein sollen und
    daher deutlich von den RTTI Klassen getrennt werden, diese arbeiten dann auf einer h旦heren Ebene 端ber den Basisklassen.     
- Ausserdem werde ich versuchen, folgende Konventionen einzuhalten:
  * Keine Verschachtelung mehr von Unterverzeichnissen, da dies eher wieder un端bersichtlicher wird als 端bersichtlicher. Also
    wird es z.B. nur noch das Verzeichnis FileSystem geben, darin jedoch keine weiteren Unverzeichnisse f端r Zip, Win32, Linux etc.    
  * Das Backend-Prinzip wird konsequent umgesetzt, also 端berall dort, wo es Systemspezifische Implementationen gibt, wird
    es nach aussen eine Systemunabh辰ngige Klasse geben, welche die Details 端ber eine systemspezifische Implementationsklasse
    abkapselt (1:1-Beziehung). Dieses Vorgehen bringt am wenigsten Probleme mit sich und ist sehr flexibel und ist daher besser,
  als z.B. direkt die Systemspezifischen Klassen abzuleiten (zumal dies nicht damit vereinbar ist, die Klasse direkt zu
  instanziieren).



>> 23.10.2007
[SB]
- Definition von _CRT_SECURE_NO_DEPRECATE in CMakeLists.txt hinzugef端gt. Dabei ist mir aufgefallen, dass im VC-Projekt
  diese Definition nicht auf die 端bliche Weise unter "Pr辰prozessordefinitionen" hinzugef端gt wird, sondern per
  "zus辰tzliche Optionen" der Kommandozeile. Habe das mal ge辰ndert, da ich keinen Grund sehe das hier anders zu machen
  als bei den sonstigen Definitionen und man so nur unn旦tig suchen muss.



>> 20.10.2007
[SB]
- zlib.dll auch aus den Installationsanweisungen in der CMake-Datei entfernt.



>> 19.10.2007
[CO]
- zlib wird im VC8 Projekt nun genauso wie in der CMake-Datei statisch eingebunden. 'zlib.dll' aus dem Runtime-Ordner gel旦scht.



>> 13.10.2007
[CO]
Alle Projekte:
- Einige 'const' eingef端gt
- Einige '#define' entfernt
- Ein paar Abs辰tze eingef端gt



>> 07.10.2007
[CO]
Alle Projekte:
- Einige 'const' eingef端gt um dem Compiler das Leben etwas einfacher zu machen und m旦glichen unerw端nschten Manipulationen
  vorzubeugen
- Dort wo es problemlos m旦glich war machte ich beim Speichern das zu speichernde Objekt Konstant. Bei ein paar Loadern wie z.B.
  Mesh Loadern ist dies leider nicht m旦glich da Index Buffer beim Lock ver辰ndert werden.
PLGeneral:
- String(const Variant &cVariant) entfernt da 端berfl端ssig, da nutzt man lieber Variant::GetString() :D
- Variant: Entfernte alle 'char*'-Funktionen da intern sowieso als 'String' gespeichert wird und man es daher gleich auch
  so 端bergeben kann ohne das es einen wirklichen Unterschied macht. Die 'GetString()'-Funktion erzeugt nun auch gleich den
  String und gibt diesen zur端ck ohne das dieser eventuell in 'm_sString' gespeichert wird... das macht die Sache zwar langsamer
  wenn 旦fters diese Funktion hintereinander aufgerufen wird - allerdings hat diese Funktion wirklich konstant zu sein.
- Parameters::GetParams() entfernt da dies einen Iterator zur端ckgab 端ber den man die Variablen h辰tte ver辰ndern k旦nnen +
  diese Funktion wurde nirgends verwendet.



>> 17.09.2007
[CO]
- Nahm das aktuelle Experimentelle Error System heraus da dies erstmal wohl nicht weiterverfolgt wird. Hab daf端r im
  lab-Repository ein entsprechendes Projekt mit diesem System angelegt.
- Entfernte nach R端cksprache mit Stefan 'PLBool'. Wir wollten zwar das noch solange drinnen lassen bis die Sache wie/ob
  wir ein 'Error System' implementieren gekl辰rt ist - allerdings ist es nicht abzusehen ob/wann das gemacht wird. Darum
  kommt das nun raus damit die Codes nicht mehr ganz so unfertig/h旦chst Experimentell wirken. Sollte man dann irgendwann
  ein 'Error System' haben, m端sste man eh nochmal alles im Detail durchgehen.
  Das war nun zwar wieder einiges an Fleiarbeit, aber so isses wieder viel besser da 端bersichtlicher + weniger Overhead...
  die einzelnen dll's sind gleich um ein paar KB (eine davon sogar um 30! :) kleiner geworden. *g*



>> 15.09.2007
[CO]
- XML-Klassen: Die Konstruktoren noch etwas aufger辰umt - keine Ahnung wieso ich das damals so umst辰ndlich machte. 'void *'
  hab ich allerdings als Parameter gelassen, man 'k旦nnte' zwar eine direkte Referenz auf das TinyXml Objekt 端bergeben, aber
  dann 'm端sste' diese TinyXml Klasse als 'Predefinition' in unseren XML-Headern stehen... und das will ich nicht. :D
  Nur die 'XmlDocument' Klassen Dokumentation weist darauf hin das intern TinyXml verwendet wird, ansonnsten sollte das wie
  gehabt absolut verborgen bleiben WIE das Implementiert ist.
- CmdLineParser nochmal etwas aufger辰umt



>> 14.09.2007
[CO]
- Element & Resource: 'Delete()'-Funktion liefert als R端ckgabewert nun ob alles gut ging oder ein Fehler auftrat



>> 13.09.2007
[CO]
- Da ich in Jens 'Kabiene'-Szene hin und wieder recht heftige stocker habe wenn ich einen neuen Raum betrete (wie es aussieht
  muss die GPU viele Textur Daten umschaufeln) das dazu f端hrt das alles kurz 'einfriert' und ich danach weit auerhalb der
  Szene bin, versuchte ich solche unregelm辰igkeiten im Timing etwas zu Kompensieren.
  In 'Timing::Update()' wird die nderung des Zeit unterschiedes mit dem des letzten Frames verglichen und wenn diese Werte
  ZU stark voneinander abweichen wird hier 'gegl辰ttet'. ber die neue Funktion 'GetTimeDifferenceNoCompensating()' kann
  man sich den 'wirklichen' Zeit unterschied ohne 'Korrekturen' zur端ckgeben lassen um z.B. feststellen zu k旦nnen ob
  unregelm辰igkeiten auftraten.



>> 08.09.2007
[CO]
- DirectoryZip::SearchCentralDir() vereinfacht, der Zwischenbuffer liegt nun direkt auf dem Runtime-Stack
- DirectoryZip::OpenObject(): Der verwendete ZIP-Iterator liegt nun direkt auf dem Runtime-Stack



>> 24.08.2007
[CO]
- SystemWin32::ErrorCodeToString() statisch gemacht da man wirklich keine Instanz der System Klasse daf端r braucht
- DynLibWin32::Load(): Gibt nun 端ber 'SystemWin32::ErrorCodeToString()' eine Fehlerbeschreibung aus
- Localization::SetLanguage(): Nahm hier das [TODO] raus. Diese Funktion setzt wirklich nur einen String, f端r das Laden
  der konkreten Sprachen ist die jeweilige Implementation selbst verantwortlich. Generell wird die Sprache am besten NUR
  beim Programm-Start gesetzt und geladen, denn das jederzeit 辰ndern zu k旦nnen w辰re ziemlich Tricky... denn man m端sste dann
  irgendwie ALLES Informatieren das sich die Sprache ge辰ndert hat, alle Strings in allen Programmteilen m端ssten sich updaten
  etc. - sehr viel sehr unsch旦ne Arbeit f端r wenig Nutzen. Das sparen wir uns lieber und gehen den einfachen Weg. :D



>> 22.08.2007
[CO]
- Machte ein paar nderungen an der Time-Klasse:
  - Ein paar statische Zeiten spendiert, 'Null' wird z.B. in PLNetworkIRC::IRCConnection::ProcessServerMessage()
    verwendet.
  - F端gte eine Funktion Namens 'ToString()' hinzu 端ber die man sich eine String Repr辰sentation der Zeit zur端ckgeben lassen kann.
  - m_nDay in m_nDayOfMonth + die entsprechenen Funktionen umbenannt damit eindeutig ist WAS das ist
  - 'EMonth' f辰ngt nun wie EDay bei 0 (wie bei Linux und nicht wie bei Win32 SYSTEMTIME) an damit das einheitlich ist + man
    sich direkt die in ToString() verwendete String Representation des Monats/Tages 端ber ShortMonthName[Month] bzw. ShortDayName[Day]
    zur端ckgeben lassen kann.
  - Einfache vergleichs-Operatoren hinzugef端gt.
  - Funktion IsLeapYear()' hinzugef端gt die ermittelt ob ein gegebenes Jahr ein Schaltjahr ist oder nicht.
  - Funktion 'SetUnixDate()' hinzugef端gt.
  - Funktion CalculateDayOfWeek()' hinzugef端gt die den Wochentag berechnent auf den ein Datum f辰llt. SetDOSDate() nutzt
    diese Funktion.
  - 'Unkown' aus 'EDay' entfernt da man sich diese Information nun berechnen lassen kann wenn man diese nicht direkt hat.



>> 21.08.2007
[CO]
- "NoMemoryManager.h" entfernt da wir das derzeit so nicht brauchen da wir keine Memory-Makros nutzen
- Konnte in "Checksum::Get(const String &sClass, File &cFile, PLResult *pResult)" das [TODO] entfernen da es mittlerweile
  m旦glich ist zu pr端fen ob man aus einer Datei lesen kann.



>> 07.08.2007
[CO]
- FSTools: ValidatePath(): War leider etwas Problematisch da man nicht genau wusste ob nun am ende ein '/' eingef端gt werden
  sollte oder nicht. Darum zerlegte ich diese Funktion in zwei Funktionen:
  - Einmal ValidateFilePath() welche einen Dateinamen korrekt macht
  - Und ValidateDirectoryPath() welche auf ValidateFilePath() aufbaut + sicherstellt das am Ende ein '/' ist
  -> Gef辰llt mir zwar nicht wirklich gut, alledings w端sste ich nicht wie man das anderst handhaben sollte... der User MUSS
     wissen WAS dieser 'Pfad' Darstellt, darum muss er uns das auch mitteilen damit man nicht irgendetwas falsches annimmt.
     "C:/MyDirectory/Test" k旦nnte ein Verzeichniss sein, aber auch eine Datei ohne Dateiendung, darum MSSEN Verzeichnisse
     bei uns ausdr端cklich mit '/' am Ende gekennzeichnet werden damit keine Mehrdeutigkeiten vorhanden sind. Allm辰hlich f辰nde
     ich es irgendwie erleichternd wenn wir 端berall bei Datei/Verzeichniss Namen die 'Url'-Klasse nehmen w端rden - das w端rde an
     vielen  Stellen einiges einfacher machen da man nicht mehr irgendeinen Mehrdeutigen Schrott 端bergeben bekommen kann.
     Derzeit sind an vielen Stellen immer 辰hnliche Abfragen, und an ein paar Stellen auch nicht wo es dann schnell mal zu
     Problemen kommen kann. :(
  -> Auf jedenfall sind sind nun keine FS Basis Pfade mehr 'doppelt' eingetragen (dort kam gerade durch eventuell fehlende
     '/' einiges durcheinander)



>> 03.08.2007
[CO]
Allgemein:
- Nahm 端berall
    m_pImage->SetInteger(PLGraphics::Image::Mode_OriginSet,  true);
    m_pImage->SetInteger(PLGraphics::Image::Mode_OriginMode, PLGraphics::Image::Origin_UpperLeft);
  vor dem Laden von Bildern raus - diese Einstellungen sind/waren bei uns bereits Default, und innerhalb von PL sollte da
  auch nix umgestellt werden. (0, 0) ist bei uns also 端berall 'links oben'. (u.a. DirectX nutzt diese Regel) Texturen die
  der GPU 端bergeben werden nutzen bis jetzt "(0, 0) ist links unten". (wie in OpenGL) Bis jetzt war das 'nur' inkonsistent,
  aber da wir nun verst辰rkt dds nutzen (um die Textur Massen halbwechs bew辰ltigen zu k旦nnen) zeigte sich das dies hier sehr
  unhandlich ist da dds von DirectX kommt. Zwar passt DevIL immer braf 'oben/unten' f端r uns an, aber bei den DXTC Daten die
  wir, wenn verf端gbar direkt zur GPU jagen, wird nix ver辰ndert. (war auch wenig Sinnvoll w辰re da man sich dadurch wieder
  den Geschwindigkeitsvorteil kaputt machen w端rde :)
  Dadurch hatte man dann 'geflippte' Texturen. Darum nun dieses nderung, damit das zum einen bei uns einheitlich wird +
  das man die Vorteile die dds bietet richtig nutzen kann.
  Musste nun zwar sorf辰ltig pr端fen wo z.B. Textur Koordinaten verwendet werden und dort 端ber "1-y" vertauschen, oder "1-y"
  rausnehmen wo nun nicht mehr vertauscht wird - aber das lohnte defintiv. Endlich ist da Ordnung drinnen und in
  PLMesh::Texture::Load() konnte ich nun endlich einen doofen Hack rausnehmen der sowieso nicht zu 100% funktionierte.
  (端ber dieses 'flip'-Problemchen stolperte ich schon fr端her im Zusammenspiel mit cube dds Texturen)
- Stellte 端berall wo m旦glich/sinnig Texturen auf das dds-Format um. (Texturen != OS Gui Bitmaps, da macht das nat端rlich weniger
  Sinn da man dadurch keine Vorteile hat :)
-> Es wird sicherlich noch einige Tage dauern bis ich 'soweit alle' Stellen angepasst habe die von diesen nderungen betroffen
   sind. Aber im groen und ganzen geht alles wieder wie vorher - nur halt flotter zu laden + Grafiker haben direkt selbst
   Kontrolle 端ber die MipMaps und was genau f端r Kompression verwendet werden soll. :D
   (ohne dds geht das im Grunde nur automatisch -> man hat weniger Kontrolle)



>> 02.08.2007
[CO]
Allgemein:
- Alle Doxygen Konfigurations-Dateien 端ber "doxygen -u" auf den neusten Stand gebracht
- Machte bei allen Loadern alle Funktionen const. Da es von diesen Loader Klassen jeweils nur eine globale Instanz gibt darf
  keine der Funktionen etwas an diesen Objekten 辰ndern oder man bekommt sp辰testens bei Multi-Threading probleme. Ein paar
  wenige Loader nutzen nun einfach 'pro Instanz'-Daten.



>> 01.08.2007
[CO]
- 'SearchHandleZip' hatte nicht das gleiche Verhalten wie die anderen Implementationen die zuerst '.', anschlieend '..' und
  erst dann die 'richtigen' Dateien auflistet... das viel in 'PLSceneViewer.exe' auf wenn man im Datei-Dialog in ein
  'zip-Verzeichniss' wechselte, aber keine '..' mehr da waren zum zur端ck gehen.



>> 30.07.2007
[CO]
- Loadable: Merkt sich nun auch den 'original' Dateinamen der zum Laden verwendet wurde
- LoadableType::AddLoader: Wenn ein Format bereits im Manager durch einen anderen Loader eingetragen wurde so ist das kein
  Fehler, sondern heist nur das man nicht eindeutig 端ber die Dateiendung rausbekommen kann welcher Loader f端r dieses Format
  zust辰ndig ist. Dies ist allerdings KEIN Problem da sowieso immer bekannt sein sollte WAS man denn eigentlich laden will,
  also obs ein Mesh, eine Scene etc. ist. Das DirectX Format kann z.B. als Mesh verwendet werden, aber da es sehr flexibel
  erweiterbar ist + Hierarische Strukturen hat kann es genauso auch als Scene genutzt werden.
  Was allerdings auch vorkommen kann ist, das z.B. zwei verschiedene Mesh Formate die gleiche Dateiendung haben, ja eventuell
  sogar im Grunde das gleiche Format sind, aber unterschiedliche Versionen davon. Derzeit wird soetwas noch nicht Unterst端tzt,
  m端sste sich sp辰ter aber erweitern lassen... macht die Sache allerdings bestimmt nicht einfacher oder 端bersichtlicher. *g*
- Nahm die String Duplizierung aus Loadable::Reload() heraus, in Loadable::Load() ist nun ein universellerer 'Sicherheits'
  Test drinnen



>> 22.07.2007
[CO]
- 'Function': Machte den Konstruktor protected und Dokumentierte kr辰ftig da ich gerade ein paar Stunden damit verbrachte
  rauszubekommen was 'genau' (hatte vorher nur eine sehr grobe Vorstellung) das ist bzw. wie man es verwendet. In PLBaseTest
  gibts nun einige Tests f端r diese Funktionalit辰t... anhand dieser Tests hab ich mich an die Sache rangetastet - Stefan,
  gib mir irgendwann bitte bescheit ob ich das soweit richtig verstanden habe und es auch wie vorgesehen nutze. :)
  Die Investierte Zeit hat sich auf jedenfall gelohnt, denn nun versteh ich was da abl辰uft - wirklich eine sseeehr feine
  Sache. :)
- Container-Klassen abermals durchgeschaut und kleinigkeiten verbessert



>> 21.07.2007
[CO]
Alle Projekte:
- Die paar 'realloc' welche noch verwendet wurden durch 'MemoryManager::Reallocator()' ersetzt + stellen an denen noch z.B.
  'memcpy' verwendet wurde ebenfalls umgestellt damit wirklich alles 端ber den Memory Manager l辰uft. Das mag zwar auf den
  ersten (und eventuell zweiten und dritten und... *g*) Blick 'extrem' erscheinen, hat aber durchaus so seine Vortelle da
  alles eine 'Zentralverwaltung' passiert. (...big brother is watching you...)
PLGeneral:
- SystemWin32: Erste ffentliche Funktion eingebaut: ErrorCodeToString(): Wandelt einen Win32 Fehler Code den man 端ber
  GetLastError() erhalten hat in einen PL-String den man dann z.B. direkt ins Log schreiben kann... das hatte ich vor einiger
  Zeit schonmal irgendwo lokal reingehackt als ich mir beim Debuggen Win32 Fehler als String zur端ckgeben lies.
  In SystemLinux hab ich soetwas nicht eingebaut da es unter Linux eine Funktion namens 'strerror' gibt die sich sehr leicht
  weiternutzen l辰sst.
- System: Neue Funktion: IsLittleEndian(): Damit kann man feststellen welche Byte-Reihenfolge die aktuelle Maschine f端r
  gr旦ere primitive Datentypen verwendet. Zuk端nftig k旦nnen wir diese Funktion nutzen um zu entscheiden wie man z.B. ein
  'float' in eine Bin辰r Datei schreiben oder auslesen muss. Das bringt allerdings erst 'wirklich' etwas sobald wir nicht mehr
  wie momentan direkt 端ber die Write/Read-Funktionen der File-Klasse diese Daten schreiben/lesen... da muss dann ein kleiner
  Wrapper her damit wir 'wirklich' Plattform unabh辰ngig werden, also auch damit klarkommen wenn die Byte-Reihenfolge anderst
  herum ist. :)
  Ich habe die Funktion 'IsLittleEndian()' und nicht 'IsBigEndian()' genannt da wir derzeit eigentlich nur auf Little-Endian
  Ger辰ten arbeiten und ich denke auch diese Anordnung in unseren Bin辰r Formaten behalten werden - der Funktionsname deutet
  also so bereits an mit welcher Anordnung PL 'intern' arbeitet.
- Nahm die auskommentierten Memory-Makros aus 'MemoryManager.h' nun komplett raus da wir das denk ich mal so nicht nutzen
  werden da es einfach 'unsch旦n' und fehleranf辰llig ist - es w辰re einfach nur doof '端berall' 'MemoryManager.h' einbinden zu
  m端ssen nur damit die Makros 'wirksam' werden. Wenn man brav mit new/delete arbeitet braucht man das auch nicht wirklich.



>> 19.07.2007
[CO]
Alle Projekte:
- Wenn 端ber new Instanzen von Klassen erzeugt werden, aber dem Konstruktor nix 端bergeben wird, war die Schreibweise nicht
  einheitlich. berwiegend hatten wir z.B. "new MyClass()" -> also mit "()" am Ende. So sieht man im Grunde sehr h辰ufig,
  und mittlerweile bin ich diese Schreibweise auch durch Jave gewohnt. Daher 辰nderte ich das entsprechend. (aber nicht
  wenn z.B. Primitive Datentypen oder Strukturen erzeugt werden... das kommt mir da etwas merkw端rdig vor und das sieht
  man auch praktisch nie so geschrieben :)
PLGeneral:
- Fand noch zwei Stellen wo ich sehr einfach malloc/free durch new/delete ersetzen konnte. Wo immer m旦glich (also praktisch
  端berall :) sollte man lieber new statt malloc etc. nutzen - dadurch braucht man sich dann auch keine Sorgen zu machen 'wo'
  bzw. 'wer' den Speicher anlegt. 'new' l辰sst sich ja sehr einfach 端berladen was auch bereits gemacht wird... aber 'malloc' &
  CO kann man nicht wirklich 端berladen. Zwar k旦nnte man ein Makro schreiben, (was ich zum probieren auch machte :) das f端hrt
  allerdings dann zu mehr Problemen (teils sogar zu Compiler fehler in Third-Party libs) als es Nutzen bringt.
  An ein paar Stellen wird noch realloc genutzt, diese Stellen werde ich bei Zeiten noch 辰ndern damit wir in PL wirklich
  nur new/delete nutzen um m旦glichen Problemen der Speicherverwaltung gleich von Anfang an aus dem Weg zu gehen.
  (man muss soetwas ja nicht provozieren :)



>> 08.07.2007
[CO]
Alle Projekte:
- Entfernte einige &<Name>[0] da & und [0] automatisch vom Compiler hinzugef端gt wird und das ohne besser Lesbar ist :)
PLGeneral:
- F端gte ein paar  #error "Unsupported platform"  ein (z.B. in SystemImpl.cpp)



>> 06.07.2007
[CO]
- Die Datei & Klassen Namen der FS Implementationen folgten nicht der Benennung der anderen PL Dateien



>> 24.06.2007
[CO]
Alle Projekte:
- Merkte gerade das in den meisten Dateien der inline Implementationen z.B.
    #ifndef __PLRENDERER_SHADERCGBACKEND_INL__
    #define __PLRENDERER_SHADERCGBACKEND_INL__
  etc. steht, also wie bei den Headern. Dies ist hier allerdings v旦llig 端berfl端ssig da diese Dateien NUR von den jeweiligen
  Headern selbst eingebunden werden d端rfen und dort bereits im 'gesch端tzten'-Teil liegen. (dem Compiler unn旦tige Arbeit
  sparen iss immer ne gute Sache, auch wenn das absolut nicht ins Gewicht f辰llt *g*)
PLGeneral:
- 'PL_F2DW()' und 'PL_DW2F()' aus 'PLRenderer/Types.h' entfernt und in 'PLGeneral/Tools/Tools.h' als FloatToUInt32() und
  UInt32FloatTo() eingef端gt. Zum einen fand ich es schon lange nicht mehr sonderlich prall das diese zwei Funktionen (fr端her
  Makros :) so lieblos irgendwo in der Gegend herumstehen + die Namen selbst waren nicht mehr ganz korrekt und nicht
  sonderlich aussagekr辰ftig.



>> 23.06.2007
[CO]
Alle Projekte:
- Verbesserte an einigen Stellen gro/kleinschreibung. Wenn z.B. mit 'windows' das Betriebssystem und nicht etwa 'GUI Fenster'
  gemeint sind sollte das 'Windows' geschrieben werden da Name. 'win32' konsequent zu 'Win32' gemacht. 'linux' ist ebenfalls
  ein Name, also 'Linux'.
- Bei 'Abk端rzungen' wurde so richtig wild gemischt und ich selbst war auch immer sehr unsicher 'wie' man das nun '端berlicherweise'
  schreibt. Da wollte ich schon lange mal was machen damit das halbwechs konsequent ist. Daher googelte ich erstmal etwas +
  informierte mich auf Wikipedia wie man 端blicherweise diverse Dinge schreibt. Danach 辰nderte ich u.a. 'url/Url' -> 'URL',
  'xml/Xml' -> 'XML', 'html/Html' -> 'HTML', 'zip/Zip' -> 'ZIP', 'gui/Gui' -> 'GUI' (bis auf die Dateiendung 'gui') - nur in den
  Dateinamen 辰nderte ich erstmal nix da dies die Lesbarkeit etwas verschlechtert - da k旦nnen wir uns sp辰ter 端berlegen ob wir das
  so lassen, oder ob wir das 端berall durchwech konsequent schreiben wollen damit keine Unklarkeiten reinkommen. Das alles k旦nnte man
  nat端rlich als 'belanglose fusselei' abtun... allerdings empfinde ich soetwas als wichtig da es gerade in der Informatik mittlerweile
  sooo viele Abk端rzungen gibt und ich es auch in Mathematik h旦chst verwirrend und st旦rend empfinde wenn ein und dieselbse Sache
  immer wieder etwas anderst geschrieben wird - das hilft definitiv nicht Anf辰ngern sich in die Materie einzuarbeiten! :(
  Zudem ist PixelLight generell 'case-sensitive' so das wir da (vorallem den Grafikern *g*) mit gutem Vorbild vorausgehen sollten.
PLGeneral:
- FileSystem vom Style und der Ordnung her aktualsiert. Also Dinge privat gemacht die privat zu sein haben, Konkrete
  Implementationen werden wo das nicht ben旦tigt wird oder w端nschenswert ist nicht Exportiert. Wo m旦glich Zeiger zu Referenzen
  gemacht damit man den NULL-Fall nicht ber端cksichten muss. Einige Kommentare verbessert oder genauer gemacht. Einige short
  zu int16 und long zu int32 (+ unsigned Variationen) gemacht damit das in PL 端berall gleich ist + das ist deutlich besser
  lesbar + man weis wirklich ganz genau was das f端r gr旦en zu sein haben.
- Bei der File-Klasse ein 'IsReadable()' hinzugef端gt. Dies wurde bereits im Loadable-System ben旦tigt + ist das passende
  Gegenst端ck zu 'IsWritable()'
- LogFormater Implementationen umbenannt da diese nicht dem PL Namens Style folgten und es mich auch schon mehrmals st旦rte
  das ich erstmal kurz die einzelnen Implementationen zusammensuchen musste - durch die Namens-nderung sind diese Dateien
  wenn man Alphabetisch Ordnen l辰sst immer nett beisammen was enorm Handlich ist.
- BufferedReader Implementationen umbenannt da diese nicht dem PL Namens Style folgten
- CMakeLists.txt: LogFormaterConsole.cpp fehlte
- 'PLEFileSeek' von FileSystem.h in die File-Klasse verschoben und in 'ESeek' umbenannt. 'PLEFileAccess' von FileSystem.h
  in die File-Klasse verschoben und in 'EAccess' umbenannt. Dadurch konnte man auch gleich wieder Header abh辰nigkeiten
  reduzieren. :)
- FileSystem: GetRootDirectory() und GetCurrentDirectory() liefern nun Referencen statt Zeiger zur端ck denn diese Dinge
  MSSEN immer g端ltig sein... ansonnsten l辰uft gerade etwas soetwas von total daneben. Durch diese nderung wird an einigen
  Stellen der Code nun etwas bersichtlicher da man keine NULL-Abfragen mehr machen muss/sollte.
- FileSystem: GetCurrentDirectory() f端gt nicht mehr automatisch eine Referenz zum aktuellen Verzeichniss hinzu



>> 22.06.2007
[CO]
- Entfernte aus Timing die Funktionen Start(), Stop() und GetEllapsedTime() und f端hrte eine neue Klasse Namens 'Stopwatch'
  ein welche diese Funktionalit辰t bereitstellt. Stellte gleich eine Handvoll Stellen in verschiedenen Projekten auf diese
  neue Klasse um - das ist wirklich sehr Handlich. :)
- Time um SetDosDate()-Funktion aus ZipDate erweitert und ZipDate anschlieend entfernt da doppelte Funktionalit辰t



>> 16.06.2007
[CO]
Alle Projekte:
- Entfernte bei allen virtuellen und nicht Implementierten Funktionen (=0) das Export Makro da in diesen F辰llen nicht ben旦tigt
PLGeneral:
- 'PL_UNUSED'-Makro entfernt da dieses mittlerweile gerade im Zusammenhang mit ungenutzten Referenzen wo man dann zwanghaft
  Header einbinden muss obwohl nix ben旦tigt wird sehr unhandlich wird - zudem wollte Stefan das sowieso vor einigen Montaten
  raushaben. :)
  Das war eine Zeitlang recht nett dieses Makro um 端berall zu checken ob Parameter 端berhaupt ben旦tigt werden bzw. korrekt
  genutzt werden, mittlerweile ist das aber nicht mehr wirklich n旦tig. Die 'nicht verwendet' Warnung erscheint 端blicherweise
  nur in der allerh旦chsten Warn-Stufe, wenn das jemand aktiv haben will, muss er es f端r sein Projekt wieder per Hand aktivieren.



>> 12.06.2007
[CO]
- Sleep() von der System Klasse in ThreadManager verschoben da dies dort Thematisch besser reinpasst (der aktuelle aktive
  Thread wird schlafen gelegt...)



>> 09.06.2007
[CO]
- MemoryCopy() & MemorySet() & MemoryCompare() aus Wrapper.h in MemoryManager.h verschoben, das ist dort denke ich recht
  gut aufgehoben
- MemoryManager.h: Defines auskommentiert: Diese Definitionen sind leider recht problematisch und verursachen recht schnell
  Fehler in 'Fremd-Header'.



>> 08.06.2007
[CO]
- BufferedFileReader: Laut Konstruktor Dokumentation wird die 端bergebene Datei automatisch freigegeben, das war allerdings
  nicht der Fall wenn das Dateiende bereits erreicht war - vereinfachte/verallgemeinerte daher den Konstruktor etwas
- An einigen Stellen wo m旦glich/sinnig Zeiger durch Referenzen ersetzt. Uh, verstehe gar nicht wieso ich das fr端her noch
  nicht gesehen habe das es 'meistens' 端ber Referenzen viel eleganter und sicherer geht da man den 'NULL'-Fall nicht
  ber端cksichtigen muss wenn er eigentlich gar nicht erst vorkommen sollte. :)
  Ist zwar einiges an Arbeit nun alle Codes/Interfaces nochmal genau durchzuschaun, aber es lohnt definitiv + nebenbei
  fallen mir auch noch immer einige andere Dinge auf die nicht mehr ganz Up-To-Date sind... ganz nebenbei stehen in ein paar
  Wochen bei mir mal wieder Pr端fungen im Studium an und da sind solche Arbeiten genau das richtige da man das nebenbei
  machen kann ohne sich Gedanklich voll reinh辰ngen zu m端ssen was zur Pr端fungszeit weniger optimal ist.



>> 07.06.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'childs' in 'children' ge辰ndert (das war an einigen Stellen noch falsch :)
PLGeneral:
- XmlAttribute: QueryIntValue() & QueryDoubleValue() 辰ndern den Wert der 端bergebenen Variable im Fehlerfall nicht, damit
  ist das Verhalten vergleichbar zu den 辰hnlichen Funktionen in XmlElement
PLNetwork:
- Wo m旦glich/sinnig Zeiger durch Referenzen ersetzt



>> 05.06.2007
[CO]
- Time f端r die Tage Enums spendiert
- Semaphore: m_nValue wurde nicht initialisiert (?)
- Thread::Thread(bool bMainThread): Hier wurden die Variablen nicht initialisiert



>> 29.05.2007
[CO]
- Erweiterte das Var-Interface etwas damit man besseren Zugriff auf die Enumeration-Daten hat



>> 26.05.2007
[CO]
- Das mischen von Debug/Release Builds gestern klappte nicht wirklich gut. Es gab merkw端rdige Crashs etc. da beide Builds
  intern unterschiedliche VC Memory Manager nutzen die nicht wirklich kompatibel zueinander sind. Da ich das aber wirklich
  wirklich endlich mal sauber am laufen haben wollte befasste ich mich heute etwas mit der Speicherverwaltung. Heraus kam
  ein eigener minimal Memory Manager der im 'PLGeneral/Core'-Ordner liegt und der die C++ new/delete Operatoren '端berl辰d'.
  Solche Operationen werden nun direkt in unseren eigenen Memory Manager 'umgeleitet' der f端rs erste nur malloc/free nutzt.
  Alles Speicher anlegen/freigeben findet nun also NUR noch innerhalb von PLGeneral statt und dadurch verschwinden diese
  merkw端rdigen Speicherproblemen + wir haben viele weitere m旦glichkeiten wie Speicher-Statistiken, Sicherheits-Checks -
  oder das die Implementation einer komplett eigenen Speicher-Verwaltung!
  Der einzige Hacken bei der Sache ist, das jedes Projekt nun per Hand 'PLGeneral/Core/MemoryManager.inl' einmal irgendwo
  einbinden m端sste damit diese Operatoren sauber 端berladen werden...
- F端gte einen Header Namens 'PLGeneral/ModuleMain.h' hinzu. Dieser ist das gegenst端ck von 'PLGeneral/Main.h' welches f端r
  Anwendungen verwendet wird. Verschob aus 'RTTIDefs.h' die paar Module-Makros in diese neue Datei - das sind Dinge die
  genauso wie in 'PLGeneral/Main.h' NUR einmal pro Projekt f端r den Einstiegspunkt ben旦tigt werden. 'PLGeneral/Main.h'
  baut somit auf 'PLGeneral/ModuleMain.h' auf, welches wiederum 'RTTIDefs.h' nutzt - so m端sste das recht berschaubar sein.
  Ich muss allerdings zusgeben das 'berschaubarkeit' nicht der eigentliche Grund f端r diese kleine nderung war, sondern
  meine aktuellen arbeiten am Memory Manager. NUR einmal pro Projekt sollte 'PLGeneral/Core/MemoryManager.inl' eingebunden
  werden welches dann new/delete Operatoren mit PL eigenen Implementationen '端berschreibt'. Allerdings wollte ich das nicht
  jedesmal an zig verschiedene Stellen schreiben m端ssen da man es mal schnell vergisst und dann der Memory Manager nicht
  korrekt in diesen Modulen arbeiten kann. Daher wird dieser eine Header gleich automatisch in 'ModuleMain.h' eingebunden das
  so oder so genutzt wird - wenn man sich an die PL Richtlinen h辰lt und 'PLMain' etc. nutzt... wer das nicht tut und meint
  er m端sste selbst beim Einstiegspunkt herumwurschteln der muss sich halt auch selbst um andere Dinge k端mmern. *g*
  Somit muss sich der User also 端berhaupt nicht um diese Speicher-Geschichte k端mmern.
-> Als Folge dieser nderungen ist das mischen von Release/Debug Builds nun endlich m旦glich. Da im Grunde im PL-SDK IMMER
   Release genutzt wird und mir die Plugin-Datei nderungen von gestern nicht soo gut gefielen da es dadurch etwas
   un端bersichtlich und unn旦tig aufw辰ndig wird, machte ich diese Plugin-Datei nderung wieder r端ckg辰ngig... lies es aber
   hier im Diary stehen damit man nachlesen kann was wieso etc.
   Nutze ich die Release Versionen von PL kann ich aber immer noch mein eigenes Programm wie gehabt Debuggen - das klappt
   sogar mit Dll's. Nat端rlich kann man mit dem Debugger nicht in die PL Funktionen 'einsteigen', aber das w端rde sowieso nicht
   wirklich gehen da im SDK die cpp-Dateien von PL nicht liegen. :)
   Leider ist derzeit ein zu 100% mischen nicht m旦glich. Trage ich z.B. als Release Library eine Debug Version ein, wird
   die dll zwar ohne Crash etc. geladen, aber die RTTI Klassen werden nicht Regestriert... genau weis ich noch nicht was
   da im Detail abl辰uft. Aber das was mir wichtig war, also z.B. Debuggen einer dll im zusammenspiel mit einer release exe
   klappt ganz wunderbar.



>> 25.05.2007
[CO]
Alle Projekte:
- In den letzten Tagen lies ich in allen Projekten nach 'DEFINE_VAR_LIST' suchen und stellte sicher das die am RTTI
  h辰ngenden Variablen direkt in der Konstruktor Initialisierer-Liste initialisiert werden.
PLGeneral:
- Base: CreateInstance(): 'bSetVars'-Parameter entfernt. Das kann man als User selbst nachtr辰glich machen wenn man will -
  zudem w端rde das nicht Initialisieren nicht wirklich Sinn machen bzw. w辰re h旦chst Gef辰hrlich da man undefinierte Zust辰nde
  h辰tte. (bzw. fr端her hatte) Generell sollten IMMER alle Klassen ihre Variablen selbstst辰ndig auf korrekte Default Werte
  setzen (also unabh辰ngig ob diese am 'RTTI' eingeh辰ngt sind oder nicht) die mit den in den RTTI Makros angegeben Werten
  端bereinstimmen. Gef辰llt mir zwar nicht wirklich dieses 'doppelte' reinschreiben von Default-Werten, w端sste aber momentan
  nicht wie man das anderst l旦sen sollte. Auf diese weise kann man u.a. bereits in den Klassen Konstruktoren diese Variablen
  nutzen was voher nicht so ohne weiteres m旦glich war da die Variablen erst 'nach' dem erzeugen auf die Default-Werte gesetzt
  wurden... das war eine sehr ungl端ckliche Situation in die ich in den letzten Jahren nat端rlich immer mal wieder reinstolperte.
  'DEFINE_VAR_RO' ging fr端her nicht korrekt da SetVars() genutzt wurde was dann nat端rlich das setzen der 'read-only'
  Variablen zu verhindern weis.
  Auch war das Initialisieren von am RTTI h辰ngenden Variablen in der Initialisierer-Liste der Konstruktoren inkonsistent.
  Einmal wie z.B. in Vector3 wurde dort initialisiert da man diese auch ohne RTTI nutzen kann, und bei anderen Klassen wie
  z.B. SceneNode nicht da diese 'nur' 端ber das RTTI Instanziert werden k旦nnen.
  Zusammenfassend hat man mehr 'Sicherheit' da immer Variablen in bekannten Initialzust辰nden - da muss wie 端blich nat端rlich
  JEDER Klassen-Schreiber daf端r sorgen! CreateInstance() ist schlanker + weniger 'Overhead' beim erzeugen von Instanzen -
  da das RTTI System mittlerweile sehr intensiv genutzt wird ein sicherlich nicht ganz unerheblicher Faktor... wird z.B.
  eine *wirklich* groe Szene mit mehreren tausend Nodes eingeladen spart man sich nicht gerade wenig Arbeit ein und auch
  wenn man mit dem Debugger Schrittweise den Code Analysiert ist das nun um einiges durchschaubarer.
  Hab mal noch kleine Performance Tests in 'PLSampleScene.exe' gemacht - gr旦te Szene (F3) die 4098 Nodes hat, aber nur
  'sehr' wenig verschiedene Daten nutzt und daher optimal f端r diesen Test ist: (jeweils zwei anl辰ufe)
  - Vorher: 6.483 sec & 6.191 sec 
  - Nacher: 5.571 sec & 5.232 sec
  -> Also in dieser Szene mit 'etwas mehr' Nodes 'minimal' schneller, jedes bischn bringt uns weiter. :)
- Plugin XML Dateien: Ich 端berlegte mir bereits seit geraumer Zeit wie man das mit Debug/Release Builds 'mischen' am besten
  auf die Reihe bekommt - denn im 旦ffentlichen PL-SDK liegen NUR Release Builds (bzw. sollten!) und trotzdem soll man auch
  seine auf PL aufbauenden Projekte korrekt Debuggen k旦nnen. Wenn man die Debug Builds hat sollen diese auch genutzt werden
  k旦nnen. Von 3ds Max hab ich auch 'nur' die Release Version, und kann trotzdem meine Exporter Plugins daf端r korrekt Debuggen,
  also irgendwie ist das sauber realisierbar. :)
  Schl辰gt das einladen einer 'Library' fehl, so k旦nnen nun alternative 'Fallback Libraries' verwendet werden. Konkret ist
  das bei Debug-Libraries sinnvoll. Im 旦ffentlichen PL-SDK sind 端blicherweise keine Debug Versionen von PixelLight dabei,
  folglich schl辰gt der Versuch diese zu laden fehl - als Fallback wird nun versucht die entsprechende Release Library zu
  laden. Hat man also die Debug Version (warum auch immer *g*) wird diese korrekt genutzt, ansonnsten die Release Version.
  Als 'normaler PL-User' bin ich aber denk ich ganz froh die Release-Builds von PL beim Debuggen nutzen zu k旦nnen, denn
  diese sind um einiges (!!) flotter und so kann man sich recht gut auf das Debuggen seines eigenen Projektes konzentrieren.
  Somit kann man problemlos und ich denke mal recht Intuitiv Release & Debug Builds mischen - das Plugin System 端ber diese
  XML Dateien m端sste nun soweit alles k旦nnen das wir derzeit brauchen.
  Nahm den Parameter der 'PLGetPluginInfo'-Funktion im 'DEFINE_MODULE_PLUGIN'-Makro heraus und f端gte daf端r eine weitere Funktion
  namens 'PLIsPluginDebugBuild' hinzu 端ber die ermittelt werden kann ob das Plugin als Release oder Debug 端bersetzt wurde.
  ClassManager::LoadPlugin() kann dann auf wunsch einen Build Type Test erzwingen so das NUR zusammen passende Builds verwendet
  werden k旦nnen - als Default ist dies allerdings deaktiviert da dies normalerweise nicht n旦tig/端blich ist bzw. sein sollte.



>> 22.05.2007
[CO]
- Bugfix: Class::GetVar(): Meine nderung der Implementation vom 18.03.2007 war nat端rlich nicht ganz korrekt da nicht
  ber端cksichtigt wurde das es sehr wohl sein kann das die Variablen der Basis Klasse noch nicht Initialisiert sind - korrigiert.



>> 21.05.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'choosen' in 'chosen' ge辰ndert



>> 19.05.2007
[CO]
Alle Projekte:
- In Funktionen wo h辰ufiger Instanzen von RTTI Klassen erzeugt werden und 'zur Sicherheit' gepr端ft wird ob die Basis Klasse
  korrekt ist machte ich eine kleine rein Funktions interne Optimierung:
  Statt Class::HasBaseClass(String) wird nun Class::HasBaseClass(Class) genutzt wodurch man sich HashMap Operationen spart
  und sofort immer einen korrekten Zeiger auf die Basis Klasse hat. (der IMMER korrekt ist da Kern-Komponenten!) Zus辰tzlich
  kann nun unsere String Klasse ihre Muskeln spielen lassen: Class::HasBaseClass(Class) nutzt intern String::Compare()...
  und hier muss dann am ende NUR noch ein einfacher Zeiger Test gemacht werden um festzustellen das die Basis Klasse gefunden
  wurde ohne die Strings selbst wirklich miteinander zu vergleichen - noch Effektiver gehts wohl kaum! *g*
  An Stellen wo teils nur ein einziges mal pro Programm start Class::HasBaseClass() verwendet wird lohnt soetwas nat端rlich
  nicht - aber bei z.B. PLEngine::SceneContainer::Create() ist das durchaus eine feine Sache.
PLGeneral:
- Loader: RTTI Variablen sind nun endlich 'read only'. Dies erreichte ich dadurch das nicht das RTTI die Variablen anfangs
  Initialisiert, sondern das die Variablen sauber wie man es gewohnt ist in der Initialisierer Liste der Konstruktoren
  initialisiert werden. Von Loader abgeleitete Klassen '端berschreiben' indem diese den jeweiligen Konstruktoren entsprechend
  neue Werte 端bergeben - das ist so wirklich deutlich besser. :)
- HtmlLogFormater: Funktionen etwas umsortiert so das die Reihenfolge der Daten immer gleich ist
- Machte bei LogFormater Implementationen einiges 'private' da man nicht weiter davon ableiten k旦nnen soll + ein paar
  旦ffenliche Funktonen wurden nicht exportiert



>> 17.05.2007
[CO]
- Stack & Queue: Pop(): Kommentar erweitert (f端r eine Situation wo man aufpassen sollte)



>> 15.05.2007
[CO]
- System::DeleteEnvironmentVariable() Implementation fehlte
- Bei den System-Klassen einige Dinge 'private' gemacht wo entweder nix von auen drauf zugreifen soll oder wo man nicht
  weiter Ableiten k旦nnen soll
- Ein paar 'const' hinzugef端gt
- Im Loadable System einige Zeiger zu Referenzen gemacht, so muss man bei den Kommentaren nicht mehr 'NEVER NULL!'
  dazuschreiben da es bereits von anfang an unm旦glich ist NULL-Zeiger zu 端bergeben.



>> 12.05.2007
[CO]
- Class::GetBaseClasses() entfernt da es hierf端r keine Implementation (mehr) gab (?)
- ClassManager::GetClasses() gibt keine Liste mehr zur端ck, sondern bekommt eine als Parameter 端bergeben. Zum einen ist
  das so nun konsistent mit z.B. Class::GetVarList(), aber noch viel wichtiger ist, das so herum nun nicht mehr aufw辰ndig
  viel herumkopiert werden muss. Das gleiche in der Module Klasse.
- Var: Machte ein paar grundliegende Funktionen protected. NUR Class darf hier direkt drauf zugreifen, so ist gew辰hrleistet
  das z.B. wirklich IMMER eine Variable zu einer Klasse geh旦rt.
- Machte an den RTTI Klassen einige 'Sicherungs'-Manahmen indem ich einige Parameter & Funktionen const machte (an vielen
  Dingen hat der User einfach selbst nix zu 辰ndern :) und dort wo
  man nicht 'umbedingt' einen Zeiger als Parameter 端bergeben muss wird nun stattdessen eine Referenz verwendet - denn die kann
  ja nie NULL werden und so kann der User schonmal weniger Schrott 端bergeben + man spart sich Sicherheits-Abfragen. (die teils
  nicht vorhanden waren)
- Durch die nderungen kann man sich nun sogar in 'RTTIDefs.h' das Einbinden von 'Var.h' sparen :)



>> 11.05.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'socked' in 'socket' ge辰ndert
- Rechtschreib-Korrektur: 'terminal NULL', ich glaub damit meinte ich 'terminating zero' (jeder lacht aber keiner sagts :)
PLGeneral:
- String: In der Funktions-Beschreibung von GetLength() fehlte eine ganz entscheidende Information, 'terminating zero'
  ist in der L辰nge nicht enthalten. berall anderst stand das bereits wenn ich nix 端bersehen hab.
PLNetwork:
- Im Server-Destruktor muss man noch zur Sicherheit 'StopHost()' aufrufen da dieser Aufruf vom Host-Destruktor aus
  dummerweise in der Host Implementation von StopHost() landet und daher wenns mal mies l辰uft nicht sauber aufger辰umt wird
- Im Destruktor von Socket() wird nun zur Sicherheit 'Close()' aufgerufen... etwas sp辰ter nach merkw端rdigen 'Problemen'
  merkte ich das ich nicht ganz verstanden hatte was bei Sockets abgeht. Nat端rlich darf man das hier NICHT automatisch
  schlieen. Damit ich das nicht nochmal mache f端gte ich ein entsprechendes Kommentar in diesem Destruktor ein. *g*
  Das gleiche in der Create()-Funktion wo es ebenfalls nicht angebracht ist automatisch Close() aufzurufen.
- Socket::Close() liefert nun anstatt 'int' ein 'bool' zur端ck welches nur angibt ob alles gut ging oder nicht, denn mit der
  Implementations abh辰ngigen Fehler ID sollte der User nicht in Kontakt kommen bzw. er kann damit im allgemeinen nix
  anfangen da er nix von der konkreten Implementation weis. (bzw. wissen sollte *g*)
  Das gleiche beim R端ckgabewert der Bind() und Listen() Funktionen.
- Socket::Create() gibt nun einen Fehler-Code zur端ck
- Socket::m_nSocket ist nun auf INVALID_SOCKET wenn 'ung端ltig'
- Connection::OnReceive(): Der 端bergebene Buffer mit den erhaltenen Daten ist nun 'const' da dieser Buffer selbst nicht
  direkt manipuliert werden 'sollte' (k旦nnte wenns dumm l辰uft irgendwann mal unfeine Seiteneffekte erzeugen)
- Stellte auf PLBool um damit das erstmal Einheitlich ist
- Erweiterte die Kommentare so das m旦glichst keine Fragen mehr offen bleiben was z.B. Parameter machen/was zur端ckgegeben
  wird etc. Einiges muss man aber bei Zeiten auf jeden Fall noch genauer Beschreiben, vorallem ein paar kleine hintergrund
  Informationen.



>> 10.05.2007
[CO]
- Sortierte ins Diary so richtig alte Eintr辰ge aus "PLSDK/internal/old_diaries.zip" ein



>> 09.05.2007
[CO]
- Sortierte ins Diary alte Eintr辰ge aus "PLSDK/internal/old_diaries.zip" von ab "02.04.04" ein
- Neue abstrakte Basis-Klasse eingef端hrt: 'Iterable': Alles was einen Iterator Implementiert sollte von dieser Klasse
  abgeleitet sein. 'Map', 'Heap' und 'Container' sind somit nun also von 'Iterable' abgeleitet - so bekommt man eine noch
  etwas schickere und stimmigere Klassen-Hierarchie. :)



>> 21.04.2007
[CO]
PLNetwork:
- Socket::Recv() in Socket::Receive() umbenannt (man spart nicht wirklich was und muss sich nen k端rzel merken)
- Klassen Beschreibungen anhand von Stefans Konzept vom 08.03.2007 hinzugef端gt/erweitert



>> 20.04.2007
[CO]
- Timing::Update(): Auf PLBool umgestellt



>> 18.04.2007
[CO]
Alle Projekte:
- Nach kurzer R端cksprache mit Stefan gestern 辰nderte ich (automatisch, also ') = NULL;' zu ') = 0;' gleiche mit const,
  ersetzen lassen, insgesammt an 688 Stellen + 1 wobei diese eine Stelle nur ungl端cklich Formatiert war so das man per Hand
  ranmusste :) alle z.B. 'virtual void Test() = NULL' in 'virtual void Test() = 0' da 'NULL' in OS-Headern leider nicht immer
  zwanghaft als '0' oder '(void*)0' definiert ist - unter Linux ist das schonmal als '__null' definiert und dann gibts
  Compiler Fehler im Zusammenspiel mit z.B. 'virtual Test() = NULL' und man muss dann immer genau nachpr端fen wo/wie NULL in
  Headern einfach umdefiniert wurde das nicht wirklich die bersichtlichkeit f旦rdert. :(
  Neben diesen Compiler-Problemen war dies 端ber 'NULL' auch hin und wieder etwas unhandlich wenn man wie in
  'PLGeneral::Iterator.h' eigentlich 端berhaupt kein Include ben旦tigt, aber durch 'NULL' dann eben doch den PLGeneral-Header
  einbinden musste. Ich googelte etwas und schaute mir verschiedene C++ Codes durch, fand aber irgendwie nichts wo bei
  virtuellen-Funktionen 'NULL' statt '0' verwendet wurde. Wenn ich mich recht erinnere sah man das 'fr端her' h辰ufiger,
  heute aber nicht mehr wirklich oft.
- Nahm '-U__GNUG__' Linux Compiler Definition aus allen CMake-Dateien heraus
PLNetwork:
- Sobald man in 'PLGeneralLinuxIncludes.h' das von z.B. 'gethostbyname' ben旦tigte '#include <netdb.h>' einband bekam man
  in '/usr/include/netdb.h:661' einen merkw端rdigen Compiler-Fehler.
  Stephan und ich fanden zusammen 端ber herumstochern heraus das die Compiler Option '-U__GNUG__' daf端r verantwortlich ist,
  nahm man diese jedoch heraus wurde 'NULL' zu '__null' umdefiniert und man bekam bei virtuellen-Funktionen Probleme wenn
  '= NULL' verwendet wurde, daher die '= NULL zu = 0'-nderungen von oben. :)
- PLNetwork & PLNetworkIRC lassen sich nun auch unter Linux 端bersetzen



>> 14.04.2007
[CO]
- Base::SetVars() verbessert so das man z.B. auch 'Flags=""' in z.B. einer Szene-Datei schreiben kann ohne eine Fehlermeldung
  zu bekommen das ein abschlieendes '"' fehlen w端rde
- Thread::Join() Kommentar etwas erweitert... wie ich gerade in PLPhysicsNewton::WorldThread::~WorldThread() feststellen
  musste ist ein 'join' ohne Timeout mit Vorsicht zu geniesen...



>> 09.04.2007
[CO]
- Nahm weitere 'return' heraus
PLNetwork:
- Nahm weitere 'return' heraus



>> 08.04.2007
[CO]
- Formte einge Codes um so das man weniger 'return' ben旦tigt was die Sache etwas 端bersichtlicher macht
- ClassManager.cpp: 'NO_GROUP'-Definition entfernt da dies mittlerweile nicht mehr verwendet wird
- ZipSearchHandle::CheckFileInDirectory(): Hier wird nun 'm_pZipDir->m_bCaseSensitive' ber端cksichtigt
- ZipDirectory: Neue Funktion: IsCaseSensitive() wird von ZipSearchHandle::CheckFileInDirectory() ben旦tigt
- Base::IsVarDefault(): Arbeitet nun Case-Sensitive da PL generell Case-Sensitive ist
PLNetwork:
- Formte einge Codes um so das man weniger 'return' ben旦tigt was die Sache etwas 端bersichtlicher macht



>> 07.04.2007
[CO]
- Dort wo in der String Klasse 'isdigit()' oder 'isalpha()' verwendet wird, wird zur Sicherheit auf 'unsigned char' gecasted
  da man sonst schnell ein Assert bekommen kann wenn man z.B. '' im String stehen hat. :(



>> 31.03.2007
[CO]
PLNetwork:
- Host::RemoveConnection(): Hm, hier fehlte das austragen der Connection aus der Liste (absicht?)
- OS/Standard-Header werden nun nur noch in den Implementationen eingebunden
- Ein paar Sicherheits-Tests in 'Socket'-Klasse eingebaut
- Globale 'Initialize()'-Funktion entfernt da es etwas unhandlich ist das Manuell aufzurufen. Das l辰uft nun wie bei Image
  端ber einen globalen Guard.



>> 29.03.2007
[CO]
PLNetwork:
- Einige einfache Stellen auf unsere String-Klasse umgestellt
- Connection: SendMsg() ist durch unsere String Klasse nun 端berfl端ssig
- Connection: In Send() gabs wenn ich das richtig sah ein Speicherleck da der Daten-Speicher nicht wieder freigegeben wurde
  - durch die String Klasse nat端rlich nun kein Thema mehr :)



>> 27.03.2007
[CO]
- Linux Port etwas aufger辰umt



>> 25.03.2007
[CO]
- Types.h entfernt. berall wo X, Y, Z, W genutzt wurde durch entsprechende Vektor-Enums ersetzt damit man weiterhin sofort
  erkennen kann welche Komponente ver辰ndert wird. R, G, B wurde nur an einer einzigen Stelle verwendet. PL_UNUSED-Makro
  in die OS-Header verschoben.
- NULL-Definition in die OS-Header verschoben



>> 24.03.2007
[CO]
Alle Projekte: Alle CMake Dateien:
- Einige Leerzeichen/Tab nderungen in den CMake Dateien
PLGeneral:
- System: Neue Funktion: GetPlatform(): Diese Funktion gibt im Gegensatz zu GetOS() nur einen 端bergeordneten Plattform
  Namen wie z.B. 'Win32' f端r ein 32 Bit Windows System etc. zur端ck
- Xml Plugin Format nach Stefans Vorschl辰gen vom 25.02.2007 ge辰ndert. Es gibt nur noch eine Plugin Datei und keine f端r
  Release und Debug. In der Datei kann es beliebig viele 'Platform'-Bl旦cke geben, jedoch werden nur die ber端cksichtigt
  welche mit System::GetPlatform() zusammenpassen. (daher diese neue Funktion :) Innerhalb eines 'Platform'-Blockes kann
  es verschiedene 'Library'-Eintr辰ge geben welche jeweils einen Release oder Debug Type haben k旦nnen. Diese Dateien k旦nnen
  absolute Pfade haben (nicht wirklich immer Sinnvoll *g*) oder relativ zur Plugin-Datei liegen.
  Passte alle Plugin-Dateien entsprechend an. Diese nderungen machen wie Stefan schon sagte die Sache 端bersichtlicher und
  ganz nebenbei m辰chtiger da ein Plugin nun z.B. aus mehreren Bibliotheken bestehen kann und diese nicht mehr zwangsl辰ufig
  im gleichen Ordner liegen m端ssen wie die Plugin-Datei selbst. :D
  Dependencies werden in diesen Plugin-Dateien pro Library wie gehabt eingetragen. Das ist jedoch rein optional und soll
  wirklich nur dazu dienen das man immer den berblick beh辰lt was von wem abh辰ngt so das man nicht lange herumsuchen oder
  gar herumprobieren muss.



>> 23.03.2007
[CO]
Alle Projekte: Alle VC-Projekt Dateien:
- Deaktivierte die Linker Option '/INCREMENTAL' (nur ge辰nderte Methoden neu 端bersetzen) da diese in Konflikt mit '/LTCG'
  (gesammte Projekt Optimierung) stand. Damit ist nun folgende Linker Warnung wech:
  "LINK : warning LNK4075: /INCREMENTAL wird aufgrund der Angabe von /LTCG ignoriert."
PLGeneral:
- Im Release Build wird die Bibliothek 'LIBCMT.lib' ignoriert da diese laut Linker Warnung in Konflikt mit einer anderen
  stand.



>> 18.03.2007
[CO]
Da wir mittlerweile sehr viele RTTI Klassen haben und sp辰ter gerade bei konkreten Projekten sicherlich nochmal einige
hinzukommen versuchte ich die vom RTTI verbrauchten Resourcen 'etwas' in den Griff zu bekommen OHNE das System komplett
umzubauen. Also minimalste nderungen mit gr旦t m旦glicher Verbesserung damit das nicht mehr ganz so z辰h l辰uft was mich
ehrlich gesagt mittlerweile etwas st旦rt.
Auf die Hash Map Optimierung vom 14.03.2007 kam ich erst als ich mir mal angeschaut hatte warum bereits einfachste
Programme vergleichsm辰ig viel Speicher verbrauchten und beim starten auch viel zu lange brauchten. Es stellte sich heraus
das die Enum Dinge in der Vars Klasse sehr viel Overhead erzeugten. Es wurde gerade f端r die Enum Hash Map viel zu viel
Speicher verschwendet obwohl diese bei nicht Enum Variablen absolut nie ben旦tigt wurde. Ich 端berlegte mir dort ob man
die Hash Map da nicht gleich ganz rausnehmen sollte, lies das aber erstmal da es nun nicht mehr so heftig ist und ich meine
nderungen an diesen Komponenten so klein wie m旦glich halten will.
Eine andere Sache ist die, das wir zwar viele RTTI Klassen haben, aber ebenfalls viele in den meisten Anwendungen 端berhaupt
nicht nutzen. Daran DAS RTTI Klassen da sind, da kann man nix 辰ndern auer nicht ben旦tigte Plugins zu deaktiveren. Aber 端ber
das bew辰rte 'Lazy Evaluation'-Muster das schon so gut im Scene Graph klappt konnte man das ohne zu groe Eingriffe Resourcen
schonender machen:
- Class: In 'Init()' werden die Variablen der Basis Klasse NICHT mehr zu der aktuellen Klasse hinzugef端gt da dies einfach
  nur unn旦tig ist. Stattdessen gehen die Funktionen 'GetVarList()' und 'GetVar()' einfach bei Bedarf Rekursiv zu der Basis-
  Klasse weiter - Funktionsm辰ig also keine nderung, aber Resourcen schonender und auch 端bersichtlicher.
- Class::AddVar(): "Overwrite an already existing variable?"-Teil entfernt da dies nun durch die nderung von oben
  端berfl端ssig ist
- Die Klassen Variablen werden nun nach dem 'Lazy Evaluation'-Schema Initialisiert, sprich, erst wirklich dann wenn diese
  zum ersten mal wirklich ben旦tigt werden... was 旦fters NIE der Fall ist und dann m端ssen die Variablen auch NIE Initialisiert
  werden :D
-> Der Windows Task Manager zeigte mir bei 'PLSampleInitExit' vor dieser nderung einen Speicherverbraucht von '31.368 K'
   an, danach '29.980 K' + es startet minimal flotter. (hab derzeit bei mir alle nicht umbedingt ben旦tigten Plugins w辰hrend
   der Entwicklung deaktiviert, sonst w辰ren das nochmal ca. 10 MB mehr Speicher)



>> 16.03.2007
[CO]
Alle Projekte: Einige Inkonsistensen behoben:
- In Headern wurde beim Einbinden von '*.inl' im Block einmal 'Implementation' oder 'Inline includes' geschrieben. nderte
  das 端berall in 'Implementation' da dies h辰ufiger verwendet wurde... so braucht man nur nach '//[ Implementation' zu
  suchen um all diese Stellen angezeigt zu bekommen.
- 'filename' wurde nicht 端berall gleich geschrieben, einmal 'FileName', oder 'file name'. Da 'filename' bei uns am meisten
  verwendet wird und das u.a. so auch auf Wikipedia geschrieben wird und mein bersetzungs-Tool das so ebenfalls kannte
  machte ich das einheitlich da es mich nun schon ein paar mal verunsicherte wie man das schreiben soll - zudem ist das
  irgendwie doof wenn das innerhalb eines Projektes immer mal wieder anderst geschrieben wird, auch wenn beide schreibweisen
  'richtig' sind... so muss man nicht pro Funktion schaun wie es jeweils geschrieben wird. *g*
- Entfernte den Begriff 'dll' bei z.B. dem 'Import/Export'-Block oder Header Titeln damit das verallgemeinert und nicht
  Begrifflich Windows bezogen ist.
- Bei einigen Klassen sind die Methoden in einzelne 'Bl旦cke' unterteilt, versuchte den Block Titel soweit einheitlich einzur端cken



>> 14.03.2007
[CO]
- HashMap Speicher Optimierung: Die internen Slots werden NICHT mehr sofort angelegt, sondern erst dann wenn das erste Element
  eingef端gt wird... denn es kann durchaus vorkommen das eine HashMap warum auch immer mal 端berhaupt nicht genutzt wird, und in
  dem Fall braucht diese intern keinen weiteren Speicher anzulegen. :)
  Der Windows Task Manager zeigte mir bei 'PLSampleInitExit' vor dieser nderung einen Speicherverbraucht von '35.596 K' an,
  danach '31.368 K'.



>> 12.03.2007
[CO]
Alle Projekte: PLBase:
- Mit den Header nderungen bin ich in PLBase nun erstmal soweit durch - mittlerweile wird von TortoiseSVN fast alles rot
  Dargestellt da ge辰ndert. Also nicht 端ber die Masse an ge辰nderten Dateien wundern, das zieht sich wirklich durch alle Projekte
  durch. Ich finde das nun wirklich um 'einiges' besser als vorher - auch wenn es noch Details zu verbessern gibt.



>> 10.03.2007
[CO]
- Container + Implementationen: Add() & Remove() & Copy() & Compare(): 'nCount' ist nun uint32, wenn 0, so wird alles hinter
  Start kopiert. <0 war sehr ungeschickt und auch teils fehlerhaft Implementiert - zudem machte das wenig Sinn, wenn jemand
  nix machen will, so hat er erst gar nicht diese Funktionen aufzurufen! :)
- Machte die besprochenen Header nderungen die auch in PLNetwork schon so gut klappten. In PL Headern sollten unter keinen
  umst辰nden mehr direkt oder indirekt z.B. Standard-Header reinkommen, also u.a. kein direktes 'memcpy' mehr in Headern/Inline
  Implementationen. Da ich die Codes nochmal komplett durch schauen musste, 辰nderte ich dabei gleich Dinge die wir mittlerweile
  anderst schreiben. (u.a. 'strukturierter') Wo m旦glich reduzierte ich die Abh辰ngigkeiten von z.B. Headern durch Predefinitions
  oder verschieben von Inline in cpp noch weiter. Auch machte ich die besprochenen nderungen bei der Verwendung von Namespaces,
  also 端berall 'using namespace' in cpp sobald etwas einmal ben旦tigt wird.
- Kleine 'Wrapper'-Klasse im Tools-Ordner hinzugef端gt f端r Dinge wie z.B. 'memset' die wir in Headern oder Inline-Implementationen
  nutzen. (was nur sehr selten der Fall ist!)



>> 09.03.2007
[CO]
Neues Projekt: PLNetwork:
Stefan schickte mir gestern per E-Mail PLNetwork das er vor 3 Jahren oder so schon mal geschrieben und immer mal wieder kurz
aktualisiert hatte. Wie besprochen Integrierte ich dieses Projekt in PixelLight. Machte auch ein paar erste kleine nderungen
die Funktionsm辰ig aben nix 辰ndern sollten: (solche nderungen sind ganz nebenbei optimal zum in etwas einarbeiten *g*)
- Host: Ersetzte die stl vector Klasse durch unsere List Klasse
- Socket::Close(): Hier stimmte glaube ich etwas nicht ganz, da z.B. gleich bei 'closesocket' die Funktion verlassen wurde, und
  etwas weiter unten dann (nicht wirklich *g*) die Variablen zur端ckgesetzt wurden
- nderte ein paar Variablen wie z.B. 'Port' in uint32 damit man gleich von vorne an keine negativen Werte bekommen kann
- Passte hier und da minimal den Code Style an die anderen Projekte an
- Machte hier gleich die nderungen die wir f端r alle Projekte machen wollen, also nur 'using namespace...' in cpp, ein Header
  hat selbst wirklich ALLES zu definieren/includieren was er selbst braucht - inklusive des Lib-Headers der eigenen Lib



>> 02.03.2007
[CO]
- FileSystem::SetBaseDirPriority() & LoadableType::SetSearchPathPriority() Implementiert
- Loader::OpenFile(): Da das File System bei absoluten Dateinamen nicht erst lange herumsuchen muss, versucht das Loadable System
  erstmal den wahrscheinlichsten absoluten Pfade zu nutzen - das klappt meistens und die Ladezeiten werden dadurch sp端rbar k端rzer!
  Gerade in groen Szenen wie z.B. der aktuellen vom Dungeon Demo ist das Laden nun um einiges annehmbarer - zwar nat端rlich noch
  nicht Optimal (Memory Mapped Files m端ssten hier nochmals einiges bringen) aber zumindestens nicht mehr 辰tzend. *g*



>> 02.03.2007
[SB]
- Da es keine Header geben sollte, die nur dann fehlerfrei benutzt werden k旦nnen wenn vorher noch andere Header eingebunden werden
  (also Abh辰ngigkeiten des Headers nicht im Header selbt eingebunden werden), habe ich PLGeneralWin32Header.h 端berall dort, wo
  Win32-Datentypen in einer Klasse direkt verwendet werden, auch direkt in dem entsprechenden Header eingebunden. Zus辰tzliche
  Abh辰ngigkeiten werden dadurch nicht erzeugt, da diese System-Header sowieso nur in den eigenen .cpp Dateien eingebunden werden
  und in der Factory-Funktion, die das ben旦tigte System-Objekt erzeugt. An beiden Stellen muten vorher also auch die System-Header
  eingebunden werden, um die Header-Datei 端berhaupt verwenden zu k旦nnen, was wie gesagt niemals passieren sollte.   
- PLGeneralOSHeaders.h entfernt. Dieser Header wurde nur ein einziges Mal eingebunden, und sollte auch in Zukunft nur sehr selten
  gebraucht werden, da man meist gleich entweder eine Win32- oder Linux-spezifische Datei hat. Dieser Header ist daher unn旦tig,
  und kann in diesen seltenen F辰llen durch eine direkte Fallunterscheidung ersetzt werden



>> 28.02.2007
[CO]
- FileSystem::Mount(): Unterscheidet nun zwischen gro/kleinschreibung wie es 端berall in PL der Fall ist
- ZipDirectory::GetName(): Gab etwas anderes zur端ck als ich erwartet h辰tte und als es die Dokumentation zu FileObject::GetName()
  beschrieb. Daher 辰nderte ich es so das es passt und f端gte eine neue Funktion 'GetNameWithinZipFile()' hinzu welche den Namen
  innerhalb der Zip-Datei zur端ckgibt.



>> 26.02.2007
[CO]
Alle Projekte:
- Ging die Namensgebung der Funktionen nochmal durch welche im Grunde nur 'ja' oder 'nein' zur端ckgeben. GetEnabled, GetActive etc.
  zu IsEnabled, IsActive etc. Da wir momentan noch PLBool drinnen haben musste ich nur nach bool Suchen ("bool Get") lassen. :)
  Ein paar Funktions-Namen lies ich jedoch, an Stellen wo 'Is' irgendwie noch unpassender als 'Get' ist und ein 'Has' auch irgendwie
  fehl am Platz ist - da m端sste man eventuell nochmal schaun ob die Funktionnamen an sich 端berhaupt Sinnvoll sind.
  (wenn man mal gerade nix besseres zu tun hat *g*)



>> 25.02.2007
[SB]
- Neue Klassen-Templates f端r Funktions-Objekte hinzugef端gt. Das sind recht praktische Zeitgenossen, mit denen Zeiger auf Funktionen
  als Objekte gespeichert werden k旦nnen. Diese Objekte k旦nnen dann genauso aufgerufen werden wie Funktionen. Im Gegensatz zu
  Funktions-Pointern k旦nnen diese Objekte aber nicht nur Zeiger auf statische Funktionen sein, sondern auch Zeiger
  auf Member-Funktionen von Klassen, die zusammen mit einem Zeiger auf ein Objekt dieser Klasse gespeichert werden.
  Bitte beachten: FunctionTmpl.inl funktioniert etwas anders als unsere 端blichen .inl Funktionen, daher auch der etwas andere Name,
  da es sich eben nicht nur um die Inline-Implementation von Function.h handelt. Das #ifdef in dieser Datei wurde NICHT vergessen
  sondern ist GEWOLLT weggelassen worden, da die Makros ansonsten nicht mehr richtig funktionieren w端rden! :-)   



>> 24.02.2007
[SB]
Alle Projekte:
- Alle Projekte so angepat, da sich wieder alles mit VC7 端bersetzen l辰t.
- Alle CMake Projektdateien angepat: Es wird jetzt ein anderes Kommando f端r die Postbuild-Kommandos verwendet, da es bei der
  alten Variante u.U. zu Problemen mit den Abh辰ngigkeiten und der Reihenfolge der Projekte kommen konnte. Auch wird so der
  Postbuild-Vorgang nicht mehr als eigenes Target angezeigt.  
PLGeneral:
- Undef einiger weiterer Definitionen aus den Window-Headern in PLGeneralWin32Includes.h hinzugef端gt, die ben旦tigt wurden da es
  sonst Namenskonflikte mit eigenen Methoden aus SystemImpl gibt.



>> 23.02.2007
[SB]
Alle Projekte:
- Alle Projekte so angepat, da sich alles auch wieder unter Linux 端bersetzen l辰t



>> 23.02.2007
[CO]
Alle Projekte:
- Da ich gerade vom Compiler in den PL Beispielen mal wieder gesagt bekommen hatte das es einen Namespace Konflikt gibt und
  nicht entschieden werden kann ob 'Rectangle' denn nun ein "Win32 Rectangle" oder ein 'PLMath::Rectangle' sei hatte ich einfach
  absolut KEINE Lust mehr auf dieses total bescheuerte herumgehacke mit den Namespaces etc. nur weil irgendwo ein OS Header
  reinkommt den man eigentlich 端berhaupt nicht braucht und dort halt Dinge definiert sind die man ebenfalls nicht braucht sondern
  wirklich nichts als rger machen. Daher baute ich das endlich mal so um das OS Header NUR noch dann reinkommen wenn man diese
  WIRKLICH braucht, also in den konkreten OS Implementationen. berall sonst darf von nun an absolut NICHTS OS Abh辰ngiges mehr
  reinkommen - und falls das doch mal 'n旦tig' sein sollte l辰uft etwas falsch, denn es MUSS ohne gehen.
  Bei den erstaunlicherweise sehr kleinen nderungen damit das ohne st辰ndige OS Header klappt gab es ebenfalls erstaunlicherweise
  praktisch keine Probleme da wir im laufe der Jahre bereits alles 'virtualisiert' hatten. :)
  Beim 端bersetzen unter Windows klappt das nun so ganz wunderbar, und man hat endlich in Projekten welche rein auf PL aufbauen
  praktisch (also bis auf das InputSystem, durch das leider noch derzeit OS Header reinkommen) keine Namespace Probleme mehr mit
  OS-Dingen. *freu*
  An ein paar Stellen bei denen Windows-Header genutzt werden, musste ich ein paar unschicke 'undefs' wie z.B. #undef MessageBox
  einf端gen, (gerade in PLGeneralWin32Includes.h ist das krass) ansonnsten bekam ich einmal Compiler Fehler da wir Funktionen haben
  die genauso heien, und beim anderen mal Linker Fehler das etwas nicht gefunden wurde was wir gar nicht nutzen. Diese define
  Dinge der OS Header sind wirklich 端belst und ich bin total froh das wir diese nun nur noch an 'sehr' wenig Stellen einbinden
  m端ssen.
  Bei den Linux Headern hab ich gekennzeichnet was umbedingt raus sollte.
PLGeneralLinux.h & PLGeneralWin32.h:
- Nahm THREAD_HANDLE heraus da es nirgends mehr verwendet wird
- NativeDirectory liegt nun direkt in FileSystem.cpp, der Benuter sollte davon nix sehen
- RTTI: Wie kurz besprochen PL_VAR_STRING & PL_VAR_FILENAME welche mit klassischen C-Strings arbeiteten entfernt und daf端r
  PL_VAR_PLSTRING & PL_VAR_PLFILENAME in PL_VAR_STRING & PL_VAR_FILENAME umbenannt. Alle Projekte daran angepasst.



>> 22.02.2007
[CO]
- ModuleID<T>::SetModuleName() & ModuleID<T>::SetModuleVendor() & ModuleID<T>::SetModuleDescription():
  Tests auf Buffer berlauf eingebaut + statt strncpy wird nun memcpy genutzt damit einen VC 2005 nicht mit Warnungen
  in allen Projekten zum端llt.
- An Stellen wie z.B. SystemWin32::GetEnvironmentVariable() wird nun neben 'Unicode' auch 'UTF8' gepr端ft, ist es ein UTF8 String
  m端ssen die Daten als Unicode zur端ckgegeben werden damit kein Informationsverlust stattfinden kann... da Windows nur wchar_t
  und kein direktes UTF8 kann muss leider immer Konvertiert werden, aber da kann man nix dran 辰ndern. (辰hnliche Thematik dann
  unter Linux, nur umgekehrt *g*)
- Win32File::Rename() auf unsere String Klasse umgestellt. M端ssen wir bei Erfolgt ebenfalls auch den neuen Dateinamen speichern?



>> 21.02.2007
[CO]
Alle Projekte:
- Machte wie besprochen die Umstellungen auf die 'sicheren angeblichen Standard-Funktionen' vom 11.02.2007 wieder r端ckg辰ngig,
  denn wie sich herausstellte sind diese leider nicht wirklich Standard - auf jedenfall wird das derzeit nicht von sonderlich
  vielen Compilern unterst端tzt und daher ist das leider unbrauchbar f端r uns. :(
  Schaute mir dabei gleich alle Stellen wo diese C-String Funktionen genutzt werden genau an damit es keine Buffer berl辰ufe
  geben kann. berall auerhalb der String Klasse stellte ich soweit irgend m旦glich/sinnig die letzten Stellen die ich finden
  konnte auf unsere String Klasse um damit man sich gar nicht erst mehr mit den C-String Funktionen herum辰rgern muss. In den
  Projekten in denen VC 2005 trotzdem noch meckert das etwas 'potentiell unsicher' sein deakvierte ich diese Warnungen einfach,
  wir wissen (meistens :) schon ganz genau was wir tun und m端ssen uns da nicht von einem Compiler zujammern lassen. *g*
  -> *bin heute noch nicht ganz mit diesen Arbeiten fertig geworden*
PLGeneral:
- FSTools::ValidatePath(): Gleiche nderung wie gestern in Win32FSTools::ConvertToWindowsPath()
- ZipDirectory::GetComment(): So ge辰ndert das kein 'strcpy' mehr verwendet wird, zudem 端bernimmt die String Klasse direkt den
  Buffer (habs getestet, funkt noch korrekt :)
- Ein paar Kommentare von ZipDirectory & ZipStream korrigiert oder genauer gemacht
- ZipIterator::GetCurrentFileInfo(): Die String Klasse 端bernimmt den Buffer mit dem Dateinamen und Kommentar direkt
- F端gte in diesem VC 2005 Projekt bei den Compiler Optionen "/D "_CRT_SECURE_NO_DEPRECATE"" ein damit keine unn旦tigen
  Warnungen kommen
- Formte in der String Klasse ein paar Ausdr端cke um so das es etwas besser Strukturiert r端berkommt



>> 20.02.2007
[CO]
Alle Projekte: Machte wie besprochen den ersten Schritt bei den Plugin-nderungen:
- ClassManager::ScanPlugins(): Sucht wie vorher auch nach Plugins, kann dies jedoch nun auch Rekursiv machen
- ClassManager::LoadPlugin(): Pr端ft ob es wirklich eine '.plugin'-Datei ist, lies die Meta-Informationen aus und pr端ft dabei
  gleich den 'Typ' auf g端ltigkeit/端bereinstimmung oder ob ein Plugin aktiviert/deaktiviert ist. Danach wird der Name der
  Dynamischen Bibliothek ermittelt - derzeit wird der Plugin Name genommen und entsprechend ge辰ndert so das Plugin und
  Dynamischen Bibliothek also erstmal im gleichen Verzeichniss liegen m端ssen. Anschlieent wird wie gehabt (also 1 zu 1
  端bernommen :) die Dynamischen Bibliothek eingeladen.
- Verschob die Plugins der verschiedenen Projekte sammt ben旦tigter externer dlls in einen Plugin-Unterordner + dort wo sinnig
  in weitere Unterordner + schrieb entsprechende '.plugin' Dateien in denen ebenfalls vermerkt ist welche dll's diese ben旦tigen,
  was ich recht hilfreich finde. Hier m端ssen wir uns allerdings noch 端berlegen ob wir das drinnen lassen da z.B. unter Linux die
  Dateiendung nat端rlich anderst ist + auch teils die Namen der ben旦tigten Dynamischen Bibliothek, oder ob wir f端r jedes OS
  Seperate Dateien machen oder ob das innerhalb der Plugin-Dateien nach OS unterteilt ist.
- DynLibManager::LoadLibrary() & DynLib::Load(): Damit man Plugins + abh辰ngige Dynamischen Bibliothek problemlos auch in
  Unterordnern halten kann was durchaus Sinnig ist 辰nderte ich das Verhalten dieser Funktionen minimal. Die Windows Funktion
  l辰sst netterweise zu das die anderen n旦tigen dll's zuerst im gleichen Verzeichniss wie die eingeladene dll zu suchen sind.
  Wenn es unter Linux soetwas nicht gibt muss man es so l旦sen wie ich es zuerst unter Windows machen wollte: Einfach das
  aktuelle Verzeichniss kurzzeitig entsprechend 辰ndern. Dynamischen Bibliotheken sind also zuallererst im 'kleinsm旦glichen Scope'
  zu suchen. *g*
- Passte die Post-Build Operationen aller VC & CMake Projekt entsprechend das herum kopieren)
PLGeneral:
- BufferedStringReader auf unsere String Klasse umgestellt. Diese Implementation ist sogar schlanker und 端bersichtlicher bei
  gleicher Effektivit辰t. :)
- Win32FSTools::ConvertToWindowsPath(): Das 'gromachen' des Laufwerksbuchstaben 'Unicode sicher' gemacht
- ClassManager::GetVarType(const String &sType) Case-Sensitive gemacht da PL generell Case-Sensitive ist
  (da diese Funktion bis jetzt nirgends genutzt wird, musste man auch nichts pr端fen ob das korrekt verwendet wird :)
- Hack: Class::Init() Registriert sich in LoadableManager damit dieser von neuen Loadern Wind bekommen kann. Das war leider
  n旦tig da ansonnsten u.a. in "PhysicsPlayground.scene" Sichtbar Dinge nicht korrekt Funktionierten. (was mich schon geraume
  Zeit st旦rte, da die Ragdolls dort wirklich extrem cool r端berkommen *g*) In dem Falle bekam man die Meldung das die Ragdolls
  nicht eingeladen werden konnten da 'Radgoll' nichts sei was eingeladen werden k旦nnte. Bei Config ist es im Prinzip genauso,
  aber da man da zum Gl端ck derzeit nix von merkt war auch kein Hack daf端r n旦tig. :)
  Klassen melden sich bei LoadableManager nicht ab, da dies derzeit nicht absolut n旦tig ist - ich wollte einfach die Hacks
  so gering halten wie m旦glich und f端gte auch ausreichene Dokumentation dazu damit man sp辰ter noch weis warum das drinnen ist.
- Loadable::Save(File *pFile, const Parameters *pParams) pr端ft ob die 端bergebene Datei beschreibbar ist
- SearchFilter::CheckMatch() auf unsere String Klasse umgestellt. Ich brauchte einige Zeit um in etwa nachvollziehen zu k旦nnen
  was hier passiert. Ich hoffe das ich das Funktionsm辰ig soweit verstanden und korrekt 端ber unsere String Klasse realisiert
  habe so es Funktionsm辰ig keinen Unterschied gibt.
  Stefan, w辰re super wenn du das auch nochmal genau Durchdenken k旦nntest ob ich da nicht doch nun eine Funktions nderung
  drinnen habe... das war das komplizierteste was ich bis jetzt auf unsere String Klasse umgestellt habe und da kann schonmal
  was daneben gegangen sein. *bibber*
  (zumindestens einfache Dinge wie '*.pak' scheinen noch korrekt zu funktionieren, und das in '*' war der heftigste Teil :)



>> 16.02.2007
[CO]
- 'ConsoleLogFormater' hinzugef端gt - stand schon so lange auf dem Plan obwohl so wenig Arbeit *g*
- ClassManager::ScanPlugins(): Musste hier leider einen Hack einf端gen: "msvcr80.dll" und "msvcr80d.dll" sollte man nie per
  Hand einladen da ansonnsten eine dll Namens 'COREDLL.dll' verlangt wird (scheinbar WindowsC E) wovon ich nur eine nicht
  wirklich brauchbare Version im Netz nach langem suchen finden konnte. Hm, mit den Plugins m端ssen wir uns wirklich mal was
  端berlegen, denn irgendwie h辰ufen sich 辰hnliche Probleme wenn man alle dlls einl辰d und nach PL brachbaren Zeug durchforstet. :(



>> 12.02.2007
[CO]
- String: Neue Funktionen: IsValidInteger(), IsValidFloat(): Pr端fen ob im String eine g端ltige Integer oder Float Zahl ist,
  solche Tests werden u.a. f端r die EditBox in PLGui ben旦tigt.



>> 11.02.2007
[CO]
Alle Projekte: Auf VC 2005 'umgestellt':
- Als ich zum ersten mal etwas unter VC 2005 端bersetze bekam ich nat端rlich viele 'Depriciated Fehlermeldungen' wie z.B.:
    c:\programme\microsoft visual studio 8\vc\include\string.h(73): Siehe Deklaration von 'strcpy'
        Meldung: "This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use
        _CRT_SECURE_NO_DEPRECATE. See online help for details."
  Zum Gl端ck nutzen wir mittlerweile 'fast' 端berall (und wo das noch nicht der Fall ist und sinnig ist, wird das bald der
  Fall sein :) unsere eigene String Klasse so das sich dieses 'Warnungen' auf eine (groe) Handvoll Stellen beschr辰nkten.
  Da die 'Sicherheits'-Warnungen + die neuen zus辰tzlichen Warnungen durchaus Sinnvoll sind stellte ich u.a. auf 'sichere'
  Funktionen um dennen man die Buffer gr旦e 端bergeben muss damit sich Buffer berl辰ufe vermeiden lassen. (ich denke da spricht
  absolut nix dagegen :) Es gibt noch aufw辰ndigere Stellen wo man umstellen m端sste oder wo wir sowieso bald unsere eigene
  String Klasse nutzen, das mache ich als zweiten Schritt - w端rde man das auf einmal machen k旦nnten sich schneller Umstell-Bugs
  einschleichen... ich hoffe da sind bis jetzt keine reingekommen, denn bei dem +1 f端r mit/ohne \0 muss man immer verdammt
  aufpassen und sich genau Informieren wie die verschiedenen Funktionen das 端bergeben haben wollen. (bitte die nderungen
  nochmal kurz 端berfliegen :)
- An Stellen wie z.B.
  .\src\Base\StringBufferASCII.cpp(285) : warning C4996: 'stricmp' wurde als veraltet deklariert
    C:\Programme\Microsoft Visual Studio 8\VC\include\string.h(213): Siehe Deklaration von 'stricmp'
    Meldung: "The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _stricmp. See online help for details."
  passte ich entsprechend an. ('Standardkonform' ist immer gut :) In 'PLGeneralLinux.h' kann man nun sicherlich einige 'stricmp' etc. entfernen.
- TinyXML: Mit VC 2005 neu 端bersetzt damit der Linker nicht meckert



>> 10.02.2007
[CO]
- SystemWin32::GetOS(): Erweitert damit auch Windows Vista + Service Packs erkannt werden



>> 01.02.2007
[SB]
Alle Projekte:
- CMake build system ist komplett, alle Projekte lassen sich sowohl f端r Windows als auch f端r Linux 端bersetzen
- Kleine Zusammenfassung, welche Probleme es mit CMake gab:
  - PROJECT_OUTPUT konnte nicht auf ein anderes als das Grundverzeichnis gesetzt werden (sollte eigentlich "bin" sein), da CMake
    ansonsten beim linux-build die Abh辰ngigkeiten nicht mehr findet und sofort abbricht. Die Ausgabedateien werden also im
    Grundverzeichnis des Projektes erstellt, was aber nicht weiter schlimm ist, da es sich ja immer um max. 2 Dateien handelt
    und sich dort ansonsten nur die Projektdateien befinden.
  - Beim linux-build werden statische Bibliotheken, die eine Abh辰ngigkeit von einer dynamischen Bibliothek darstellen, nicht nur
    zu dieser Bibliothek gelinkt sondern auch zu allen davon abh辰ngigen Projekten (eine Erkl辰rung hierf端r findet sich in der CMake FAQ).
    Da die Pfade zu diesen Bibliotheken aber in den abh辰ngigen Projekten nicht bekannt sind, werden diese nicht gefunden und das
    bersetzen bricht ab. Um das zu vermeiden m端ssen die externen Bibliotheken immer mit absolutem Pfad angegeben werden, anstatt
  LINK_DIRECTORIES zu benutzen.
- Altes Linux-Buildsystem ausgebaut



>> 28.01.2007
[CO]
Alle Projekte:
- VC Projekt-Dateien wie besprochen in die jeweiligen Grundordner verschoben



>> 27.01.2007
[SB]
Alle Projekte:
- Neues Build-System f端r Linux auf Basis von CMake eingebaut. Die Projektdateien k旦nnen daf端r benutzt werden,
  sowohl die Linux-Version zu erstellen als auch mittels Cross-Compiling mit VC7 die Windows-Version.
- PLBase Projektdateien sind komplett, jedoch lassen sich zur Zeit noch nicht alle Projekte auch f端r Linux 端bersetzen.
  Das Cross-Compiling f端r Windows funktioniert aber schon perfekt :-)



>> 26.01.2007
[CO]
Kleinere Aufr辰umarbeiten in PLGeneral:
- "Friend declarations" in "Friends" ge辰ndert
- z.B. "Public interface" in "Public functions" ge辰ndert
- Namespace Style vereinheitlicht
- Ein paar Leerzeichen/Tabs korrigiert
- In ein paar Konstruktoren wurden nicht alle Variablen Initialisiert + an ein paar Stellen wurde noch nicht die
  Initialisierungs-Liste genutzt
- Ein paar const eingef端gt
- In ein paar Headern wo m旦glich Includes durch Predefinitions ersetzt
- F端gte in einigen cpp-Dateien 'Bl旦cke' hinzu damit man sofort sehen kann welche Funktionen public, private etc. sind
- Ein paar Kommentare korrigiert/vervollst辰ndigt (u.a. "@remarks:" zu "@note" gemacht, oder "@remarks" zu "@note")
- An ein paar Stellen Codes etwas vereinfacht/versch旦nert, z.B. "for (;;)" in "do/while" ge辰ndert oder 'tote' Codes entfernt
  oder ein [TODO] davor gesetzt wenn nicht eindeutig klar war das es nicht mehr ben旦tigt wird
... An der Funktionalit辰t sollte sich nichts ge辰ndert haben. Stellen wo man etwas Funktionell 辰ndern/pr端fen
    muss hab ich mir erstmal nur notiert um diese in einem zweiten Schritt abzuarbeiten. (damit nix durcheinander kommt :)
    Gerade einige Umbenennungen waren mir sehr wichtig da diese das durchsuchen aller Projekte nach bestimmten Begriffen
    sehr erleichtern.
- BufferedStringReader::GetString(): Hier kann der String Buffer direkt 端bernommen werden. Bringt jedoch nur 'im Augenblick'
  etwas, denn BufferedStringReader m端sste man komplett auf die String Klasse umstellen ohne 'char *' zu nutzen *Unicode Sicher*
- CmdLineParser Code Style angepasst und 'printf' f端r Debugging rausgenommen, soetwas sollte nie im Code bleiben und auch nie
  n旦tig sein... man braucht hier *wirklich* einen brauchbaren Debugger damit man keine printf-Kr端cken nutzen muss die den Code
  durcheinander werfen. Ich fand auch ein paar Stellen wo man die Implementation etwas vereinfachen konnte + Variablen die nix
  machten entfernen konnte. An der Funktionalit辰t hab ich nichts ge辰ndert.
- Bugfix: SearchFilter::SearchFilter(): "m_sFilter.ToLower()" entfernt da PL generell case sensitive ist
- Tokenizer: 'm_sSingleChars' Default Einstellung ist nun eindeutig wie gehabt "{}()[]<*>/=,;\"", in den Codes war auch noch
  "{}()[]<>+-*/=,;\"" auskommentiert drinnen und in der Klassen Dokumentation stand "{}()[]=,;\"" als Default. + und - machen
  im Zusammenspiel mit Zahlen welche ein Vorzeichen haben schwere Probleme, darum sollten diese Zeichen als Default keine
  einzelnen Zeichen sein.



>> 18.01.2007
[CO]
- Bugfix: FSTools::ValidatePath(): ".." und "." wurden nicht korrekt aufgel旦st da FSTools::GetFirstPath() ebenfalls '\' am
  Ende stehen hat. (war fr端her mal anderst) Dies viel vorallem im Datei-Dialog auf. :)



>> 16.01.2007
[CO]
- Timer: SetTimeScaleFactor(), SetSlowMotionFactor() und SetCustomSlowMotionFactor(): Der 端bergebene Faktor MUSS gr旦er als
  0 sein, ist das nicht der Fall, liefern diese Funktionen nun einen Fehler zur端ck. Ein Faktor von 0 oder gar ein negativer
  Faktor macht an verschiedenen Stellen nur probleme und logisch 端berhaupt seinen Sinn. 0 ist das gleiche wie Pause, also
  kann man gleich 'richtig' Pausieren wenn man das will, und negative Faktoren, hm, dann m端sste ja automatisch alles
  r端ckw辰rts laufen... grrr... *g*



>> 23.12.2006
[CO]
- ChecksumCRC32 Checksum Implementation hinzugef端gt
- ChecksumSHA1 Checksum Implementation hinzugef端gt. Damit haben wir nun 3 Checksum Implementation (aller guten Dinge sind
  3... 3 Gui-Implementationen, 3 Renderer-Implementationen, 3 Sound-Implementationen... *g*)



>> 17.12.2006
[CO]
Alle Projekte:
- Bei den 'GetLoadableTypeName()'-Implementationen wird nun nicht mehr ein C-String zur端ckgeben, sondern diese Funktionen
  halten ihren R端ckgabe-String in einem statischen PL String der zur端ckgeben wird. Auf die weise muss nicht jedesmal
  der *wirklich* statische String in einen PL String umgewandelt werden nur um kurz darauf wieder zerst旦rt zu werden.
  Statt z.B.
    String SceneContainer::GetLoadableTypeName() const
    {
      return "Scene";
    }
  wird nun
    String SceneContainer::GetLoadableTypeName() const
    {
      static String sString = "Scene"
      return sString;
    }
  geschrieben. Von auen merkt man also nix, und intern isses eine geschicktere Implementation. Das mag zwar die Performance
  nicht um das tausendfache steigern, aber wenn man soetwas machen kann ohne das es alles total durcheinander bringt sollte
  man das machen. An 辰hnlichen Stellen sollten wir das immer genauso machen, bin daher mal die Codes durchgegangen und 辰nderte
  es dort wo es sinnig ist. Wird nur "" zur端ckgeben, k旦nnen wir das wie gehabt lassen da hier sowieso nix herum kopiert wird,
  oder wo der mehraufwand das 端berhaupt nicht rechtfertigt und es dadurch nur un端bersichtlich wird sollten wir das ebenfalls
  wie gehabt lassen... z.B. bei pButton->SetText("Blah!").



>> 16.12.2006
[CO]
- Loadable: m_sAbsFilename muss leider protected sein da PLMesh::Texture und PLMesh::Material *sehr* spezielle Lade Funktionen
  komplett selbst Implementieren und entsprechend m_sAbsFilename in Eigenverantwortung setzen m端ssen.
- Loadable::Reload() darf der Lade-Funktion nat端rlich keine direkte Referenz auf 'm_sAbsFilename' 端bergeben da dieser String
  innerhalb der Lade-Funktion durch die Unload()-Funktion zur端ckgesetzt wird und dann nat端rlich nicht bekannt ist was denn
  nun geladen werden soll. :)



>> 13.12.2006
[CO]
Alle Projekte:
- Schaute mir alle Stellen in den Codes an in denen 'using namespace' verwendet wird: Nahm un旦tige 'using namespace'
  heraus, entfernte z.B. 'PLGeneral' vor 'PLGeneral::uint32' wenn gerade PLGeneral als Namespace verwendet wird, fand und
  entfernte dabei einige mittlerweile unn旦tigen Header-Includes.



>> 03.12.2006
[CO]
- Ich schaute mir nochmal kurz die verschiedenen Implementation von Container::Remove() (+ 端berall wo GetIndex() verwendet wird)
  an und merkte das diese bei weitem nicht Optimal war... denn da wurde ein int Wert von 'GetIndex()' ner Funktion 端bergeben die
  ein uint32 erwartete und konnte ein Element nicht gefunden werden wurde -1 in uint32 umgewandelt... ging zwar meistens gut
  da wir nie Container mit SO vielen Elementen haben, war aber nat端rlich nicht korrekt. Bei der Gelegenheit erweiterte ich die
  Container-Kommentare auch noch minimal so das m旦glichst keine Fragen offen bleiben.



>> 02.12.2006
[CO]
- Der Loadable-Manager ist nun ebenfalls ein Loadable und kann sich somit selbst Laden und Speichern. File System Basis
  Pfade werden momentan ebenfalls speichern, wenn das unn旦tig/ungeschickt sein sollte, k旦nnen wir uns 端berlegen wie wir
  das am besten anderst l旦sen.
- Loadable um Reload()-Funktion erweitert, das ist zwar praktisch 'nur' ein pLoadable->Load(pLoadable->GetAbsFilename()),
  passt aber wunderbar rein und wird auch mehrmals genutzt. PLMesh::Material und PLMesh::Effect erweitern diese Reload()
  Funktion indem nach dem Neuladen zus辰tzlich noch die verwendeten Texturen neu geladen werden.
- Bugfix: BufferedFileReader: Beim beenden wurde Release() von File aufgerufen, aber beim Datei Zeiger speichern wurde
  keine Referenz hinzugef端gt und so wurde in sehr ungl端cklichen Situationen die Datei einfach gekillt obwohl diese noch
  Referenziert und auch verwendet wurde. F端gte nur ein 'm_pFile->AddReference();' ein anstatt auf Smart Pointer umzustellen.



>> 01.12.2006
[CO]
Alle Projekte:
- Auf Anregung von Stephan 辰nderte ich 端berall
    XmlDocument *pDocument = new XmlDocument();
  in
    XmlDocument cDocument;
  wodurch auch kein delete mehr n旦tig ist.
PLGeneral:
- Stack und Queue Kommentare minimal erweitert: Sucht man nun in PixelLight.chm z.B. nach 'FILO' wird man recht schnell
  das Stack Template finden. :)
- 'Timer' Klasse in 'Timing' umbenannt. Dieser Name ist passender - und ganz nebenbei kann's auch keinen Namenskonflikt mehr
  mit der neuen Timer Klasse in PLGui geben.
- Code im Destruktor von XmlNode entfernt da genau das gleiche in dessen Basis-Klasse XmlBase passiert (kein Fehler, nur unn旦tig)
- F端gte bei den Xml-Klassen in denen es noch 'keinen' Destruktor gab einen leeren ein (wir hatten uns vor einiger Zeit geeinigt
  das wir das so machen wollen, also immer Destruktoren reinschreiben)



>> 30.11.2006
[CO]
- ClassManager::GetVarType(): PL_VAR_PLSTRING fehlte hier, merkw端rdig das dies bis jetzt noch nicht aufgefallen war :D
- XmlDocument::LoadFile() setzt nun ebenfalls den Dokument Wert auf den Dateinamen aus dem dieses Dokument geladen wurde
- Verschob FSTools::GetRelativePath() in den Loadable-Manager. Dieser schaut als allerersten Schritt nach ob's f端r diese Datei
  Endung 端berhaupt einen eingetragenen Loadable Type gibt, wenn ja, so wird die Anfrage einen 'relativen Pfad' zu erzeugen
  an diesen Loadable Type weitergeleitet.
FileSystem:
- Nahm folgende Funktionen heraus da nun das Loadable-System f端r diese Jobs zust辰ndig ist:
  GetNumOfSearchPaths(), GetSearchPath(), IsSearchPath(), AddSearchPath(), SetSearchPathPriority(), RemoveSearchPath(),
  ClearSearchPaths(), GetNumOfFileTypes(), GetFileType(), RemoveFileType().
- OpenInPaths() ist nun unn旦tig und wurde daher entfernt
- Enfernte die Klasse FileType, Sie ruhe in Frieden *g*



>> 26.11.2006
[CO]
- Container Klassen etwas herausgeputzt: ein paar Klassen-Bl旦cke hinzugef端gt, Prefix bei Klassen-/Stuktur-Namen entfernt,
  ein paar kleinere Kommentare etwas ge辰ndert
- XML-Klassen etwas herausgeputzt: Haupts辰chlich Kommentare komplettiert/verbessert
- ClassManager::LoadPlugin(): Eine Datei wurde ge旦ffnet, aber nicht wieder freigegeben -> Stefan schau bitte nochmal dr端ber
  nicht das ich da nun etwas vermurkst habe. :)
- LoadableManager & Config: Ich wunderte mich gerade das Ragdolls im Scene Viewer nicht mehr geladen werden k旦nnen da angeblich
  'Ragdoll' ein nicht bekannter Loadable Typ ist... als ich der Sache nachging stellte sich schnell heraus das der Loadable
  Manager bereits nach Loadable Typen sucht und diese Registriert (in dessen Konstruktor) bevor der Runtime-Ordner nach Plugins
  durchsucht wurde. Das l辰sst sich momentan leider nicht 'beheben' da man sich nicht Informieren lassen kann wenn neue Plugins
  eingeladen wurden um anschlieend diese 'Neulinge' nach zu Registrierenden Komponenten zu durchsuchen. :(



>> 25.11.2006
[CO]
Alle Projekte:
- Schaute 'NULL' in allen Headern nochmal durch und ersetzte es im zusammenhang mit PL-Strings durch 'empty'
  (das waren noch Zeiten als wir 'char*' nutzten :)
PLGeneral:
- Loadable: Da es bei Mehrfachvererbungen (siehe PLEngine::SceneContainer oder PLPhysics::SNRagoll) leider schnell zu cast
  Problemen kommt baute ich bis eine bessere L旦sung gefunden ist virtuelle 'LoadLoadable()' und 'SaveLoadable()' Funktionen
  ein mit denen sich das Problem 'umgehen' l辰sst. Sehr schade, denn bis auf dieses Problem ist das Loadable-System mittlerweile
  recht nett, sehr einfach zu verwenden und zu erweitern.
- Localization Loader + Implementation f端r unser eigenes Format hinzugef端gt
- Config Loader + Implementation f端r unser eigenes Format hinzugef端gt



>> 24.11.2006
[CO]
- Vereinfachte das Loadable-System noch etwas und nahm einige Dinge aus 'Resource' heraus diese nun in dessen Basis-Klasse 'Loadable'
  liegen... Machte zuvor eine Kopie Namens 'ElementManager' etc. da sehr oft 'Resource' allein von Namen her in der Verwendung
  nicht korrekt war. (oder zumindestens nicht wirklich passend) Das ist zwar ingesammt immer noch nicht sonderlich prall, aber
  immerhin etwas besser als vorher. :)
  'Resourcen' sind 'Dinge' wie man Einladen & Speichern und von denen man 端berlicherweise viele im Speicher hat und diese
  daher 'Verwaltet' haben m旦chte. 'Elemente' sind 辰hnlich, aber einfacher und auch nicht lad oder speicherbar.
- Graph Loader + Implementation f端r unser eigenes Format hinzugef端gt
- Graph Path Loader + Implementation f端r unser eigenes Format hinzugef端gt



>> 11.11.2006
[SW]
- String: da die atof funktion unter linux auch locale abh辰ngig ist, wird in den Funktionen GetFloat und GetDouble
      wie in den Format funktionen die locale auf "C" gesetzt.
- LinuxDirectory: ein Fehler bei der berpr端fung ob der Suchpfad mit einem "./" beginnt
  und dem l旦schen dieser 2 zeichen behoben. In der urspr端nglichen Fassung wurde das L旦schen durch die Stringfunktion Replace durchgef端hrt,
  was aber einen b旦sen nebeneffekt hatte, wenn der pfad auch "../" enthielt.



>> 04.11.2006
[CO]
- Win32File & LinuxFile: Kann es wirklich sein das im Destruktor die Datei nicht geschlossen wurde falls diese noch offen
  war? (was bei Reference Counting schonmal passieren kann... der letzte hat die T端r zuzumachen... :)



>> 03.11.2006
[CO]
- Entfernte ein paar 'PLGENERAL_API' wo das nicht n旦tig ist da es rein PLGeneral intern genutzt wird
- F端gte einige 'const' ein
- Virtual vor Destruktor entfernt da unn旦tig: (verwenden nur eingebettete Implementationen) Semaphore, Mutex, DynLib
- In einigen cpp-Dateien Kommentar Bl旦cke hinzugef端gt damit man sofort sieht ob die Funktionen public etc. sind
- System: Neue Funktion GetLocaleLanguage(): Diese Funktion gibt den Namen der aktuell eingestellten Programm Sprache wie z.B.
  'English' zur端ck. Diesen String kann man dann nutzen um im Lokalisations-System eine korrekte Default-Sprache zu w辰hlen.
- ~ThreadManager: nderte das l旦schen noch vorhandener Threads da Theads sich beim l旦schen automatisch aus der Liste
  entfernen was beim Interator Probleme machen 'k旦nnte'. In diesem speziellen Fall machte das zwar keine Probleme da der List
  Iterator intern direkt einen Zeiger auf das n辰chste Element h辰lt, aber beim z.B. Array-Iterator w端rde das schon nicht mehr
  gehen... lieber auf Nummer sicher gehen. :)
- SystemWin32: SetThreadAffinityMask() aus PLEngine::PL::InitEngine() hierher verschoben
- Thread um SetPriorityClass() und SetPriority() erweitert, PLEngine::PL::InitEngine() nutzt diese Funktionen um das Programm
  mit einer gew端nschten Priorit辰t laufen zu lassen. (bis jetzt wurde dort mit einem ifdef gearbeitet)
  Stephan, bitte schau mal nach ob das mit der Thread Priorit辰t unter Linux 辰hnlich abl辰uft, wenn nicht, so m端ssten wir uns
  zusammen 端berlegen wie wir das in PL handhaben wollen.



>> 28.10.2006
[CO]
- Loadable: Neue Funktion: GetAbsFilename() gibt den absoluten Dateinamen der Datei zur端ck aus dem dieses 'Ladbare Teil'
  geladen wurde. So einen absoluten Dateinamen braucht man 旦fters mal, z.B. in PLMesh::Texture::Load() um nach einer
  entsprechenden 'plt'-Datei zu suchen oder wenn eine Resource 'neu geladen' werden soll. Noch find ich die aktuelle
  L旦sung noch nicht sooo prall, mal schaun ob wir das noch irgendwie besser & universeller hinbekommen k旦nnen - aber f端r
  den Augeblick m端sste das reichen.
- FS: Directory::OpenCanonical(): Das Laden aus einer Zip-Datei anhand eines absoluten Namens klappte nicht (mehr) korrekt



>> 27.10.2006
[CO]
Alle Projekte:
- Nahm an ein paar Stellen <Extension>.ToLower() und CompareNoCase() heraus da wir generell zwischen gro/kleinschreibung
  unterscheiden wollen. In den Beispielen musste ich dadurch ein paar 3ds-Meshs per Hex-Editor korrigieren da Max irgendwie
  absolut keinen Wert auf gro/kleinschreibung legt und bei 3ds wie es momentan aussieht IMMER zwanghaft groschreibt.
  (da m端sste ich noch etwas Experimentieren ob dem wirklich so ist)
PLGeneral:
- 'Loader'-System eingebaut, dieses System lag bereits seit ein paar Monaten im Lab/PLResource-Ordner. Nahm 'File' aus
  den Klassen Namen heraus damit es etwas deutlicher wird das dies nicht 'direkt' etwas mit dem FS zu tun hat.
  Alles was irgendwie Lad- & Speicherbar ist sollte von nun an von 'Loadable' abgeleitet werden. Die konkreten Lade & Speicher
  Funktionen liegen in von 'Loader' abgeleiteten Klassen. Diese 'Loader' m端ssen sich wirklich NUR um das Laden & Speichern
  k端mmern, und nicht um das 旦ffnen/schlieen der Datei - das vereinfacht an vielen Stellen einiges. Abfragen welche Typen & Formate
  unterst端tzt werden kann man universell & bequem 端ber den 'LoadableManager'. Das muss nun also nicht mehr x mal neu
  geschrieben werden, sondern 'Loader' werden zentral automatisch Registriert und verwaltet. Das System ist noch nicht final
  und wird an ein paar Stellen noch etwas vereinfacht werden. Aber es ist denk ich schonmal etwas besser als vorher... leider
  brachte dies keine groartige Ladezeit Verbesserung, trotzdem ist nun beim Laden einiges an Overhead weg. :)
- XmlDocument: Lade-Funktion hinzugef端gt der man dirkt eine Datei 端bergeben kann



>> 18.10.2006
[CO]
Alle Projekte:
- F端gte "#pragma once" in alle Header ein damit das bersetzen "minimal" schneller geht. Da dies sowohl unter VC als auch
  gcc bekannt ist, m端sste es damit keine 'Kompatibilit辰tsprobleme' geben.
- Mithilfe von "__pragma" kann man Pragmas auch in Makros nutzen. nderte daher die PL_WARNING_PUSH & PL_WARNING_POP &
  PL_WARNING_DISABLE Makros entsprechend.



>> 17.10.2006
[CO]
Alle Projekte:
- Wie besprochen "PL_WARNING_POP", "PL_WARNING_PUSH", "PL_WARNING_DISABLE" Precompiler Makros eingebaut. Jedoch konnte man
  es leider nicht so realisieren das man direkt "PL_WARNING_DISABLE(4100)" schreiben kann... stattdessen muss man
  "#pragma PL_WARNING_DISABLE(4100)" schreiben. Nun m端ssten unter Linux die pragma-Warnungen weg sein. Wie genau man das l旦st
  wenn man bestimmte Warnungen unter Linux deakivieren will m端ssten wir sehen wenn das ein Thema wird.



>> 16.10.2006
[SB]
Alle Projekte:
- Habe mal versucht die Export-Makros etwas zu entwirren. In PLGeneral ist jetzt jedes dieser Makros auch noch etwas genauer
  beschrieben, damit hoffentlich keiner mehr verwirrt ist welches Makro wozu gut ist.



>> 14.10.2006
[SW]
Alle Projekte:
- Finale version f端r das visibility attribute feature vom gcc.



>> 14.10.2006
[CO]
- Error System, zweiter Ansatz: (Namen & Implementation noch nicht final :)
  Hat eine Funktion einen 'boolschen' R端ckgabewert, so wird statt bool/PLBool 'PLReturn' genutzt welches ein Smart Pointer
  auf ein 'Result'-Objekt ist. (Experimentelle Implementation) Trat kein Fehler auf, so zeigt dieser auf 'Result::NoError',
  bei Fehler auf ein erzeugtes Result-Objekt. Dieses Result-Objekt kann man wie gehabt genauso wie einen einfachen boolschen
  R端ckgabewert verwenden falls man sich 'nur' daf端r Interessiert ob es einen Fehler gab. Interessiert einen selbst das nicht,
  wird dank dem Smart Pointer dieses Result-Objekt automatisch wieder 'freigegeben'. Gibt eine Funktion z.B. einen String
  zur端ck, so sollte es IMMER einen Optionalen PLResult-Zeiger geben der auf Wunsch das Ergebniss bekommt. Zwar bietet der
  Error-Manager die M旦glichkeit sich den 'letzen' Fehler zur端ckgeben zu lassen, dies ist jedoch NICHT Multithreading-Safe...
  aber falls das einen nicht juckt, kann man diesen Optionalen Parameter auch ignorieren und z.B. Error::GetLast() nutzen was
  etwas 'bequemer' zu verwenden ist - das ist dem User 端berlassen ob er dieses 'Risiko' eingehen will. Wir selbst sollten in
  der Engine aber NIE Error::GetLast() nutzen. :)
  Das System unterst端tzt auch 'Rekursion' so das man sich den vorherigen Fehler zur端ckgeben lassen kann um zu sehen wo der erste
  Fehler passierte. Anhand von Checksum::GetFile() kann man sehen wie das mit der Fehler-Rekursion derzeit abl辰uft. Anhand von
  PLBaseTest::ChecksumTest() kann man sehen das dies bereits sehr gut klappt - wenn wir das so machen wollen, muss sich nat端rlich
  dann jede Funktion daran halten damit das durchgehend klappt und man Fehler bis an den Ursprung zur端ckverfolgen kann.
  Die 端bergebenen Funktions-Parameter sollten wenn m旦glich IMMER mit einem PL_ASSERT() auf g端ltigkeit gepr端ft werden und in der
  Funktions Dokumentation sollte genau beschrieben sein ob ein Parameter g端ltig sein MUSS oder nicht. Hier wird aber wirklich
  nur gepr端ft und gewarnt wenn etwas nicht stimmt, danach gehts fr旦hlich weiter bis zum Crash.



>> 13.10.2006
[CO]
- PLMain Dokumentiert damit wirklich klar ist was die Parameter und vorallem der R端ckgabewert zu bedeuten haben
- UTF8Tools: Die 3 neuen Funktionen von Stephan vom Style & der Namensgebung her angepasst. Kommentar "One or both strings
  can be pure ASCII Strings" entfernt da dies eine allgemein g端ltige UTF8 Eigenschaft ist. 'FindSubString' k旦nnten
  wir eventuell auch 'IsSubString' oder 'GetSubString' nennen... von der Funktionali辰t her hab ich nix ver辰ndert - konnte
  mit den erweiterten Unit-Tests auch keine Bugs oder so finden. :)



>> 11.10.2006
[SW]
Alle Projekte:
- Die projekte verwenden das neue visibility feature vom gcc, wenn vorhanden.
PLGeneral:
- Neues Makro PLTEMPLATE_EXPORT hinzugef端gt, mit denen unter Linux die Templates komplett exportiert werden k旦nnen.
  Momentan betrifft das nur Array und Singleton



>> 06.10.2006
[CO]
Alle Projekte:
- Nachdem mich Stephan auf eine 'POD-Warnung' in "PLGui/Dialogs/ResourceManagerDialog.inl:288" aufmerksam machte,
  ging ich nochmals alle String::Format-Stellen durch und pr端fte auf PLT()-Makro verwendung - denn dieses gibt mittlerweile
  einen PL String zur端ck. :)



>> 01.10.2006
[CO]
- Bugfix: XmlDocument::GetRootElement() -> Hier ging der Aufruf nicht 端ber GetPLNode() und daher wurde keine korrekte eingebettete
  PL XML Node erzeugt. (gut das Stephan diese Funktion mal ausprobiert hatte *g*)



>> 28.09.2006
[SW]
Alle Projekte: PLBase:
- Die linux-projecte dateine an die nderungen angepasst.



>> 27.09.2006
[CO]
- Auf PLBool umgestellt und wie 端blich alle Projekte entsprechend angepasst. Stellte auch dort auf PLBool um wo das true/false
  bereits passte damit das 'Einheitlich' ist und das einbauen eines netten Fehler Systems leicher geht. (man muss fast nur noch
  nach PLBool suchen *g*)
  Beim Linux Teil *k旦nnte* es noch Stellen geben wo man noch den Fehler Code anpassen muss.



>> 26.09.2006
[SW]
- In RTTIDefs.h an zwei stellen (void)0 anstelle von 0 geschrieben um eine gcc-4.x warnung zu beheben
- ClassManager::LoadPlugin da der DynLibManager momentan in der Hasmap von bereits geladenen Libs nur den Dateinamen speichert,
  wird nun der GetLibrary nur der Dateinamen 端bergeben und nicht der komplette pfad.
  Wenn jemand was dagegen hat soll es entweder wieder zur端ck辰ndern oder mir bescheid geben. (diese 辰nderung wieder auf wunsch von stefan revidiert)
- ein paar dumme printfs rausgeschmissen, die eigentlich nicht hochgeladen werden sollten



>> 26.09.2006
[CO]
- Machte ein paar kleinere erste Style anpassungen



>> 21.09.2006
[CO]
- Einfache Error-System Klasse hinzugef端gt + diverse Makros die einem das Leben mit Fehlern etwas einfacher machen
- Checksum & Config Klasse auf bessere Fehlerbehandlung umgestellt um zu sehen ob wir das so machen k旦nnen/wollen



>> 21.09.2006
[SB]
- Neue Klasse Url hinzugef端gt. Diese Klasse verwaltet einen Pfad oder Dateinamen, kann zwischen den Unix/Windows Formaten sowie
  der URL Darstellung konvertieren und beinhaltet die 端blichen Funktionen um einen Pfad in Verzeichnis, Dateiname, Extension aufzuspalten etc.
  Im Gegensatz zu den Funktionen aus FSTools ist die Klasse darauf ausgelegt, m旦glichst flexibel zu sein, und mit so vielen Eingaben
  wie m旦glich noch irgend etwas anfangen zu k旦nnen. Kommt also z.B. ein Dateiname bunt gemischt mit \ und / herein st旦rt das die
  Url Klasse nicht, der Pfad wird erstmal so gespeichert ohne gleich zwangsl辰ufig konvertiert zu werden. Sobald man dann einen f端r das
  System g端ltigen Pfad braucht l辰t man sich die Url umwandeln, damit sie korrekt wird.
  Im FS wird ab sofort nur noch diese Klasse verwendet und damit die alten FSTools Funktionen ersetzen. Auerhalb kann die Klasse nat端rlich
  auch verwendet werden, um z.B. an einen Pfad/Dateiname/Extension o.辰. heranzukommen, zum Speichern eines Dateinamens sollte sie allerdings
  nur sehr selten verwendet werden, da sie einiges an Speicherplatz braucht. Normalerweise sollte ein Pfad also weiterhin einfach als String
  gespeichert werden.
- FSRefCount entfernt. Die Basisklasse f端r alle FS Objekte (auch SearchHandle) ist nun FileObject, welches direkt von RefCount abgeleitet ist.
- FileObject: EType hinzugef端gt, welches angibt um was f端r ein Objekt es sich handelt. Dies wird nun nur noch in der FileObject Klasse behandelt,
  die virtuellen Funktionen zu diesem Zweck wurden daher entfernt.
- FileObject: Hat nun keinen Pointer mehr auf FileSystem, da es davon nur eine Singleton-Instanz gibt, auf die jetzt direkt zugegriffen wird.



>> 20.09.2006
[SB]
- Neue Hilfsklasse PLBool hinzugef端gt. Die macht nicht viel, auer einen bool zu speichern, und kann benutzt werden, um die
  true/false-Umstellung zu machen. Die Klasse ist so aufgebaut, da sie *nicht* automatisch von/nach bool konvertiert,
  sondern bei jedem solchen Versuch einen Compilerfehler generiert. Das kann also so benutzt werden:
  - In der Funktion, die umgestellt werden soll, den R端ckgabetyp von bool in PL_BOOL um辰ndern
  - return true -> return PL_FALSE
  - return false -> return PL_TRUE
  - Alle Projekte compilieren, dadurch gibt es 端berall dort eine Fehlermeldung, wo die Funktion benutzt wird, z.B. bei
    if (TheFunction()), oder if (!TheFunction()) etc. Dort kann nun die Umstellung erfolgen:
  - if (theFunction()) -> if (PL_NOT theFunction())
  - if (!theFunction()) -> if (PL_IS theFunction())
  - Wenn sich wieder alles 端bersetzen l辰t, kann man den Typus wieder auf bool setzen und per Suchen/Ersetzen alles zur端ck umwandeln
  - 'PL_FALSE' -> 'false'
  - 'PL_TRUE' -> 'true'
  - 'PL_NOT ' -> '!'
  - 'PL_IS ' -> ''
Auf diese Weise sollte die Umstellung wesentlich erleichtert werden, und dank der Compilerfehler m端te man auch *alle* Stellen finden,
an denen die jeweilige Funktion verwendet wird, man kann also nichts mehr 端bersehen. Nat端rlich m端ssen immer alle Projekte compiliert werden,
denn nach dem Umwandeln sieht f端r die Compiler wieder alles richtig aus, auch wenn man ein Projekt noch nicht angepat hat. Hoffe das macht
diese Umstellung etwas ertr辰glicher ;-)



>> 19.09.2006
[CO]
- UTF8Tools: Neue Funktionen FromWideCharacterString() & FromWideCharacterString() + 辰nderte ein paar Namen so das klar ist
  das es sich z.B. um einen 'wide character' handelt. nderte den Datentyp von 'wide character' von uint32 zu wchar_t - das
  ist zwar irgendwie total doof da wchar_t keine fest vorgegebene gr旦e hat, allerdings k旦nnen wir mit uint32 'wide character
  Dingen nix anfangen da die Windoof Unicode Funktionen nunmal leider wchar_t und kein UTF8 oder uint32 nutzen. :(
  Hatte mir zuerst 端berlegt wchar_t UND uint32 Versionen der Funktionen anzubieten - aber das w辰re dann doch etwas zuviel
  des guten geworden. Hat man mit wchar_t Problemen da es z.B. unter Windows zu klein ist, muss man ganz einfach NUR UTF8
  in seinem Projekt nutzen - es hindert einen ja bei unserer String Klasse bald (sobald fertig Implementiert) nix dran! *g*
- String Klasse: GetUTF8() m端sste mittlerweile Problemlos funktionieren -> Stephan, wenn du willst kannst du mal den Linux
  Port entsprechend anpassen bzw. mit GetUTF8() durchtesten ob das wirklich bereits brauchbar klappt. Der Rest muss noch
  ausgearbeitet werden.



>> 18.09.2006
[CO]
- Neue Tool-Klasse: UTF8Tools: Diverse UTF8 Funktionen die man immer mal wieder ben旦tigt. Hatte diese zuerst direkt als statische
  Hilfs-Funktionen in StringBufferUTF8 drinnen bis ich merkte das es immer mehr Funktionen wurden die man ebenfalls noch br辰uchte...
  Daher entschloss ich mich diese Funktionen in einer seperaten Hilfs-Klasse abzulegen damit das nicht zuviel auf einmal wird.
- Fing damit an die String Klasse um UTF8-Support zu erweitern (noch nicht lauff辰hig!)



>> 13.09.2006
[CO]
Alle Projekte:
- Schrieb bei jedem "#pragma warning(disable : <Number>)" dazu was genau dieses deaktiviert (... zumindestens bei VC...)



>> 12.09.2006
[SW]
- in Main.h das setlocale(LC_ALL, "") hinzugef端gt(unter Linux), da dadurch die systemlocale f端r den Prozess gesetzt werden, ist n旦tig,
  da sonst im PLSampleGui die jpanischen schriftzeichen nicht angezeigt wurden.
- Durch die nderung in der Main.h tauchten problem auf, wenn man floats in String und zur端ck umwandelt, da im Deutschen das Trennzeichen ein ',' ist und im Englischen ein '.'.
  Um das problem zu l旦sen wurde in den Format-Funktionen des String-Klasse die locale auf "englisch" ("C") gesetzt und am ende der Funktion wieder auf die systemlocale zur端ckgesetzt.
  Das Problem und die L旦sung(momentan nur f端r LINUX als test) habe ich zusammen mit Christian ausgearbeitet.



>> 11.09.2006
[CO]
- Beseitige Warnungen die erscheinen wenn der Compiler auf Warnungs-Level 4 gestellt wird:
 - Per Absicht nicht verwendete Variablen (da z.B. Virtuelle Funktionen) sollten mit PL_UNUSED() gekennzeichnet werden
   damit hier nicht angewarnt wird.
 - Beim Einbinden externer Header (z.B. tinyxml.h) deaktiviere ich diverse Warnungen da wir hier nix 辰ndern sollten.
 - Musste das PL_LOG-Makro minimal umschreiben damit nicht immer angewarnt wird das ein Ausdruck dort Konstant ist.
 - Deaktivierte die Warnung "warning C4201: Nicht dem Standard entsprechende Erweiterung: Struktur/Union ohne Namen" da
   ich nicht rausbekommen konnte wie man das besser machen k旦nnte ohne das diese Warnung erscheint. :(
   (einfach keine Unions nutzen ist KEINE Option! ;-)
-> In den Projekten in denen ich die Warnungen beseitige hab ich im Debug-Modus erstmal Warn-Leven 4 aktiv gelassen. Solange
   es nicht st旦rt k旦nnen wir das so lassen und bekommen ein paar weitere n端tzliche Tips vom Compiler wo m旦glicherweise
   etwas noch nicht ganz ok aussieht. Viele der 'zus辰tzlichen' Warnungen sind durchaus hilfreich... um nur ein Beispiel f端r
   einen dadurch gefundenen Bug zu nennen:
      PLPhysicsNewton::WorldNewton::GenericContactBegin:: -> if (nCollisionGroup1 && Ignore)
    -> !! bler Bug der nun zum Gl端ck angewarnt wurde! ;-)
   Desweiteren werden auch Variablen angewarnt die zwar Initialisiert, aber nie verwendet wurden, ebenfalls recht n端tzlich,
   und wie schon oben erw辰hnt sollte man PL_UNUSED() verwenden wenn das schon korrekt so ist.
-> Ich werde sicherlich noch ein paar Tage brauchen bis ich durch alle Projekte sauber durch bin. :)



>> 10.09.2006
[CO]
- Config: - GetVarBool() entfernt da man daf端r mittlerweile auch locker GetVar().GetBool() schreiben kann.
          - GetVarFloat() entfernt da man daf端r mittlerweile auch locker GetVar().GetFloat() schreiben kann.
- FSTools::ValidatePath(): Bei einem der Zahlreichen String-Anpassungen der letzten Zeit kam hier ein kleiner Bug rein so
  das es zu Problemen mit '/' oder '\' kommen konnte. Stefan, w辰re nett wenn du irgendwann sp辰ter 端ber diese Funktion
  nochmal dr端ber schaun k旦nntest - nicht das ich das Schrittweise kaputt oder zu umst辰ndlich gemacht habe. :)
- Variant um GetString()-Funktion erweitert damit man sich ausdr端cklich die String-Version des Wertes zur端ckgeben lassen
  kann ohne vorher auf String casten zu m端ssen



>> 08.09.2006
[CO]
- Abstraktes Checksum-Interface + MD5 Implementation hinzugef端gt



>> 04.09.2006
[CO]
Alle Projekte:
- Fand einige Stellen an denen es z.B. netter ist vVector.x anstatt vVector[0] zu schreiben
PLGeneral:
- Types.h: FALSE, TRUE, und NULL flogen heraus bzw. verschob diese Definitionen in den Linux Teil da diese dort soweit ich
  weis ben旦tigt werden. (bei Windows werden diese Dinge in den Win32-Headern definiert)



>> 04.09.2006
[SW]
- Linux implementation des Unicode(wchar_t) supports, habe den aufruf der durch "int vswprintf( wchar_t *buffer,const wchar_t *format, va_list argptr )"
  durch die funtion "int vswprintf(wchar_t *buffer, size_t count, const wchar_t *format,va_list argptr)" ersetzt, da unter linux nur die mit dem count parameter gibt.



>> 01.09.2006
[CO]
Alle Projekte:
- Wie Stefan es w端nschte verwenden wir nun 端berall 'd' als Prefix f端r 'double' anstatt ein universelles 'f' f端r 'floating point'.
PLGeneral:
- Lokalisierungs-System eingebaut. Das System an sich ist recht einfach aufgebaut und auch leicht zu bedienen. Texte sind
  in Gruppen aufgeteilt und jedes Projekt kann seine Texte in einer eigenen Gruppe anlegen damit es z.B. keinen Konflikt mit
  PL-Texten gibt. Wie 端blich ist das 'Localization' Format in XML gehalten.
  Da wir bereits 端berall wo Sprachabh辰ngige Texte verwendet werden das 'PLT'-Makro verwenden, waren die Code Umstellungen minimal.
  Nur den Header '#include <PLGeneral/Tools/Localization.h>' muss man nun einf端gen wo man Sprachabh辰nige Texte hat. Neben
  dem 'PLT'-Makro welches 'PixelLight' als Text-Gruppe nutzt gibt es noch ein 'PL_TEXT'-Makro bei dem als zweiter Parameter
  die Gruppe angegeben werden muss. Ob wir das 'PLT'-Makro drinnen lassen m端ssen wir noch sehen, auf jedenfall ist es im Augenblick
  noch nett da man die Codes dadurch nicht 辰ndern musste oder sich um die Gruppe innerhalb der PL-Codes k端mmern muss.
  Als 'native'-Sprache verwenden wir innerhalb von PL Englisch. F端r diese 'native'-Sprache ist keine Lokalisierungs-Datei
  n旦tig da der Englische Text gleich als Schl端ssel f端r die bersetung verwendet wird. Wird keine bersetzung gefunden weil
  gerade z.B. Englisch als Sprache aktiv ist, so wird einfach dieser Text-Schl端ssel als Ergebniss verwendet. :)
  Was im Augenblick noch fehlt ist ein Tool welches Codes als Eingabe bekommt, nach unseren Lokalisierungs-Makros sucht
  und die Gefundenen Dinge in einer bzw. mehreren Lokalisierungs-Dateien auflistet so das man die Codes nicht per Hand nach
  zu 端bersetzenden Texten durchw端hlen muss.
  Auch w辰re es wohl sinnig wenn die Beispiele & Tools ihre Texte in eigenen Gruppen verwalten w端rden, das muss man aber
  noch ausjungeln wie was am besten ist. Hier ein Beispiel wie so eine Lokalisierungs-Datei aussieht:
    <?xml version="1.0" ?>
    <Localization From="English" To="Deutsch">
        <Text Name="Hello">Hallo</Text>
        <Text Name="This is a test">Dies ist ein Test</Text>
    </Localization>



>> 30.08.2006
[CO]
- Jede String Buffer Implementation speichert nun noch den String in einem jeweils anderen Format. Hab ich z.B. einen ASCII
  String, fordere aber einen Unicode-String an, so wird intern eine Unicode-String Variante erzeugt. Fordere ich nochmals
  Unicode an, so wird direkt dieser gepufferte Unicode-String zur端ckgegeben. Sobald der Orginal String ver辰ndert wird, wird
  dieser gepufferte String 'schmutzig' und muss sobald er wieder angefordert wird neu erzeugt werden. Arbeitete die internen
  String Konvertierungen aus, also wenn ich z.B. 'sMyString = sACII + sUnicode' schreibe.



>> 29.08.2006
[CO]
- String Klasse um wchar_t-Unicodes erweitert. In unseren Projekten sollte nun immer bei den Compiler-Einstellungen 'Unicode'
  anstatt 'Multi-Byte' verwendet werden was normalerweise die Standard-Einstellung ist. Da wchar_t von der gr旦e her nicht
  fest Definiert ist, sollte man NIE davon ausgehen das ein Buchstabe 2 Byte oder so gro ist sondern IMMER sizeof(wchar_t)
  verwenden. Zudem sollte man aus diesem Grund wchar_t Strings auch nicht in Dateien speichern oder aus solchen Laden. Das
  sollte man dann 端ber das 'sicherere' UTF-8 Format machen sobald dies Implementiert ist. Durch die 辰nderung der Compiler
  Einstellung wurden einige fehlerhafte String-Stellen gefunden wo z.B. !sMyString abgefragt wurde, 'true' zur端ckgegen wurde
  obwohl der R端ckgabewert ein String war etc. - also Stellen die man bei den krassen String Umstellungen von damals 端bersehen
  hatte. :)
  An ein paar Stellen wie z.B. im Win32 PLGui Backend wird bereits das Format des PL Strings gepr端ft und dann entsprechend
  die Unicode oder ASCII OS Funktions Variante verwendet... wie man anhand von PLSampleGui sehen kann geht nun auch Japanisch
  ganz wunderbar. *g*



>> 28.08.2006
[CO]
- Vorherige String Klasse durch die 端berarbeite String-Klasse ersetzt. Das Interface ist noch kompatibel mit dem alten und
  wurde nur minimal erweitert. Die ASCII Implementation ist komplett Implementiert, wurde an einigen Stellen neu geschrieben
  und mit den erweiterten String-Tests gepr端ft so das halbwechs sichergestellt ist das nicht wieder von neuem 端ble Bugs
  reingekommen sind. ;-) (zudem l辰uft alles auch im Release Modus noch stabil was auch schonmal ein gutes Zeichen ist *g*)
  Das sehr gut funktionierende String-Buffer Konzept wurde nat端rlich beibehalten, jedoch haben String Buffer nun auch noch
  den Job die konkreten String Operationen auszuf端hren - abh辰ngig von deren internen String-Format. Die String Klasse selbst
  ist also sogesehen 'nur' noch ein String-Buffer-Container der bestimmte allgemeine Bedingungen pr端ft so das diese nicht
  in jeder String Buffer Implementation erneut gemacht werden m端ssen.
  Es kamen noch ein paar zus辰tzliche Hilfs-Funktionen hinzu damit man Strings auch mit Zahlen recht einfach zusammenbasteln
  kann. Beispiel: sString = 5 + sString + '_' + true + "HeHo" + 55.9; -> 5MyString_1HeHo55.9
  Damit kann man nun relativ einfach an vielen stellen String::Format() ersetzten was vorallem dann sehr sinnig ist wenn
  dort auch noch Strings miteingewoben werden sollen... man also GetString() nutzen muss. GetString() sollte man jedoch
  wo immer m旦glich in den PL innereien vermeiden da man sich f端r auf ein String Format (sollte IMMER Unicode sein) festlegen
  muss. Zudem vergisst man bei String::Format auch mal schnell GetString() und dann bekommt man Schrott zur端ck - der VC Compiler
  meckert das ja leider nicht an. Am besten & flexibelsten & sichersten ist das String-System, wenn ALLE String Operationen
  KOMPLETT 端ber die String Klasse gemacht werden und GetString() NUR genutzt wird um z.B. dem OS den String zu 端bergeben.
  (sprich, um mit der Welt auerhalb von PL zu Kommunizieren *g*) H辰lt man sich an diese Spielregel, so braucht man sich nicht
  darum zu k端mmern ob man gerade mit ASCII, Unicode, UTF-8 oder weis der Teufel was arbeitet - man verwendet einfach 'PL-Strings'
  und gut iss. ;-)
  Was noch fehlt sind Unicode-String Buffer die ich als n辰chstes angehen werde.



>> 26.08.2006
[CO]
- System: GetProgramName() -> Gibt den Namen des laufenden Programms zur端ck. (z.B. 'c:\MyApplication\Test.exe')



>> 25.08.2006
[CO]
Alle Projekte:
- Nach dem 旦ffnen eines FS Verzeichnisses wurde meistens nicht gepr端ft ob das gut ging - verbesserte dies um Crashs zu vermeiden
  falls das 旦ffnen eines Verzeichnisses mal nicht klappen sollte.



>> 24.08.2006
[CO]
Alle Projekte:
- Fand noch ein paar Stellen an denen anstatt stricmp/strcmp die String Funktionen verwendet werden k旦nnen.
- Es gab noch ein paar Interface-Stellen wo 'const char*' anstatt 'String' verwendet wurde. Bei z.B. TestCase::GetName()
  ist dies aber durchaus Absicht da die Tests selbst nicht bereits von unserer String Klasse abh辰ngig sein sollen.
- Entfernte extra 'const char*'-Funktionen in diversen Interfaces wie z.B. PLGeneral::Tokenizer so das 'nur' noch die eigene
  String Klasse verwendet wird. Da die String Klasse mittlerweile auch 'nur' einen Pointer auf einen 'char*' String halten
  kann 'ohne' dabei den gesammten String zu kopieren, ist dies ebenfalls kein 'Performance'-Problem. :)
- An ein paar Stellen wo String::CompareNoCase verwendet wurde wird nun == verwendet welches zwischen gro/kleinschreibung unterscheidet.
- Ersetzte wo m旦glich String::Format durch String Addition. Zum einen ist das etwas kompakter & besser Lesbar, aber viel wichtiger:
  Das wird so mit z.B. Unicode Strings weniger Probleme bereiten da es nicht mehr 端ber GetString() abl辰uft.
- Entfernte einige <MyString.>GetString() wo das nicht wirklich n旦tig ist.
PLGeneral:
- String: Nahm die Print()-Funktion heraus da diese in der 端berarbeiteten String Klasse auch nicht mehr vorhanden ist. Ab
  jetzt muss man das immer 端ber String::Format() machen, so gibt's nur noch eine einzige Funktion daf端r (kein doppelter Code)
  und die 'Performance' wird darunter wohl auch nicht wirklich leiden. ;-)
- String::String(const char *pszString, bool bCopy = true, uint32 nLength = 0) -> Am Ende kann man nun noch optional
  die L辰nge 端bergeben. Dies ist u.a. in PLMesh::EffectLoaderFX recht praktisch da man hier einen sehr langen String hat
  wo man aber bereits genau weis wie lange dieser ist.
- Tokenizer::Start(const char *pszBuffer, long nSize) entfernt und die Codes in den anderen Projekten entsprechend angepasst.
- BufferedStringReader::BufferedStringReader(const char *pszBuffer, uint32 nSize) entfernt.



>> 23.08.2006
[CO]
- Da ich momentan an einer neuen String Implementation mit Unicode Support Arbeite muss ich zwangsl辰ufig die String Dinge
  nochmal gaaaaaanz genau durchgehen. Dabei vielen mir gleich ein paar Dumme Dinge in der aktuellen Version auf - UND, wie es
  aussieht fand ich sogar unseren b旦sen Release Crash Bug!!! String::Replace(char nOld, char nNew) -> 'Set pointers to new
  location' war NICHT in Ordnung, denn da bereits nIndex drauf addiert wurde durfte man nicht einfach nochmal zus辰tzlich
  die String L辰nge draufz辰hlen um das Ende des Strings zu bekommen... denn nun schoss man 端ber den Speicher heraus und es
  wurde irgendwo herumgeschrieben wo das nicht sein durfte - KEIN Wunder das dies Probleme machte! *g*



>> 22.08.2006
[CO]
Alle Projekte:
- Die Projekte verwenden nun die .lib's in PLSDK/Actual/libs anstatt die aus den build/win32 Verzeichnissen.
PLGeneral:
- Stellte TinyXML von 2.4.3 auf 2.5.0 (Beta) um. Da etwas an der Lib ver辰ndert wurde muss diese auf jedenfall noch
  gepackt vorliegen damit man selbst neu 端bersetzen kann. (tinyxml_2_5_0_changed.zip)



>> 21.08.2006
[CO]
- XmlDocument: GetErrorDesc() so erweitert das standardm辰ig auch in den String geschrieben wird 'wo genau' der Fehler
  auftrat - das will man in den meisten F辰llen nat端rlich auch direkt wissen. :)
  Mir viel dabei auf das die Xml-Datei Namen noch nicht den eigentlichen Klassen Namen entsprachen, 辰nderte dies.



>> 17.08.2006
[SB]
- Bei Log::Open() den Paramter f端r den LogFormater mit dem Standardwert "" versehen, falls man keine Parameter mit angeben m旦chte
- Log::GetLogFormater() gibt nun kein const-Objekt mehr zur端ck, da man ansonsten auf die Optionen, die dieses Objekt zur Verf端gung stellt,
  gar nicht zugreifen kann. Das Objekt mu also auch ver辰nderlich sein, damit man sich den LogFormater zur端ckgeben und dann bequem
  dessen Optionen 辰ndern kann
- Einige Kommentare 端berarbeitet



>> 16.08.2006
[SW]
- Log: XmlLogFormater hinzugef端gt.



>> 14.08.2006
[CO]
- String: berarbeitete die Replace()-Funktion nochmal sorgf辰ltig, z.B. war bereits der 'Count' am Anfang nicht ok. Die nochmals
  etwas erweiterten String Tests konnten nun keine Fehler mehr feststellen. (was allerdings leider nicht bedeutet das nix mehr
  drin w辰re ;-)



>> 13.08.2006
[SW]
- HTML LogFormater hinzugef端gt: Und im zuge dieses LogFormaters die OpenFunktion des Logs um den Parameter sParameters erweitert.
  mit diesem Parameter ist es nun m旦glich die LogFormater bezogenen Parameter zu 辰ndern, welche ans RTTI angebunden sind.
  beim HTML LogFormater sind das die Parameter Title(zum setzten des HTML-Titels), Header(dieser Text direkt nach dem <body>-tag geschrieben)
  Background(zum setzen einer Background farbe bzw. bild) und DefaultTextColor(zum setzten der default Farbe f端r den Text).
- Log::GetLogFormater hinzugef端gt. Hiermit ist es m旦glich sich den aktuellen LogFormater zu hohlen um dann optionen des LogFormater zu 辰ndern.
  (z.b. beim HTML LogFormater kann man dar端ber die Formatierung der Meldungen f端r jeden Loglevel seperat angeben).
- Log: die maximale anzahl der Loglevel von 2^32 auf 255 reduziert, da chris und ich glaube das kaum jemand mehr als 255 Loglevel brauchen wird.
- String::Replace: Hier wurden die restliche Zeichen des alten Textes nicht in den neuen String 端bertragen, nachdem der eigentliche Replace beendet war.



>> 12.08.2006
[CO]
Log nderungen:
- Bei LogLevel wieder meine nderungen eingespielt, also wie besprochen das nur mit 'Debug'. Bei der Ausgabe steht dann auch
  nur 'Debug' - wie Stephan auch merkte wird das hier zuviel Text, das einzige was ich noch mehr hier habe ist das bei Debug
  wirklich 'nur' Debug und nicht Debug0 steht. Erst bei 'User Debug' Levels steht dann Debug1 etc. dabei.
- Verschob das Makro wieder nach oben wie Stephan es vorschlug, unterschied macht das keinen. Ich selbst geh die Codes nur
  immer von oben nach unten durch, und wenn dann oben etwas verwendet wird das aber 'rein Code liniear' gesehen erst 'unten'
  definiert wird sieht das f端r mich immer etwas merkw端rdig aus... aber bei Makros iss das ja Funktionsm辰ig kein Unterschied...
  und wenn es euch oben besser gef辰llt schreiben wir das mit den Makros *immer* oben.
- Wie Stefan vorschlug bei PL_LOG wird vor Level PLGeneral::Log:: eingef端gt -> passte alle Codes an, viel schlanker so das nun ist :)
- Nahm wie von Stephan vorgeschlagen die Update-Funktionen heraus, f端gte nun *aber* wie von mir geschrieben eine Flush Funktion
  hinzu damit ich von PLEngine::SNConsole aus einen Flush ERZWINGEN kann unabh辰ngig vom Flush Log Level das die Konsole nat端rlich
  *nicht* 辰ndern soll... zus辰tzlich *MUSS* dort auch noch gepr端ft werden ob sich die Datei seit dem letzten Check ge辰ndert hat,
  sei es durch ein fr端heres Log Flush oder durch eine Datei 辰nderung des Users. (warum auch immer er eine machte)
  Derzeit ist das OS abh辰ngig Implementierte, aber das 端berarbeite FS wird dann ja solche Infos ebenfalls bereitstellen so das dies
  dann universell machbar ist.
- ... bei dieser neuen Flush Funktion merkte ich das Log::Write() noch nicht ganz ok war. Denn sobald m_qLastMessages einmal voll war,
  wurde nach jedem Output flush ausgef端hrt. Darum f端gte ich m_nFlushMessages hinzu. Bei jedem Eintrag wird das um eines erh旦ht, und
  erst wenn m_nBufferedMessages erreicht ist wird dieser Counter zur端ckgesetzt und ein Flush ausgef端hrt.
- F端gte nach 'Quiet' noch ein Log Level namens 'Always' ein. In SNConsoleBase::ProcessCommand() *muss* der gerade eingebene
  Befehl *immer* unabh辰ngig vom aktuell Eingestellten Log Level ausgegeben wird, auer nat端rlich Log Ausgaben sind wieso auch
  immer mal komplett deaktiviert. Darum ist 'Info' hier nicht nutzbar. Wenn jemand da eine andere Idee hat wie man das l旦sen k旦nnte gebt
  bescheit... so wie das jetzt im Augenblick alles ist l辰uft auch die PL Konsole wieder so sauber wie vor der Log Umstellung.



>> 08.08.2006
[SB]
- Kleinen Fehler im Log-Makro behoben: __LINE__ ist eine Zahl, daher mu es im printf-Style mit %d
  in den String eingef端gt werden, das %s f端hrte nat端rlich zu einem Crash



>> 07.08.2006
[CO]
Alle Projekte:
- Stellte auf das neue Log System um



>> 06.08.2006
[CO]
- Timer um Funktion GetTimer() erweitert. Hierbei handelt es sich um einen allgemeinen Timer auf den einfach der aktuelle
  Zeitunterschied bei jedem Update addiert wird.



>> 31.07.2006
[CO]
- Array<AType>::Add(const AType Elements[], uint32 nCount): Hier habe ich Vorsichtshalber das memcpy durch Element weise
  Kopieren ersetzt, denn soetwas wie memcpy kann ja leider sehr schnell nach hinten Losgehen vorallem wenn man etwas komplexere
  Klassen direkt nutzt. Es ist zwar noch memset drinnen um auf *ausdr端cklichen* User Wunsch neue Elemente zu Initialisieren,
  da w端sste ich allerdings nicht wie man das anderst machen k旦nnte, einfach jedem Element '0' oder so zuweisen geht ja nicht.



>> 28.07.2006
[CO]
- In SystemLinux/SystemWin32 wird im Konstruktur nun auch srand aufgerufen um den Zufallsgenerator zu Initialisieren. Bis
  jetzt stand in PLMath::Math ein Kommentar das man dies selbst 端ber diese Funktion machen muss, und in PLEngine wurde dies
  dann auch gemacht... allerdings sollte man soweit irgend m旦glich auf OS/Standardfunktionen verzichten um eventuellen
  Inkompatibil辰ts oder Makro Problemen gleich von anfang an die Luft anzuschn端rren.



>> 26.07.2006
[CO]
- Stellte alles auf die neue HashMap um und nahm die alte HashTable Klasse heraus. Beim Umstellen viel mir auf, das wenn
  etwas aus einer HashMap entfernt wurde das Objekt selbst 端bergeben wurde, und nicht dessen Name. Wann immer m旦glich sollte
  man Namen/Keys 端bergeben da diese *sehr* viel schneller gefunden und entfernt werden kann - bei einem Objekt/Zeiger muss
  man erst die GESAMMTE HashMap durchlaufen um den entsprechenden Eintrag zu finden.
- Nahm an ein paar Stellen 'stdio.h' etc. heraus wo man dies nun nicht mehr ben旦tigt. (vor der String Umstellung brauchte man das
  dort wohl noch) Gerade in Headern sollte man es soweit m旦glich vermeiden solche Header einzubinden um eventuellen Problemen
  die dadurch entstehen k旦nnen zu vermeiden. (Makros etc.)
  Das ist momentan zwar noch nicht Optimal, zeigt aber wo es hingehen k旦nnte/sollte. So bekommt man dann auch hoffentlich weniger
  Probleme wenn man mal einen Memory Manager/Tracker hinzuf端gt, denn manche dieser Standard Header 端berschreiben new etc. was
  dann ziemlich ung端nstig ist.



>> 23.07.2006
[CO]
- F端gte wie vor einigen Wochen mit Stefan bereits besprochen String::SetCharacter() hinzu.
  Ersetze in FSTools::ValidatePath() 'sValidPath.Delete(0, 1); sValidPath.Insert(&c, 0, 1);' durch 'sValidPath.SetCharacter(0, c)'.



>> 22.07.2006
[CO]
- FSTools::GetDirectory(): Hier habs noch einen Bug, wenn in einem gegebenen Pfad kein Verzeichniss vorhanden war, wurde der
  gesammte String als Verzeichniss zur端ckgegeben was aber sicherlich nicht gewollt war. Es wird in dem Fall nun ein leerer 
  String zur端ckgegeben. Das gleiche in FSTools::GetFirstPath(). Auch musste FSTools::ValidatePath() angepasst werden da GetFirstPath()
  es wie es bereits in der Funktions-Kommentierung stand am Ende ein '/' hat. Der File System Unit Test l辰uft nun ohne das
  'Fehler' festgestellt werden. (vorher gabs Fehler bei den zip-Tests)
- Stephan fand gestern noch einen Fehler in XmlDocument::SaveFile(), hier wurde FSTools::GetPathPrefix() anstatt FSTools::GetDirectory()
  verwendet um das Verzeichniss herauszufinden in dem sich die Datei befindet. Solche Stellen gabs noch ein paar mal und ich korrigierte
  das 端berall.
- berall wo man eine Datei 旦ffnet um einen Tokenizer darauf arbeiten zu lassen wird eine Datei im Binary Modus ge旦ffnet, ansonnsten
  im Text Modus. Diese Stellen waren bereits mit einem [TEST] versehen und Stefan und ich hatten das auch bereits vor einer weile kurz
  besprochen. (Immer Text Modus kann Probleme machen, und h辰uftig ist/war das leider auch der Fall :(
- Den Fehler in RefCount<AType>::Release() behoben den ich bereits am 16'ten gefunden hatte. F端gte desweiteren zur Vollst辰ndigkeit
  == und != f端r 'Direkte Zeiger' hinzu. Ebenfalls wird nun VOR einer Zeiger zuweisung gepr端ft ob dies bereits der aktuell gesetzte
  Zeiger ist, machte man diesen Test nicht, konnte es zu einem 端blen Crash kommen wenn man einen Reference Counted SmartPointer sich
  selbst zuwies. Die entsprechenden Bast Tests laufen nun sauber & stabil.



>> 21.07.2006
[SW]
- Linux port nderungen von Christian teilweise angepasst/fehlendes hinzugef端gt.



>> 16.07.2006
[CO]
- Xml-Klassen: Diverse Definitionen nun mit gro/kleinschreibung geschrieben. Das ist zum einen Lesbarer, und manchmal sogar
  etwas k端rzer da man keine '_' mehr braucht.
- Types.h: Nahm einige mittlerweile total veraltete Definitionen heraus (das meiste wurde auch 端berhaupt nicht mehr genutzt)



>> 16.06.2006
[SW]
- GetOpts in CmdLineParser umbennant
- CmdLineParser:
  eine Parse-funktion f端r PLGeneral::Array<PLGeneral::String> hinzugef端gt.
  und 2 statische funktionen ( String CmdArrayToString(int argc, char** argv) und
    Array<String> CmdStringToArry(String cmd_str) )
  hinzugef端gt.
  Die 1. Funktion Convertiert das char argumenten Array in ein String um
  Die 2. Funktion Convertiert ein String in ein Array<String> um.
- PLMain 端bergibt nun ein PLGeneral::Array<PLGeneral::String> f端r die cmd-Parameter



>> 13.07.2006
[CO]
- HashString<AType>::~HashString(): Hier fehlte ein [], die Klasse ist zwar sowieso veraltet und mittlerweile durch HashMap
  ersetzt, aber solange das noch drinnen ist m端ssen eventuelle Bugs raus :)
- String::GetSubString(): Es wurde Speicher angelegt, korrekt gef端llt und einem String() Konstruktur 端bergeben, da dieser jedoch
  selbst den String kopiert und nicht den Zeiger 端bernimmt, hatten wir danach ein Speicherleck. Hab dem String(const char *pszString)
  Konstruktor erstmal einen Optionalen Parameter geben 端ber den man dann festlegen kann das dieser Speicher 端bernommen, und nicht
  kopiert werden soll... hat Vorteile wenn man das festlegen kann, ist aber auch etwas 'Gef辰hlich'. L辰d man z.B. eine Datei ein,
  so kann man den 'Buffer' nun direkt an String 端bergeben ohne das nochmal kopiert und danach der eingelesene Buffer wieder
  gerst旦rt werden muss. Standardm辰ig wird aber immer Kopiert.
- String: Dem StringBuffer muss man nun immer die L辰nge des Strings 端bergeben. Da diese IMMER bekannt ist, ist es einfach nicht
  so prall diese vom StringBuffer nochmals ermitteln zu lassen. Zudem ist der Zeiger auf den String innerhalb es StringBuffers
  NIE NULL, sobald es NULL wird, wird auch der StringBuffer nutzlos... Nahm daher auch den StringBuffer Konstruktor ohne
  Parameter heraus. Auf z.B. m_pStringBufffer->GetString() muss man daher NIE pr端fen da es NIE NULL sein kann - bis auf eine Stelle
  in der String Klasse wurde das auch nie gepr端ft. :)
  Machte die interne StringBuffer Implememtation inline und nahm 'Sicherheitsabfragen' wie z.B. pszString == NULL heraus da diese hier
  einfach nur Sinnlos sind, es ist schlichtweg ein ganz 端bler Fehler der eigentlich NIE passieren d端rfte wenn hier mal NULL kommt,
  und wenn das mal der Fall ist, so ist das ein Bug in der eigentlichen String Implementation der behoben werden muss.
- DynLibManager::~DynLibManager(): Hier wurde der Iterator nicht wieder gel旦scht
-> Die oberen Bugs fand ich als ich zum Testen mal den Memory Manager von http://www.fluidstudios.com/ im PLGeneral
   Header includierte, der merkte sofort das in der Hash Table der Speicher anderst wieder freigegeben wurde als er erzeugt wurde.
   Auch wurde ein Speicherleck in String::GetSubString() angemeckert - und tats辰chlich war was noch was... wir sollten uns
   wohl dranmachen unseren eigenen kleinen Memory Manager/Tracer zu schreiben, denn gerade bei solchen Speicherlecks hilft das
   enorm viel.



>> 29.06.2006
[CO]
- Bitset::Resize(): Das gleiche wie gestern in Array::Resize()



>> 28.06.2006
[CO]
- Array::Resize(): Hier konnte es zu Problemen kommen wenn ein Array intern bereits genug Elemente hatte und nach einem
  'Gr旦e 辰ndern' bereits alle Elemente 'hinzugef端gt' sein sollten. Erstaunlich das dies bis jetzt noch nicht aufgefallen war.



>> 26.06.2006
[CO]
- CmdLineParser: 'DEBUG' zu '_DEBUG' gemacht damit das unter VC klappt



>> 17.06.2006
[CO]
- Container: Neue Funktion 'uint32 Add(const AType Elements[], uint32 nCount)'



>> 14.06.2006
[SB]
- Style-Anpassungen an GetOpts vorgenommen. Bitte mehr auf Spaces und Tabs achten
- PLMain arbeitet nun nur noch mit PLGeneral::String



>> 07.06.2006
[SW]
- Neu Klasse GetOpts hinzufgef端gt. Mit dieser Klasse l辰t sich 辰hnlich, wie die getopt funktion unter linux, Optionen parsen.
  Die Klasse wertet nur die Optionen aus welche ihr vorher bekannt gegeben worden sind.



>> 05.06.2006
[CO]
- ResourceManager: Neue Funktion: LoadResource(): Create() sollte jeweils NUR eine Resource erzeugen, aber diese nicht auch noch
  eventuell gleich einladen... daf端r ist nun die neue Funktion da. Siehe PLMesh Tagebucheintrag von heute f端r mehr Informationen.



>> 04.06.2006
[CO]
- String: Vor ein paar Tagen hatte ich in der String Klasse StringBuffer aus dem Interface in die Implementation verschoben
  damit das Interface m旦glichst keine Implementations Details enth辰lt und etwas 端bersichtlicher ist. Allerdings konnte man nun
  nicht mehr beim Debuggen ohne weiteres 'in den String' schaun was oft sehr hilfreich ist. Machte daher diese nderung wieder
  zu gunsten des Debugging r端ckg辰ngig. F端gte auch gleich ein kleines Kommentar hinzu warum das public ist, nicht, das ich in
  ein paar Jahren wieder vergessen habe wieso das public ist und wieder auf die schlaue Idee komme das in die Implementation
  zu verschieben. ;-)
- Map: Neue Funktion: Replace() -> Stephan viel auf das diese Funktion welche recht n端tzlich ist noch fehlte



>> 30.05.2006
[CO]
- String: Mir viel gerade auf das wir zwar operator =(const char *pszString) hatten zum String kopieren, aber keine Funktion
  wo man nur eine bestimmte Anzahl von Zeichen kopieren konnte. Also f端gte ich eine Copy()-Funktion hinzu welche bereits
  im OpenGL Renderer verwendet wird. Ersetzte auerdem 'strcpy' durch 'strncpy' da das erstere mittlerweile 'deprecated' ist
  da keine 端berpr端fung auf Speicher端berlauf. Nahm auch ein paar mehr oder weniger 端berfl端ssige 'strlen' heraus.
  Verschob die interne StringBuffer Klasse in die String.cpp Datei damit das Interface etwas aufger辰umter ist.



>> 25.05.2006
[CO]
- Module::GetClasses() die gleichen Parameter wie bei ClassManager::GetClasses() verpasst damit es einheitlich ist.
  Die Codes der Funktionen sind identisch, baute am Anfang noch eine Abfrage ein ob alle Regestrierten Klassen zur端ckgebenen
  werden sollen, in diesem Fall kann man sich extra Arbeit sparen und einfach die Klassen Liste zur端ckgeben. In
  PLEngine::GuiDebugScene::UpdateClassList() macht es die Sache mit dem einheitlichen GetClasses() auch etwas einfacher da
  ich mir dort gleich eine Liste mit in Frage kommenden Klassen zur端ckgeben lassen kann ohne per Hand aussortieren zu m端ssen.
  (der Grund f端r diese nderung :)



>> 23.05.2006
[SW]
- Linux backend zum filesystem auf die Strings umgestellt



>> 22.05.2006
[CO]
Alle Projekte:
- Fand in diversen Projekten noch Stellen wo man z.B. Vector3::ZERO einsetzen konnte anstatt ein neues Tempor辰res Objekt zu erzeugen.
  Fand auch jede Menge stellen in denen man Werte direkt den Konstruktoren 端bergeben konnte anstatt diese Werte intern erst
  initialisieren zu lassen um anschlieend einen Wert zuzuweisen.
- Ein paar Variablen Namen angepasst wo man z.B. einen Zeiger auf Zeiger hat (also z.B. **ppMyPointer)
PLGeneral:
- String::LastIndexOf(): An ein paar Stellen in den Codes wurde der R端ckgabewert in uint32 gespeichert was probleme gab wenn
  nichts gefunden wurde und '-1' daher als Ergebniss kam.
- FileSystem: IsBaseDir() hinzugef端gt. Da es bereits auch IsSearchPath() gibt und ich bereits an ein paar Stellen umst辰ndlich
  per Hand pr端fte ob ein gegebener Pfad ein Basis Verzeichniss ist oder nicht um z.B. diesen Pfad dann gegebenenfalls w辰hrend
  dem einladen einer Szene Tempor辰r als Basispfad einzusetzen, denk ich diese Funktion hat im FS seine Existensberechtigung. :)
  Machte bei der Gelegenheit gleich ein paar int zu uint32, damit verschwinden ein paar Compiler cast Warnungen an diversen
  Stellen.
- String: + Operator hinzugef端gt damit man auch soetwas wie sResult = "A" + sString schreiben kann... wird bereits in
  PLSamplePhysics verwendet da hier recht praktisch.



>> 21.05.2006
[SB]
- B旦sen Fehler im String behoben: Beim Duplizieren des StringBuffers hatte sich ein Fehler eingeschlichen, so da nicht
  wirklich ein neuer Stringbuffer benutzt wurde. Daher wurde also im falschen Buffer geschrieben, so da sich Strings ver辰nderten,
  die eigentlich vorher kopiert worden waren. Ein weiterer Fehler war auch noch in Replace(char, char), dort wurde der Index
  innerhalb des Strings erst nach dem Kopieren des Buffers berechnet, so da man hinterher wieder im alten Buffer landete.
- FileSystem auf String umgestellt. Nach dem Beheben des String-Fehlers funktionierte das meiste wieder erstaunlich gut, nur ein
  paar kleine Fehler die bei der Umstellung des FS passiert waren. Da die FS Funktionen aber aus heftigen String-Manipulationen
  bestehen, die nun dank String-Klasse v旦llig anders implementiert werden muten als vorher, kann es aber gut sein da noch weitere
  Fehler auftauchen. Also bitte mal verst辰rkt auf Probleme mit dem FS achten.
- Einige kleine Umstellungsfehler beseitigt
- String: Replace(char, char) vereinfacht, so da nur noch eine Schleife ben旦tigt wird. Schleife in Schleife wobei die erste dann
  abgebrochen wird ist unsch旦n und sollte vermieden werden :-)



>> 18.05.2006
[CO]
- Nachdem Stephan beim 端bersetzen mit gcc bei der Funktion PLPlugins -> PLSceneNodes1 -> SNLightning.cpp -> GenerateLightning()
  eine Warnung bekam da etwas nicht const war und 'pPoint[f]+vDest' einmal als Parameter verwendet wurde was eine Warnung
  verursachte, f端gte ich in GeneralWin32.h etwas hinzu so das auch bei uns bei Warnungs Level 3 bei soetwas eine Warnung kommt.
  (die Warnung empfinde ich als sinnig :)



>> 16.05.2006
[SB]
- Resourcen-Klassen auf Strings umgestellt
- Log-Klasse auf Strings umgestellt
- Profiling-Klasse auf ... Na ihr k旦nnts euch wohl denken ;-)
- Einige Style-Anpassungen vorgenommen
- PLBase::FromString() und PLBase::VarChanged() auf String umgestellt und alle Projekte darauf angepat



>> 15.05.2006
[SB]
- Nochmal die XML Klassen ver辰ndert. Die vorherige nderung hatte zur Folge, da in den Klassen mit einem public Konstruktor
  erstmal eine interne Node erzeugt wurde, und dann wieder 端berschrieben wurde (Speicherleck). Leider f辰llt mit keine sinnvolle
  L旦sung ein, denn auch eine statische Methode m端te ja intern einen Konstruktor aufrufen, gleiches Problem also.
  Habe daher den internen Konstruktor wie vorher wieder eingebaut, nur statt (void*) nimmt er nun (void*, int).
  Das ganze ist nur n旦tig, weil ansonsten ein Aufruf von z.B. XmlText("Bla") einen Compilerfehler wegen Aufruf eines privaten
  Konstruktors ausl旦st (void* passt "besser" als String, daher wird das genommen). Darum also nun der zus辰tzliche Parameter int,
  der wird zwar nicht verwendet, verhindert aber diesen Fehler.



>> 14.05.2006
[CO]
- Container/Functions.cpp hinzugef端gt in dem die Implementation f端r die String Funktionen liegen. Sobald man die String Klasse
  nutzt muss man PLGeneral einbinden, aber nutzt man 'nur' die Container Templates ohne String Klasse, so braucht man PLGeneral
  nicht einzubinden - praktisch f端r z.B. Max Exporter damit man nicht f端r alles diese gr辰sslichen stl Klassen nutzen muss. :)



>> 14.05.2006
[SW]
- POD-warnungen gefixed



>> 14.05.2006
[SB]
- RTTI Funktionen gr旦tenteils auf Strings umgestellt. Dies bringt ein paar Probleme mit sich, denn da die RTTI Funktionen nun nat端rlich
  auch Strings zur端ckgeben, ist es nicht mehr so einfach m旦glich, festzustellen ob ein Fehler aufgetreten ist. Zumeist ist "" als
  R端ckgabe zwar ein Anzeichen f端r einen Fehler, jedoch k旦nnte nat端rlich auch der leere String eine g端ltige Variable sein.
  Anders herum ist es auch problematisch, denn wenn eine Variable auf "" gesetzt werden soll, wird jetzt vermutlich der Standardwert
  gesetzt - bei Strings kann jedoch wirklich "" gemeint gewesen sein. Dieses Problem bestand allerdings vorher auch schon, von daher
  sollte es erstmal keine gr旦eren Probleme geben, nach den ganzen Umstellungen 端berlege ich mir genau, wie wir das mit den Standardwerten
  k端nftig machen wollen.
- Base besitzt nun keine Funktionen mehr, um die Variablen aufzuz辰hlen oder an ein Var* zu kommen. Daf端r mu dann halt
  GetClass()->GetVar() geschrieben werden (intern passierte ja sowieso nichts anderes). 
- GetVarTypeAsString() in GetVarType() umbenannt - die Funktion heit nun als in "beiden Richtungen" gleich
- Config: m_szVariableValue entfernt. Sollte einmal der Fall eintreten, da aus zwei Threads auf das gleiche Config-Objekt zugegriffen wird,
  w端rde das b旦se schiefgehen. Wir m端ssen daher in Zukunft darauf achten, da alles Thread-Safe ist
- Tools: CombineStrings() entfernt. Diese Funktion ist 辰uerst unsch旦n und wurde sowieso nur an einer Stelle verwendet, wo sie 端berhaupt
  nicht notwendig war. Die anderen String-Funktionen teilweise umbenannt, damit besser zu verstehen ist was die machen.
- Da die XML Klassen leider noch keine Strings verwenden, war es an einigen Stellen n旦tig, so etwas wie String(pszString).GetBool() zu schreiben.
  Damit diese Stellen hoffentlich sp辰ter nicht vergessen werden, habe ich mich bem端ht diese immer mit einem [TODO] zu markieren. 
- Es sind immer noch an viel zu vielen Stellen Konvertierfunktionen f端r Strings vorhanden, teilweise in dreifacher Ausf端hrung und jedesmal
  leicht anders implementiert :-( Habe daher angefangen die zu vereinheitlichen, das werde ich aber in den kommenden Tagen erst richtig angehen.
- XML Klassen auf Strings umgestellt  



>> 13.05.2006
[CO]
- Erweiterte HashMap & SimpleMap um eine Vergleichs-Funktion. Da die definierbaren Funktionen recht universell sind, packte ich
  diese in eine gemeinsame Datei Namens 'Functions.h' welche im Container Ordner liegt.



>> 12.05.2006
[CO]
- Fand einen Bug in HashMap::CSlotsList::Add() -> Falls dies nicht das erste Element dieses Slots ist, so wurde der Next 
  Zeiger nicht Initialiert.



>> 11.05.2006
[SB]
- Class Groups wurden entfernt, da diese k端nstliche Definition von Gruppen so keinen Sinn mehr ergab.
  Da die Gruppen sowieso mit den Ableitungen von einer Basisklasse 端bereinstimmen, ist es sinnvoller gleich
  nach Basisklassen zu suchen. Nur das Aufz辰hlen von Gruppen ist jetzt nicht mehr m旦glich, wird aber auch
  nicht wirklich gebraucht. Das Interface von ClassManager wurde daher so angepat, da man sich entweder alle
  abgeleiteten Klassen einer Basisklasse direkt zur端ckgeben lassen kann, oder nur die direkt abgeleiteten.
  Einige Klassen wurden auerdem auf Strings umgestellt.



>> 09.05.2006
[SB]
- Externe Libraries wurden nach "external" verschoben und dort entpackt, damit das Projekt direkt 端bersetzt werden kann
  und keine Archive mehr entpackt werden m端ssen. Evtl. Sourcen k旦nnen innerhalb der Lib-Verzeichnisse abgelegt werden,
  aber auch nur wenn diese wirklich ben旦tigt werden, weil z.B. f端r PL etwas ver辰ndert werden mute.
  Die Projekte wurden entsprechend angepat.



>> 26.04.2006
[CO]
- XML Klassen: Ein paar Leerzeichen & Tabs verbessert
- FileSystem: RemoveBaseDir(): Der 端bergebene Pfad muss zuerst 'korrigiert' werden so das dieser auf jedenfall mit dem
  intern gespeicherten Pfad 端bereinstimmt.



>> 22.04.2006
[CO]
- Stefan und ich besprachen gestern das Iterator Problem und entschieden das es das beste ist, zus辰tzlich in den Container
  Klassen neben GetIterator() noch GetEndIterator() anzubieten welches 'hinten' im Container startet. HasNext() gibt
  also 'false' zur端ck und HasPrevious() 'true'. Die nderung in den Klassen war nicht wirklich aufw辰ndig. Passte gleich die
  Stellen in allen Projekten an wo man einen Iterator f端r einen R端ckw辰rtsdurchlauf verwendet.
- XmlDocument::LoadFile(): Hier gabs gleich zwei kleinere Problemchen. Man muss die Datei im Bin辰rmodus 旦ffnen damit TinyXML
  End Of Line (EOF) behandeln kann, und zum anderen fehlte ganz am Ende '\0'. Nun funktioniert im XML Test das Parsen von
  'demotest.xml' korrekt. In der neuen TinyXML Version wurde hier etwas ge辰ndert, darum konnte es nun Probleme geben.



>> 21.04.2006
[CO]
- HashMapIterator Konstruktor: Sind keine Elemente in der Map, so wird der Konstruktor nun sofort wieder verlassen da man
  ja bereits weis wie die Suche nach dem ersten Map Element ausgehen wird. Ist NUR ein Element drinnen ist es allerdings
  etwas Problematisch. Hab das nun erstmal so gemacht das man ein n辰chstes aber kein Vorheriges Element zur端ckbekommt. Hier
  muss man sich wirklich 端berlegen wie man diesen Sonderfall behandeln will, denn HasPrevious() gibt hier nun momentan immer
  false zur端ck. Dieses Problem gibts in jeder Iterator Implementation.
- Bei der Gelegenheit schaute ich gleich nochmal die Container Klassen durch und entfernte 端berfl端ssige Tabs & Leerzeichen



>> 20.04.2006
[CO]
- Container Klassen um Copy-Konstuktoren f端r den eigenen Typ erweitert



>> 17.04.2006
[CO]
- Stellte auf TinyXML 2.4.3 um. Anscheinend wurde intern etwas an den Strings ge辰ndert, wird hier nun NULL 端bergeben gibts
  einfach einen Crash. Daher musste nun in
    XmlDeclaration::XmlDeclaration(const char *pszVersion, const char *pszEncoding, const char *pszStandalone)
  eine Sicherheitsabfrage rein.



>> 08.04.2006
[CO]
- Pool & FastPool: FreeElements(): Hatte vergessen den Fall zu ber端cksichtigen wenn gerade 端berhaupt keine Elemente vorhanden 
  sind...
- Bitset: Machte einige Funktionen inline



>> 05.04.2006
[CO]
- Pool & FastPool: FreeElements(): Die alte Implementation war viiieeel zu umst辰ndlich. Man muss einfach nur die gesammte 
  Liste gerade verwendeter Elemente in die Liste der freien Liste 'anh辰ngen'... das macht Pool & FastPool dort wo man sehr 
  h辰ufig Elemente einf端gt, l旦scht und alles komplett zur端cksetzt extrem Performant. :)



>> 28.03.2006
[SB]
- Base::GetClassName(): return false bei "const char *" ... ? in return NULL ge辰ndert :-)



>> 22.03.2006
[CO]
- Base::GetClassName(): Sicherheitsabfrage ob Klasse vorhanden ist eingebaut



>> 12.03.2006
[SW]
- Fehler in PLGeneral/Main.h behoben, explizites angeben des Namespaces f端r String da nicht immer
  sicher ist, das "using namespace PLGeneral;" vorher "verwendet" wurde wenn dieser Header includiert wird.
- Fehlerausgabe unter linux hinzugef端gt, wenn das laden einer LIB fehlschlug.



>> 27.02.2006
[SW]
- SemaphoreLinux.cpp: Der Check f端r den Maximalen wert des Semaphore eingebaut.
- TheadLinux.cpp: Der Execution Mutex (Er wird verwendet um Join(Timeout) zu implementieren ) wird
  in Terminate() und in Join(Timeout) explizit unlocked.
  In Terminate() wird er unlocked weil der Thread hier nichtmehr dazu kommt den Mutex selbst freizugeben.
  Wenn in Join(Timeout) der Mutex->Lock(Timeout) erfolgreich war, so muss der Mutex dort auch unlocked werden,
  da sonst beim n辰chsten start des selben Thread-objectes der Thread nicht im versuch des "Locken" des Execution-Mutex
  blocked.



>> 27.02.2006
[SB]
- Ebenfalls noch einige kleine Style-Dinge hochgeladen. Das mit den Tabs und Freizeichen ist manchmal Geschmacksache,
  vor allem wenn man Variablen untereinander anordnen will etc. Am Anfang einer Zeile sollte jedoch immer Tab verwendet
  werden. Ebenfalls sollte darauf geachtet werden, da Freizeilen auch wirklich frei sind, sprich keine Leerzeichen oder
  Tabs darin enthalten sind
- Einige kleine nderungen im Linux Port:
  - MutexLinux: Habe den pthread mutex von einem Pointer in eine direkte Variable verwandelt, da bei allen Beispielen
    die ich gefunden habe keine Pointer verwendet wurden, sondern die Struktur direkt. Die Variable heit nun entsprechend
    m_sMutex, da es sich um eine Struktur handelt. Das mit dem Pointer war nat端rlich auch in Ordnung, allerdings scheint
    man sich das dynamische Erstellen hier sparen zu k旦nnen, es ist also nicht notwendig (deswegen aber nicht falsch).
    In dem Falle h辰tte allerdings nach pthread_mutex_destroy() noch das Objekt selber per delete gel旦scht werden m端ssen,
    da die Funktion dies allem anschein nach nicht tut (wie sollte sie auch unterscheiden, ob das Objekt dynamisch erzeugt
    worden ist oder nicht). Und es ist nicht notwendig, beim Portieren die gleichen Namen zu verwenden wie im Win32 Port -
    dort handelt es sich ja um ein Mutex-Handle, welches man vom System zur端ckbekommt, daher m_hMutex, handelt es sich aber
    dann beim Linux Port um einen Pointer, so sollte auch der Name in m_pMutex oder wie jetzt f端r eine Struktur m_sMutex
    ver辰ndert werden.
  - Die System-Ports sollten m旦glichst die Terminologie der entsprechenden System 端bernehmen, damit sich ein Windowsprogrammierer
    z.B. im Windows-Port gleich zurechtfindet und ein Linux-Programmierer im Linux Port. Daher sollten die Datentypen entsprechend
    angepat werden und nicht per Definitionen vereinheitlicht werden - dies ist ja auch nicht mehr n旦tig, denn es handelt sich
    ja gerade um systemspezifische Klassen, welche nur im entsprechenden System funktionieren m端ssen. Das unabh辰ngige Interface
    wird ja von den Klassen System, Thread, Mutex etc. bereitgestellt und benutzt die Impl-Klassen als Backend. Daher besteht
    also in den Backends selber keine Notwendigkeit mehr, irgendwelche Datentypen umzudefinieren oder zu vereinheitlichen :-)
  - DynLibLinux: Habe daher HANDLE m_hModule in void *m_pLib umbenannt
  - ThreadLinux: Variable in m_nThreadID umbenannt
  - ThreadLinux: In RunThread lpParameter in pParameter umbenannt. lp ist wieder nur f端r Windows und den dortigen Datentypen LPVOID 端blich
  - ThreadLinux: In RunThread ppThread in pThread umbenannt. pp deutet auf einen zweifachen Pointer hin, es ist jedoch ein direkter Pointer
  - ThreadLinux: m_pMutex wurde nicht in jedem Fall initialisiert, jedoch sp辰ter benutzt. Nun wird es immer mit NULL initialisiert
  - Die neuen Member-Variablen wurden dokumentiert
  - Variablen sollten immer im kleinst m旦glichen Kontext deklariert werden, also am besten beim ersten Benutzen und dann gleich
    initialisieren. Wenn es anders geht also m旦glichst nicht am Anfang einer Methode die Variablen deklarieren und dann erst
    sp辰ter benutzen
  - Bitte Debug-Code immer mit [DEBUG] kennzeichnen
  - In den Kommentaren "Windows" durch "Linux" ersetzt :-)
- Der Linux Port ist wirklich schon sehr gelungen, ist einfach toll wie 端bersichtlich das jetzt schon geworden ist :-)
  Hier noch ein Paar Anmerkungen bzw. Dinge die noch getan werden m端ssen:
  - ThreadLinux: Die Verwendung von m_pMutex mu noch etwas 端berarbeitet werden. Beim Join beispielsweise mu wohl nicht mehr Unlock()
    aufgerufen werden, dann wenn der Mutex noch gelocked w辰re d端rfte pthread_join gar nicht zur端ckgeben. Auerdem ist das L旦schen
    des Mutexes an vielen Stellen nicht ok, denn dann geht der Aufruf beim n辰chsten Starten des Threads schief, da der Mutex nicht
    mehr da ist. Eigentlich m端te es reichen den Mutex nur im destruktor wieder zu l旦schen, beim Abbrechen des Threads etc. mu nur
    darauf geachtet werden, da korrekt Unlock() aufgerufen wird.
  - SemaphoreLinux: Hier fehlt noch die Behandlung des Max-Values. Bitte mal schauen ob Linux das bietet, wenn nicht ist die Frage
    ob wir das selber einbauen, oder ob dieses Feature unter Linux halt nicht zur Verf端gung steht. Falls wir das selber machen
    sollte dies vielleicht besser in Semaphore geschehen und damit einheitlich f端r alle Systeme. Bl旦d ist es nat端rlich wenn eine
    Semaphore auch von anderen Prozessen verwendet wird, aber in dem Fall w端rde auch jetzt schon das Mitz辰hlen des aktuellen Wertes
    schiefgehen, und solange es daf端r keine Systemfunktionen gibt ist das Problem wohl auch nicht zu l旦sen



>> 27.02.2006
[CO]
- Linux Dateien dem VC Projekt hinzugef端gt (werden jedoch vom Build ausgeschlossen)
- Machte beim Linux hier und da ein paar kleine Style nderungen damit alles wie aus einem St端ck aussieht... die Linux 
  Implementation ist sehr viel 端bersichtlicher als vor dem PLGeneral umbaun - gute Arbeit Stephan. :)
- Mir ist aufgefallen das an einigen Stellen wo z.B. als Abtrennung von Funktions Sammlungen bei z.B. 
    //[-------------------------------------------------------]
    //[ Public virtual ThreadFunction functions               ]
    //[-------------------------------------------------------]
  oft keine zwei Leerzeilen waren - bis jetzt hatten wir es hier immer so gemacht das wir hier zwei Leerzeilen hatten um 
  die Funktions Bl旦cke sch旦ner zu trennen so das man schon beim berfliegen der Codes sehr schnell erkennt was zusammen 
  geh旦rt. Ist nat端rlich wieder so eine Geschmacksfrage - ich pers旦hnlich finds so aber einfach 端bersichtlicher.
  Das ist nat端rlich wieder so ein mehr oder weniger Sinnfreies 'kleinmist' Zeug... allerdings erleichtert ein durchg辰ngig 
  Einheitlicher Code Style enorm die Arbeit wenn man sich daf端r Entscheidet eine Style nderung vorzunehmen wie wir es in 
  der Vergangenheit ja schon recht oft gemacht hatten. :)
- An ein paar Stellen '/*<' durch '/**<' ersetzt... wenn ich solche Dinge per zufall finde, so 辰ndere ich diese immer 
  gleich so das es nicht noch mehr Stellen werden... man arbeitet ja oft mit Copy'n'Past oder schaut nach wie es woanderst 
  geschrieben wurde. ;-)



>> 26.02.2006
[SW]
- Linuxport auf die Klassen-Umstellung angepasst
- In der Thread-klasse die Funktion Stop in Terminate umbenannt, da die Bezeichnung Stop in meinen Augen nicht 
  "Kill den thread" sondern "Sende thread ein signal damit er sich beendet" bedeutet.



>> 25.02.2006
[SB]
- Haupt-Header von 'General.h' in 'PLGeneral.h' umbenannt
- Projekte an nderungen angepat



>> 23.02.2006
[SB]
- Habe mit der kompletten Umstrukturierung von PLGeneral begonnen. Das Projekt teilt sich ab jetzt in 3 Teile: Base, System und Core.
  In Base kommen alle Basisklassen und Datentypen, welche die Basis von PLGeneral bilden, also sprich Base, String, die Container, XML, Graphics etc.
  In System befinden sich die Klassen welche welche eine Abstraktion des Systems darstellen, also die fr端here Platform Klasse, Filesystem, Threading, Libraries, Timing usw.
  In Core letztlich kommt dann das Application-Framework, welche PLGeneral zur Verf端gung stellt. Das ist insbesondere das RTTI mit allen dazugeh旦rigen Klassen, also
  Klassen, Module, Config etc. Das wird dann nach und nach ausgebaut, so da ein richtig sch旦nes Framework entsteht. Die Trennung von System und Core ist wichtig,
  denn dies sind zwei v旦llig unterschiedliche Dinge, es war daher nicht sch旦n da diese vorher zusammen waren.
- Die Platform-Klasse wurde entfernt, da diese nicht gut gelungen war. Daf端r befinden sich in System nun alle systemabh辰ngigen Klassen, jeweils mit einer
  Implementierung f端r das jeweilige System. Die Win32 Implementierung ist jeweils schon dabei, die Linux-Implementierung k旦nnte Stephan nachtragen :-)
  Das meiste kann aus der alten Platform-Klasse kopiert werden, es hat sich inhaltlich nicht viel ver辰ndert, nur das Interface ist sch旦ner geworden.
- Die System-Klassen benutzen nun ein Backend-System, es gibt also jeweils eine System-unabh辰ngige Klasse als Interface, und eine Implementierungsklasse mit Ableitungen
  f端r jedes System. Das Interface besitzt dann einen Pointer auf die Implementierungsklasse. Das ist zun辰chst komplizierter, hat jedoch den Vorteil da das Interface
  und die Implementierung komplett voneinander getrennt sind, damit entsteht nicht wieder so ein Chaos wie in der alten Platform-Klasse.
- Habe den Threads und der Synchronisation ein vern端nftiges OOP System spendiert. Die Thread und Synchronisations Funktionen befinden sich in Threading, es gibt einen
  ThreadManager der die aktuellen Threads auflisten kann etc, f端r die Threads selber gibt es eine Klasse Thread, Mutex und Semaphore sind ebenfalls eigene Klassen.
  Damit ist dies nun endlich auch vern端nftig objektorientiert, wie es sich f端r C++ geh旦rt.
  Das schreiben eines Threads geht nun auf verschiedene Arten, bevorzugt aber so: Eine Klasse MyThread wird von Thread abgeleitet und ihre Run() Methode 端berschrieben.
  Mit new MyThread und pMyThread->Start() kann der Thread dann gestartet werden. Auf diese Weise hat der Thread ein Objekt zur Verf端gung und mu nicht mehr 端ber void*
  Pointer umst辰ndlich Daten 端bergeben bekommen. Bitte in Zukunft darauf achten auch bei neuen Funktionen gleich vern端nftig objektorientiert zu arbeiten, und nicht pl旦tzlich
  in unserem kompletten OOP Framework altbackene prozedurale Methoden zu verwenden. Auch ist es nicht gut das Win32 Interface inklusive der gesamten Kommentierung
  einfach zu kopieren, denn erstens legt man sich damit auf das oftmals merkw端rdige Windows Interface fest, und zweitens hat Microsoft sicherlich ein Copyright auf seine
  Hilfetexte :-) Also wenn neue Funktionalit辰t eingebaut wird bitte auch die M端he machen das vern端nftig zu designen, so da es sch旦n ins System passt.
- Beim Umbauen der Threads bitte wenn m旦glich von Thread ableiten, oder zumindest von ThreadFunction. Ich habe lange 端berlegt, ob ich die M旦glichkeit eines Function-Pointers
  端berhaupt noch anbieten will, habe mich dann daf端r entschieden. Das heit jedoch nicht, da das nun 端berall einfach weiter verwendet werden sollte, da es am einfachsten
  ist das so umzubauen. Die OOP Methode ist viel flexibler und besser, der Funktionspointer sollte nur in Ausnahmef辰llen verwendet werden.
- Die System-Klasse wurde um ein paar nette Funktionen erweitert, so kann man nun z.B. den Computernamen und den Usernamen abfragen. Ebenfalls soll hier端ber eine
  Versionsverwaltung implementiert werden, so da z.B. Plugin-DLLs schnell feststellen k旦nnen, wenn sie mit einer inkompatiblen PLGeneral.dll arbeiten. Auch dient dies
  nat端rlich den Log-Ausgaben. Das mu jedoch noch vern端nftig implementiert werden.
- Die Methode GetCPUMhz() aus der Tools-Klasse wurde ebenfalls nach System verschoben.



>> 20.02.2006
[CO]
- Array, Bitset: RemoveAtIndex(): Fand und behob einen b旦旦旦sen uint32 Umstell-Bug... war ja klar das so eine Umstellung 
  diese Viecher anlockt ;-)
  Resize(): Auch hier gabs noch einen heftigen Bug - wow, das ich das bis jetzt 端bersehen hatte, hm, die Container Tests 
  sind wohl noch nicht genau genug... :)



>> 12.02.2006
[SW]
Alle Projekte: Subversion:
- habe das property svn:eol-style f端r die neuen Dateien gesetzt.
    um dies automatisch zu machen sollten folgende optionen in der config-datei 
    von subversion vorgenommen werden:
    [miscellany]
    enable-auto-props = yes
    
    [auto-props]
    *.c = svn:eol-style=native
    *.cpp = svn:eol-style=native
    *.h = svn:eol-style=native
    *.inl = svn:eol-style=native
    *.dsp = svn:eol-style=CRLF
    *.dsw = svn:eol-style=CRLF
    *.sln = svn:eol-style=CRLF
    *.vcproj = svn:eol-style=CRLF
    *.sh = svn:eol-style=native;svn:executable
    *.py = svn:eol-style=native
    *.txt = svn:eol-style=native
    SCons* = svn:eol-style=native
    Makefile = svn:eol-style=native
    
    damit sollte jede datei die passende eol-kennung(bis auf die vc-projekt-dateien immer die kennung, welche vom OS verwendet wird)
    beim auschecken haben.
PLGeneral:
- Stellte die linux-thread-functionen auf pthread um.



>> 10.02.2006
[CO]
- Wie mit Stefan vorhin im Chat besprochen 辰nderte ich die Stack & Queue Klassen etwas so das Pop nun NICHT mehr das 
  entfernte Element zur端ckgibt da dies ziemlich Problematisch war. Stattdessen sollte man sich das Element nun 端ber 
  GetTop()/GetBottom() zur端ckgeben lassen und danach Pop() aufrufen - oder Pop() einen Zeiger 端bergeben der das Element 
  bekommen soll. (falls man nicht immer zwei Funktionen aufrufen m旦chte :)



>> 09.02.2006
[CO]
- Binominal Heap Iterator implementiert, vorw辰rts ging ja noch, aber r端ckw辰rts war etwas fies zu Implementieren. Da in 
  diesem Heap nur der Nachfolger, aber nicht der Vorg辰nger bekannt ist, ist das r端ckw辰rts durchlaufen auch nicht wirklich 
  gut von der Laufzeit her. Dort habe keinen Vorg辰nger Zeiger eingebaut da er hier unn旦tig ist und 'nur' die Iterator 
  Implementation f端r r端ckw辰rts durchlauf vereinfachen w端rde - da aber Iteratoren keine g辰ngige Operation auf Heaps sind, 
  entschied ich mich dagegen hier im Binominal Heap pro Eintrag noch mehr Speicher zu verschwenden.
- Neue Heap Implementation: FibonacciHeap: Hat gewisse hnlichkeiten zum Binominal Heap, jedoch geht u.a. das einf端gen 
  neuer Elemente superflott... daf端r ist das entfernen von Elementen etwas Aufw辰ndiger da hier dann auch gleich etwas 
  aufger辰umt werden muss. Ohne diese Funktion l辰uft es zwar auch korrekt, aber dann hat man im Prinzip nur eine 
  doppelt verkettete List und diese Struktur wird Witzlos. :)
  Wir haben nun drei g辰ngige Heap Implementationen - das sollte f端rs erste reichen.



>> 09.02.2006
[SB]
- Singleton hat nun wieder einen Destruction Guard, da die Benutzung des SmartPtr hier nicht m旦glich war.
  Aufgrund des static initialization order problems kann es vorkommen, da der statische SmartPtr sp辰ter initialisiert wird,
  als der Singleton. Beim Aufruf von GetInstance() wird also die Instanz erzeugt und im SmartPtr gespeichert, danach wird
  dann aber erst der SmartPtr initialisiert und somit der Zeiger wieder auf NULL zur端ckgesetzt, so da beim n辰chsten Aufruf
  von GetInstance() eine zweite Instanz erzeugt wird und die erste nat端rlich auch niemals mehr gel旦scht wird.
  Die statische Instanz welche das L旦schen des Singletons 端berwacht darf also keine Daten haben, die initialisiert werden
  m端ssen, daher mu hier doch wieder der speziell darauf abgestimmte Destruction Guard verwendet werden
- Der Destruction Guard besitzt nun eine leere inline Methode, welche innerhalb des Singleton einmal aufgerufen wird.
  Dies ist notwendig, damit der Compiler die statische Instanz erzeugt, ansonsten scheint diese in einer template-klasse
  wegoptimiert zu werden, wenn nicht einmal darauf zugegriffen wird. Die Methode macht also nichts ist aber notwendig,
  damit der Compiler richtig arbeitet. Interessant ist, da dieses Problem nur bei Template Klassen auftrifft, bei Nicht-Templates
  funktioniert das mit der statischen Instanz auch ohne solche einen Trick
- Im Singleton werden nun auch die Zuweisung und der Copy-Constructor deklariert, um ein Kopieren des Objektes und damit
  die Umgehung des Singletons zu verhindern
- Die unsch旦ne Methode CheckInstance() wurde entfernt, statt dessen wird 端ber ein Destroy-Flag 端berpr端ft, ob das Objekt
  bereits gel旦scht wurde. Damit wird w辰hrend der Deinitialisierung das Objekt nicht noch einmal neu erzeugt, nachdem es bereits
  gel旦scht worden ist.
  Generell sollte man w辰hrend der Deinitialisierung keine Singletons mehr verwenden, da diese schon gel旦scht worden sein
  k旦nnten - static DE-initialization order problem ;-) Also sollte z.B. in einem Destruktor eines Singletons nicht mehr auf andere
  Singletons zugegriffen werden. Sollte man es doch einmal tun mu auf jeden Fall der R端ckgabewert von GetInstance() auf NULL
  端berpr端ft werden, da dies nun zur端ckgegeben wird, falls die Instanz bereits gel旦scht wurde
- Singleton generell noch etwas 端berarbeitet



>> 08.02.2006
[CO]
- Heap Interface um GetTop() und ExtractTop() erweitert um das 'oberste' Element anzufragen bzw. zu entfernen
- Neue Heap Implementation: BinominalHeap: Nachdem ich erstmal die Theorie soweit kapiert hatte war die Implementation 
  nicht soo schwer wie ich anfangs dachte, eigentlich sind nur CTree::Union() und ExtractTop() etwas kompliziert gewesen - 
  der Rest war 'trivial'. ;-)
  Die entsprechende Iterator Klasse muss ich noch Implementieren...



>> 07.02.2006
[CO]
- F端r Heaps (Priority Queue) gibts nun wieder wie fr端her ein eigenes allgemeines Heap Interface da Heaps einfach etwas 
  anderes sind als Maps. (das erkannte ich erst wieder als ich mich wieder genauer mit den Datenstrukturen befasste :)
  Wie auch bei Container & Map hab ich Support f端r Iteratoren Implementiert. Dies ist zwar genauso wie bei Map eher 
  un端blich bei dieser Datenstruktur, jedoch ist das ein nettes Feature. In welcher Ordnung die Elemente beim Iterator 
  zur端ckgegeben werden kann man wie bei Map nicht wirklich vorausgesagen - man weis nur das das ERSTE Element jeweils das 
  gr旦te/kleinste aller Elemente ist - je nach verwendeter Compare-Funktion.
- Binary Heap an neues Heap Interface angepasst
- Nam den Sicherheits-Test innerhalb einiger Container Iteratoren der pr端fte ob der Container Zeiger g端ltig ist heraus 
  da total 端berfl端ssig - dieser Zeiger MUSS immer g端ltig sein, ansonnsten l辰uft gerade etwas total schief... ;-)
- Einige Container Iterator Implementationen waren noch nicht ganz korrekt.



>> 06.02.2006
[SB]
- PLGeneral_Rewrite Branch entfernt. Die nderungen wurden gr旦tenteils in den main Branch 端bertragen, der Rest mu sowieso
  noch einmal komplett 端berarbeitet werden, was dann direkt in den aktuellen Sourcen geschieht.
- Kleine Fehler in RefCountPtr und SmartPtr entfernt. Diese Klassen werde ich wohl nochmal gr端ndlich durchgehen m端ssen, da der
  Compiler ja leider nur die Teile compiliert die auch wirklich ben旦tigt werden. Und diese Klassen sind schon etwas kompliziert,
  da sie einige template Tricks verwenden :-)
- Singleton: DestructionGuard entfernt. Statt dessen wird der Zeiger nun in einem SmartPtr gespeichert, dieser l旦scht genauso wie
  vorher der Guard das Objekt wenn er selbst gel旦scht wird (also am Ende des Programmes, da es sich um eine statische Instanz handelt).
  Diese statische Instanz wird auch korrekt initialisiert, was wohl daran liegt da sie nicht selbst zum Template geh旦rt - dies ist wohl
  ein Fehler der Sprache, da dies nicht korrekt funktioniert.
  Singleton ist nun von RefCount abgeleitet, damit der SmartPtr vern端nftig die Referenz halten und l旦schen kann. Die Ableitung ist
  jedoch private, da ansonsten jeder den RefCount erh旦hen oder verringern k旦nnte, und somit das Singleton ad absurdum f端hren w端rde.
  Damit der SmartPointer dennoch den RefCount nutzen und die Instanz l旦schen kann, mute er als friend deklariert werden.
  Falls es Probleme mit dieser L旦sung gibt, bitte Bescheid sagen, denn dies ist schon einigermaen kompliziert - und bei den
  Templates noch durchzuschauen f辰llt hier schon etwas schwer :-)



>> 06.02.2006
[CO]
- Bitset: Die Anzahl der ben旦tigten Integers wurde noch nicht immer korrekt berechnet + verbesserte das Initialisieren 
  der Bits. Container::GetSize() Kommentar etwas erweitert damit wirklich klar ist WAS hier zur端ckgebenen wird.
  (Kommentar also bitte nicht l旦schen :)
- Tokenizer: Da momentan + und - als einzelnde Zeichen betrachtet werden funktioniert ParseNumber() nicht korrekt - 
  negative Zahlen werden nicht mehr korrekt gesetzt. Entweder m端sste man bei ParseNumber() nun nach Vorzeichen ausschau 
  halten oder wir behandeln diese Zeichen nicht als einzelnde Zeichen. (hab das erstmal auskommentiert damit alles sauber 
  l辰uft)
- FastPool: FastPoolElement: Virtuellen Destruktor etc. hinzugef端gt damit alles sauber 端ber die B端hne l辰uft



>> 05.02.2006
[SB]
- String: Konstruktor mit Printf-Funktionalit辰t wurde entfernt, da dies nicht bei jedem String erw端nscht ist.
  So war es unm旦glich, einen normalen String der ein Prozentzeichen (%) enth辰lt zu speichern. Statt dessen
  gibt es nun die statische Funktion Format, die einen formartierten String mit Printf syntax erstellt und einen
  String zur端ckgibt (named constructor).
- Tokenizer:
  - Fehler in ParseEquation(String, int&) entfernt - hier fehlte die Referenz, das Ergebnis wurde also nicht zur端ckgegeben
  - SingleChars zu {}()[]<>+.*/=,;" ver辰ndert. Damit d端rfte die 端bliche Syntax von C Programmen besser abgedeckt werden
- Auf String::Format() umgestellt



>> 04.02.2006
[SB]
- String:
  - IsFixedNumeric() in IsNumeric() umbenannt. Man mu hier im Hinterkopf behalten, da es um Eigenschaften der Zeichenkette geht (nicht um den Inhalt!),
     und das umfat z.B., ob diese nur aus alphabetischen Zeichen besteht, nur aus numerischen oder aus alpha-numerischen Zeichen. Diese Begriffe sind
     allgemein bekannt und daher sollten diese Funktionen nun sehr verst辰ndlich und eindeutig sein. An solchen Stellen sollte drauf geachtet werden, da keine
     eigenen Begriffe erfunden werden, da dies auenstehende nicht verstehen w端rden, noch dazu wenn z.B. Fixed noch eine ganz andere Bedeutung hat
     (Fixkomma Zahl), das verwirrt die User dann noch einmal unn旦tig, in diesem Fall also lieber gleich nach allgemein bekannten Begriffen suchen, wenn es
     einem einmal nicht einf辰llt :-)
  - IsFloatingPointNumeric() entfernt. Diese Funktion geh旦rt nicht in den String, da es sich nicht mehr um die Eigenschaft einer Zeichenkette handelt. Aus was
    f端r Zeichen eine Zeichenkette besteht kann direkt als Eigenschaft dieser Zeichenkette gesehen werden, daf端r die Funktionen IsAlphaNumeric() etc.
    Hier jedoch geht es eigentlich schon um den Inhalt, und daf端r sollte ein Parser zust辰ndig sein. Abgesehen davon sollte so eine Funktion dann auch gleich
    ein anerkanntes Floating-Point Format erkennen, die sehen dann etwas komplizierter aus (123.4567E10 (f/d) o.辰.) Daf端r gibt es aber genug Definitionen, die
    man dann benutzen kann. Im Moment bleiben wir beim alten Verfahren, da wir nicht alles auf einmal machen k旦nnen, sp辰ter werden dann solche Dinge gleich
    korrekt geparsed z.B. mittels regul辰rer Ausdr端cke.
  - Einige Kommentare angepat
  - Bei einigen Funktionen const hinzugef端gt
- Profiling:
  - Kleine nderungen im Coding Style



>> 04.02.2006
[CO]
- Profiling: SelectNextGroup() & SelectPreviousGroup() behob kleine uint32 umstell Fehler
- String:
  - Compare Funktionen wie besprochen um Start Position Parameter erweitert, in der Implementation werden ein paar 
    Sonderf辰lle ber端cksichtigt in denen man auf einen Schlag weis ob die Strings gleich sind oder nicht - gerade beim 
    Vergleichen l辰ngerer Strings wird das enorm Speed bringen.
  - IsSubString() wie besprochen ge辰ndert und neue Funktionen IndexOf() & LastIndexOf() hinzugef端gt.
  - IsCharacter() entfernt da mittlerweile 端berfl端ssig... IsCharacter() das kann man nun auch selbst per Hand in zwei 
    Schritten machen. (z.B. sToken.GetLength() == 1 && sExpected.IsSubString(sToken))
  - < und > Operatoren hinzugef端gt um Strings Lexikographisch vergleichen zu k旦nnen (f端r sortieren wichtig)
  - Neue Funktionen: Replace() in 3 Varianten, einmal f端r const char *, String und f端r Buchstaben - Ich w端rde wirklich gerne 
    diese spezielle Replace Funktion f端r Buchstaben behalten da die Implementation deutlich einfacher ist. Zwar wird auch 
    in der String-Replace Implemenation getestet ob es sich nur um Buchstaben handelt und dann eine schnellere Implementation 
    gew辰hlt, aber in der const char * m端sste ich dazu erst die L辰ngen der Strings ermitteln lassen was hier ja nicht 
    'for free' ist... und will man wirklich nur Buchstaben austauschen ist diese extra Funktion handlich & Performant.



>> 03.02.2006
[SW]
- Linux buid: build is wieder fehlerlos unter linux
  habe in RTTIDefs.h den r端ckgabewert von CLASS_OFS von PLGeneral::uint64 auf size_t ge辰ndert.
  da size_t immer die passende l辰nge auf dem entsprechenden sysstem hat.
  (32Bit-System -> 32 Bit, 64Bit-System -> 64Bit)



>> 03.02.2006
[CO]
- Container Klassen: Intern verwendete Klassen & Strukturen sind nun nicht mehr von auen 'sichtbar'... vorallem 'HashMap' 
  sieht nun in der Implementation ziemlich krank aus - dieses Template wirrwar ist kaum noch lesbar. ;-)
- String:
  - Compare Funktionen kann man nun noch optional die Anzahl der zu vergleichenden Zeichen 端bergeben, so muss man nicht erst 
    umst辰ndlich sich einen String & dann einen Substring davon erzeugen lassen damit man bestimmte Regionen von Strings 
    vergleichen kann.
  - Neue Funktion: IsSubString(): Pr端ft ob ein gegebener String ein Unterstring ist
  - Delete() f辰ngt nun auch den Fall ab wenn der String nun leer ist
  - Print() pr端ft nun ob der 端bergebene String NULL ist (ansonnsten gabs einen Crash in '_vscprintf')
  - GetSubString(): Position Parameter wird auf korrektheit 端berpr端ft
  - IsAlphabetic() & IsAlphaNumeric(): Kommentare um jeweils eine kleine Beispielzeile erweitert, denn ich hatte total 
    verpeilt f端r was diese eigentlich da sind und nahm an es w端rde sich um 'ist keine Zahl/ist eine Zahl' Funktionen handeln. 
    Stefan kl辰rte mich kurz im Chat auf und jetzt ist diese Sache nat端rlich total logisch - aber da es sicherlich auch 
    andere nicht auf anhib peilen werden lieber kurz nen Beispiel dazu. :)
  - Neue Funktionen IsFixedNumeric() (hm, besserer Name??) pr端ft ob der String eine Zahl ist, IsFloatingPointNumeric() pr端ft 
    ob es eine Fliekommazahle ist



>> 31.01.2006
[CO]
- HashMap: HashSlot zu einfacher Stuktur gemacht, das spart Funktionsaufrufe und ist auch etwas kompakter. HashSlot speichert 
  nun auch den Vorg辰nger, dadurch war nun auch die Implementation der 'Previous' Iterator Funktionen m旦glich - wobei diese 
  HashMap Iterator Implementation f端r 'vorw辰rts' & 'r端ckw辰rts' Support etwas Tricky ist... aber ich glaub das es kaum 
  einfacher gehen wird. :(
- SimpleMap Implementiert - diese Klasse verwendet intern 'Fast Pool' damit das h辰uftige Einf端gen & L旦schen etwas flotter 
  von dannen geht, aber zum auffinden der entsprechenden Eintr辰ge muss man nat端rlich sequentiell die gesammte Liste 
  durchgehen... diese Klasse sollte daher mit bedacht eingesetzt werden. Andere Map Implementationen wie z.B. 'Binary Heap' 
  sind hier deutlich flotter und diese Implementation hat noch den netten Seiteneffekt das die Elemente vom Iterator gleich 
  'nach Schl端ssel geordnet' zur端ckgegeben werden was bei dieser Implementation 'for free' kommt. Bei SimpleMap und HashMap 
  ist dies nicht der Fall und ein geordnetes zur端ckgeben der Element zu 'erzwingen' w辰re hier definitiv nicht gut da diese 
  Implementationen das einfach nicht 'unterst端tzen' und dies dann extra Implementiert werden m端sste was dann recht langsam 
  w辰re. Jede Implementation hat hier genauso wie die Container-Klassen vor und Nachteile die man geschickt nutzen sollte. 
  Wenn wirklich ben旦tigt k旦nnten wir sp辰ter noch extra Funktionen anbieden die Elemente 'IMMER' geordnet zur端ckgeben - ob 
  nun performant oder nicht... aber in den meisten F辰llen ist es egal in weiler Reihenfolge die Elemente zur端ckgegeben 
  werden und da sollten wir defintiv die Sache nicht unn端tz k端nstlich ausbremsen.



>> 30.01.2006
[CO]
- Nahm wie mit Stefan besprochen die Funktion ExpectCharacter() wieder aus dem Tokenizer und implementierte eine vergleichbare 
  Funktion namens IsCharacter() in der String Klasse.
- Container, Map & Iterator Templates um virtuellen Destructor erweitert, auch bei Templates scheint dies Pflicht zu sein - 
  gut das genau zu wissen. :)



>> 29.01.2006
[CO]
- Pr端fte 端ber Doxygen ob die Kommentare soweit ok sind und verbesserte ein paar Stellen



>> 24.01.2006
[CO]
- Tokenizer: Neue Funktion: ExpectCharacter(): hnlich wie ExpectToken(), aber erwartet das der n辰chste Token ein einzelner
  Buchstabe ist welcher mit einem der 端bergebenen Buchstaben 端bereinstimmt. Wird bereits in Var::CheckMinMax() verwendet um 
  zu pr端fen ob ein " oder ' vorhanden ist.
- Var::CheckMinMax() Funktionen an neuen Tokenizer angepasst
- Base::SetVars() an neuen Tokenizer angepasst



>> 23.01.2006
[SB]
- Tokenizer ver辰ndert, so da bei Quotes erst die Anf端hrungszeichen ("), dann der Inhalt und dann noch einmal die Anf端hrungszeichen zur端ckgegeben werden.
  Ist das Wort leer, so wird es nicht zur端ckgegeben. Auf diese Weise kann der Tokenizer sowohl f端r strikte Syntax
  verwendet werden oder es kann wie bisher einfach der Inhalt der Quotes ausgelesen und weiterverarbeitet werden



>> 22.01.2006
[CO]
- Resource Manager & Profiling Klassen an uint32 angepasst damit die Warnungen verschwinden



>> 21.01.2006
[SB]
- Neue Tokenizer Klasse geschrieben. Intern benutzt diese nun eine vern端nftige State-Machine (TheoInf l辰t gr端en) ;-) Dies ist zwar u.U. etwas langsamer, sollte daf端r
  aber wesentlich stabiler sein und ist vor allem verst辰ndlicher zu lesen
- Die Klasse arbeitet nun mit Strings anstatt mit char arrays
- Die Optionen werden nicht mehr beim Starten des Parsers festgelegt sondern 端ber eigene Get/Set Methoden
- Die grundlegende Funktionalit辰t des Tokenizers wurde besser von den erweiterten Parser-Funktionen getrennt. Diese sind zwar nach wie vor vorhanden, sollten aber nur
  eingesetzt werden, wenn keine strikte Syntax gebraucht wird. Im allgemeinen sollte der Tokenizer nur die Tokens liefern, danach mu der Output vern端nftigt
  geparsed werden
- Neue Klassen: BufferedReader, BufferedStreamReader und BufferedFileReader. Diese Klassen werden benutzt, um Schritt f端r Schritt aus einem Stream oder einem
  Buffer zu lesen. Dies wird im Tokenizer verwendet, so da dieser jetzt auch direkt aus Dateien parsen kann. Leider ist die Implementierung nicht so performant wie sie
  sein k旦nnte, dies sollte sp辰ter noch einmal 端berarbeitet werden. Auerdem sollte es eine Stream-Klasse geben, die Byte f端r Byte zur端ckgibt, der BufferedStreamReader
  k旦nnte dann auf beliebige Streams angewendet werden. Auf diese Weise k旦nnte jeder Stream verwendet werden, nicht nur Dateien sondern auch z.B. Netzwerk-Streams o.辰.
- Codes an neuen Tokenizer angepat



>> 21.01.2006
[CO]
- Etwas an den Container Klassen gefeilt, u.a. wird nun dort so m旦glich/sinnig uint32 anstatt int verwendet - dadurch kann 
  man gleich von vorne heraus Negative Werte ausschlieen so, das man sich intern extra Abfragen sparen kann. Bei 
  GetIterator() kann man nun optional einen Start Index setzen. Die Iterator Konstruktoren sind nun protected so das diese 
  NUR von dem jeweiligen Container Typ erzeugt werden k旦nnen.
- Bitset: Damit wir endlich ein paar cpp-Dateien im Container Ordner haben machte ich das Bitset Template zur normalen 
  Klasse. Ein etwas weniger wichtiger Grund war, das man nicht jedesmal <bool> angeben muss - denn ein anderer Typ ist hier 
  sowieso nicht m旦glich/gew端nscht... ein Bitset mit z.B. floats w辰re total daneben. :)



>> 17.01.2006
[SB]
- Alle Klassen auf Namespaces umgestellt. Das RTTI machte dabei etwas Probleme, die Makros m端ssen hier nochmal 端berarbeitet werden, es
  ist also m旦glich da externe Klassen im Moment nicht mehr richtig funktionieren.
- Alle Container-Klassen nach 'PLGeneral/Container' verschoben
- Quicksort nach 'PLGeneral/Tools' verschoben
- Verzeichnis 'FileSystem/Base' gel旦scht und alle Dateien direkt nach 'FileSystem' verschoben
- Patch von Christian f端r einen Fehler in SearchMultiHandle eingearbeitet



>> 16.01.2006
[SB]
PLString:
- Die Operatoren gefielen mir noch nicht wirklich, da dies eine bunte Mischung aus der Verwendung von String und char* war.
  Habe nun bei den wichtigsten Operatoren jeweils beide Varianten eingebaut, wird dies mit char* aufgerufen ist es also minimal
  schneller, da nicht erst ein String-Objekt erzeugt werden mu
- StringModule wurde in StringBuffer umbenannt
- Der StringBuffer implementiert nun nicht mehr einen eigenen Reference Counter sondern benutzt PLTRefCount
- Hilfsfunktionen zur Verwendung von String-Buffern in der Klasse eingebaut. Dies erleichtert die Arbeit mit den Buffern, da ansonsten
  an vielen Stellen immer wieder das gleiche getan werden mute (Buffer kopieren wenn der String ver辰ndert wurde etc)
- Der String-Buffer 端bernimmt nun immer einen neuen Zeiger auf einen Buffer, die M旦glichkeit einen eigenen Buffer zu allokieren und
  den 端bergebenen String zu kopieren f辰llt weg. Dies macht die Verwendung des Buffers wesentlich verst辰ndlicher, zumal das Kopieren
  des Strings nur an einer einzigen Stelle n旦tig war
- Compare-Funktionen 端berarbeitet
- Konstrukturen mit einem Char-Zeichen als Parameter aus StringBuffer entfernt. Im String selbst bleibt dieser Konstruktor erhalten,
  damit Operationen auf Strings auch mit Buchstaben funktionieren, ansonsten w辰re das Umwandeln eines Buchstabens in einen String
  der L辰nge 1 recht kompliziert
- IsAlpha: Wurde umbenannt in IsAlphabetic. Auerdem pr端ft diese Funktion nun den gesamten String und nicht mehr nur ein Zeichen,
  f端r ein einzelnes Zeichen sollte entweder die System-Funktion direkt aufgerufen werden oder SubStrings verwendet werden
- IsAlphaNumeric: Pr端ft nun ebenfalls den gesamten String, ob dieser nur aus alpha-numerischen Zeichen, sprich alphabetischen ODER
  numerischen Zeichen besteht. Vorher pr端fte diese Funktion nur auf numerische Zeichen, der Name war also falsch
- PrintF in Print umbenannt. Naja typische Sch旦nheitsoperation, sollte dies auf heftigen Widerstand stoen k旦nnen wir es auch wieder
  umbennen, aber ich finde so ein groes F am Ende irgendwie h辰lich ;-)
- Insert (char) entfernt. Wenn dies nicht dringend und an performance wichtigen Stellen gebraucht wird sollte dies lieber 端ber einen String
  der L辰nge 1 gemacht werden
- EatLeadingWhitespace und EatTrailingWhitespace umbenannt in TrimLeading und TrimTrailing. Auerdem noch Trim hinzugef端gt, welches
  beides macht. Auerdem geben diese Funktionen nun ebenfalls den String zur端ck
- Konvertierungsfunktionen aufger辰umt. Kleine nderung: Beim =(char) wird nun der Buchstabe ausgegeben, nicht dessen Ascii-Wert.
  Dies war zuvor inkonsistent, bei =(char) wurde die Zahl genommen, bei += jedoch der Buchstabe
- Const bei entsprechenden Methoden hinzugef端gt
- String-Klasse liegt nun in Base
PLGeneral:
- PLTRefCount Template hinzugef端gt, Basisklasse f端r Reference Counting
- PLTRefCountPtr Template hinzugef端gt, diese Klasse ist ein spezieller Reference Counter f端r externe Objekte
- SmartPtr-Template hinzugef端gt. Diese Klasse arbeitet mit dem PLTRefCount Interface und 端berpr端ft dabei,
  ob das verwendete Objekt dieses Interface unterst端tzt oder nicht. Falls nicht wird mittel PLTRefCountPtr ein
  externer Reference-Counter f端r das Objekt erzeugt, es ist jedoch besser, wenn die Klasse auf die gezeigt
  wird von PLTRefCount abgeleitet wird, da dies Fehler z.B. durch doppeltes Zuweisen des gleichen Zeigers
  besser verhindern kann
- Alle Klassen auf die neue PLTRefCount-Klasse umgestellt



>> 07.01.2006
[CO]
- RTTIDefs.h: Da 'VAR_OFS' bei Stephan unter Linux Compiler Warnungen verursacht bastelte er ein Makro welches unter Linux 
  keine Warnungen produziert. Da VC aber anscheinend kein '__alignof__' kennt musste ich hier defines einsetzen, unter 
  Windows das eine Makro, unter Linux das andere... vielleicht bekommt man irgendwann sp辰ter etwas Universelles zusammen das 
  端berall sauber geht, aber ich denke wir k旦nnen das erstmal so lassen.



>> 03.01.2006
[SW]
Alle Projekte:
- Habe das subversion property "svn:eol-style 'native' " f端r die source-files, text-files und project-files gesetzt.
  dieses property sorgt daf端r, das beim checkout,update die eol-kennung entsprechend des OSes ist
  d.h. unter linux ist die eol-kennung nur \n und unter windows \r\n und zwar egal vom welchem os aus diese
  Datei ver辰ndert oder erstellt worden ist



>> 02.01.2006
[SW]
- Memleak in der String-klasse unter linux behoben. Das Problem war das die _vscprintf-implementation
  fehlerhaft war(ein return hat gefehlt, *asche 端ber mein haupt*).
  Da die vsnprintf-function unter linux das selbe macht, wurde die protabele_vsnprintf-fn aus GeneralLinux.cpp
  entfernt.



>> 01.01.2006
[SW]
- habe die kompabilit辰t zu gcc 3.4 hergestellt bzw. zum c++-template standard
  zum einen musste ich den header string.h in HashTable.inl hinzuf端gen, weil sonst der gcc mit folgender fehlermeldung 
  bez端glich strlen, strcpy,strcmp abbrach:
  "there are no arguments to `strcmp' that depend on a template parameter, so a declaration of `strcmp' must be available"
  Die 辰nderung von AType zu AType1 in der friend declaration in den Dateien ResourceManager.h, ResourceHandler.h und 
  Resource.h war n旦tig weil sonst der gcc mit folgender Fehlermeldung abbrach:
  "include/PLGeneral/Base/ResourceManager.h:32: error: declaration of `class AType'
   include/PLGeneral/Base/ResourceManager.h:25: error:  shadows template parm `class AType'"
  es m端sste nur getestet werden ob diese nderungen keine probleme verursachen
- tinyxml: habe eine statische lib f端r linux von tinyxml in den zips hinzugef端gt und tinyxml.h so abge辰ndert das sie auch 
  unter linux 端bersetztbar ist
  
  
>> 01.01.2006
[CO]
- PLTString &PLTString::operator += (char nCharacter): Hier waren die Parameter vertauscht



>> 22.12.2005
[CO]
- Optimierte PLTHashTable da diese Klasse recht h辰ufig verwendet wird und etwas lahm war... die alte Implementation war etwas 
  d端rftig. Bei 'Add()' wird nun nicht mehr gepr端ft ob dieses Objekt bereits eingetragen ist - das muss der User schon selbst 
  machen wenn er hier unsicher ist und das jedesmal inter zu pr端fen ist schlichweg zu Aufw辰ndig... Codes angepasst habe ich 
  keine da wir eh vorher immer im  Falle des Falles pr端fen. Nahm diverse 端berfl端ssige 'Sicherheitsabfragen' raus - denn in 
  den Innereien kann man IMMER davon ausgehen das die gegebenen Dinge stimmen da diese bereits vorher mal gepr端ft wurden. :)
  Desweiteren wird nun zwischen gro/kleinschreibung unterschieden. Die neue Implementation ist nun teils mehr als doppelt 
  so schnell wie die alte und die Namen k旦nnen beliebig lang sein.
- PLTResource & PLTResourceHandler: Die alte Resource Handler Implementation war viel zu umst辰ndlich - daher machte ich dies 
  'direkter', Resource kann also intern direkt auf Handler zugreifen und umgekehrt... da diese Dinge stark zusammenh辰ngen 
  ist das denk ich ok und es vereinfacht die Sache enorm. Wenn ein Resource Manager automatisch nicht l辰nger verwendete 
  Resourcen l旦schen soll, l旦schen nun die Resource Handler die alte Resource wenn diese nicht mehr verwendet wird.



>> 15.12.2005
[CO]
- Da PLTString nun stark an Bedeutung gewinnt, 端berarbeite ich die String Klasse nochmal komplett - die alte Implementation 
  war leider teils heftig Buggy/Unbefriedigend. Das berarbeiten war zwar einiges an Arbeit, aber ich denke es hat sich 
  definitiv gelohnt. :)
- Stellte intern die Speicherung von Namen im Resource Manager auf PLTString um - den Rest in PLGeneral wird Stefan 
  anpassen. Das verwenden von PLTString zur Speicherung von Namen bringt einige Vorteile, zum einen haben wir so keinen 
  Overflow mehr wenn man einen l辰ngeren Namen hat als Speicher f端r einen Namen verf端gtbar ist... und zum anderen Spart man 
  einiges an Speicher da ein 'leerer' String gerade mal 4 Byte gro ist... und ansonnsten wird nur soviel Speicher f端r den 
  String verwendet wie wirklich n旦tig ist. Also nicht mal fest char[256/1024 usw.] anlegen und hoffen das dies reichen 
  wird. ;-)
- In PLTParameters::AddParam() kam es nun nach 'PLTVariant *pVar = new PLTVariant(cParam);' zum Crash da in 
  'PLTVariant::m_sName' merkw端rdigerweise Schrott stand. Machte hier eine kleine nderung, lies aber das vorherige als 
  Kommentar drinen. Stefan, schau bitte mal was hier schiefgeht und ob man es so wie es jetzt ist lassen kann.



>> 12.12.2005
[CO]
- PLTXmlElement::GetFirstAttribute(): An ein paar Stellen wo ich diese Funktion verwendete hatte ich vergessen vorher zu 
  Pr端fen ob hier 端berhaupt etwas zur端ckgegeben wird bevor ich es verwende - wieder soetwas wo man sich schwer wundert das 
  dies nicht schon vorher aufgefallen ist. ;-)
- Nahm wie besprochen die Priorit辰ten aus dem Resource Manager da diese dort mehr rger als nutzen bringen
- PLTSingleton: 'm_pInstance' bekommt nun im Constructor die Instance zugewiesen und nicht mehr in GetInstance(). Nach den 
  kleinen nderungen im Resource Manager Template hatte ich hier in den konkreten Resource Managern nun das Problem das 
  in deren Constructoren teils GetInstance() verwendet wird - jedoch lieferte dies zu diesem Zeitpunkt NULL zur端ck da diese 
  Variable erst noch gesetzt werden musste. (endlos Rekursion :)
  Ich hoffe diese kleine nderung geht ok...



>> 08.12.2005
[CO]
- PLTResourceManager: Die Funktion Get(<Name>) ist nun virtuell, in der Engine beim Scene System hat diese Funktion eine 
  erweiterte funktionalit辰t da man 端ber z.B. 'Root.Scene.Jeep' auch 'absolute Namen' angeben kann. Machte SetResourceName() 
  Protected da es reichen m端sste wenn man 端ber PLTResource::SetName() den Namen einer Resource setzen kann. 
  PLTResource::SetName() ist nun ebenfalls virtuell da z.B. in der Engine bei PLTSceneContainer in Namen kein '.' vorkommen 
  darf und der Name 'Root' nicht verwendet werden darf. (NUR die Root Node selbst hat diesen Namen :)
  Dummerweise musste ich auch Get(<int>) virtuell machen und in PLTSceneContainer implementieren, ansonnsten bekam ich 
  folgende Fehlermeldung:
    "error C2664: 'PLTSceneContainer::Get': Konvertierung des Parameters 1 von 'int' in 'const char *' nicht m旦glich"
  Was machen wir hier? Irgendwie ist das total d辰mlich. :(



>> 02.12.2005
[CO]
- PLTHeap: Kann nun auf Wunsch auch den Key zur端ckgeben



>> 30.11.2005
[CO]
- PLTBase::SetVars(): Konnte kein '=' gelesen werden, wurde das n辰chste gefundene Wort '端bersprungen' was nicht korrekt war.



>> 20.11.2005
[SB]
- Habe das Interface von PLTContainer ver辰ndert: Die Funktion Add(const AType &Element) gibt nun ebenfalls einen AType* Zeiger zur端ck.
  Man braucht dies nicht, wenn man nur eine Liste von Zeigern hat, besteht die Liste jedoch aus direkten Objekten, welche kopiert werden,
  ist dieser Zeiger sehr n端tzlich, ansonsten w端rde es wesentlich umst辰ndlicher.
- Habe in PLGeneral und PLMath alle Aufrufe von Add(const AType &Element) angepat - da vorher true als Fehler zur端ckgegeben wurde, nun
  aber NULL f端r den Fehlerfall steht, mu leider jeder Aufruf angepat werden. Habe dies auch in den anderen Projekten getan.



>> 18.11.2005
[SB]
- Include von PLTLog in PLTSingleton entfernt, dadurch muten an anderen Stellen die Include-Files ge辰ndert werden



>> 10.11.2005
[CO]
- PLTResourceManager<AType>::SetResourceName(): Ohman, wie konnte DIESER total d辰mliche Bug nur soo lange unbemerkt 
  bleiben? (war nat端rlich mein verschulden :) Hier wurde zuerst der neue Resourcen Name gesetzt, und dann wurde die 
  Resource mit hilfe diesen neuen Namens aus 'm_lstNameHashList' entfernt und dann mit dem neuen Namen wieder 
  hinzugef端gt... brrr, nat端rlich muss die Resource mit dem alten Namen aus 'm_lstNameHashList' entfernt werden.



>> 09.11.2005
[CO]
- PLTTools: Neue Funktion: CombineStrings(): Kombiniert Strings miteinander. Diese Funktion wird u.a. im Renderer in den 
  Shader Backends ben旦tigt um den Shader korrekt zusammenzukopieren... denn hier m端ssen noch Renderer & Custom Definitionen 
  in den Shader eingef端gt werden.
- PLTList: Get() & ReplaceAtIndex() & AddAtIndex() & RemoveAtIndex() & Compare() etwas Optimiert: Ist der Index in der 
  'hinteren' h辰lfte, so wird nun vom letzten Element r端ckw辰rts durchlaufen wodurch man in diesen F辰llen eine bessere 
  Suchzeit hat... wenn man schon ne doppelt Verkettete Liste hat, so kann man auch ruhig die Vorteile die diese bietet 
  nutzen. ;-)
  Passte ebenfalls PLTPool & PLTFastPool entsprechend an.



>> 07.11.2005
[SB]
Alle Projekte:
- Habe im Repository die Verzeichnisse _Branches und _Tags entfernt - ich fand die st旦rend, und wir nutzen das bisher eh nur sehr selten.
  Der PLGeneral-Branch sitzt nun direkt im Hauptverzeichnis, was nicht weiter st旦ren sollte, zumal Branches ja sowieso keine allzu lange Zeit
  am Leben sein sollen :-)



>> 02.11.2005
[CO]
- Reset-Funktion zu PLTArray hinzugef端gt mit der man den Array 'zur端cksetzen' kann - recht praktisch das
- PLTTools: Neue Funktionen: GetIntegersFromString(), GetFloatsFromString() und GetDoublesFromString()



>> 01.11.2005
[CO]
- PLTXmlDocument: LoadFile() und SaveFile() setzen nun den Dokument Wert auf den Dateiname + einen TinyXML Fehlercode
  wenn die Datei nicht ge旦ffnet werden konnte.



>> 29.10.2005
[CO]
- PLTSystem: Vergr旦erte die Anzahl der Slots der Hash Tables von m_hashClasses & m_hashModules da ich derzeit 217 Klassen, 
  und 19 Module z辰hle - so ist die Hash Table wieder Effektiver und da es nur eine Instance von PLTSystem gibt gibts auch 
  Speicher m辰ig keine Probleme.
- Es k旦nnen nun auch Passwort Gesch端tze Zip-Dateien verwendet werden. Daf端r musste ich PLTFile::Open() um einen weiteren 
  Optionalen Parameter erweitern. (das Passwort wenn ben旦tigt)



>> 25.10.2005
[CO]
- PLTTools: Neue Funktion GetBooleanFromString() welche einem den booleanischen Wert in einem String zur端ckgibt. Dies ist 
  z.B. beim Auslesen von XML Attribute Werten recht praktisch da der User dadurch '0' oder auch 'false' schreiben kann.
  PLTVar::Set() verwendet nun ebenfalls diese Funktion damit das Einheitlich gehandhabt wird.
- PLTXmlElement: Schl辰gt das zur端ckgeben eines Attribute Wertes fehl, so 辰ndert TinyXML troztdem die 端bergebene Variable - 
  das ist total unpraktisch und darum wird hier nun diese Variable nicht mehr ge辰ndert falls die Funktion fehlschl辰gt. 
  Hatte mir schon 端berlegt diese nderung direkt in TinyXML zu machen, sah aber davon ab da dies eventuell Probleme 
  verursachen k旦nnte.



>> 24.10.2005
[CO]
- PLTBase: Um Funktion AddVarsToXMLElement() erweitert welche die Variablen zu einem XML Element hinzuf端gen. Dabei kann man 
  als Parameter 端bergeben ob die Variablen als Attribute oder Elemente hinzugef端gt, und ob Variablen mit Default Werten 
  irgnoriert werden sollen. Da dieses 'Variablen zu XML Element hinzuf端gen' 旦fters ben旦tigt wird, ist diese hilfs Funktion 
  ziemlich praktisch. Das 'Gegenst端ck' zu dieser Funktion SetVarsFromXMLElement() ist ebenfalls vorhanden. Diese zweite 
  Funktion kann auf W端nsch selbst辰ndig nach Variablen in den Attributen UND Child-Elementen suchen soll, Default Einstellung 
  ist jedoch Variablen nur in den Attributen suchen.
- PLTConfig l辰d & speichert nun in einem XML Format, dabei werden die verschiedenen Variablen als Elemente hinzugef端gt 
  und auch Variablen mit Default Werten werden ebenfalls gespeichert - das ist hier irgendwie 端bersichtlicher.
- PLTXmlDocument: LoadFile() verwendet nun eigene File System Funktionen um eine Datei einzuladen und zu Parsen



>> 21.10.2005
[CO]
- PLTConfig: Beim Laden & Speichern kann man nun Optional angeben ob die Config Datei NUR im aktuellen Verzeichniss gesucht
  werden soll. Damit kann man Konflikte zwischen verschiedenen Config Files verhindern - z.B. das pl旦ztlich in PLSamples 
  Configs aus PLTools genommen werden da die gew端nschten Configs in PLSamples nicht gefunden wurden und PLTools im FS als 
  Basis Pfad eingetragen ist... und somit wurden teils unerw端nschte Einstellungen verwendet. :)



>> 05.10.2005
[CO]
- Musste in TinyXML eine weitere kleine nderung vornehmen: Hatte Probleme beim Scene Format da '[' und ']' nicht in Namen 
  vorkommen durften - aber somit konnte eine Scene nicht mehr geladen werden sobald eine RTTI Array Variable verwendet 
  wurde. Also erweiterte ich TiXmlBase::ReadName() so, das auch '[' und ']' in Namen akzeptiert werden... hoffentlich macht 
  das keine Probleme... hat jemand ne Ahnung ob das 'Absicht' ist das '[' und ']' bei XML nicht in Namen vorkommen darf, 
  sprich, es so in den 'Vorgaben' steht? Wenn ja, und wir uns daran halten wollen, m端ssten wir uns f端r RTTI Array Variablen 
  etwas anderes 端berlegen was aber ziemlich unsch旦n werden w端rde.
- An ein paar Stellen wo das RTTI float Variablen in einen String schreiben soll %f durch %g ersetzt damit am Ende keine 
  berfl端ssigen Nullen stehen.



>> 29.09.2005
[CO]
- PLTString::Insert() um weiteren optionalen Parameter erweitert. Ist dieser nicht -1 so gibt dieser die Anzahl der 
  einzuf端genden Zeichen an. Desweiteren noch ein paar Tool Funktionen hinzugef端gt.
- PLTSystem::ScanPlugins() um optionalen Parameter erweitert. Da wir mittlerweile ziemlich viele dll's haben kann 
  ScanPlugins() vorallem beim Programmstart im Debug Modus nervend viel Zeit in anspruch nehmen da zuerst einmal die dll 
  geladen werden muss und wenn nichts Interessantes drinen ist wird diese wieder entladen. Ist dieser neue Parameter auf 
  'true' (Default = 'true'), so wird anhand des Namens ein kleiner 'Vortest' gemacht so das man meist gut die h辰lfte der 
  dll's erst gar nicht zu laden braucht was den Scan Vorgang beschleunigt. Dabei wird das 'D' am Ende des Namens gepr端ft. 
  Ist man im Release Modus und ist dort ein 'D' wie z.B. bei PLSampleSceneNodesD.dll so wird dieses Module komplett 
  ignoriert. Da wir selbst uns an diese Namens Konvention halten klappt das hier, der User m端sste sich am Ende auch daran 
  halten, oder beim Scannen diesen Parameter auf 'false' setzen damit nicht eigentliche g端ltige Module ignoriert werden. 
  Ist nat端rlich eine Sache die schnell daneben gehen kann wenn jemand nicht aufpasst - allerdings spart das Wertvolle 
  Ladezeit was ein deutlicher Pluspunkt ist... und eine andere L旦sung um die ScanPlugins() Ladezeit zu verk端rzen hab ich 
  bis jetzt noch nicht gefunden. Ich machte das da diese Ladezeit gerade im Debug Modus mittlerweile deutlich auff辰llig - 
  das iss schon fast so nervend wie bei 3D Studio Max wo am Anfang erstmal tausende von Plugins geladen werden welche man 
  teils gar nicht braucht was Debuggen zur Qualt macht. Das Scannen selbst kann man wohl nicht umgehen, aber halt wie 
  gesagt grob anhand des Names 'ausfiltern'. In meinem Debug Modus Test wurden fr端her beim Programmstart gut 252 mal dll's 
  geladen und entladen. Jetzt nur noch 39 mal - fr端her war das so hoch da wenn eine dll geladen wird ja auch gleich noch 
  alle damit Verbundenen dll's geladen werden, und beim endladen werden diese anderen dll's meist auch wieder entladen und 
  das gleiche Spielchen immer und immer wieder. Hoffentlich kommt Stefan mit dieser L旦sung klar... oder findet etwas 
  besseres. ;-)
  Alternativ k旦nnten wir vielleicht auch alle Plugin in extra Unterordner wie z.B. 'Plugins' und 'PluginsD' packen und dann 
  gezielt beim Initialisieren der Engine in diesen Ordnern Scannen lassen. Aber dann m端sste z.B. 'Newton.dll' auch im 
  entsprechendem Ordner liegen wenn man was 'rausgibt'... und im Grundordner m端sste dieses nochmal liegen falls die 
  Anwendung selbst Newton verwendet. (denn in diesem 'rausgeben' Fall w辰re es nicht gut an den Environment Variablen zu 
  drehen)



>> 25.09.2005
[CO]
Alle Projekte:
  Ging alle PL Projekte durch und machte einige RTTI Variablen 'read only':
  PLTImageLoader, PLTTextureCreator, PLTMeshCreator, PLTSkeletonAniLoader, PLTMeshLoader
PLGeneral:
- PLTFileSystem: Neue Funktion: IsSearchPath() -> Pr端ft ob ein gegebener Pfad ein Suchpfad eines gegebenen Types ist. Dies 
  brauchte ich in PLTMeshLoader wo ich pr端fe ob ein Pfad bereits eingetragen ist. Wenn nicht, werden bei bedarf 
  w辰hrend des Laden eines Meshs ein paar Suchpfade hinzugef端gt und nach dem Laden wieder entfernt. (siehe PLEngine Diary)
- PLTFileType::RemoveSearchPath() korrigiert nun den 端bergebenen Pfad wenn n旦tig (sicher ist sicher)



>> 22.09.2005
[CO]
- Neue Funktion: PLTPlatform::ShellOpen(): Das OS 旦ffnet eine Datei mit dem Programm welches mit diesem Datei Typ vern端pft 
  ist. Weis nicht ob diese Funktion wirklich in Platform passt oder nicht doch eher ins File System. Auf jedenfall ist diese 
  Funktion recht n端tzlich wenn man z.B. auf einen Link Klickt und sofort auf eine Internet Seite kommt - oder wenn man z.B. 
  im Mesh Editor ein Material 旦ffnen will. (in dem Fall wird nen Text Editor mit diesem Material ge旦ffnet)



>> 10.09.2005
[CO]
- Der einzige Unterschied zwischen PLTPool und PLTResourceManager bestand darin das PLTPool Element zus辰tzlich noch 
  eine Priorit辰t haben - wichtige Element liegen dann also immer am Anfang. Da Priorit辰ten bei Resourcen sicherlich auch 
  nicht verkehrt sind erweiterte ich den Resource Manager um solche. Somit hat PLTPool nun keine Existensberechtigung mehr 
  und wurde gekillt. N旦tige (meist kleinere) Anpassungen:
  - PLGeneral: PLTProfiling
  - PLModel: PLTAnchorPoint, PLTAnimationEvent, PLTAnimationInfo, PLTMesh, PLTMeshHandler, PLTMorphTargetAni
  - PLEngine: PLTSurfaceListener, PLTSky
  - MeshEditor: TGuiEditAnimationEdit
- Das mit PLTPool hatte ich mir nochmal angeschaut da ich den Namen PLTPool f端r etwas anderes brauchte - es gibt nun eine 
  Neue Container-Klasse mit diesem Namen. Im Prinzip handelt es sich hierbei um eine Verkettete Liste wie bei PLTList, 
  jedoch gibts Intern zwei Listen, eine mit den aktuell verwendeten Elementen und eine Liste mit derzeit nicht ben旦tigten 
  Elementen. Diese Klasse ist recht praktisch wenn man viele Dynamischen Elemente Managen will, also wenn h辰ufig Element 
  gel旦scht und wieder hinzugef端gt werden. Beim L旦schen wird das eigentliche Element 'nur' zur Liste der freien Elemente 
  hinzugef端gt, und f端gt man wieder ein Element hinzu wird erst geschaut obs noch ein nicht verwendetes Element gibt - 
  ansonnsten muss wie bei der normalen Liste ein neues erzeugt werden.
- Neben PLTPool gibts noch eine schnellere Variante Namens 'PLTFastPool'. Bei diesem Container MSSEN die Elemente von 
  PLTFastPoolElement abgeleitet sein - damit kann man dann superschnell ein Element direkt vom Container entfernen ohne 
  voher wie bei PLTPool das reale Pool Element zu finden. Diese Klasse ist also Optimal wenn man sehr viele Elemente 
  regelm辰ig l旦scht und hinzuf端gt. Ansonnsten verh辰lt sich diese wie alle anderen Container Klassen auch. In der Engine 
  werde ich wohl PLTParticleGroup auf diese Klasse umgestellen und die neue Scene Hierarchy 'PLTSceneHierarchySphereTree' 
  verwendet diese Klasse ebenfalls da hier oft etwas gel旦scht und wieder eingef端gt wird und dies daher so flott wie m旦glich 
  gehen muss.
- In PLTList::RemoveAtIndex() war noch nen Bug, der Index wurde nicht erh旦ht - das dies nicht schon vorher aufgefallen ist...
- PLTStack: PushBack() Privat gemacht da dies nicht in das '端bliche' Stack Schema passt
- Neue Klasse: PLTQueue (FIFO) ist das Gegenst端ck zu PLTStack (FILO)



>> 30.08.2005
[CO]
- PLTBitset::Resize(): Parameter waren vertauscht



>> 26.08.2005
[CO]
- Bei einigen XML Funktionen Funktionen ein Get davor gesetzt + ein paar interne Sicherheits Abfragen auf NULL Zeiger
- XML Interface Kommentare soweit vervollst辰ndigt, sind aber noch hier und da nicht wirklich Aussagekr辰ftig da die TinyXML 
  Doku hier leider teils l端ckenhaft ist. Einiges undokumentiertes Verhalten hab ich bereits direkt in den Codes nachgeschaut 
  und bei uns Dokumentiert. Drehte auch ein paar boolische R端ckgabe Werte um so das diese zu unserem Style passen. 
  (bei Fehler 'true' statt 'false' - da wir fragen 'gabs nen Fehler?' und nicht 'ging alles glatt';-)
- PLTXmlDocument: Eigene Speicher Funktion eingebaut



>> 17.08.2005
[CO]
- XML Wrapper Versucht Nr. 2: Wie beim Treffen bei Jens Besprochen hat nun jede XML Klasse eine eigene Datei und alles 
  liegt in dem  Ordner. Zudem werden von diesen Klassen nun 'echte' Objekte erzeugt. Konkrete PL XML Objekte werden
  erst DANN erzeugt wenn diese ben旦tigt werden - z.B. wenn man sich ein Element zur端ckgeben lassen will wird intern falls
  zu dem TinyXML Element noch kein PL XML Element vorhanden ist eines erzeugt.
  Mit dieser L旦sung kann es sein das bestimmte Elemente/Attribute NIEMALS 'angefasst' werden und man hier daher auch keine
  eigenen PL XML Objekte erzeugen muss. (wird wohl vorallem bei Attributen der Fall sein :)
  Bei der Implementation gabs nen paar Kleinigkeiten zu beachten:
  Da die User Data Variable von TinyXML verwendet wird, muss man beim Kopieren und beim Einf端gen der Objekte aufpassen da 
  sonst die PL XML Objekte Zeiger nicht mehr stimmen. nderte in TinyXML TiXmlNode::CopyTo() es so das User Data NICHT
  mehr mitkopiert wird - denn das im Wrapper zu kompensieren war zuviel Aufwand. (rekursiv)
  Das L旦schen der PL XML Objekte war etwas mehr Aufwand da man rausbekommen musste wann ein TinyXML Objekt zerst旦rt wurde - 
  da TinyXML aber soetwas nicht anbietet erweiterte ich TinyXML um eine Destroy-Callback Funktion welche jedesmal aufgerufen 
  wird wenn ein Objekte zerst旦rt wird. Durch diese Mini Erweiterung spart man sich dann in unseren Wrapper eine ganze Menge 
  an Arbeit. :)
  Alles in allem find ich diesen Wrapper recht brauchbar und der Aufwand/Nutzen Faktor stimmt. Mit einer komplett eigenen
  internen Hierarchy w辰re alles mehr Arbeit als dies momentan der Fall ist. Zwar musste ich nun zwei mini nderungen an 
  TinyXML selbst machen - aber ohne diese nderungen h辰tte man sich teils heftig im Wrapper verbiegen m端ssen um es sauber
  laufen zu lassen, ich finde das ist nen akzeptabler kompromiss zwischen 'TinyXML umschreiben und direkt in PLGeneral',
  'gesammte XML Hierachy selbst Managen' oder gar gleich 'komplett eigenen XML Parser schreiben'.



>> 16.08.2005
[CO]
- PLTTokenizer::GetNextToken(): Quote verhalten minimal ge辰ndert. Bis jetzt wurden = und ` gleich gehandelt. Man konnte also
  mit " starten und mit ` Enden. Nun wird es so gehandhabt das wenn mit " begonnen muss es mit " auch wieder enden muss. Hat
  den Vorteil das man nun Quotes 'Schachteln" kann was enorm Praktisch ist. z.B. kann man nun Problemlos eine Scene Node 
  erzeugen dessen Mesh automatisch erzeugt wird mit z.B. 
  pContainer->Create("PLTObject", "Sphere", "Pos=\"0.0 0.0 5.0\" MeshFilename=\"PLTMeshCreatorSphere 
  Name=`Sphere` Radius=`4.0` Detail=`20.0`\"");
- PLTArray: Ist nun wieder ein 'richtiger' Array, bei meinen Tests hatte ich keine Probleme und alles l辰uft mit dieser 
  nderung genau wie fr端her. nderungen in den anderen Codes sind nicht n旦tig. Mit GetData() bekommt man den Zeiger auf 
  das erste Element des Arrays.
- Vertauschte bei PLTBitset & PLTArray Init & Add Parameter - denn Init sollte im Normalfall false sein und nicht ge辰ndert
  werden. (auer man weis genau was man tut :)
  Init ist praktisch wenn man GENAU weis das man einen Primitiven Variable Typ wie float hat oder einfache Klassen - aber 
  sobald z.B. virtuelle Funktionen ins Spiel kommen sollte man nie nie nie den Init Parameter auf True setzen da memset
  zum Initialisieren der Elemente verwendet wird!
  Keine Anpassungen in PLBase n旦tig, ansonnsten nur eine Handvoll Parameter Anpassungen in allen Projekten zusammen.
- PLTBitset: SetResizeCount() hat nun den Default Wert 320 - denn da jedes Element hier nur 1 Bit ist und je 32 Bits in
  eine Integer Variable 'passen' ist es so wesentlich Effizienter.
- PLTBitset & PLTArray: RemoveAtIndex() verkleinert nun bei Bedarf den Array wieder. NUR diese Funktion l旦scht die
  Elemente, alle anderen verwenden diese nur.
- PLTVar::SetEnumString(): Da m_lstEnum Array ist und jedesmal wenn ein neues Element hinzugef端gt wird sich die Adresse 
  im Speicher von anderen Elementen 辰ndern kann, darf man m_hashEnum erst nachdem alle Elemente eingetragen wurden
  erzeugen.



>> 10.08.2005
[CO]
- Wrapper f端r TinyXml geschrieben und im Tools Unterordner abgeladen. (+ Base Test um XML Test erweitert)
  Der Wrapper ist noch nicht 'perfekt' und es fehlen noch nen paar PL spezifische Funktionen f端r z.B. das eigene
  File System verwenden.



>> 06.08.2005
[SB]
- PLTWin32File::GetS() filtert nun nicht mehr das '\n' heraus sondern verh辰lt sich jetzt genauso
  wie fgets(). Vermutlich werden wir jetzt aufgrund des neuen Verhaltens einige andere Stellen
  anpassen m端ssen, aber es ist ja immer besser sich an Standards zu halten :-)
- PLTWin32File::PutS() gibt jetzt die l辰nge des Strings zur端ck, wenn es beim Schreiben keine
  Fehler gab, damit liefert PLTFile::Print() auch keine l辰stigen Fehler mehr. Bin mit nicht 100%
  sicher, ob das auch beim Textmode immer funktioniert, sollte aber eigentlich :-)
- Habe einen neuen Branch f端r PLGeneral erstellt, an dem ich in n辰chster Zeit arbeiten werde.
  Da ich noch einiges an PLGeneral 辰ndern m旦chte und es unpraktisch w辰re, dies im "laufenden Betrieb"
  zu tun, da dann st辰ndig alles angepat werden m端te, ist dies eine gute Gelegenheit, mal Branches
  in Subversion auszuprobieren. Dies ist also eine Kopie des aktuellen PLGeneral, an der ich
  beliebig arbeiten kann, wenn die Arbeiten abgeschlossen sind werden die nderungen wieder mit
  dem Hauptzweig gemerged - bei Bedarf kann man das auch zwischendurch schon machen, wenn ich z.B.
  nur einen kleinen Bugfix mache, der auch in der aktuellen Version ok ist, oder andersherum
  wenn jemand am Hauptzweig was 辰ndert was ich gleich 端bernehmen kann. Also mal schauen wie gut
  das funktioniert :-)



>> 28.07.2005
[CO]
- Erweiterte das Resource Manager Template um die Virtuelle Funktion PLTResource::DestroyResource(), diese Funktion
  wird/sollte nun immer anstatt delete <Resource> verwendet werden. Als Standard ist ein einfaches 'delete' 
  Implementiert - in PLTSceneNode ist es aber n旦tig VOR dem L旦schen die Scene Node sauber aus dem Container zu 
  entfernen. Vorher wurde in PLTSceneNode erst direkt im Destruktor der Knoten aus dem Container entfernt - dies 
  machte aber casting-Probleme da anscheinend bereits Teile des Objektes gel旦scht waren was dazu f端hrte das
  DeInitFunction() nicht mehr korrekt aufgerufen wurde.



>> 11.07.2005
[CO]
- PLTPlaneSet::IsBoxIn() kann nun Optional noch mit ausgeben welche Ebenen die Box schnitten.



>> 11.06.2005
[CO]
- Da ich merkte das man das Informer&Listener Prinzip immer wieder ben旦tigt und es mir einfach zu dumm wurde
  das immer wieder von neuem zu Implementieren erstellte ich Informer&Listener Templates an und legte diese im 
  Base-Unterordner ab. (PLTSceneQuery und PLTSceneQueryListener in der Engine verwenden diese Templates bereits)
- PLTString etwas erweitert



>> 17.05.2005
[CO]
PLTPlatform:
- F端gte Funktionen f端r Multi-Tasking hinzu da die Rechner (und vorallem neue Konsolen :) immer mehr CPU's
  haben, muss man zwangsl辰ufig versuchen wo immer m旦glich bestimmte Aufgaben als eigene Tasks zu realisieren um 
  diese Systeme Effektiver nutzen zu k旦nnen. PLPhysics z.B. werd ich dann gleich in einem eigenen Task laufen
  lassen da dies dort 'relativ' Problemlos m旦glich ist - und der Trend bei Physik geht eindeutig zum eigenen
  Task daf端r. (Thema Physics CPU etc. :)
  Auch m端sste man nun so Ladebildschirme realisieren k旦nnen welche lustige fl端ssige Animationen zeigen w辰hrend Parallel 
  dazu in einem Task die Daten geladen werden.
  Damit m端ssten wir auch das CPU/GPU Problem besser in den Griff bekommen... denn wenn die CPU im Hauptprogramm an einer 
  Stelle einmal dummerweise auf die GPU warten muss, wird die CPU im Hintergrund f端r z.B. die Physics weiter verwendet so 
  das keine/kaum Resourcen brach liegen.
  Hab mich beim Design an der SDL Implementierungen Orientiert da dies im Endeffekt recht Einfach zu verwenden 
  und Sinnig ist. (und es l辰sst sich sicherlich kaum anderst machen da man ja nur die Grundfunktionen Wrapt :)
  Der User selbst kommt nur mit einer Handvoll Funktionen f端r Task & Mutex in Kontakt. Intern und vorallem
  bei den Linux Implementierungen ist das alles teils ziemlich umst辰ndlich - da man dort anscheinend XXX
  verschiedene F辰lle beachten muss. Hab dort die Funktionen aus SDL 端bernommen, Stephan muss da aber nochmal dr端ber schaun
  ob das so ok ist und nat端rlich das mal ausprobieren - das wir endlich auch mal Multi-Tasking verwenden/unterst端zen sollen
  war ja schlielich seine Idee. ;-)
  Ich bin mir seeehr sicher das es sich so wie es momentan ist noch nicht einmal bersetzten l辰sst. ;-)
  Erweiterte PLBaseTests gleich um einen einfachen Multi-Tasking Test.



>> 12.05.2005
[CO]
- PLTBase::SetVars(): Der Tokenzier behandelt hier '[' und ']' nun nicht mehr als einzelne Zeichnen da ansonnsten Variable
  Namen wie 'Test[3]' nur als 'Test' gelesen werden - sehr merkw端rdig das dies bis jetzt noch nicht Aufgefallen war. ;-)
- PLTConfig::GetVarInt() ber端cksichtigt nun die F辰lle wenn die Variable vom Typ Flag oder Enum ist
- PLTResourceManager<AType>: Add() & Remove() waren noch nicht ganz ok. Der Resource wird nun mitgeteilt das dies nun in 
  dem Manager ist und bei Remove() das diese nun in keinem Manager mehr ist. Den Bug merkte ich erst als ich eine Resource
  nachtr辰glich einem Manager zuwies in es einen Crash gab als der Manager wieder gel旦scht wurde... ohmanohman, wie konnte 
  ich das nur 端bersehen. ;-)



>> 09.05.2005
[CO]
- In VC 7.1 spuckte der Compiler bei PLGeneral leider diverse Fehler aus. Diese liesen sich aber zum Gl端ck recht leicht
  beheben:
- PLTSingleton
  template <class AType> PLTSingleton<AType>::__Destruction_Guard PLTSingleton<AType>::__Guard;
  Hier muss typename Eingef端gt werden:
  template <class AType> typename PLTSingleton<AType>::__Destruction_Guard PLTSingleton<AType>::__Guard;
- PLRTTIDefs.h
  template <class T> typename PLTModuleID<T>::SelfInit__Class PLTModuleID<T>::__SelfInit;
  Hier muss ebenfalls typename Eingef端gt werden:
  template <class T> typename PLTModuleID<T>::SelfInit__Class PLTModuleID<T>::__SelfInit;
- PLTParameters::AddParam(const char *pszName, const PLTVariant &cParam) -> cParam ist nun const -> Machte sonst Probleme
  unter VC 7.1. und noch krassere Probleme auf dem Linux Compiler :)
- Musste in PLGeneralWin32.h auf einmal das Makro 'min' selbst definieren da es ansonnsten nicht gefunden werden konnte
Beseitigte probleme welche bei Stephans Linux Compiler auftraten:
- PLTSystem: Friend Definitionen:
 'friend class PLTModuleID<int>;
' zu 'template<class T> friend class PLTModuleID;
' gemacht
- PLRTTIDefs.h: Ca Zeile 150: 'template PLTModuleID<int>;' wurde entfernt da es Compiler Probleme verursachte.
  (die Zeile wird anscheinend auch nicht ben旦tigt :)
  Desweiteren musste hier 'PLSystem.h' eingebunden werden und in PLBase.h wurde 'PLSystem.h' entfernt.
  (sollte keinen Unterschied machen - tut es aber ;-)



>> 07.05.2005
[CO]
- PLTBase::SetVars() minimal ge辰ndert so das auch 'PLTTextureCreatorASCII3D Name=ASCII3D' verstanden wird. In dem Fall wird
  wie 端blich eine Fehlermeldung ausgegeben das bei 'PLTTextureCreatorASCII3D' ein '=' + Wert fehlt, der Rest wird nun aber 
  trotzdem weiterverarbeitet.
- PLTFileSystem::OpenInPaths() -> Hier wird nun zuerst in den Suchpfaden f端r den Typen (falls angegeben) gesucht, erst 
  wenn das nicht klappt wird versucht direkt zu 旦ffnen. (ansonnsten hatte pszType keine Auswirkung)



>> 27.04.2005
[CO]
PLTConfig:
- Implementiere die Funktionen Load() und Save(). Load() ist kein gr旦eres Problem, Save() hingegen bietet die M旦glichkeit
  entweder ALLE aktuellen Konfigurationen zu speichern oder nur diejenigen welche in einer bestimmten Konfigurations-Gruppe 
  sind. PLTConfig::GetInstance()->Save("All.cfg"); speichert allso ALLES in eine Datei namens 'All.cfg', w辰hrend
  PLTConfig::GetInstance()->Save("Engine.cfg", "PLTEngineConfigGroup"); NUR diejenigen Konfigurations Klassen in eine Datei
  speichert welche von PLTEngineConfigGroup abgeleitet wurden. PLTEngineConfigGroup hingegen wurde von PLTConfigGroup 
  abgeleitet. Auf die Art ist das Config-System nun sehr flexibel und man kann beliebig neue Gruppen von Gruppen von Gruppen
  etc. Erzeugen. Die Engine selbst l辰d/speichert also NUR 'PLTEngineConfigGroup'. :)
  Passte gleich PLRenderer (jedes Backend l辰d/speichert sich selbst), PLEngine und PixelLab + Plugins an. (nur minimalste 
  Erweiterungen :) Bei der Gelegenheit vergab ich dort auch gleich entsprechende Variable Namen.
- PLTFileSystem::AddBaseDir() -> Baute Abfrage ein ob dieser Basis-Pfad bereits Regestriert ist.



>> 23.04.2005
[CO]
Alle Projekte:
- Stellte bei ALLEN Projekten die Release Einstellungen etwas Resourcen schonender ein. Im Netz gibts nen kleinen 
  Artikel Namens 'Compiler Optimization Of MechAssault 2' wo diese Einstell 'Tips/Tricks' beschrieben wurden.
  - Exception handling /EHsc) wird Deaktiviert - wir verwenden dad sowieso nicht
  - Whole program optimization (WPO) Aktiviert



>> 10.04.2005
[CO]
- PLSingleton.inl: Hm, irgendwie will das mit PLTLog dort nicht funktionieren. Sobald das Log hier verwendet wird beendet 
  sich jedes Programm welches PLGeneralD.dll mal kurz pr端ft sofort ohne weitere Warnungen!??



>> 09.04.2005
[CO]
- Stellte PLGeneral auf neuen Kommentar Style um. PLSingleton.inl: Dort wo '[TODO] Add to log' stand stellte ich auf PLTLog
  um. PLTZipDate -> Packte die Inline Funktionen in PLZipDate.inl.



>> 20.03.2005
[SB]
- PLTZipStream::Read():
  Auch hier mu nun nSize und nCount angegeben werden, um Daten aus dem Stream auszulesen.
  Zwar wird intern wieder multipliziert und Byteweise gelesen, jedoch ist dies zur Kompatibilit辰t
  mit anderen Funktionen n旦tig: Will eine Funktion einen Block von 18 Byte lesen, so ist der
  korrekte R端ckgabewert nach dem Lesen '1', und nicht '18', die Anzahl der gelesenen Bytes mu
  also noch einmal durch die Blockgr旦e geteilt werden. Genau dies f端hrte zum Fehler beim
  Lesen von "standardflare.tga", da der falsche R端ckgabewert '18' gefunden wurde, brach DevIL
  das Lesen der Datei ab


  
>> 20.03.2005
[CO]
- PLTZipFile::Seek() -> Wird der Offset auf 0 gesetzt, so wird nur zur端ckgesetzt, aber nicht 0 Bytes gelesen.
  (k旦nnte probleme machen)



>> 02.02.2005
[CO]
- PLTVar::Set() -> F端gte optionalen Parameter hinzu mit dem man den Aufruf von VarChanged() unterdr端cken kann. Z.B. ist
  der Aufruf von VarChanged() in PLTBase::IsVarDefault() total ung端nstig da im schlimmsten Fall hierdurch etwas kaputt gehen
  kann - das hatte ich beim Klonen im WE. Danach waren die Orginal Entities pl旦tzlich in keiner Gruppe mehr da der Gruppen
  String leer war. Diese Gruppen wurden Dynamisch hinzugef端gt - dumme Sache das, derzeit hab ich noch keine Ahnung was man
  da machen kann auer auch die Dynamischen Gruppen einfach zu diesem String hinzuzuf端gen.
  Zudem ist das hier in PLTBase::IsVarDefault() nen totaler Overhead. Mir gef辰llt das zwar irgendwie nicht mit diesem Extra
  Parameter da priniziell IMMER Informiert werden sollte, aber bis uns f端r PLTBase::IsVarDefault() was besseres einf辰llt ist
  das denk ich ok. Hauptsache es geht hier (vorallem im WE :) erstmal ohne oben Beschriebene Probleme beim einfachen
  Vergleichen zu erzeugen. Hatte mit VarChanged() auch bei PLTEntity Probleme wenn nen Entity noch nicht Initialiert war,
  aber bereits seine Variablen z.B. beim Initialisieren gesetzt wurden. Das umging ich dort 端ber IsInitialized() Tests. 



>> 25.02.2005
[CO]
- PLTBase::GetVars() -> Intern auf PLTString umgestellt da ansonnsten der String aus PLTString wieder zerst旦rt wurde und am 
  ende Schrott in pszBuffer Kopiert wurde.



>> 23.02.2005
[CO]
- PLTString um ein paar Sicherheits abfragen erweitert



>> 22.02.2005
[SB]
- Neue Klassen:
  - PLTVariant: Dies ist ein Variabler Datentyp, welcher verwendet werden kann wenn der Datentyp einer
    Variablen nicht feststeht. Dies wird bei dynamischen Parametern verwendet, auch k旦nnte die Scriptsprache
    sp辰ter gebraucht davon machen. Ansonsten sollte es aber eigentlich kaum Verwendung daf端r geben :-)
  - PLTParameters: Dynamische Parameterliste, die bei Methodenaufrufen 端bergeben werden kann. Im Moment ist
    dies nur f端r den Konstruktor da, wenn das RTTI eine Klasse mit Parametern kreieren will. Sollte das
    RTTI sp辰ter noch um dynamische Methodenaufrufe erweitert werden, wird diese Klasse auch dort Verwendung
    finden
- RTTI-Makros angepat:
  - DEFINE_CLASS erstellt keine 旦ffentlichen Konstruktoren mehr, arbeitet also so wie vorher DEFINE_CLASS_PRIVATE
  - Zum Erstellen 端ber CreateInstance() mu nun zus辰tzlich das Makros DEFINE_CONSTRUCTION_PUBLIC hinzugef端gt werden
  - Zus辰tzlich kann ein Konstruktor definiert werden, dem Parameter 端bergeben werden k旦nnen, dies geschieht mit
    DEFINE_CONSTRUCTION_PARAMS, der Konstruktor mu die form Class(PLTParams&) haben
  - Vor den Variablen mu die Liste mit DEFINE_VAR_LIST begonnen werden
  - Durch diese nderungen war es nun m旦glich, das Registrieren der Variablen wieder einfacher zu gestalten,
    es m端ssen also keine Variablen mehr r端ckw辰rts und von vorne eingetragen werden. REDEFINE_VAR wurde
    ebenfalls entfernt, statt dessen werden bei DEFINE_VAR schon vorhandene Variablen mit dem gleichen
    Namen einfach 端berschrieben
  - Neue PL_VAR-Variablentypen hinzugef端gt
  - Bei DEFINE_VAR mu nun immer auch der Enum-String als letzter Parameter angegeben werden, daf端r wurde
    DEFINE_ENUM entfernt
  - Bei DEFINE_VAR kann hinter der Variablen nun noch ein Variablen-Name angegeben werden. Ist dieser "",
    wird wie bisher der richtige Name der Variablen verwendet
- PLTBase: IsVarDefault() hinzugef端gt
- Klassen an neue RTTI-Definitionen angepat



>> 11.02.2005
[CO]
- RTTI: REDEFINE_VAR() funktioniert durch die letzte nderung nicht mehr da die Basis-Variablen nun erst bei Init()
        eingetragen werden. Zuerst wollte ich ne PLTClass Interne Liste anlegen wo die dann bei Init() zu '端berschreibenden'
        Variablen eingetragen werden... Aber ich merkte schnell das dies etwas viel Aufwand ist - und wenn wir das so machen
        wollen w辰re es das beste wenn Stefan, der sich ja deutlich besser mit dem RTTI auskennt das 端bernimmt. Ich entschloss
        mich stattdessen erstmal in den MeshLoadern DEFINE_VAR() zu verwenden. Und will die Basis-Klasse dann ihre gleiche
        Variable eintragen geht das schief da diese Variable bereits vorhanden ist. War die einfachste L旦sung - nur Typ
        Sicherheit hat man damit nun nat端rlich nicht... da k旦nnte man ne Warnung ins Log schreiben wenn wir das so lassen
        wollen...
        Macht REDEFINE_VAR() 端berhaupt noch Sinn? Denn dann m端sste man auch DEFINE_ENUM() etc. Varianten anbieten.
- PLTLog::Open() -> Erzeugt nun ein neues Log wenn kein solches vorhanden ist.



>> 10.02.2005
[CO]
- PLTArray::AddAtIndex() und PLTList::AddAtIndex() waren noch nicht ganz ok. Wenn man ganz am ende ein neues Element einf端gen
  wollte ging das noch nicht wie erwartet. Dadurch funktionierte bei mir dann das Regestrieren der Klassen-Variablen nicht
  richtig.



>> 09.02.2005
[SB]
- PLTConfig: Die Methoden GetVarb() etc. umbenannt in GetVarBool(), GetVarInt(), etc. Wie haben bisher immer aussagekr辰ftige Namen
  verwendet, daher sollten wir dies auch hier tun. Es w辰re zu 端berlegen, ob Methoden dieser Art nicht gleich in PLTBase
  eingebaut werden sollten, um es dem Programmierer zu erleichten, auf Variablen zuzugreifen (ist nat端rlich dann
  schlecht, wenn der Programmierer den falschen Typ verwendet).
- PLTConfig: Habe AddClass() wieder entfernt und durch eine simple "Create-On-Demand" L旦sung ersetzt, da mir kein Grund einfiel,
  der dagegen sprach :-) Wenn jemand versucht, auf eine Konfiguration eines bestimmten Typs zuzugreifen, wird erst
  einmal geschaut, ob es diese schon gibt. Wenn nicht, wird das Objekt in dem Moment erzeugt und zur端ckgegeben.
  Sollte w辰hrend das Programm l辰uft niemand versuchen, auf eine Config-Klasse zuzugreifen, wird diese auch niemals
  erzeugt, was ich auch f端r genau richtig halte, warum sollte man erst einmal alle m旦glichen Objekte erzeugen,
  wenn diese dann gar nicht gebraucht werden? Wir m端ssen da nur evtl. beim Speichern darauf achten, aber es stellt
  sich mir sowieso die Frage, ob das Speichern der gesamten Konfiguration sinnvoll ist, da ja z.B. Game-Config und
  Engine-Config nicht zusammen in eine Datei kommen sollten.
- PLTSystem: Eintragen der Config-Klassen wieder ausgebaut (s.o.). L旦sungen dieser Art sollten grunds辰tzlich vermieden werden,
  da sie die Hierarchie eines Systems durcheinander bringen. PLTSystem steht ganz oben in der Hierarchie, d.h. alle
  anderen Teile der Engine verwenden PLTSystem, aber PLTSystem wei nichts von diesen anderen Teilen. Wenn wir nun
  anfangen, das zu 辰ndern (PLTSystem wei pl旦tzlich von PLTConfig und tr辰gt dort Klassen ein), wird das ganz schnell
  un端berschaubar, da in beide Richtungen aufeinander zugegriffen wird - wozu das f端hren kann, sah man sehr deutlich
  beim alten FS, wo GetValidFileName() zu abwechselnden Aufrufen im Manager und im FS f端hrte, dadurch konnte 端berhaupt
  nicht nachvollzogen werden, was wo getan wird und welches System wof端r verantwortlich ist. Das gleich k旦nnte leicht
  bei PLTConfig und PLTSystem passieren, wenn nun PLTConfig im Gegenzug anf辰ngt, neue Klassen einzutragen, und schon
  pendeln die Aufrufe wieder hin und her. Darum also: Aufrufe immer nur in eine Richtung, so da die Hierarchie erhalten
  bleibt, niemals wieder zur端ck vom oberen Teil der Hierarchie in untergeordnete Teile.
- PLTSystem: Beim Eintragen der Klassen wird nun geschaut, ob die Basisklasse bereits registriert wurde, ist dies nicht der Fall
  wird so lange gewartet, bis die Basisklasse da ist und erst dann die Registrierung der Variablen aus dieser
  Basisklasse vorgenommen. Damit die Variablen in der richtigen Reihenfolge bleiben, mute ich bei den Schleifen und beim
  Eintragen der Variablen etwas tricksen, sch旦nere L旦sungen w辰ren hier sehr willkommen. Bitte mal schauen ob die Probleme
  damit gel旦st sind, in meinen Tests hat's jedenfalls funktioniert :-)
- PLTSystem: Mir ist aufgefallen, da immer wieder PLGENERAL_API zu allen Funktionen hinzugef端gt wird. Dies ist ok, wenn es wirklich
  ben旦tigt wird, also die Funktion soll von auen verwendet werden und es gibt unaufgel旦ste externe Symbole aufgrund des
  fehlenden Exports. Ist dies aber nicht der Fall, bitte nicht einfach so hinzuf端gen, denn die Entscheidung, welche
  Methoden exportiert werden sollen und welche nicht, ist an den meisten Stellen schon mit Bedacht gew辰hlt worden!
  Dies ist z.B. eine gute M旦glichkeit, um noch etwas mehr Sicherheit zu gew辰hrleisten, indem Methoden, die nur intern
  verwendet werden sollen, auch nur intern aufgerufen werden k旦nnen (im System ist dies z.B. bei kritischen Methoden
  wie dem Hinzuf端gen von Modulen der Fall). Dies kann dann auch nicht durchs Ver辰ndern eines Headers (protected in
  public 辰ndern) umgangen werden, und ist daher f端r solche kritischen Methoden n端tzlich.
  Also bitte immer 端berlegen, ob das Exportieren einer Methode wirklich gew端nscht ist, und nicht einfach alle Methoden
  exportieren.



>> 08.02.2005
[CO]
- PLTResourceHandler: Machte SetResource() virtuell da es man z.B. in PLTSkeletonHandler sobald eine Resource gesetzt wurde
  diverse Aufgaben erledigen muss.




>> 05.02.2005
[CO]
- PLTConfig: Neue Funktion: AddClass() -> Da jederzeit neue Module mit eventuell neuen Konfigurations-Klassen darin
  eingeladen werden k旦nnen war es n旦tig eine Funktion anzubieten um neue Config-Klassen zu regestrieren.
  In PLTSystem::RegisterClass() wird nun versucht die neue Klasse in PLTConfig einzutragen - mir viel da 
  keine bessere M旦glichkeit ein... vielleicht w辰re da ne art von System-Listener angebracht, falls man noch
  an anderen Stellen mitbekommen m旦chte wenn z.B. neue Klassen regestriert/entladen werden.
- PLTFile: Die Read&Write Funktion wurde so erweitert das man auch Count angeben kann -
  das war leider n旦tig da DevIL nicht korrekt laden konnte wenn man nSize*nCount direkt berechnete und als zu
  lesende Bytes 端bergab - da gibts anscheinend intern irgendwo doch nen Unterschied. 
  Auch bei ZLib ists nen Unterschied wenn man die Parameter size und count bei fread vertauscht.
  Stefan, wenn du weit wieso dad so iss kl辰re mich bitte auf - ich kanns mir momentan noch nicht Erkl辰ren. ;-)



>> 04.02.2005
[CO]
- PLTResourceManager: In Create() wird nun die interne Funktion CreateResource() verwendet welche man in einem konkreten
  Manager 端berschreiben MUSS. Da das mit der automatischen Erzeugung im Template nicht klappt falls
  der Resource-Typ abstrakt ist, wie dies beim Sound-Manager der Fall ist, musste das ge辰ndert werden.



>> 02.02.2005
[CO]
- Ein paar kleinigkeiten an den Resource-Templates ge辰ndert



>> 01.02.2005
[CO]
- Neue Funktion: PLTFSTools::GetRelativePath() -> Macht aus einem Absoluten Pfad wenn m旦glich einen Relativen 
- PLTWin32FSTools::ConvertToWindowsPath() & PLTFSTools::ValidatePath() -> Kleine Laufwerksbuchstaben werden zu
  Grobuchstaben gemacht da es sonst Probleme geben kann. (ich hatte da eines in AddBaseDir() :)



>> 01.02.2005
[SB]
- PLFSTools, PLPlatform: Nannte FileNameEnding in FileExtension um.
  Dieser Begriff sollte wohl allgemein bekannt sein, und wir sollten es dem User nicht unn旦tig schwer machen :-)
- PLSearchHandle: Nahm die nderung, da '.' und '..' grunds辰tzlich aufgelistet werden, wieder heraus (und wenn ich
  es richtig sah, wurden inzwischen sogar alle Verzeichnisse aufgelistet). Dies mag an einigen Stellen n端tzlich sein,
  doch es gibt gen端gend Situationen, in denen das ausdr端cklich nicht gew端nscht ist, doch die k旦nnen dann nichts
  mehr daran 辰ndern (z.B. versucht unser PluginSystem "." und ".." als DLL zu laden, was sicher nicht gut ist).
  Wenn also alle Verzeichnisse sowie bestimmte Dateien gefunden werden sollen, sollte dies ist zwei
  Schritten erfolgen, worin ich kein Problem sehe (der FileDialog macht dieses ja auch genau so), denn diese L旦sung
  behindert im Gegensatz zur anderen nicht die entsprechend andere Situation.



>> 31.01.2005
[CO]
- Machte PLTProfiling zum Singleton und passte Engine etc. an.



>> 29.01.2005
[CO]
- Nahm die Module-Templates aus der Engine, benannte diese in ResourceManager etc. um, 端berarbeitete diese etwas - diese
  Resource-Templates liegen im Base-Unterordner da es universelle Grundklassen sind die man 端berall gut brauchen kann.
  Dabei implementierte ich es so das man auch Resourcen & Resource Handler OHNE Resource Manager verwenden kann. Ist jedoch
  ein solcher Resource Manager vorhanden so MUSS jede Resource einen einmaligen Namen bestitzen - und das wird intern 
  auch sichergestellt. :)
  Somit k旦nnen diese Resource & Resource Handler Templates auch in PLRenderer, PLSound etc. verwendet werden, denn dort gibt
  es auch Resourcen, allerdings ohne konkreten Manager dahinter da dies dort unn旦tig ist - das w端rde sonst dort zuviel des
  guten sein.
- Die konkreten Template Implementationen von PLTStack, PLTHashTable, PLTHeapBinary, PLTSingleton liegen nun in seperaten
  'inl'-Dateien. Ich finde es einfach 端bersichtlicher wenn im Header NUR das Interface liegt. :)


>> 26.01.2005
[CO]
- PLTConfig: Funktionen wie GetVarb() hinzugef端gt mit dem man komfortabel gleich den Boolean Wert abfragen kann etc.
- PLTFileType::AddSearchPath(): Pfad wird nun intern bei Bedarf 'korrigiert'



>> 21.01.2005
[CO]
- PLTPlatform: GetTickFrequency() entfernt und PLTTimer entsprechend angepasst. Dies war n旦tig da es erstens so nicht
  unter Linux ging (dort hab es schwere Probleme mit dem richtigen Timing...) und zweitens war das mit der extra Frequenz
  sowieso nicht so brall. ;-) Da der Name 'TickCount' nicht wirklich aussagekr辰ftig war, benannte ich ihn in
  GetMilliseconds() und GetMicroseconds() um, damit wei man auch sofort in welcher Einheit man die vergangene Zeit
  zur端ckbekommt. Ein paar Dateien mussten in diversen Teilprojekten angepasst werden, aber nun m端sste das etwas Sauberer
  sein.



>> 17.01.2005
[CO]
- Kleinen Fehler in PLTFile::Seek() behoben - das viel mir erst auf als bei FMod das Streaming aus PLTFile einfach
  nicht funktionieren wollte - nun gehts. ;-)



>> 10.01.2005
[CO]
- PLTPlatform: Neue Funktion: GetModuleFileNameEnding() -> Gibt die Dateiendung von Modulen, also unter Windows 
  'dll' und unter Linux 'so' zur端ck. PLTSystem::ScanPlugins() verwendet nun diese Funktion. Das IMMER 端ber #ifdef
   zu machen w辰re keine so dolle L旦sung gewesen. :)
- PLRTTIDefs.h: Foreward declaration von PLTSystem eingef端gt da es ansonnsten unter Linux einen Compiler
  fehler gibt.
- PLGeneralWin32.h/PLGeneralLinux.h: Dort wird nun PLEXPORT/PLIMPORT definiert da man dies ja seehr oft ben旦tigt.
  PLRTTIDefs.h -> DEFINE_MODULE_PLUGIN verwendet nun PLEXPORT. (ging ja sonst so nicht unter Linux :)
-> Das waren noch die paar Dinge wie Port-m辰ig gemacht werden mussten. Damit es unter Linux problemlos 端bersetzen geht.
- PLStack.h: Nahm PLGeneral.h include raus da ich dann z.B. beim Max Exporter nun durch die weiter intern
  eingebundenen Dinge dazu gezwungen bin PLGeneral dort miteinzubinden was ich aber nicht will. :)
- PLTPlatformWin32::LoadModule() -> Der Dateiname wird nun zuerst in einen Win32-Pfad umgewandelt bevor die Lib
  geladen wird.



>> 10.01.2005
[SB]
- Die nderung vom 29.12. geht leider so nicht, weil sie dazu f端hrt, da der DestructionManager
  nicht mehr korrekt gel旦scht wird und somit ein Speicherleck entsteht:
  DestructionGuard wird beim beenden deinitialisiert und l旦scht den DestructionManager
  -> dieser l旦scht alle Singletons
  -> Singleton ruft PLTDestructionManager::GetInstance()->RemoveObject(this) auf
  -> Dadurch wird der DestructionManager neu erzeugt und nie wieder gel旦scht.
  Dies habe ich nur deswegen so ausf端hrlich aufgeschrieben um klarzumachen, da kleine und v旦llig
  harmlos aussehende nderungen beim RTTI sehr b旦sartig sein k旦nnen, da das RTTI leider auf vielen
  Tricks basiert, aber genau dies erm旦glicht erst, da es so gut und einfach zu bedienen ist :-)
- Habe nun DestructionManager und DestructionObj gel旦scht, statt dessen hat jede Singleton-Klasse
  ab jetzt einen eigenen DestructionGuard, welcher das Singleton beim Beenden wieder l旦scht
  (damit ist die Abh辰ngigkeit der Singletons von einem weiteren Singleton nicht mehr gegegeben).
- Die Klassen eines Moduls melden sich beim Beenden nicht mehr vom System ab, weil dies ein
  辰hnliches Problem wie oben ergab: Die Reihenfolge der Deinitialisierung statischer Variablen
  wird vom Compiler vorgegeben und kann nicht beeinflut werden, es passiert also, da zuerst
  das PLTSystem-Singleton gel旦scht wird und dann die Klassen eines Modules deinitialisiert werden,
  wenn diese dann PLTSystem::GetInstance()->Remove() aufrufen, wird PLTSystem neu erstellt und
  wir haben wieder ein Speicherleck.
  Um die Abh辰ngigkeiten m旦glichst gerin zu halten, melden sich also die Klassen nicht mehr ab,
  sondern nur noch das Modul, wodurch automatisch alle Klassen entfernt werden. Um das Problem
  hier zu beheben, gibt es in PLTSingleton nun noch eine Methode CheckInstance(), welche nur die
  Instanz zur端ckgibt aber keine erstellt. Im oben genannten Fall meldet sich ein Modul also
  nicht mehr ab, wenn das System bereits deinitialisiert worden ist, denn in diesem Fall
  wurden ja sowieso schon alle Klassen beim Beenden gel旦scht.



>> 09.01.2005
[CO]
- PLTPool: GetElements() in GetNumOfElements() umbenannt, PLTProfiling musste entsprechend angepasst werden.
- PLTArray & PLTBitset & PLTList: Compare() so umgeschrieben das der Operator != nun nicht mehr zwangsl辰ufig vorhanden
  sein muss



>> 03.01.2005
[CO]
- PLTSearchFilter::CheckMatch() -> '.' und '..' kommen nun immer durch den Test, ansonnsten gibts probleme beim Auflisten
  des Inhaltes eines Verzeichnisses.
- PLTFSTools::GetFileNameEnding() -> Ber端cksichtigt nun auch nicht vorhandene Dateinamen Endungen
- PLTFSTools::ValidatePath() -> F端gt nun am Ende des Pfades noch ein / an falls dort keines ist damit Pfade immer mit /
  Enden.



>> 29.12.2004
[SW] + [CO]
- Die Linux Tests Crashten immer nachdem das Programm bendet wurden - nach Stundenlanger Such und dem durchgehen aller
  m旦glichkeiten waren wir schon nahe am Verzweifeln da man sich den Crash einfach nicht erkl辰ren konnte. Tja, und irgendwie
  landeten wir dann eher per Zufall im Destruktor von PLTDestructionManager und dort Crashte es beim L旦schen eines Objektes.
  Es stellte sich raus das Zeiger ung端ltig waren - ein Blick auf den Destruktor von PLTDestructionObj zeigte das sich Objekte
  nicht wieder bei Tot abmeldeten sondern sich einfach ins Nirvana schlichen. ;-)
  Kleines Problem, merkw端rdige Ph辰nomene - viele Stunden suchen. ;-)
- PLGeneral und PLMathLib auf Linux portiert:
  -> Nun laufen PLBaseTest, PLFileTest und PLMathTest auch problemlos und sauber unter Linux - wir haben Teils auch alles 端ber
     Eclipse Debugt etc. Jetzt da diese Dinge auf zwei Platformen laufen kann man annehmen das es so nun schon recht ordentlich
     ist.  :):)



>> 27.12.2004
[CO]
- Passte PLTTimer an die aktuellen nderungen an. Die Timer Klasse verwendet nun PLTPlatform und ist dadurch Platform unabh辰ngig
  und die ganzen Timer Platform-Dinge konnten entfernt werden - erleichtert das Portieren. :)
- Erweiterte PLTPlatform um GetTickFrequency() - wird f端r PLTTimer ben旦tigt
- Dort wo in PLGeneral noch PLTDynamicList verwendet wurde stellte ich auch PLTArray um. Hab nun die alten Listen Klassen +
  PLTDataSet was wir ja mittlerweile nicht mehr brauchen gel旦scht. Desweiteren alte Stack-Klasse herausgenommen.
  -> Endlich wieder Ordnung in PLGeneral - da Stephan und ich uns die n辰chsten Tage intensiv mit der Linux Portierung besch辰ftigen,
     wollte ich dieses alte Zeug drauen haben so das wir nicht mit unn旦tig vielen Dateien jonglieren m端ssen.



>> 26.12.2004
[CO]
- PLTArray: Musste internes Speicher Management etwas umstellen da es Probleme mit Klassen welche Klassen etc. beinhalten gab
  ... diese wurden dann nicht korrekt Initialisiert wenn alle Element in einem groen Buffer lagen. Nun hat PLTArray einen Buffer
  aus Zeigern auf die Elemente welche 端ber new erzeugt und 端ber delete wieder gel旦scht werden... hat den kleinen Vorteil das nun
  auch die Konstruktoren & Destruktoren verwendung finden. :)
  -> Mittlerweile ist auch das merkw端rdige Static Initialization Problem in der Engine verschwunden und alles l辰uft wieder
     einigermaen - so langsam m端ssten die Container Klassen aber so passen. :):)



>> 25.12.2004
[CO]
- PLTFileSystem: Um GetNumOfFileTypes() & GetFileType() & RemoveFileType() erweitert damit ich in 
                 GuiFileSystemDialog die Search Path Ansicht f端llen konnte
- In PLTFileSystem::AddSearchPath() wurde der File Type Name nicht korrekt gesetzt
-> Diese nderungen wurden nur gemacht um GuiFileSystemDialog implementieren zu k旦nnen - es zeigte sich ja schon bei
   GuiSystemView das es ganz Praktisch ist diese Dinge 端ber einen Dialog 'anfassbar' zu machen... zudem wird dieser Dialog
   auch in PixelLab verwendung finden damit man Einstellen kann von wo die Daten kommen sollen.
- PLTBitset & PLTArray: Resize() kann nun optional mitgeteilt werden das ALLE Speicherpl辰tze f端r Elemente automatisch
  zugreifbar sind... ist dann so als h辰tte man alle Elemente einzelnd hinzugef端gt. Dies ist immer wieder n端tzlich wenn man
  einfach ein Feld haben will bei dem man frei auf die Elemente zugreifen kann ohne vorher alle 端ber Add hinzugef端gt zu haben
  wie dies bei 'normalen Listen' der Fall ist.
  Wenn man Resize() per Hand aufruft sind immer standardm辰ig ALLE Elemente gleich verf端gbar, so, als h辰tte man alle 端ber Add()
  hinzugef端gt - denn wenn man schon selbst Resize() aufruft erwartet man normalerweise das alles gleich zugreifbar ist, xxx
  mal beim Array Add() aufzurufen w辰re schlichtweg zu umst辰ndlich. :)



>> 24.12.2004
[CO]
- PLContainer: AddAtIndex(int nIndex) hinzugef端gt um ein neues Element an einer bestimmten Stelle zu erzeugen
- In PLTConfig() korrekten Config Klassen Name gesetzt



>> 22.12.2004
[CO]
- PLTFSTools: Neue Funktionen: - GetFileNameEnding() -> Liefert die Datei-Endung zur端ck
                               - CutFileNameEnding() -> Liefert Dateinamen ohne Endung
                               - GetDirectory() -> Liefert das Verzeichniss eines Dateinamens zur端ck
- PLContainer Klassen minimal erweitert



>> 21.12.2004
[SB]
- PLTBase.h: Die virtuelle Funktionen stehen nun in einem eigenen Bereich, wie wir es sonst auch meistens haben. Ich finde
  das zwar an dieser Stelle etwas unsch旦n, da z.B. die beiden ToString() Methoden damit auseinandergerissen werden, es
  dient jedoch der bersicht des Programmierers. Die Dokumentation der Methoden habe ich auch noch etwas erweitert.
- PLGeneral: Die Definition von systemabh辰ngigen Klassen wird nun einheitlich in den Include-Dateien f端r das jeweilige
  System vorgenommen. Dies f端hrt zwar dazu, da einige Header immer eingebunden sind, scheint mir jedoch besser zu sein,
  da dann alle Plattformdefinitionen an einem Ort sind und somit schnell wiedergefunden werden k旦nnen.
- FileSystem: PLNativeDirectory.h gel旦scht und die Definition entsprechend nach PLGeneralWin32/Linux.h verschoben
- PLTTimer: Anpassung an unseren 端blichen Stil, die Basisklasse ist nun abstrakt, da es kaum sinnvoll ist, diese direkt
  zu instanziieren (es gibt ja auf jeder Plattform eine systemspezifische Implementierung). Die Konstrukturen/Destruktoren
  sind nun protected (nicht unbeding n旦tig, aber einheitlich), und auch die Basisklasse besitzt Konstruktur/Destruktor
  wobei der letztere virtuell ist, da die Klasse virtuelle Methoden besitzt. Auch hier wurde die Definition von PLTTimer
  verschoben
- PLTPlatform: Neue Klasse, welche plattformabh辰ngige Systemfunktionen enth辰lt. Der Einfachheit halber, und weil man es
  vom Namen her sowieso so erwarten k旦nnte, habe ich PLTSystem einfach von dieser Klasse abgeleitet - damit braucht man
  sich nicht mehr 端berlegen, wer wo eine Instanz davon erzeugen k旦nnte sondern bekommt diese bei PLTSystem::GetInstance()
  ja gleich mit (nur f端r die Doku ist es nicht so sch旦n, weil die Systemfunktionen nicht direkt in PLTSystem dokumentiert
  sind, allerdings sollten diese Funktionen sowieso nicht von einer Applikation verwendet werden, da wir ja alles sch旦n
  mit unserem eigenen System abgekapselt haben). Auch die Timerfunktionen sind jetzt in PLTPlatform zu finden - fragt
  sich ob das so gut ist, wenn ja m端ten wir eigentlich auf die Unterteilung der Timerklassen verzichten k旦nnen, oder?
- PLTSystem: Zum Zugriff auf dynamische Bibliotheken wird jetzt PLTPlatform verwendet, womit PLTSystem jetzt hoffentlich
  plattformunabh辰ngig ist



>> 21.12.2004
[CO]
- Behob kleines Problem in PLTBase::GetVars() mit dem vergleichen von Default-Werten - denn z.B. bei float-Werten k旦nnen
  u.a. am ende noch diverse Nullen sein - um solche Probleme zu verhindern wird zuerst der aktuelle Wert der Variable gespeichert,
  dann wird der Default Wert gesetzt welcher dann wieder als String ausgelesen wird, anschlieend wird der Variable Wert wieder
  auf seinen aktuellen Wert gesetzt - und nun hat man zwei vergleichbare Strings welche bei float Zahlen am Ende gleich viele  
  Nullen haben wodurch korrekt gepr端ft werden kann ob dies wirklich der Default Wert ist.
  -> bei pVar->Set() ist es an dieser Stelle unn旦tig und vielleicht auch etwas Riskant das in Set() pObject->VarChanged(m_szName);
     aufgerufen wird, vielleicht k旦nnte man es hier noch etwas sch旦ner machen - hab aber die Finger davon gelassen da es ansonnsten
     zu viele nderungen geworden w辰ren... Stefan, wenn du Zeit und Lust hast kannst du ja mal schaun wie man das besser L旦sen
     k旦nnte. :)
- Bei PLTBase::ToString() -> pszBuffer[nCopy+1] zu pszBuffer[nCopy] gemacht da das letzte Zeichen ansonnsten Schrott war :(
- PLTIterator um Funktionen erweitert um zum vorherigen Element zu springen, dies ist hin und wieder n旦tig wenn z.B. w辰hrend
  der Iterator verwendet wird ein Element aus der Liste gel旦scht wird, in dem Fall muss man den Iterator um ein Element 
  zur端cksetzen und ganz nebenbei wird nun endlich auch pPreviousElement in PLTList verwendet.
  (Previous() brauchte ich zum ersten mal in GuiSys::Update())
- PLContainer: AddAtIndex() ist Index = -1 wird nun am Ende eingef端gt (wie fr端her)



>> 19.12.2004
[SB]
- Containerklassen in PLGeneral eingebaut, dabei die alten Klassen umbenannt, damit diese noch verwendet werden k旦nnen
  und schrittweise umgestellt werden kann
- Iteratoren: Remove() entfernt, ein Iterator dient nun nur noch zum Anschauen der Container, nicht zum ndern. Dadurch
  ist es auch m旦glich, Iteratoren von const-Listen zu erhalten, dies ging vorher leider gar nicht
- Container: Jeweils einen operator= hinzugef端gt, welcher die selbe Klasse als Parameter erwartet. Dies scheint leider
  n旦tig, da der Compiler diese Methode anscheinend implizit verwendet und nicht die vorhandene Methode mit PLTContainer
  als Parameter verwendet, wenn beide Operanden vom selben Typ sind (bei z.B. *pList = *pArray geht es dagegen!)
- PLGeneral: Auf neue Containerklassen umgestellt. Zun辰chst ist dies nur eine 1:1 Umstellung, also noch keine Verbesserung
  der Interfaces was Listen/Container angeht, dies wird im n辰chsten Schritt passieren (erstmal sehen, ob alles noch
  funktioniert)
- RTTI: Kleinen Fehler bei der Registration von Modulen behoben. Wenn ein Module zuerst registriert wird, bevor Klassen
  aus diesem Modul registriert worden sind, war die ModuleID noch nicht gesetzt worden, was dazu f端hrte da die Klassen
  nicht dem Modul zugeordnet werden konnten. Da man auf die Reihenfolge der Initialisierungen keinen Einflu hat (das
  macht der Compiler), kann dies mal so und mal so passieren, es mu also in beiden F辰llen funktionieren - und ich hatte
  es auf den worst-case ausgelegt, so da der best-case fehlerhaft war ;-))



>> 19.12.2004
[CO]
- PLTFSTools: Um GetPathInfix() erweitert damit es vollst辰ndig ist. (prefix, infix & postfix :)
  Wollte das zuerst in GuiSys::SaveWindows() verwenden, dort reicht aber schon GetPathPrefix().



>> 18.12.2004
[CO]
- PLTVar::SetFlagsString(): Kleine zus辰tliche Abfrage eingebaut damit bei Flags am anfang kein '|' steht.
- PLTVar: Musste m_szEnum vergr旦ern da z.B. bei GuiSlider mehr Zeichen ben旦tigt werden (hab lustige fehler am ende :)
- PLTFile::PrintLn() musste Buffer etwas vergr旦ern da es oft nicht reichte - vielleicht finden wir da bei Zeiten ne bessere
  L旦sung f端r die Dynamische bergabe von Strings - f(char *text, ...)



>> 18.12.2004
[SB]
- PLTClass:  Constructor und Destructor sind jetzt protected, da ja nur die Klassen selber eine Instanz von sich erzeugen
             sollen und diese dann selbst辰ndig am System anmelden
- PLTModule: Die Informationen 端ber das Modul wurden in zwei Teile aufgeteilt, einmal dem Info-Teil bestehend aus
             Name/Vendor/Description, und dem Handle-Teil, bestehend aus ModuleID, Instance-Handle und Dateinamen
- PLTSystem: Neue Funktion zum Registrieren von Modulen eingebaut. Ein Modul wird erzeugt, sobald die erste Klasse aus
             diesem Modul registriert wird, dann wird auch die Module-ID zugeordnet, danach kann dann diese Funktion
             verwendet werden, um die Informationen 端ber dieses Modul zu setzen
- PLTSystem: Einige Umstrukturierungen sowie Namens辰nderungen der Funktionen, die Funktionen zum Registrieren sind nun
             protected, womit das ganze wenigstens halbwegs sauber ist ;-)
- RTTI:      Makros zum Registrieren von Modulen so angepat, da diese sich per Selbstinitialisierung nun ebenfalls beim
             System anmelden, um ihre Informationen zu 端bertragen. Dadurch k旦nnen nun sowohl interne als auch plugin-module
             registriert werden, die Makros wurden daf端r entsprechend angepat und erweitert
- PLGeneral: Hauptdatei PLGeneral.cpp hinzugef端gt, in welcher das PLGeneral-Modul registriert wird



>> 15.12.2004
[CO]
- Neue Listen-Klassen geschrieben welche die alten ersetzen werden. Es gibt nun eine universelle abstrakte Klasse namens
  PLTContainer. PLTList, PLTArray und PLTBitset werden davon abgeleitet. Desweiteren gibt es eine universelle Iterator
  Klasse f端r die es jeweils pro Listen-Art eine spezielle Variante gibt. Die Codes hab ich noch nicht in PLGeneral 
  geladen da Stefan die Anpassungen in PLGeneral & PLGui vornehmen wird.



>> 13.12.2004
[CO]
- PLConfig.h: PLTConfigGroup eingef端hrt, alle Configurations Gruppen sollten davon abgeleitet werden.



>> 13.12.2004
[SB]
- Module:    Es gibt nun f端r jedes Module eine eindeutige ModuleID, welche von PLGeneral und nicht vom System vergeben wird.
             ber diese ID sollten die einzelnen Module angesprochen werden, da dies auf jeder Plattform funktioniert,
             die System-Handles sollten nur noch dann verwendet werden, wenn z.B. ein Modul wieder entladen werden soll,
             was jedoch innerhalb von PLTSystem passiert (es d端rfte also eigentlich gar keinen Grund geben, das System-Handle
             anstatt der ModuleID zu verwenden).
- Module:    Klasse 端berarbeitet, so da nur PLTSystem die wichtigen Daten der Klassen 辰ndern kann sowie Zugriff auf die
             darin enthaltenen Klassen hat. Ebenso einige nderungen bez端glich der Daten, da bei neuen Module zun辰chst
             nur die ModuleID bekannt ist, w辰hrend die anderen Daten (Dateiname, Name, Vendor) erst sp辰ter bekannt
             werden. Btw: Es hat seinen Grund, da der Name nur Module und nicht PLTModule ist :-)
- PLTClass:  Anstatt des Module-Handles besitzt die Klasse nun nur noch die ModuleID ihres Modules
- PLTSystem: Auch hier wurden die Module-Handles durch Module-IDs ausgetauscht. Auerdem besitzt diese Klasse nun eine
             Methode, um die eindeutigen IDs zu erzeugen, dies wird von den RTTI-Makros benutzt um f端r jedes Modul
             eine eigene ID zu erhalten
- RTTI:      Die Makros wurden so ge辰ndert, da sie pro Modul eine eindeutige ID erhalten und diese in ihren Klassen
             vermerken. Damit ist das System in der Lage, jede Klasse einem eindeutigen Modul zuzuordnen, auch wenn
             das System-Handle dieses Modules zur Zeit der Registrierung noch nicht bekannt ist (was leider immer
             der Fall ist, deswegen kann nicht einfach die HINSTANCE durchgereicht werden). Um dies zu erreichen,
             speichert eine Template-Klasse die ModuleID, welche sie vom System bekommen hat, und gibt diese an
             die Klassen weiter. Sp辰ter setzt das System die zugeh旦rigen Daten wie System-Handle, Dateinamen etc.
             im Modul, so da diese Daten angezeigt werden k旦nnen. Anmerkung: Dieses Vorgehen f端hrt dazu, wirklich
             jedes Modul seine eigene ID bekommt, auch alle nicht dynamisch geladenen, dadurch sind also
             PLGeneral/PLEngine/PLGui/etc. unterschiedliche Module, welche allerdings erstmal alle den Namen
             "Internal" bekommen (wie kann man von loadtime-gelinkten DLLs den Namen herausbekommen?). Ob das ein
             Vor- oder Nachteil ist, kann unterschiedlich sein, wenn jemandem einf辰llt, wie man anders die Module
             und Klassen zuordnen kann, bitte sagen :-)
- PLTClass:  Der Gruppenname wurde entfernt, daf端r kann jede Klasse als Basisklasse einer Gruppe definiert werden, welche
             dann alle abgeleiteten Klassen enth辰lt
- RTTI:      Das Makro DEFINE_GROUP() angepat
- PLTSystem: Gruppen wurden entfernt, daf端r kann bei GetClassList() die Basisklasse angegeben werden. Zus辰tzlich k旦nnen
             alle als Gruppen definieren Klassen zur端ckgegeben werden



>> 12.12.2004
[CO]
- Bei der Klasse Module fehlten noch ein paar PLGENERAL_API - vielleicht sollte man diese Klasse bei Zeiten in 
  PLTModule umbenennen damit es einheitlich ist.
- PLTSystem::UnloadPlugin() -> Nur Dynamische Module k旦nnen entladen werden
- PLTSystem::ScanPlugins() -> verwendet nun LoadPlugin() um die Module einzuladen
- PLTSystem::LoadPlugin() -> Module werden nun korrekt regestriert
- IsClass(), IsClassGroup() und IsModule() - hm, vielleicht w辰re ne art von Iterator Klasse nicht schlecht damit das 
  端berall einfach Einheitlich ist :)



>> 30.11.2004
[SW]
- PLGeneral: linux port + project archiv upgedated



>> 29.11.2004
[SB]
- PLTBase: Der Destruktor ist nun wieder protected, da dies unbedingt n旦tig ist, wenn das ganze RTTI System 端berhaupt
           einen Sinn machen soll. Das Problem ist, wenn der Destruktor in PLTBase 旦ffentlich ist, kann jede Klasse
           damit gel旦scht werden, es besteht f端r die Klasse also keinerlei M旦glichkeit mehr, dies zu verhindern. Damit
           wird die Verwendung von DEFINE_CLASS_PRIVATE() nutzlos, und alle Sicherheitsvorkehrungen von abgeleiteten
           Klassen k旦nnen damit umgangen werden: z.B. PLTRefCount ist so angelegt, da es sich nur selber l旦schen
           kann, wenn der RefCount auf 0 sinkt, dies stellt sicher da das Objekt niemals gel旦scht werden kann, wenn
           es noch irgendwo gebraucht wird. Wenn nun aber PLTBase einen 旦ffentlichen Destruktor hat, wird es
           m旦glich, dieses Verhalten von PLTRefCount zu umgehen und das Objekt von auen ungeachtet des RefCounts
           zu l旦schen, was nat端rlich gravierende Fehler zu Folge haben k旦nnte. In PLTBase ist dies nun auerdem
           n辰her erleutert, warum Constructor und Destructor von PLTBase protected sind :-)
- RTTI:    Habe das RTTI nun so erweitert, da ein Objekt mit PLTBase::Destroy() gel旦scht werden kann, FALLS dessen
           Klasse mit DEFINE_CLASS() und nicht mit DEFINE_CLASS_PRIVATE() definiert wurde. Auf diese Weise kann
           man ein Objekt nur mit Hilfe eines PLTBase-Pointers l旦schen, aber nur wenn die Klasse dies explizit
           erlaubt, denn dies ist wichtig um die Wahl bei den Klassen zu belassen (s.o.).
           Hierzu waren einige nderungen in PLTBase, PLTClass und PLRTTIDefs notwendig



>> 26.11.2004
[CO]
- PLTBase: Musste Destruktor public machen damit ich Klassen Instanzen von denen ich nur einen Zeiger auf 
  PLTBase habe auch wieder zerst旦ren kann. Ich hoffe das ist ok so - ich fand keine andere m旦glichkeit...
  (siehe PLTConfig::~PLTConfig())
- Neues Configuration-System PLTConfig als Singleton implementiert. Dieses Config-System verwendet das RTTI
  und l辰sst sich daher sehr einfach bedienen und erweitern. Load() & Save() ist noch nicht implementiert,
  ansonnsten funktioniert alles.
          


>> 24.11.2004
[CO]
- Neue Datenstruktur: PLTHeap welche als Priorit辰tswarteschlange verwendet werden kann. Bereits implementierter
  konkreter Heap: PLTHeapBinary. Ich entschloss mich zu dieser abstrakten Template realisierung damit der Schl端ssel
  und der damit verbundene Wert sowie die konkrete Implementation m旦glichst universell sind.



>> 21.11.2004
[CO]
- PLTQuickSort: QuickSort Algorithmus der sp辰ter u.a. zum sortieren der Partikel verwendet wird. Ich hab versucht
  die Klasse so allgemein wie m旦glich zu halten, die Compare Funktion wird 辰hnlich wie in Java 端ber eine abgeleitete
  Klasse implementiert. L辰sst sich im Prinzip also genauso verwenden wie das bereits in VC vorhandene qsort - aber
  ich denke es ist das beste wenn man da was eigenes hat, man weis ja nie... ;-)



>> 21.11.2004
[SB]
- PLMain.h: Diese Datei beinhaltet nun einen plattformunabh辰ngigen Einstiegspunkt f端r die Programme. Die L旦sung per Makro
  war zwar eine gute Idee, jedoch nicht wirklich praktikabel, da ein Zugriff auf Programmparameter und Optionen damit 
  faktisch unm旦glich gemacht worden w辰re, denn diese Parameter w辰ren nach wie vor je nach System unterschiedlich gewesen.
  Auch fand ich die Verwendung dieser Makros nicht sonderlich sch旦n, da innerhalb eines Makros-Blocks dann der
  Funktions-Quellcode gestanden h辰tte, man aber gar nicht gewut h辰tte, wie diese Funktion nun wirklich aussieht.
  Ein Programm, welches die plattformunabh辰ngige Einstiegsfunktion verwenden will, mu nun einfach PLMain.h einbinden
  und die Funktion PLMain deklarieren, die Parameter dieser Funktion sind dabei nun wirklich auf jedem System gleich,
  da sie je nach OS unterschiedlich implementiert wird.
  Es mu nat端rlich darauf geachtet werden, da PLMain.h nur ein einziges Mal in eine .cpp Datei eingebunden wird, da
  ansonsten die Einstiegsfunktion f端r das System mehrfach im Programm vorhanden w辰re und es dann beim Linken nat端rlich
  einen Fehler g辰be. Dies sollte aber kein Problem darstellen, wenn dies einfach in der main.cpp verwendet wird, wie
  es wohl nat端rlicher Weise der Fall sein sollte.
- PLRTTIDefs.h: Makros f端r den Programm Einstiegspunkt entfernt



>> 20.11.2004
[CO]
- PLRTTIDefs.h: Makros f端r den Programm Einstiegspunkt hinzugef端gt. (DEFINE_MAIN/END_MAIN) Diese sind zwar Optional, sollten aber
  IMMER verwendet werden damit man Plattform unabh辰ngig bleibt ohne sich immer selbst drum k端mmern zu m端ssen.



>> 19.11.2004
[CO]
- PLTTimer zum Singleton gemacht, PLTTimer in PLTTimerBase umbenannt und PLTTimer definiert das wie beim Gui automatisch jeweils korrekt
  je nach Plattform definiert wird so das man sich nicht mehr drum k端mmern muss. Hab auch gleich die Linux Variante mit angepasst,
  Stephan - bitte gleich mal pr端fen ob ich nicht fehler reingemacht hab. :)
  Passte gleich alle Codes an so das der Renderer nun endlich von der Engine selbst unabh辰ngig sein kann.
- PLTLog: Ein paar kleine nderungen gemacht, z.B. wird nun bei PLTLog::OutputString(const char *pszText) direkt in die Datei geschrieben
  damit man keinen Crash bekommt wenn der String l辰nger als 1024 ist. Bei den mit ,... gehen wir einfach momentan noch aus das diese Strings
  nicht ZU lang werden. ;)
- PLTFile: PutC() -> Parameter mit const versehen



>> 18.11.04
[SW]
- Bis auf das FS auf linux portiert und ein paar kleine include fehler behoben (pfadangaben)



>> 15.11.2004
[SB]
- PLTPluginManager wurde wieder ausgebaut, und dessen Funktionalit辰t nach PLTSystem verschoben. Dies ist sinnvoller
  und vor allem f端r den Programmierer einfacher, da PLTSystem besser zwischen den Klassen und den Modulen verkn端pfen
  kann - das w辰re mit einer getrennten L旦sung kaum m旦glich gewesen, da die Libraries und die Klassen damit scheinbar
  voneinander getrennt gewesen w辰ren. Da PLTSystem nun aber beides managed, kann es die Klassen gleich den entsprechenden
  Modulen zuordnen und bietet so auch f端r den Programmierer einen flexibleren Zugriff auf diese Informationen.
  PLTSystem ist jetzt also eine 端bergeordnete Klasse, die der Programmierer nutzen kann um auf Klassen und Bibliotheken
  zuzugreifen sowie alle Plugins zu managen, ohne dabei die Struktur der Applikation oder der Plugins festzulegen.
- PLTSystem wurde noch einmal in groen Teilen umgebaut, und ist nun sowohl einheitlicher als auch komfortabler.
  Dabei gibt es f端r Klassen, Gruppen und Module jeweils eine Methode GetXXXList(), um alle Objekte des Typs aufzulisten,
  sowie eine Methode GetXXX(), um einzelne Objekte per Name bzw. ID anzusprechen. Es ist jetzt also m旦glich, alle
  Klassen, Gruppen oder Module aufzulisten sowie deren Zugeh旦rigkeiten untereinander zu erkennen. Die Methode
  GetClassList() wurde dabei so erweitert, da entweder alle Klassen, oder alle Klassen einer Gruppe und/oder eines
  Moduls aufgelistet werden k旦nnen, was die Einordnung der Klassen wiederum vereinfacht. Intern wurden die Methoden
  vereinheitlicht, auerdem sind die Add/Remove Methoden nun protected und k旦nnen also nicht mehr wie vorher von
  auen aufgerufen werden, was h辰tte mibraucht werden k旦nnen.
- Die wahnwitzigen RTTI-Makros wurden noch einmal umgebaut, indem die Register-Funktionen nun nicht mehr Teil der
  zu registrierenden Klasse sind, sondern Teil der geschachtelten Info-Klasse. Durch Ableitung von der Basisklasse
  PLTClass und Aufruf der darin deklarierten Basisfunktionen _Register und _Unregister kann die Klasse dann bei PLTSystem
  angemeldet werden. Dieser weitere Trick dient nur dazu, die Add/Remove-Methoden von PLTSystem nach auen abzuschotten
  und als protected zu deklarieren, damit diese nicht beliebig aufgerufen werden k旦nnen.
- Da sich die RTTI-Makros ver辰ndert haben, m端ssen s辰mtliche Projekte, welche diese verwenden, neu 端bersetzt werden, damit
  die Klassen vom aktuellen System korrekt registriert werden k旦nnen. Dies sollte jedoch in der Zukunft nicht mehr so
  oft vorkommen :-)



>> 06.11.04
[SB]
- PLGeneral: Das Template PLTShared wurde gel旦scht, die Idee war zwar nicht schlecht, h辰tte aber zu mehr Verwirrung gef端hrt
  als da es Nutzen gebracht h辰tte. Es gibt nun also nur noch Singletons, welche nur eine globale Instanz der Klasse
  erlauben, dies gilt z.B. f端r Syste, FileSystem, Log, etc. Die Klassen sollten also so strukturiert werden. da entweder
  beliebig viele Instanzen m旦glich sind (wie z.B. bei der Gui), oder nur eine globale Klasse, um eine saubere Struktur
  zu bewahren.
- PLGeneral: Neue Klasse PLTPluginManager eingebaut, welche das Laden und Verwalten von Plugin-DLLs 端bernimmt. Dabei wird
  端berpr端ft, ob eine DLL bereits geladen wurde und ob debug/release Modus 端bereinstimmen. Das Scannen einen Verzeichnisses
  nach Plugins wird zun辰chst von der Engine aufgerufen, jedoch kann ein Programm auch weitere Verzeichnisse Scannen.
  Zur Definition von Plugin-DLLs wurde PLRTTIDefs.h um entsprechende Makros erweitert.



>> 05.11.04
[SB]
- PLTRefCount: Abfrage des counts ist nun eine const-Funktion
- PLTFileSystem: Ist nun wieder ein singleton, es kann also nur eine einzige Instanz davon geben, die von allen
  Programmteilen verwendet werden mu. Dies ist aber kein Problem, da die Verwaltung von Suchpfaden nun doch
  nicht zentral im FS stattfinden wird, da dies einfach zu komplex geworden w辰re (vor allem auch die Verwaltung
  durch den Programmierer, denn die Implementierung war ja bereits komplett).
- PLTFileSystem: Beim erstellen des FS wird nun das aktuelle Verzeichnis vom OS 端bernommen
- PLTFSTools: GetFileName() gibt den Dateinamen aus einem kompletten Pfad zur端ck (splitpath() 辰quivalent)
- PLTWin32Directory: Bei Angabe von "." wird das aktuelle Verzeichnis vom OS genommen
- PLTLog: Ist ebenfalls wieder ein Singleton, zur Unterscheidung verschiedener Logs wird diese Klasse entsprechend erweitert



>> 27.10.04
[CO]
- Behob kleinen 'Fehler' in den Vektor und Farb Klassen welche Offset Probleme im zusammenspiel mit dem RTTI erzeugten.
  Heute dazugelernt: "Vorsicht beim umgang mit this Zeigern!" ;-)
  Desweiteren ist es beim RTTI erfordlich das ALLE von PLTBase abgeleiteten Klassen virtuelle Destruktoren haben da es 
  ansonnsten bei delete [] zu einem Crash kommt - ebenfalls in PLTBase Notiert.



>> 15.10.04
[SB]
- PLTStack2: Da leider jedes Mal, wenn ich die Stack-Klasse benutzen will, irgend etwas nicht funktioniert, habe ich
  eine neue, sehr einfache Stack-Klasse geschrieben, welche auch wirklich nur das tut, was von einem Stack erwartet
  wird und daf端r hoffentlich stabiler ist als die bisherige Klasse. Implementiert sind die Standardmethoden eines
  Stacks, Push()/Top()/Pop(), sowie noch eine Extramethode PushBack(), um ein Element an das andere Ende des Stacks
  anzuf端gen (dies ist vor allem beim Kopieren eines Stacks sehr wichtig). Ansonsten ist der Stack als einfache
  verkettete Liste implementiert, was vollkommen ausreicht da ja nur auf das Top-Element des Stacks zugegriffen werden
  kann, worauf immer ein direkter Zeiger existiert. Ein beliebiger Zugriff auf alle Elemente des Stacks ist also nicht
  implementiert und sollte auch nicht gebraucht werden, f端r einen solchen Fall sollte entweder eine Liste oder eine
  Array-Klasse verwendet werden. Dann ist auch endlich gegeben, da sich die Containerklassen wirklich voneinander
  unterscheiden und somit je nach Situation optimal eingesetzt werden k旦nnen.
  Die alte Klasse PLTStack sollte nun 端berall durch PLTStack2 ersetzt werden, oder durch eine andere Containerklasse,
  falls die Stackoperationen nicht ausreichend sind f端r einen bestimmten Fall, danach sollte die alte Klasse gel旦scht
  werden und die neue Klasse in PLTStack umbenannt werden. Die zwei Klassen sollen also nur vor端bergehend nebeneinander
  existieren, um die Anpassung zu erleichtern
- PLTTokenizer: Auch hier habe ich zun辰chst nderungen vorgenommen, ohne die alte Version davon zu entfernen, damit die
  entsprechenden Stellen problemlos angepat werden k旦nnen. Die Methoden Push()/Pop() implizieren schon vom Namen her
  eine Stack-Funktionalit辰t, die sie dann jedoch nicht bieten, da nur ein einziger State gespeichert werden kann. Solche
  Dinge sind es aber, die sp辰ter andere Programmierer, die mit PL arbeiten wollen, in den Wahnsinn treiben werden, denn
  ein Programmierer wei, was er von einer Push()/Pop() Methode erwarten kann und wird nicht auf den Gedanken kommen, 
  da der Name vielleicht zu viel verspricht. Ich habe daher einen echten Stack in den Tokenizer eingebaut sowie
  Funktionen, um auf diesen zuzugreifen. Mit PushState() kann der aktuelle Status des Tokenizers auf dem Stack gespeichert
  werden, mit PopState() wird dieser wiederhergestellt oder mit DropState() vom Stack verworfen. Damit ist ein einfacher
  recursive-descent parser, der nat端rlicher Weise mehr als einmal den Status speichern mu, also sehr leicht zu schreiben.
  Auch hier sollten die alten Methoden entfernt werden und durch die neuen ersetzt werden, sobald alle Stellen angepat
  sind, wo dies verwendet wird. Sollten die alten Methoden aus irgend einem Grund erhalten bleiben, k旦nnten sie z.B. in
  SaveState()/RestoreState() umbenannt werden, was auch ihrer Funktionalit辰t entspr辰che.



>> 08.09.2004
[CO]
- PLTArray um const [] erweitert



>> 05.09.2004
[CO]
- PLVar.h: Zwei Includes hinzugef端gt



>> 29.08.2004
[SB]
- PLTRefCount: GetRefCount() ist nun const
- PLTVar besitzt nun eine Funktion, um eine Zeiger auf die Variable selbst zu erhalten. Da der Variablentyp nat端rlich nicht
  bekannt ist, ist der R端ckgabewert ein void* Zeiger. Diese Funktion sollte nat端rlich nur mit gr旦ter Vorsicht verwendet
  werden, da man hiermit quer im Speicher rumschreiben kann. Auch alle Sicherheitsmechanismen wie readonly-variablen k旦nnen
  mit dieser Funktion nat端rlich umgangen werden. Dennoch war eine solche Funktion n旦tig, um z.B. bei Variablen von Typ
  PL_VAR_CLASS an den Klassennamen heranzukommen (hierzu mu man sich den Zeiger auf das Objekt zur端ckgeben lassen und dann
  mit PLTBase::GetClassName() den Klassennamen ermitteln). Hierzu viel mir leider bisher kein besserer Weg ein...



>> 28.08.2004
[CO]
- F端gte PLTList<AType>::Add() noch einen Parameter hinzu mit dem man bei bedarf verhindern kann das gepr端ft wird ob etwas bereits
  in der Liste ist. Bei GuiListBox war es t旦tlich wenn extrem viele Elemente eingef端gt wurden - da war der Aufwand ganz enorm so das 
  es teils viele Sekunden dauerte bis alles eingef端gt war. :(
  Durch das deaktivieren des Tests geht es zwar nur etwas flotter, aber immerhin.
  


>> 26.08.2004
[SB]
PLGeneral:
- Habe PLGeneral.h umgebaut: Hier werden nun die OS-Spezifischen include-files eingebunden, so da die Verwendung m旦glichst
  auf allen Betriebssystem identisch ist. Bei einer Portierung wird also einfach eine neue .h-Datei hinzugef端gt und
  in PLGeneral.h mit den entsprechenden #ifdef's eingebaut. In PLGeneralWin32.h und PLGeneralLinux.h sind nun f端r das
  jeweilige Betriebssystem die import/export Makros sowie  die Datentypen definiert.
  Die Unterscheidung zwischen Import und Export geschieht nun nicht mehr 端ber unterschiedliche .h Dateien sondern
  端ber eine Compilerdefinition (welche von VC++ automatisch gesetzt wird, diese m端te dann nur f端r Linux in die
  Makefiles eingebaut werden)
- Datentypen angepat, es werden nun nur noch die n旦tigsten definiert: int32, uint32, etc. Diese sollten nur da verwendet
  werden, wo es auf die Bitgr旦e des Datentyps explizit ankommt, also meist bei Dateizugriffen. Ansonsten sollten nur
  noch die primitiven Datentypen, also z.B. int, long, ... verwendet werden (f端r Flags z.B. unsigned long). Da DWORD/WORD
  von vielen als Windows-Datentypen verstanden werden, die man nicht braucht, habe ich mich f端r die Bezeichnung
  int16/int32/int64 entschieden, um klarzumachen da es nur um die Bitgr旦e der Datentypen geht.
- PLTypes.h: Alle immer wieder verwendeten Datentypen/Definitionen der Engine befinden sich nun in dieser Datei,
  statt wie vorher noch in PLEngine. Da PLGeneral von den anderen Teilprojekten eingebunden wird ist dies besser,
  so mu PLEngine nicht mehr eingebunden werden, um z.B. die Definitionen f端r X/Y/Z verwenden zu k旦nnen, wie dies
  bisher der Fall war
- Dummerweise vergessene PLGENERAL_API in PLTVar eingef端gt :-)
RTTI:
- PLTSystem: Fehler bei den ClassGroups behoben: Da "" nicht als g端ltiger Hash-String gilt, wird nun ein Dummy-GroupName
  verwendet, um Klassen ohne Gruppe zu bezeichnen
- SelfInit-Class so erweitert, da Klassen auch wieder automatisch ausgetragen werden, wenn das entsprechende Modul
  entladen wurde. Wenn kein SelfInit verwendet wird, mu der Programmierer stattdessen das Makro UNREGISTER_CLASS verwenden.
  Wie er mitbekommt, da seine DLL entladen wurde, ist dann allerdings sein eigenes Problem ;-)



>> 18.08.2004
[CO]
- PLTBase::ToString: Behob String Problem, der Zeiger auf den Speicher wurde ung端ltig da das String Objekt nach ToString() wieder
  zerst旦rt wurde und auch den String-Speicher selbst dabei killte.
- PLTSystem: Zwei neue Funktionen: GetVarType() & GetVarTypeAsString()



>> 10.08.2004
[SB]
- Neuer Variablentyp PL_VAR_PLSTRING zum Zugriff auf Variablen vom Typ PLTString eingebaut
- PL_ENUM Makros ver辰ndert: Der enum-string steht nun doch am Ende des Makros, da dies die Variablendefinition 端bersichtlicher gestaltet



>> 08.08.2004
[SB]
- PLTClass: Der Methode CreateInstance kann nun angegeben werden, ob die Variablen des erzeugten Objektes automatisch auf
  ihre Default-Werte gesetzt werden wollen, dies ist nun auch das Standardverhalten von CreateInstance().
- PLTBase: Neue virtuelle Methode VarChanged() eingebaut, diese wird aufgerufen wenn der Wert einer Variablen durch das
  RTTI ver辰ndert worden ist, um ggf. n旦tige Aktionen nach dem Ver辰ndern einer Variable durchzuf端hren



>> 07.08.2004
[SB]
- PLTBase, PLTClass: GetVarList(List, true) gibt nur die Variablen der eigenen Klasse zur端ck, ohne die von Basisklassen
  vererbten
- PLTVar::GetClass() gibt zur端ck, in welcher Klasse die Variable deklariert wurde
- Mittels DEFINE_ENUM k旦nnen Aufz辰hlungs-Variablen registriert werden. Als Typ kann hier entweder PL_VAR_ENUM oder
  PL_VAR_FLAGS angegeben werden. Das Setzen der Variablen kann entweder 端ber die numerischen Werte oder 端ber die
  enum-Namen erfolgen: z.B. Set("2|4"); Set("beta"); Set("Read|Write");



>> 06.08.2004
[SB]
- PLTypes.h erweitert, so da die Definitionen an anderer Stelle komplett entfallen k旦nnen. Die verwendeten Datentypen
  sollten jedoch noch einmal komplett 端berarbeitet werden
- Log-Ausgaben wieder eingebaut, dazu wird nun das "shared"-Log verwendet. Zur Zeit wird dieses jedoch nirgendwie aktiviert,
  deshalb verschwinden die Logausgaben im Nirvana :-)
- RTTI System erweitert:
  - Klassen beinhalten nun auch die Variablen ihrer Basisklassen
  - Es wird nun mit m_nBaseOfs auch der Offset zu PLTBase gespeichert, damit die Variablen auch dann noch korrekt gesetzt
    werden k旦nnen, wenn eine Klasse nicht als erstes PLTBase in der Ableitungsliste stehen hat
  - DEFINE_VAR_READONLY erlaubt das Definieren von Variablen, die nur gelesen aber nicht ver辰ndert werden k旦nnen
  - REDEFINE_VAR erlaubt das "berschreiben" von Variablen in abgeleiteten Klassen, dabei k旦nnen DefaultValue,
    Description und Annotation ver辰ndert werden



>> 05.08.2004
[CO]
- Den Ordner Tools in PLTools umbenannt. Beim Includieren w辰re es am ende unsch旦n wenn man #include <Tools/...> schreiben
  w端rde, da vermiss ich irgendwie das PL davor... und so musste ich die anderen Codes nicht an die verschiebung von PLTools
  in PLGeneral anpassen. ;-)
  Vielleicht sollten wir auch die anderen Ordner entsprechend anpassen damit es einheitlich ist. 
  (wieder so ne dumme Namensgeschichte ;-)
- Bei ein paar Headern in PLTools noch PLGeneral.h eingebunden - bei der Gelegenheit ging ich gleich alle Includes unserer
  Projekte durch und passte alles an. (waren ja in letzter Zeit einige nderungen)
  Nun sieht man z.B. sch旦n wie die Libs aufeinander aufbauen da alles geordnet ist.
- PLTimerWin32.inl & PLTimer.inl gel旦scht da die inlines dort nicht so doll sind (was dachte ich mir fr端her dabei? :-)
- PLTypes.h von der Engine in PLGeneral verschoben, musste PLTypes in z.B. PLList.h einbinden da in der Engine teils
  NULL unbekannt war da windows.h dort nicht eingebunden werden musste



>> 04.08.2004
[SB]
- PLTDestructionManager eingebaut. Diese Klassen sorgen daf端r, da Instanzen von Singleton- oder Shared-Klassen am
  Ende der Programmausf端hrung auch wieder gel旦scht werden. Die Implementierung ist relativ kompliziert, da man
  hierbei wieder sehr mit der Compiler- und Exportproblematik herumschlagen mute. Die Funktionsweise des Systems:
  - Statische Initialisierung wird durch Singleton::GetInstance() vermieden, dies ist n旦tig damit die Klassen sich
    端ber Selbstinitialisierung beim Programmstart bei PLTSystem anmelden k旦nnen. W辰re PLTSystem eine statische
    Variable, k旦nnte dies zu Problemen f端hren, wenn PLTSystem noch nicht initialisiert wurde
  - Jede Instanz von PLTSingleton und PLTShared meldet sich beim PLTDestructionManager an. Dies ist m旦glich, da
    PLTDestructionManager selbst ein Singleton ist und daher bei der ersten Verwendung erzeugt wird
  - Am Ende m端ssen alle Instanzen wieder gel旦scht werden. Dazu dient die einzige statisch Variable
    PLTDestructionGuard::Instance, deren Destructor am Ende des Programmes automatisch aufgerufen wird. Diese l旦scht
    die Instanz von PLTDestructionManager, welche wiederum alle bei ihr angemeldeten Objekte l旦scht. Auf diese
    Weise werden alle erzeugten Instanzen auch wieder automatisch gel旦scht :-)



>> 03.08.2004
[SB]
- Neues Verzeichnis PLTools, hier befinden sich nun allgemeine Tool-Klassen
- PLTTokenizer nach Tools verschoben
- Klassen aus PLEngine nach PLGeneral verschoben, welche allgemein verwendet werden k旦nnen. Die Klassen sind nun
  allgemein und k旦nnen auch auerhalb der Engine verwendet werden, PLEngine-spezifischer Code wurde dabei entfernt
  und mu weitern in der Engine selbst ausgef端hrt werden (z.B. Anzeige von Informationen etc).
  Verschobene Klassen: PLTLog, PLTProfiling, PLTTimer, PLTTools



>> 02.08.2004
[SB]
- PLTRefCount nach Base verschoben und von PLTBase abgeleitet
- PLTFile: Neue Methode PrintLn eingebaut
- PLTFile: Neue Methode Flush eingebaut
- PLTWin32File und PLTZipFile angepat



>> 01.08.2004
[CO]
- PLTDynamicList: In der Engine hab es nun mit den const/nicht const etwas probleme. Hab die Warnung
  "PLTDynamicList<AType>' : multiple assignment operators specified" f端rs erste Deaktiviert da diese ansonnsten tausende male
  kam. ;-)
  Bei Zeiten m端ssten wir nochmal schaun wie wir das besser machen k旦nnen...
- PLTPool: Um Copy Operator erweitert



>> 01.08.2004
[SB]
- Neue Basisklassen PLTShared und PLTSingleton eingebaut. Dies sind Template-Klassen, welche verwendet werden k旦nnen,
  um Klassen mit nur einer Instanz (PLTSingleton) oder mit einer gemeinsamen Instanz f端r alle Programmteile (PLTShared)
  zu definieren.
- PLTFileSystem benutzt nun die neuen Basisklassen PLTSingleton und PLTRefCount
- PLTSystem: Anpassung an neue Basisklassen sowie kleinere Korrekturen
- Neue Definition PLGENERAL_TEMPLATE zum Exportieren von template-Klassen, dies mu bei allen zu exportierenden
  Template-Instanzen verwendet werden
- Verzeichnisse umbenannt



>> 30.07.2004
[SB]
- Habe das RTTI System in PLGeneral eingebaut und daf端r die vorl辰ufigen Plugin-Klassen wieder entfernt, da diese
  damit 端berfl端ssig geworden sind :-)



>> 29.07.2004
[SB]
- Die Gruppe einer Klasse wird nun mittels eines eigenen Makros gesetzt, wird dieses nicht verwendet geh旦rt die Klasse
  keiner Gruppe an
- Die Basisklassen einer Klasse werden nun in PLTClass gespeichert und k旦nnen dort abgefragt werden. Ebenso kann
  PLTBase::IsInstanceOf() als Shortcut zur Abfrage einer Basisklasse verwendet werden
- PLTBase selbst wird jetzt als Klasse registriert
- Beim Definieren einer Klasse wird nun eine interne von PLTClass abgeleitete Klasse erzeugt, welche dann in PLTSystem
  gespeichert wird. Dadurch ist es m旦glich, private Methoden von PLTClass zu verwenden sowie virtuelle Methoden
  zu 端berschreiben
- PLTClass::CreateInstance() kann benutzt werden, um eine neue Instanz einer Klasse zu erzeugen. Es mu allerdings noch
  ein Weg gefunden werden, da Klassen dieses Verhalten unterbinden k旦nnen, wenn eine direkte Erzeugung von Instanzen
  nicht erw端nscht ist
- PLTClass: Methoden zum ndern einer Klasse sind nun protected, k旦nnen von Auen also nicht mehr aufgerufen werden,
  damit sind auch die konstanten Zeiger nicht mehr von N旦ten und wurden durch normale Zeiger (PLTClass*) ersetzt
- Pointer-Truncation Warnungen wurden beseitigt, indem zur Speicherung des Offsets nun der 64Bit-Datentyp int__64
  verwendet wird
- Neues Makro: Wird DEFINE_CLASS_PRIVATE anstelle von DEFINE_CLASS verwendet, so kann die Klasse nicht 端ber
  CreateInstance() instanziiert werden. Dies ist n端tzlich f端r Klassen, die nicht beliebig instanziiert werden
  sollen und daher meits auch keinen 旦ffentlichen Standardkonstruktor besitzen
- Mittels der Compiler-Definition USE_SELFINIT kann bestimmt werden, ob die Selbstinitialisierung verwendet werden soll
- In PLTClass wird nun ein Module-Handle gespeichert, zu dem die Klasse geh旦rt



>> 28.07.2004
[SB]
- Zugriff auf Variablen vollst辰ndig implementiert und getestet
- Klassen k旦nnen nun in Gruppen eingeteilt werden, um einfach die Klassen eines bestimmten Typs auflisten zu k旦nnen. Dies
  dient nur dem Entwickler zur Einfacheren Verwaltung seiner Klassen, z.B. sollten alle Plugins eines Typs den gleichen
  Gruppennamen bekommen (z.B. PLEntities), dann kann der Plugin-Manager sich eine Liste aller Klassen dieses Typs herausgeben
  lassen um die Plugins dann zu verwenden
- PLTVar wurde doch noch einmal umgeschrieben, es ist nun nicht mehr m旦glich, mit hilfe eines PLTVar-Objekts direkt auf
  eine Instanz einer Variablen zu zeigen, da dies zu Inkonsistenzen f端hrte (PLTClass::GetVar() gab einen konstanten Zeiger
  auf PLTVar zur端ck, der nicht gel旦scht werden durfte, w辰hren PLTBase::GetVar() ein neues PLTVar Objekt erzeugte, welches
  dann wieder gel旦scht werden mute!). Die jetzt zur端ckgegebenen Objekte m端ssen grunds辰tzlich nicht mehr gel旦scht werden,
  da sie Zeiger auf feste Instanzen darstellen und nicht neu erzeugt werden. Daf端r gibt es nun Methoden in PLTVar,
  um den Wert der Variablen bezogen auf eine Instanz zu setzen: SetVar(PLTObject*, const char *pszValue)
- RTTI Interface ist nun komplett



>> 27.07.2004
[SB]
- Neue Funktionen in PLTBase: ToString() und FromString(). Mit diesen Methoden wird der Inhalt eines
  Objektes in einem String 端bergeben. Dies entspricht in wesentlichen dem VarString, jedoch kann das
  Aussehen dieses Strings von der Klasse bestimmt werden, es m端ssen also nicht die Variablennamen
  angegeben werden (die Repr辰sentation eines 3D-Vectors k旦nnte z.B. "10 20 30" sein, anstatt "X=10 Y=20 Z=30")
- Mittels PLTVar k旦nnen nun Werte von Variablen gesetzt und abgefragt werden
- Klassen werden in PLTClassRegistry gespeichert und k旦nnen dort abgefragt werden
- PLTClassRegistry wurde in PLTSystem umbenannt, da diese Klasse die allgemeine Verwaltung des Systems 端bernehmen
  wird (neben Registrierung der Klassen werden auch Plugins, Dynamic Libraries etc. in ihren Aufgabenbereich fallen,
  evtl. kann man sp辰ter auf Log etc. in PLTSystem einbetten)
- Die Klassen wurden 端berarbeitet und vereinheitlicht, z.B. wurden Unterschiede beim Zugriff auf Listen und Daten
  der Klassen beseitigt
- SelfInit-Part eingebaut, welcher die Klasse automatisch registriert
 


>> 25.07.2004
[SB]
- PLTVar 端berarbeitet, die Instanz des Objektes kann nun nur noch im Konstruktor 端bergeben werden
- Zugriff auf Variablen 端ber PLTClass implementiert



>> 24.07.2004
[SB]
- PLTVar fertiggestellt, diese Klasse beinhaltet Informationen 端ber eine Variable innerhalb einer Klasse. In PLTClass
  kann man eine Liste der registrierten Variablen abfragen, und in PLTObject k旦nnen die Werte der Variablen gesetzt
  oder abgefragt werden. Zus辰tzlich kann auch PLTVar die Instance einer Variablen darstellen, dann kann auch 端ber
  PLTVar auf die Werte der Variablen zugegriffen werden



>> 22.07.2004
[SB]
- Habe endlich einen generellen Weg gefunden, da die Variablen einer Klasse nicht mehr pro Objekt gespeichert werden
  m端ssen sondern nur noch einmal f端r jede Klasse. Bisher besa jede Instanz einer Klasse eine eigene Variablenliste,
  in der die Zeiger auf die Variablen gespeichert wurden (die Informationen 端ber die Variablen wurden nur einmal
  gespeichert, dies f端hrte jedoch dazu, da es zwei unterschiedliche Klassen f端r Variablen geben mute, was auch
  nicht sch旦n war). Dies ist nun nicht mehr n旦tig :-)



>> 21.07.2004
[SB]
- PLGeneral: PLTDynamicList und PLTList so erweitert, da diese nun auch mit konstanten Daten umgehen k旦nnen.
  Dies ist z.B. dann n端tzlich, wenn der Zugriff auf eine const PLTList/PLTDynamicList erfolgt
- RTTI System begonnen. Mit Hilfe dieses Systems wird es m旦glich sein, zur Laufzeit auf Klasseninformationen zuzugreifen,
  damit k旦nnen z.B. die vorhanden Variablen oder Methoden eines Objektes abgefragt und ver辰ndert werden, sowie
  nat端rlich generelle Informationen 端ber den Typ eines Objektes abgefragt werden.
  Das System entspricht in seiner Funktionsweise dem EntityPluginSystem, ist jedoch allgemeiner und soll um einiges
  flexibler werden. Wenn alles klappt, wird durch dieses Klassensystem auch gleich ein sehr einfach zu verwendendes
  Pluginsystem zur Verf端gung stehen, wobei die bisherigen Fallunterscheidungen nicht mehr ben旦tigt werden sollten
  (bisher mute unterschieden werden, ob eine Klasse im Hauptprojekt, in der Engine-DLL oder in einer Plugin-DLL
  deklariert wurde, dies ist nicht sehr sch旦n und kann hoffentlich vermieden werden). Auch das Scriptsystem wird
  nach der Implementierung der RTTI leicht zu entwickeln sein, da der Zugriff auf Klassen und Variablen/Methoden
  zur Laufzeit damit bereits implementiert ist :-)
  Das RTTI wird also eine Reihe von Basisklassen zur Verf端gung stellen, die in der gesamten Engine verwendet werden,
  zus辰tzlich wird es noch einige abgeleitete Klassen geben, welche f端r bestimmte Klassentypen zum Einsatz kommen
  k旦nnen (RefCount, Singleton, etc)



>> 30.06.2004
[SB]
PLFileSystem:
- Fehler in PLTSearchMultiHandle behoben: HasNextFile() gab false zur端ck, sobald der erste SearchHandle komplett durchlaufen
  war, dadurch wurden die anderen SearchHandles ignoriert
- Das Interface von PLTFileSystem wurde noch einmal leicht ver辰ndert. GetRootDirectory() gibt nun das System-Root-Verzeichnis
  zur端ck, dieses kann jedoch nicht selbst gesetzt werden. SetCurrentDirectory()/GetCurrentDirectory() erm旦glichen das Setzen
  eines aktuellen Verzeichnisses, sowie AddBaseDir() etc., welche im Prinzip weitere aktuelle Verzeichnisse hinzuf端gen lassen
  (falls mehrere ben旦tigt werden). Hierdurch bleibt das System kompatibel zu den 端blichen Dateisysteme, erlaubt jedoch zus辰tzlich
  mehr Kontrolle
- Zugriff auf Suchpfade und Rootverzeichnisse ist vollst辰ndig, es funktioniert nun also alles was f端r die Engine ben旦tigt
  wird. Es k旦nnen Dateitypen (z.B. "Textures", "Sounds", etc.) festgelegt werden und Suchpfade daf端r angelegt werden.
  Das FS durchsucht dann beim ffnen einer Datei automatisch diese Pfade, so da sich die Anwendung nicht mehr darum
  k端mmern mu, was wo liegt
- Suchpfade/Rootverzeichnisse ausgetestet und den PL-Realfall simuliert (separate Verzeichnisse f端r Textures/Models/etc)



>> 29.06.2004
[SB]
PLFileSystem:
- Geschwindigkeitstests durchgef端hrt. Leider ist das FS vor allem beim Zugriff auf viele kleine Dateien deutlich langsamer
  als die Standardfunktionen, beim Zugriff auf groe Dateien f辰llt der Unterschied allerdings kaum mehr ins Gewicht.
  Dies d端rfte haupts辰chlich an den vielen String-Operationen liegen, wie m端ssen also einfach austesten, ob dies im reellen
  Gebrauch negativ auff辰llt und ggf. versuchen, diese Funktionen zu optimieren
- Neue Funktion PLTSearchHandle::GetNextFileAbs(), diese Funktion liefert den absoluten Pfad zur端ck. Funktion wurde in
  allen abgeleiteten Klassen implementiert
- Neue Funktion PLTZipDirectory::GetZipFile(), liefert ein Handle auf die Zip-Datei zur端ck, die das Verzeichnis beinhaltet.
  Der R端ckgabewert ist const, damit zwar Dateiattribute (Namen etc.) abgefragt werden k旦nnen, die Datei aber nicht
  ver辰ndert werden kann
- Fehler in PLTZipSearchHandle behoben: Das zugrunde liegende Verzeichnis wurde nicht gesichert (refcount)



>> 28.06.2004
[SB]
PLFileSystem:
- Dateien aus Zip komplett 端berarbeitet und an den PL-Style angepat
- Alle Dateien 端berarbeitet und die 端blichen "Versch旦nerungen" vorgenommen :-)



>> 25.06.2004
[SB]
PLFileSystem:
- Beim Suchen mit Filter entspricht der Filter "" nun der Suche nach allen Dateien
- Beim Suchen mit Filter ist es nun auch m旦glich, noch Unterverzeichnisse mit anzugeben (z.B. Suche nach "subdir/*.txt")
- Mounten von Root-Verzeichnissen implementiert
- Dateitypen und Suchpfade wurden implementiert
- PLTSearchMultiHandle eingebaut: Dies ist ein Search-Handle, welches intern wiederum aus mehreren Search-Handles besteht
  und diese nacheinander abarbeitet
- PLTFileSystem interface wurde komplett implementiert
- Dateien aus Base und Win32 端berarbeitet und komplett kommentiert



>> 23.06.2004
[SB]
PLFileSystem:
- PLEFileType und entsprechende Zugriffsmethoden in PLTFileObject wurden entfernt, IsDirectory() und IsFile() werden
  nun von abgeleiteten Klassen implementiert
- Neue Methoden GetName() und GetAbsName() in der Basisklasse PLTFileObject eingebaut, diese dienen dem Abfragen von
  relativen und absoluten Namen aller Dateiobjekte
- Interface von PLTFileObject wurde 端berarbeitet (const-Methoden)
- GetName() und GetAbsName() in allen abgeleiteten Klassen implementiert und getestet, es kann nun immer der relative
  sowie der absolute Pfad angefragt werden
- PLTSearchFilter implementiert, dieser filtert Suchergebnisse nach Wildcards
- Beim Erzeugen des Dateisystems wird das aktuelle Verzeichnis '/' automatisch als system-root gemountet
- Setzen des aktuellen Verzeichnisses implementiert
- Design von PLTFileSystem wurde festgelegt. Diese Klasse stellt das Hauptinterface zum FS dar, dient also dem Benutzer
  zum ffnen von Dateien und Verzeichnissen sowie zum Suchen von Dateien



>> 22.06.2004
[SB]
PLFileSystem:
- FSTools: Neue Funktion IsAbsolutePath() eingebaut
- PLTWin32Directory: Es k旦nnen nun auch absolute Pfade angegeben werden (z.B. D:\test.txt), welche unabh辰ngig vom aktuellen
  Verzeichnis gefunden werden. Auerdem kleine Anpassungen an IsValid() vorgenommen



>> 20.06.2004
[SB]
PLGeneral:
- Neue Basisklasse PLTRefCount in PLGeneral eingebaut, da dies nun bereits in mehreren Klassen verwendet wird.
  Davon abgeleitet gibt es speziell f端r das FS die Klasse PLTFSRefCount, welche zus辰tzlich die Anmeldung erzeugter Objekte
  beim FileSystem 端bernimmt



>> 19.06.2004
[SB]
PLFileSystem:
- Fehler behoben: Das MountParent-Attribut eines Verzeichnisses wird nun weitergegeben, wenn ein Unterverzeichnis ge旦ffnet
  wird. Dadurch bezeichnet MountParent jedoch nicht mehr unbedingt das direkte Superdirectory, wenn es gesetzt ist, sondern
  das Basisverzeichnis des gesamten Unterbaumes. Dies wurde ebenfalls in PLTZipFile implementiert
- Die einzelnen Implementierungen von PLTDirectory::Open() rufen nun intern OpenCanonical auf, wenn sie die Datei auf
  direktem Wege nicht 旦ffnen k旦nnen
- PLTWin32Directory und PLTZipDirectory: Enth辰lt der zu 旦ffnende Dateiname ein / (bzw. \) am Ende, so wird nur ein
  PLTDirectory* zur端ckgegeben. Wird nur eine Datei gefunden, beendet die Funktion mit einem Fehler und gibt NULL zur端ck
- PLTFileSystem: Mount ist nun protected, darf also nur vom FileSystem selbst (und PLTDirectory) aufgerufen werden
- Weitere kleine Fehler in Mount() und PLTWin32Directory/PLTZipDirectory behoben. Der Zugriff auf Dateien und Verzeichnisse
  scheint nun komplett zu funktionieren
- ReferenceCounting und garbage collection wurden nun auch in PLTSearchHandle implementiert, damit dies einheitlich f端r das
  gesamte FS ist
- Kleinere Fehler im ReferenceCounting und beim ObjectManagement behoben, dies scheint nun fehlerfrei zu funktionieren
  (nicht mehr ben旦tigte Objekte werden selbst辰ndig gel旦scht)
- Umstrukturierung der Open/OpenCanonical Funktionen. Dadurch konnten redundante berpr端fungen entfernt werden (ffnen von
  Verzeichnissen oder Dateien), und eine endlose Rekursion zwischen den Funktionen Open und OpenCanonical ausgeschlossen werden
- PLTDirectory::FindFirst() gibt nun einen SearchHandle zur端ck, der immer alle Dateien im Verzeichnis auflistet. Daher mu
  PLTSearchHandle also keine Suchmaske mehr implementieren, dies wird sp辰ter durch eine ContainerKlasse implementiert
- Hilfsfunktion FindFirst(pszFilter) und neue Klasse PLTSearchFilter erstellt, wor端ber das Suchen von Dateien mit einem
  Filter m旦glich ist. PLTSearchFilter ist jedoch noch nicht implementiert
- Die Grundfunktionen des FS sind nun *endlich* komplett implementiert, d.h. es kann auf alle Dateien und Verzeichnisse
  zugegriffen werden, wobei ZIP-Dateien bei Bedarf automatisch gemountet werden. Auch der Zugriff auf Dateien und
  Verzeichnisse 端ber Dateisystemgrenzen hinweg ist m旦glich. Es fehlt nun noch das Mounten von root-Verzeichnissen
  sowie die Verwaltung von Dateitypen und Suchpfaden



>> 18.06.2004
[SB]
PLFileSystem:
- Beim ffnen des Verzeichnisses '..' wird nun immer das korrekte Verzeichnis zur端ckgegeben, auch wenn dazu auf ein fr端her
  gemountetes Verzeichnis zur端ckgegriffen werden mu
- OpenCanonical wurde implementiert. Diese Funktion 旦ffnet einen Pfad Schritt f端r Schritt, wobei wenn n旦tig auch Dateisystem
  gemountet werden (z.B. ZIP-Dateien)
- On-The-Fly-Mounten implementiert (z.B. beim ffnen von "C:\test.zip\test.txt")



>> 16.06.2004
[SB]
PLFileSystem:
- PLTZipDirectory wurde so erweitert, da nun auf ein bestimmtes Verzeichnis im ZIP-File zugegriffen werden kann.
  Mittels Open() k旦nnen jetzt auch Unterverzeichnisse ge旦ffnet werden
- Fehler in PLTZipFile behoben: Das PLTZipFile erh旦ht nun den Reference-Counter seines Zip-Verzeichnisses, damit
  dieses nicht gel旦scht werden kann, solange das PLTZipFile existiert
- Zip-Implementierung wurde komplett implementiert. Der Code basiert auf unzip.c, wurde jedoch objektorientiert umgesetzt



>> 14.06.2004
[SB]
PLFileSystem:
- IsValid() wurde als Basisfunktion in PLTFileObject fertiggestellt
- PLTFSTools::ValidatePath() wurde implementiert. Diese Funktion validiert einen Verzeichnisnamen, indem z.B. '..'
  und '.' soweit m旦glich entfernt werden, / und \ vereinheitlicht werden und sonstige Fehler m旦glichst korrigiert werden



>> 11.06.2004
[SB]
PLFileSystem:
- Das Interface von PLTFileSystem wurde noch einmal komplett 端berarbeitet
- Dateisysteme k旦nnen nun gemountet werden, wobei der Typ des Dateisystems automatisch festgestellt wird
  (z.B. zum Mounten von ZIP-Dateien). Damit der Kontext erhalten bleibt, kann ein Basisdirectory 端bergeben werden,
  welches die zu mountende Datei enth辰lt



>> 05.06.2004
[SB]
PLFileSystem:
- Win32-Implementierung wurde komplett fertiggestellt



>> 04.06.2004
[SB]
PLFileSystem:
- Die Interfaces wurden noch einmal komplett umgestellt und vereinheitlicht
- Das Erzeugen und L旦schen von Instanzen ist nun nur noch 端ber spezielle Methoden und Klassen m旦glich
- Reference-Counting f端r PLTFileObject (und abgeleitete Klassen) implementiert
- Alle erzeugten PLTFileObject-Instanzen werden nun beim PLTFileSystem gespeichert und sp辰testens dann gel旦scht,
  wenn auch das PLTFileSystem selbst gel旦scht wird
- Auch PLTFileSystem selbst besitzt nun einen Reference counter



>> 26.05.2004
[SB]
PLFileSystem:
- Die erste Version vom PLFileSystem wurde fertiggestellt



>> 11.05.2004
[CO]
- PLGeneral: PLError wurde entfernt. Gel旦schte Dateien: PLBuffer.h, PLError.cpp, PLError.h. Nahm desweiteren PL_ASSERT
  aus diversen Codes heraus da WENN da m端sste man dies konsequent in ALLEN Codes machen. :)



>> 30.03.04
[SB]
- Plugin-Basisklassen in PLGeneral eingebaut. Diese ist noch nicht ganz fertig, funktioniert
  aber schon ganz gut. Es fehlen noch einige Optimierungen sowie die Verkn端pfung mit dem
  FileSystem, damit die Plugins leicht gefunden werden k旦nnen. Auch m端ten die Klassen noch
  auf Linux Systeme angepat werden. Wenn dies fertig ist kann ein PluginManager in der Engine
  erzeugt werden, der alle Arten von Plugins einl辰dt und zur f端r Verf端gung stellt, die
  einzelnen Programmteile benutzen dann den Manager um ihre Plugins zu erzeugen



>> 25.03.04
[CO]
- Wie ich sehe hat Michael nochmals PLTBuffer verbessert... ich selbst hatte gestern in PLBuffer in PLArray
  umbenannt und mehr oder weniger komplett umgeschrieben da ich diese Klasse mittlerweile im neuen Renderer beim
  Wrappen von Render States etc verwende und die alte Klasse nicht stabil genug war. Hatte die Codes aber noch
  nicht hochgeladen - PLArray.h ist nun auf dem Server, PLBuffer.h lass ich auch erstmal noch oben nicht das da
  etwas durcheinander kommt. :)



>> 23.02.04
[CO]
- PLTStack leicht modifiziert



>> 19.02.04
[CO]
- PLTString um Funktionen zum setzen und auslesen von Zahlen hinzugef端gt.



>> 15.02.04
[CO]
- Plugin Systeme wie Entity und Sound: Dadurch das nun w辰hrend der Entwicklung zwei Versionen eines jeden Plugins vorhanden
  sind (Debug und Release) gab es teils crashs da dann doppelt noch das andere z.B: Release Plugin eingeladen wurde was
  aufgrund inkompatiblem Compiler Modus einen crash verursachte. Diese Plugins haben nun intern einen vermerk ob diese im
  Release oder Debug Modus sind - Plugins in einem falschen Compiler Modus werden nun nicht mehr geladen. Nun m端sste das mit
  dem Release/Debug Problemen entg端ltig der Vergangenheit angeh旦ren! Wenn nun was nicht geht dann liegts nur an nichtzusammen
  passenden Release Versionen. (da z.b. eine dll veraltet ist :)
- PLTList und PLTDynamicList -> Add Funktion so erweitert das optional ein Index mitgegeben werden kann um 
  festzulegen WO in der Liste das neue Element eingef端gt wird



>> 11.02.04
[CO]
- PLTLanguageManager::GenerateLanguageList() -> Kann nun auch aus einer Preload Datei im Languages Block die verf端gbaren
  sprachen auslesen falls mal ALLE Daten in einer pak Datei sind und daher die Sprachverzeichnisse nicht direkt abgelesen
  werden k旦nnen.
- PLTList + PLTDynamicList: -> Da man beim Kopieren oft Start+Anzahl trifft (siehe read etc) haben wir nun beide
  Kopier Funktionen drin, also Start+Anzahl und Start-End. (heist CopyFromTo())
  Da die Listen sehr h辰ufig Verwendung finden m端sste es ok sein wenn man da etwas mehr komfort bietet.
  Die Kopier Funktionen m端ssten so nun wirklich passen. (getestet)



>> 07.02.04
[CO]
- Ein paar kleinigkeiten am alten FS ge辰ndert so das man nun im HDRI Viewer auch direkt pak/zip files einladen kann



>> 05.02.04
[CO]
- PLTTimer: Delay() in Sleep() umbenannt damit es identisch mit dem PLGui Sleep() ist. Ist zwar nun im GuiNative und Timer
  doppelt, aber so hat man alles Timer Relevante in der Engine sauber in einer Klasse beisammen. :)



>> 04.02.04
[CO]
- PLTDynamicList: Copy() kopierte durch <= ein Element mehr als man angab
- PLTList: Neue Funktion. Copy
- PLTBitset: Neue Funktionen: GetSize() -> Liefert die Bitset gr旦e zur端ck
                              Copy() -> Copiert Bits in ein anderes Bitset



>> 01.02.04
[CO]
- PLTTokenizer: GetDataBlock() Funktionen erweitert. Es gibt nun neben der Block Schreibweise [X Y Z ...] auch alternativ
  {X, Y, Z ...} da man beide Schreibweisen h辰ufig antrifft. wird z.B. im 端berarbeiteten Material Format bei den Parametern
  verwendet um dort ein fx-辰hnliches Aussehen beizubehalten damit die Grafiker nicht zu 100% umdenken m端ssen und es leicht
  ist ein fx File in unser eignes Material Format umzuschreiben.



>> 29.01.04
[CO]
- PLTList: neuer operator: Concat. Zur Verkettung zweier Listen.
  Desweiteren wurden in einem Kunstruktor noch nicht die Variablen Initialisiert. (siehe MH oben)



>> 22.01.04
[CO]
- PLTOutputDevice in PLTErrorOutputDevice und PLTError in PLError (da gleich statische instanz) umbenannt.
- Erweiterte PLGeneral Headers um jeweils ein kleines Beispiel wie man die verschiedenen Klassen einsetzt



>> 21.01.04
[CO]
- Nahm aus PLList, PLHashTable und PLStack wieder die Assertion Funktionen heraus da man durch diese selbst bei
  einfachen Templates GEZWUNGEN wurde PLGeneral ins Projekt mit einzubinden auch wenn man eigentlich 'nur' Templates
  aus PLGeneral verwendete. PLMath ist somit wie PLGeneral komplett eigenst辰ndig - verwendet zwar z.B. Listen aus PLGeneral
  aber dies erfordert keine Einbindung von PLGeneral in das PLMath Projekt.
  In Klassen welche sowieso die Einbingung von PLGeneral erfordern kann man ja sorgenlos die Assert Funktionen verwenden. :)
- Einige von Michals 辰nderungen an String und Error wieder angepasst - ich hoffe da kam nun nichts durcheinander da unsere
  Codes diesmal stark voneinander abwichen - Michael, passe bitte auf das du nicht auf dem Server
  bereits ge辰nderte Dateien 端berschreibst. (wie dieses Tagebuch oder Codes)
  Am besten bevor du etwas hochl辰ds zur Sicherheit pr端fen ob jemand was dran ge辰ndert hat. Am FileSystem 辰ndern wir erstmal
  nichts bis du nicht das ok gibst - sonst kommt das durcheinander. :)
  Sobald wir auf CVS umstellen wird das sicherlich besser da diese Programm dann heftig warnt wenn man Datein die man
  hochladen will auf dem Server ge辰ndert wurden.
  Ps. Es ist wirklich, wirklich wichtig das die Codes so sauber sind wie m旦glich und m旦glichst kein Buchstabe vom Style
  abweicht. Wir haben mittlerweile insgesammt weit mehr als 2 MB an Quellcodes und wenn man da anf辰ngt mit soetwas nachl辰ssig
  zu werden wird man sich ganz bestimmt sp辰ter mal dr端ber 辰rgern. Von daher kommts schonmal vor das wir mehr Zeit in die Code
  pflege stecken als in das schreiben des Codes selbst... aber es lohnt sich da man sich dadurch sp辰ter Zeit spart!



>> 20.01.04
[CO]
- PLTTokenizer::GetDataBlockInt() und PLTTokenizer::GetDataBlockFloat() -> Brechen nun ab wenn beendende Klammer ]
  gefunden wurde und f端llen den Rest mit 0. Geben die Anzahl der gelesenen Elemente zur端ck.
  (PLModelLoad.cpp und PLTextureHandler.cpp mussten aktualisiert werden)



>> 12.01.04
[CO]
- PLTFile::GetS() -> Fehler korrigiert (sonst gibts probleme beim HDRI maps im Viewer einladen)



>> 09.01.04
[CO]
- PLGeneral.h muss nun nicht mehr inkludiert werden bevor man z.B. PLTBitset verwenden will
  (dies geschieht nun in den PLGeneral Headern automatisch)



>> 03.01.04
[CO]
- PLTDynamicList: Neue Funktion: Add() -> F端gt ein neues Element in die Liste ein und gibt einen Zeiger darauf zur端ck
- PLTBitset erweitert -> Pr端ft nun auch ob ein gegebener Bit Index korrekt ist
- PLTTokenizer: Neue Funktionen: GetNextTokenBool() und GetTokenBool() -> Machen das gleiche wie die Funktionen ohne Bool
  am Ende auer das diese den gefundenen Token als boolean Wert zur端ckgeben (erkennt auch 'false' und 'true')
- berall in Formaten wo man statt einer 1 auch 'true' schreiben k旦nnte ist dies nun dank umstellung auf GetNextTokenBool()
  auch m旦glich



>> 30.12.03
[CO]
- PLTString: Michales neue nderungen wieder angepasst (bitte noch mehr drauf achten wie wir was schreiben Michael :)



>> 27.12.03
[CO]
- Passte noch ein paar kleinigkeiten von Michaels 辰nderungen an PLTString an. Find() gibt nun direkt den Index zur端ck.



>> 20.12.03
[CO]
- PLTFileSystem::GetFilenameEnding() -> Wenn Datei keine Datei endung hat so wird pszFilenameEnding nun auf "" gesetzt



>> 13.12.03
[CO]
- PLTTimer: Neue Funktion: GetTickCountLow() -> Macht das gleiche wie GetTickCount() nur mit weniger genauigkeit
- PLTDataSet.Get() -> Gibt nun NULL zur端ck wenn ung端ltiger Index -> ein paar stellen in der Engine an denen Zeiger
  verglichen werden mussten angepasst werden



>> 27.11.03
[CO]
- PLString: Neue Funktion: - TStringModule::GetUsage() -> Gibt zur端ck wie oft ein String Module verwendet wird
  Neue Operatoren: += -> H辰ngt einen String an einen String an +  -> Verbindet zwei Strings zu einem neuen



>> 25.11.03
[CO]
- Mir war ein paar Minuten langweilig und da warf ich nochmal einen kurzen Blick auf PLGeneral und behob
  ein paar kleine Sch旦nheits fehler - also absolut unn旦tige nderungen. (sieht nun aber etwas universeller aus ;-)



/*********************************************************\
 *  Eintr辰ge aus altem Diary, damals noch ohne genaue Datum angaben. (oben -> unten = neuer -> 辰lter)
\*********************************************************/



[SB] Neues Projekt PLGeneral erstellt, welches alle allgemeinen Toolklassen enth辰lt (Listen, Strings, ...). Die
     entsprechenden Toolklassen wurden aus PLEngine entfernt, alle Projekte wuredn umgestellt (betrifft nahezu alle
     Projekte)
[CO] In PLTypes.h stehen nun auch Daten-Typ definationen wie z.B. WORD oder DWORD
[CO] PLTTimer: Portabel gemacht -> System abh辰ngige Funktionen abgekapselt
[CO] PLTFileSystem::GetValidFilename() -> Pr端ft ZUERST ob eine Datei in einem Sprach Unterornder ist und somit f端r eine
     Sprache quasi '端berladen' wird (wichtig f端r Lokalisierungen :)
[CO] PLTFileSystem: Neue Funktionen: ConvertBackslashsToSlashs() und ConvertSlashsToBackslashs()
[CO] Kleinen fehler in PLTList::Remove(int nIndex) behoben
[CO] PLTModule::IsHandler() war mittlerweile veraltet und musste daher aktualisiert werden
[CO] PLTList & PLTDynamicList um ein paar hilfreiche weitere Funktionen erweitert - auch in PLGui2
[CO] PLTLog: GetSystemMetrics herausgenommen, somit ist diese Klasse Windows unabh辰ngig :)
[CO] PLTLanguageHandler: Strings werden nun anstatt mit Get() mit [] angefordert, etwas k端rzere und angenehmere
     Schreibweise :) CustomUpdate-Funktionen entfernt da wechseln der Sprache w辰hrend das Programm l辰uft nicht mehr
     m旦glich ist. *nur probleme mach* -> API Doku um Language System erweitert
[CO] Ordnungs-Wahn: Alle Dateien nochmal durchgegangen um sicherzustellen das alle das gleiche Layout haben... also die
     Beschreibung der Dateien, #idndef usw.   Den Code durchgegangen um sicherzustellen das immer zuerst Get und danach
     erst Set funktionen kommen. (damit alles einem einheitlichen Schema folgt ;-)
[CO] File System um Ordner f端r 2D Guis erweitert, der Gui2D Loaded setzt nun wie alle anderen Loader den Dateinamen
     selbstst辰ndig dynamisch zusammen
[CO] PLTPluginManager: Alle Entity Plugins befinden sich in einem Module (internal, dll, entities) dessen name nun im
     Plugin selbst gespeichert wird. Mit GetModulePluginList() kann man eine Liste aller Plugins in einem Module
     anfordern. GetNumberOfModules() und GetModuleName() um Module Namen zu erhalten.
[CO] PLTTimer: Neue Funktion: Delay() -> H辰lt die ausf端hrung des Programms f端r eine gewisse zeit an
[CO] PLTDataSet: Neue Funktionen: GetTotalSize() of den gesammten speicherbedarf in Bytes abzufragen GetElementSize() ->
     Liefert die gr旦e eines grund Elements in Bytes zur端ck GetAllocated() -> Liefert die Anzahl der belegten grund
     Elements zur端ck. Desweiteren oben eine kurze Beschreibung des Data-Sets hinzugef端gt.
[CO] PLTModuleManager: Behob einen (mehr oder weniger) kleinen fehler beim Laden von Modulen... bei SetName() wird das
     Module in den Module Handler eingetragen, kann das Module nicht geladen werden so wird es nun wieder korrekt vom
     Manager entfernt (ansonnsten crash beim Laden von nicht vorhandenen Resourcen :)
[CO] PLTTools: Neue Funktionen: FlipRB3() & FlipRB4() -> Optimierte Assembler Funktionen welche die RB komponenten in
     einem RGB bzw. RGBA Buffer vertauschen... ist bei diversen Bild Formaten notwendig... und so kann man die
     Ladezeiten etwas verk端rzen :)
[CO] PLTLog: Neue Funktion: GetActive()
[CO] PLTFile um Funktionen zum Schreiben in Dateien erweitert
[CO] PLTModuleHandler: Neue Lade Funktion welche den Handler direkt mit einem Objekt l辰d
[CO] Stil der Friend deklarationen in den Klassen vereinheitlicht (端ber all nun friend class, so machts auch weniger
     probleme mit den Predefinationen :)
[CO] PLTTimer: mit GetFPSLimit() & SetFPSLimit() kann man nun eine FPS limitierung einbauen, diese FPS wird dann nicht
     端berschritten... die Engine wird entsprechend aktualisiert, dadurch bleiben dem System mehr Resourcen f端r andere
     Dinge -> in fertigen Anwendungen sollte es keine FPS limitierung geben, zum Debuggen usw. k旦nnte es aber n端tlich
     sein :)
[CO] PLTModelHandler: GetStaticBoundingBox() & GetCollisionBoundingBox() entfernt. Wird ein Modell geladen so 端bergibt
     dieses all seine Bounding Boxes an sein Entity. Wird ein Modell entladen so verliert auch das Entity automatisch
     ALLE Bounding Boxes. Im Modell Handler selbst ist nun nur noch eine Bounding Box welche f端r die Sichtbarkeits
     bestimmung verwendet wird! (diese wird beim Modell Laden automatisch erzeugt)
[CO] PLTTools: Neue Funktionen: GetVarType() & GetVarTypeString() -> Tool-Funktionen welche einen Variable Typen in
     einen String konvertieren oder umgekehrt
[CO] nderte bei den Pfadangaben die Backslashs zu Slashs damit alles einheitlich ist (es sind ja zwei verschiedene
     Schreibweisen im Umlauf :)
[CO] Alle PL-Tools in PLTools verschoben (ME, WE & Max plugin)
[CO] Die PLEBitField Flags waren falsch... das f端hrte zu einem ganz erheblichen Performance verlust (da die Clear flags
     somit schrott waren :)
[CO] PLTTools: Neue Funktionen: SetFlagsString() und GetFlagsFromString() zum setzen und auslesen eines Flag-Strings
[CO] Ist der Timer 'eingefrohren' so werden nun auch keine Eingaben usw. akzeptiert, alles steht still ;-)
[CO] PLTModuleManager & PLTModule ge辰ndert. Nun hat PLTModule einen zeiger zur端ck auf PLTModuleManager denn wenn der
     Name von PLTModule ge辰ndert wird, so muss der Module Manager aktualisiert werden! Wichtig da die Module meist mit
     ihrem Namen angesprochen werden, daher darf es keine doppelten Module Namen geben! :)  ('Hey DU!... wer ich? NEIN
     du!' ;-)
[CO] PLTTokenizer: Einige Funktionen wie z.B. FindToken() und GetDataBlockInt() setzten am Ende automatisch auf den
     n辰chsten Token, dies erwies sich als ziemlich unpraktisch, daher ist dies nun ge辰ndert. (Funktionen welche den
     Parser verwenden wurden angepasst)
[CO] PLTModuleManager: Instance Check vorherst herausgestrichen da es ansonnsten unm旦glich ist den Module Manager von
     einer Anwendung aus zu verwenden (da durch Template Problem Instance dort immer NULL), desweiteren nahm ich
     m_lstIDHashList heraus womit die Get(ID) funktion nun besser zum durchlaufen einer Module Schleife geeignet ist
[CO] Neue Funktion: PLTModuleManager::Create() -> Erzeugt ein neues Modul und liefert den Zeiger darauf zur端ck
[CO] ber PLTConfig kann man nun einstellen ob die 3 Ebenen visualisiert werden sollen oder nicht
[CO] PLTFileSystem::SetApplicationPath() f端gt nun am Ende automatisch ein '\' ein wenn dieses nicht vorhanden ist
[CO] Neue Window-Klasse: PLTWindowOpenDialog -> Ein Dialog zum ausw辰hlen von Dateien -> Nam
     PLTFileSystem::GetFilenameDialog() heraus da nun 端berfl端ssig
[CO] PLTList ist nun nur noch ein 'Hilfmittel', sprich, es kann keine Zeiger mehr L旦schen!
[SB] Makros geringf端gig ver辰ndert und die Namen vereinheitlicht, 端ber PL_IMPLEMENT_BASECLASS k旦nnen nun auch mehrere
     Basisklassen implementiert werden
[SB] Die Makros wurden so erweitert, da nun auch die Variablen der Entity-Klassen exportiert werden k旦nnen. In einer
     VarTable werden diese Variablen dann mit ihren Namen gespeichert
[CO] PLTFileSystem: Neue Funktion: SetApplicationPath() -> Damit l辰sst sich der Pfad der Anwendung einstellen, im Fall
     des Modell Editos kann man diesen Pfad nun einstellen
[CO] Diverse Tool-Klassen erweitert
[CO] PLTModuleManager hatte teils gleiches problem wie das PLTGui... in den Listen wurden gel旦schte Eintr辰ge nochmals
     gel旦scht...
[CO] PLTTime -> Mit m_fTimeScaleFactor l辰sst sich nun ein universeller Zeit Faktor einstellen welcher IMMER angewannt
     wird. In der Konsole kann man diesen mit 'timescale 'f'' einstellen... beim Debuggen hilfreich :)
[CO] PLTPool -> Die Priorit辰t eines Pool-Elements l辰sst sich nun ver辰ndern... praktisch wenn man ein Element vor einem
     anderen haben will (z.B. Sky layer ver辰ndern) :)
[CO] Baute eine Profiling Tool Klasse ein welche Hilfreich bei der berwachung der verschiedenen Engine Teile sein wird,
     grob gesehen ist es nur eine Klasse welche verschiedene Gruppen von Texten verwaltet... aber mit diversen
     Hilfs-Funktionen :)
[CO] Neue Tool-Klasse: PLTPool -> Verwaltet eine Gruppe von Elementen wie z.B. Animations Informationen, Anker Punkten,
     Animation Events usw.
[CO] Copy funktionen eingebaut in: PLTMesh, PLTDataSet, PLTList, PLTDynamicList, PLTStack, PLTBitset
[CO] Neue Tool-Klasse PLTBitset zum verwalten beliebiger bits (z.B. um zu vermerken ob eine Geometry schon gerendert
     wurde oder nicht)
[CO] PLTFileSystem -> Neue Funktionen -> GetOnlyFilename() und GetDirectory()
[CO] Neue Funktion: PLTTimer::GetTickCount()
[CO] PLTTokenizer: GetNextToken() liefert nun einen Zeiger auf den gefundenen Token zur端ck damit man diesen z.B. sofort
     via atoi() in eine zahl umwandeln kann
[CO] PLTList & PLTDynamicList & PLTStack: Nahm Funktionen FindFirst(), FindNext() und GetCurrent() heraus da diese
     potentielle Fehlerquellen sind und der Operator [] durch die intere Zeiger optimierung mittlerweile genauso wenig
     Performance ben旦tigt
[CO] Behob einen Fehler in der Listen-Klasse (beim L旦schen... man, wie viele Fehler sind denn noch im Code!?? ;-)
[CO] Code sinnloserweise 'versch旦nert' ;-)
[SB] PLTTokenizer: Habe einen kleinen Fehler in den Abbruchbedingungen der Parserschleife behoben: Es ist auch m旦glich,
     da sich z.B. Kommentare und ung端ltige Zeichen mehrfach abwechseln, diese m端ssen alle ignoriert werden und d端rfen
     nicht als korrekte Zeichen angesehen werden
[CO] Behob einen kleinen Fehler im ModuleManager (zuerst Remove() und dann Objekt selbst entladen)
[CO] Erstellte eine einheitliche Tokenizer Klasse... benannte meine Klasse um und f端gte Funktionen deiner hinzu... nun
     haben wir ein Monster Tokenizer ;-)
[SB] PLTTokenizer: Delimiters k旦nnen nun auch w辰hrend des Parsens ausgewechselt werden
[SB] PLTTokenizer Klasse hinzugef端gt, welche zum direkten Auslesen von Tokens aus einer Textdatei dient.
[CO] PLTParser: Neue Funktionen: CompareTokens(), FindTokens(), GetTokensValueInt(), GetTokensValueStr(),
     GetDataBlockInt(), GetDataBlockFloat(), Push(), Pop()
[CO] Das Laden aus Archiven funktioniert nun endlich!! :)
[CO] Arbeitete etwas am FileSystem weiter. U.a. kann man nun auch 端ber die Klasse PLTFile aus zip Archiven laden.
[CO] FileSystem: Dateien k旦nnen nun auch auerhalb des Spieleordners liegen
     (dies sollte man aber trotzdem vermeiden :)
[CO] Baute eine Hash-Klasse ein (PLTHash) welche z.B. im Entity Manager verwendet wird
[CO] Baute PLTString Klasse ein
[SB] Module System eingebaut
[CO] PLTDataSet wurde erweitert und kann nun auch die Daten anderer Daten sets verwenden. Dies wird z.B. in PLTMesh
     verwendet um einzelne Daten mit anderen Meshs zu teilen. Ein Vorteil dieser Technik: Kommen die geteilten Daten
     'abhanden', so werden die anderen Daten Sets dar端ber informiert.
[CO] Erweiterte PLTDataSet um einzelene Elemente um alles noch dynamischer zu machen. Um z.B. Textur Koordinaten zu
     speichern kann man entweder PLTDataSet<PLFLOAT2> fTexCoord (1 element) oder PLTDataSet<float> fTexCoord (mit 2
     elementen) verwenden... wobei die letztere Technik mehr freiheiten l辰sst. ;-)
[CO] umbekannt: PLTDynamicLinkedList in PLTDynamicList
[CO] umbekannt: PLTLinkedList in PLTList
[CO] beseitigte den h辰sslichen Zeiger auf die delete-Funktion...  (Projekt-Einstellungen auf SE werte eingestellt :)
[CO] einen dummen Rechtschreibfehler behoben
[CO] baute dein Data Set Template ein (und erweiterte es etwas :)
[CO] viele kleine Stil anpassungen :)
[CO] Ordner strukturierung & docs
[CO] Namens ndung
[CO] Intel-Jpg-Lib durch Independent JPEG Group's ersetzt
