>> 10.03.2012
[SW]
- Regex: Added some comments.
    Added additional functionality to get the result string:
	e.g. RegEx expr("Hal+o");
		 String subject("Hallo World!");
		 if(expr.Match(subject))
		 {
			String result = expr.GetResultMatch(); // returns "Hallo";
		 }



>> 10.03.2012
[CO]
- Within the unit tests, Jens Schmer tried
    PLCore::Directory cDir("testData/FileSystemTest.zip/");
    CHECK(cDir.Exists());
    CHECK(cDir.IsDirectory());
  with the result that "cDir.IsDirectory()" returned "false" although the "FileObject" class documentation stated that this should be "true".
  In case of a directory, "FileObject::Assign()" was removing "/" at the end of the filename without more information why it's done. Also, the
  URL was collapsed which is an expensive operation - we might not do that if it's not absolutely required. The system shouldn't play around too
  much with the given data. Reviewed and changed the behaviour which is now according to the existing documentation and the unit test no longer
  fails. Also tested several existing projects, I hope this doesn't break anything unnoticed.
  -> The "FileObject::GetUrl()"-documentation stated:
     "The URL of a 'FileObject' always contains a filename that never ends with "/"! (so, you can safely use 'Url::GetFilename()' to get the name
      of any file or directory)"
     and
     "e.g.: 'Directory("C:\\test")' and 'Directory("C:\\test\\")' are equal, but
      'GetUrl()' will always return "C:/test"."
     Updated comments according to the made change. This behaviour is now also consistent with the URL-class which preserves "/", in case there
     was one.
- "FileSearchZip::GetNextFile()" was removing "/" at the end of a string without more information why this was done. Looked odd and when playing
  around within the unit tests the behaviour was unexpected.
PLFrontendQt:
- Added "QTableViewWithCopy": A "QTableView" where it's possible to copy the selected content into the clipboard. I was using this widget already
  within my master thesis to be able to copy out data without having to typewrite it from the GUI.
- Added "DockWidgetSceneMeshInformation" for information about the mesh of the currently selected scene node. I was also already using such a thing
  for volume scene nodes within my master thesis. For now it's a basic table, I assume a tree view would be better in here for a better overview -
  but the current first implementation is all I need for now.
- Added helper method "DockWidget::AddDockWidgetAndTabify()"
- Usability: By default, new RTTI dock widget instances are "tabified". Currently I'am working with the RTTI dock widgets all day long and constantly
  have to move around them after hey have been instanced. Finally more comfortable to work with.



>> 08.03.2012
[CO]
- While working on PLUnitTests, Jens Schmer noticed that the "nCount"-behaviour of
    "bool Container<ValueType>::Compare(const Container<ValueType> &lstContainer, uint32 nStart, uint32 nCount) const"
  was inconsistent to the other similar methode like
    "bool Container<ValueType>::Add(const Container<ValueType> &lstContainer, uint32 nStart, uint32 nCount)"
  -> Fixed this (shouldn't break anything)



>> 07.03.2012
[CO]
- "template <class ValueType> ValueType Iterable<ValueType>::Null;" is causing issues within "Bitset" due to "class PLCORE_API Bitset" resulting that
  stuff from the template base classes have now to be exported/imported as well. It's like a virus or a spreading wildfire. Results in
  "Bitset.obj : error LNK2001: unresolved external symbol "public: static bool PLCore::Iterable<bool>::Null" (?Null@?$Iterable@_N@PLCore@@2_NA)"
  within e.g. PLUnitTests. Usually, we don't write something like "class PLCORE_API Bitset" in PixelLight, instead we export/import stuff explicitly in order
  to have full control. As far as I remember, some time ago, this caused issues on a GCC or Clang compiler version within the bitset class (vtable issue).
  Now the issue strikes back within PLUnitTests. I don't have time to check all compilers for whether or not the issue we had earlier still exists, so I go the,
  hopefully safe way, by moving this "Null"-instance from the base into derived classes. E.g. the bitset class can now do the usual export/import and the linker
  issue within PLUnitTests is gone (it's no hack, just a safer approach).



>> 06.03.2012
[JS]
- "PLCore::Tools::Checksum": added new virtual method "Reset()" to clear stored checksums
  -> I spotted a weird behaviour of the Checksum Classes (MD5, CRC32, SHA1) during unit testing. It seemed that every test after the first checksum
     calculation failed. I could locate the Problem in the abstract interface "PLCore::Checksum": it calls the implementation-specific "Update"-Method
     without clearing previous checksums first and that results in corrupted checksums if you calculate more than one checksum on one specific checksum-object.
  -> Fixed that with introducing a new method to the abstract "Checksum"-interface named "Reset". It should reset all previous calculated checksums.
  -> Using the "Reset"-method before calculating anything in the "Checksum"-interfaces "Get"-methods including its overloads fixes this bug.



>> 03.03.2012
[CO]
- "Var::SetInt64()": Disabled the annoying warning (VC 2010)
   "warning C4244: 'argument' : conversion from 'PLCore::int64' to 'PLCore::int32', possible loss of data""
   -> We know that this conversion will introduce a potential loss of data



>> 27.02.2012
[CO]
- The loadable system can now also deal with file formats which don't have any file extension
  -> Personally, I would try to avoid using such file formats because if there are multiple of such file formats, it becomes hard to
     figure out automatically which one should be used *content must be analysed*
- The loadable system can now also deal with file formats like DICOM which load from directories instead of files
  -> Now working since 4 month with DICOM data within my master thesis. Until now I had some uggly hacks within my project and now it's time for
     cleanup. Similar to file formats without an extension, such "directory formats" should not be overused because it becomes hard to
     figure out automatically which one should be used *content must be analysed*.



>> 20.02.2012
[CO]
- Improved "Checksum"/"ChecksumCRC32" usability (I currently use a CRC32 checksum to deal with shader permutations)



>> 19.02.2012
[CO]
PLScriptLua:
- "LuaUserData": Added support for Lua's "__eq" metamethod callback (called when Lua tries to check for equality)



>> 12.02.2012
[CO]
- Feature request "ID: 3486884" (http://sourceforge.net/tracker/?func=detail&aid=3486884&group_id=507544&atid=2063685): Added "MemoryManager::Move()"



>> 11.02.2012
[CO]
PLScriptBindings:
- "SNMScript": In case there's no script instance or no valid update function, we also don't need a constant update
- Now directly storing singleton instances, they will not change over time
PLScriptLua:
- "RTTIObjectMethodPointer::CallDynFunc()" performance optimization: There's no need to perform expensive parameter conversion if a function has no parameters
- "RTTIObjectPointerBase::NewIndexMetamethod()" performance optimization: If possible, no string is used for parameter conversion
- Now using "LuaJIT" by default, classic Lua external packages will still be supported
PLFrontendOS & PLFrontendPLGui:
- Calling "OnUpdate()" is only allowed when the frontend is already fully initialized, everything else would be like a Russian roulette



>> 09.02.2012
[CO]
- Handled bug report "PLCore::String operator <" (http://dev.pixellight.org/forum/viewtopic.php?f=4&t=226)
  "
  PLCore::String s1 = "so";
  PLCore::String s2 = "so1";
  printf("%d %d\n",s1 < s2,s2 < s1);
  "
  -> Result was "0 0", should have been "1 0"
  -> "StringBuffer": "IsLessThan()", "IsLessThan()", "IsGreaterThan()", "IsGreaterThan()" were using the minimum length of both strings when calling e.g. "strncmp".
     When debugging into "strncmp()" and "strcmp()" within Visual Studio, the "strcmp()"-implementation appears to be more simple and now I'am just using "strcmp()"
     instead of "strncmp()" for the lexicographical comparison.
PLScriptLua:
- "RTTIObjectPointer", "RTTIObjectSlotPointer", "RTTIObjectMethodPointer", "RTTIObjectSignalPointer" and "RTTIObjectSignalMethodPointer" instances
  are now managed by "LuaContext" instead of constantly using "new" and "delete" directly. "LuaContext" will cache no longer used instances so that they can be reused
  later on. Before this performance optimization my stress test took 3167 milliseconds, after this change it took 1360 milliseconds.
  -> Added base classes "RTTIObjectPointerBase" and "RTTIObjectSignalPointerBase" to make it possible to use "RTTIObjectPointer" and "RTTIObjectSignalPointer" as fast
     pool elements as well. Removing elements takes now O(1) instead of O(n).
- "Script::Execute()" and "Script::EndCall()" perform an incremental step of garbage collection
  -> For now I don't want to bother the script API user with somethig like garbage collection, so do this automatically
  -> Without doing this, the instance reuse optimization from above has no chance to improve the performance because Lua will not release unused stuff when it's not
     asked to do so
PLFrontendQt:
- "SceneGraphTreeModel::dropMimeData()": Currently, there's a different tree view item drag'n'drop behaviour on Linux and Windows
  -> Linux: If an item is marked to not allow drop onto it, the mouse cursor gets "X" and dropping is impossible (as expected in the first place)
  -> Windows: If an item is marked to not allow drop onto it, the dropped item is inserted in top of or below the
              item we dropped our item onto. When debugging into Qt in order to understand the drag'n'drop behaviour,
              the exlaination for this behaviour can be found within
              "QAbstractItemView::DropIndicatorPosition QAbstractItemViewPrivate::position(const QPoint &pos, const QRect &rect, const QModelIndex &index) const"
               When just looking at this Qt source code, it appears that this has nothing to do with the Windows operation
              system at all. No OS features are used. Interesting that the behaviour under Linux is that different. Maybe
              we should also debug the drag'n'drop procedure under Linux to be able to find the one part were it starts to differ.
              I assume that there are some other relevant parts before "QAbstractItemViewPrivate::position()" is even called.
  -> When searching for this issue in the internet, it appears that there are also other people which have noticed the same thing
  -> For now we have the following hack under Windows, if we don't do this, items will disappear regularly when doing drag'n'drop making is unusable :/
  -> I'am using this drag'n'drop feature regularly when testing stuff from my master thesis and I already had this change locally to not constantly stumble into
     this issue... but it would only have been a matter of time until this local change would have been committed accidentally. So, an error description and OS
     related hack is probably the better way. As for me, I have to focus on none Qt parts in order to be able to accomplish the work I have to get done in a certain time frame.



>> 07.02.2012
[CO]
PLFrontendQt:
- "QModelIndexList - The Return" (see diary entry "31.01.2012"): The new "ModelIndexMimeData" is also using "QModelIndexList" and it appears that 
  this time there's no work around: Data is allocated within our project (debug) and deallocated in Qt (release). Bang! Debugging impossible in Visual Studio.
  Ok, I have to stop some other work to solve this issue because it starting to get annoying. :/
  Updated today from Qt 4.7.0 to Qt 4.8.0. In the new Windows x86 and x64 packages are also debug versions of Qt. The Visual Studio files within the Git repository
  are now using the Qt debug version for the debug version of the projects. This solves this issue within the Git repository, but for the Windows SDK I
  still have to do some more work. We now have to build PLFrontendQt twice. One time as usual in release mode, and one time using PixelLight release version
  and Qt debug version. An ugly mix up, but I'am afraid there's no way around. As mentioned in the diary entry "31.01.2012", adding debug versions
  of everything within the SDK is no option right now because there's no available time to spend on this topic. Other work must be done, which can't be
  delayed.



>> 05.02.2012
[CO]
PLCore:
- Added "Script::Execute()"
PLScriptBindings:
- Added "SNMScript::ScriptExecute"
PLFrontendQt:
- "PLDynVarFlagsTreeItem::PLDynVarFlagsTreeItem()": Now asking the RTTI for the flag value to ensure it's always valid (it's possible that e.g.
  there's no flag with a value of, say "4", but one with a value of "8")



>> 04.02.2012
[SW]
PLCore:
- "Array and ElementManager": Implemented MoveItem Method. With this method an item can be moved within the container "list" (between index 0 and itemcount-1)
PLFrontendQt:
- "SceneRendererDataModel": Implememted internal Drag and Drop support for moving items (only SceneRendererPass items can be moved)
- "DockWidgetSceneRenderer": Activated Drag and Drop with internal move on the tree view
- "SceneGraphTreeModel":  Implememted internal Drag and Drop support for moving items (currently only SceneNode items can be moved)
- "DockWidgetSceneGraph": Activated Drag and Drop with internal move on the tree view



>> 03.02.2012
[SW]
PLFrontendQt:
- "SceneGraphTreeModel": Fixed removing items which were added to model when setting the start SceneNode



>> 03.02.2012
[CO]
PLFrontendQt:
- "DockWidgetSceneGraph": Added support for the "AddedObject"-broadcast



>> 02.02.2012
[CO]
PLFrontendQt:
- "DockWidgetLog": Usability: Update the Qt plain text edit cursor to in order to reduce the need for manual scrolling



>> 01.02.2012
[SW]
PLFrontendQt:
- "TreeItemBase": Removed the inheritance to QObject. The features of QObject aren't needed for such items. The only thing which was used was the parent<->child relationship management.
  But this management didn't support reordering of child items. So now the TreeItemBase implements an own paren<->child relationship management with some similarity to the management of QObject:
	- The TreeItem takes ownership of an child item. When the TreeItem gest destroyed then also the childs gets destroyed as well.
	- When a child item gets destroyed it removes itself from the parent
	- This management requires that an child element can't be an stack object. The Items must be created on the heap.
- Replaced all model specific header tree items with the generic HeaderTreeItem.
- "SceneGraphMenu::CloneSceneNode": Extended  the Method with an additional parameter to specify the position to which the cloned item should be inserted in the internal child list of an SceneContainer.
- Added "ActionCloned" to SceneGraphMenu::EAction enum. This value is used to add the cloned SceneNode after the source instead of adding it to the end if the child list. 
PLCore:
- "ElementManager": Added GetIndex Method.



>> 01.02.2012
[CO]
PLFrontendQt:
- "DockWidgetSceneGraphQObject::UpdateTreeView()": Usability: Automatically select the new object
- "DockWidgetSceneGraph::PostSelectObject()": Usability: By default it's ensured that the selection will be visible, the item may
   be on top of our tree view or on the bottom. In case it's e.g. a scene node with expanded scene node modifiers and the selected
  item is placed at the bottom of the widget one has to scroll before it's possible to access a modifier. By asking Qt to place the
  item at the center of the widget the item is always at the same position and it's easier for the eye to quickly find the selection,
  need for scrolling is also reduced.



>> 31.01.2012
[SW]
PLFrontendQt:
- "SceneGraphTreeModel": - enable the hack only on Windows builds. No need to pollute non Windows builds with Windows only hacks/workarounds
                         - Added methods for handling adding/deleting items in the scene graph
- "DockWidgetSceneGraph": - Instead of setting the Scene Root Container to the model it uses now the new methods of the model for handling add/delete actions



>> 31.01.2012
[CO]
PLFrontendQt:
- "DockWidgetManager::ShowDockWidget()": Was not calling "show()", "activateWindow()" and "raise()" on a newly created RTTI dock widget.
  After this minor change the "QTreeView::scrollTo()" issue we noticed was completly gone, without changing anything on the system itself
  or on applications using this system. But it may just be luck that it's now working, and the discussed enhancement below should still
  be done to be on the safe side.
- An special issue occured in "DockWidgetSceneGraph::SelectObject()" when using "QTreeView::scrollTo()", resulting in an internal
  discussion showing me that it's appearently not obvious how the RTTI dock widget system works. So, I added the following description
  to "DockWidgetManager" to make it clear how the system is intented to work: ("Pre<method name>" and "Post<method name>" was just
  added as a result of this internal discussion)
  "
     When using the "CallDockWidgetsMethod()"-method to perform a broadcast, the following actions are performed:
    - Calling "Pre<method name>"
    - Calling "<method name>"
    - Calling "Post<method name>" (don't do anything in here which may influence the outside world)

    Just calling directly "<method name>" may not be enough for every broadcast participator due to the near endless
    possibilities what such a participator can actually do when receiving the broadcast. Let's have a more or less
    abstract example to make the background clear:
    For better usability a broadcast participator is calling the Qt method "QTreeView::scrollTo()" to bring something
    into the visible area. "QTreeView::scrollTo()" is using the widget size, which may change during the main-broadcast
    when any broadcast participator is for example opening another dock widget with additional information causing the GUI
    to reduce the hight of our own dock widget. Or changing the size of the main window. Or changing the display resolution.
    Or doing something totally unexpected crazy. So, while "QTreeView::scrollTo()" was correct at the exact time it was called,
    the desired final result visible to the user may not be correct when the main-broadcast has been finished.
    -> This is no problem of the GUI system, a GUI may not even be used at all in certain system constellation
    -> This is no problem of any application using this system, the using application can't know any technical details of
       a certain system constellation, nor what broadcast participators will do

    Let's take "DockWidgetSceneGraph::SelectObject() as a concrete example, even if it may not be used in a certain system
    constellation. In here, the order "issue" from above can't be resolved by simply ensuring that the broadcast receivers
    are in the order required to make the special case "DockWidgetSceneGraph::SelectObject()" behaves correctly. Reasons:
    1. Adding any fixed order would require additional information, which is not available to the system or users of the system
    2. The system itself does not know "DockWidgetSceneGraph::SelectObject()", nor does it know what any broadcast participator do
    3. Another broadcast participator like "Bob::SelectObject()" may require a totally different broadcast receiver order
    4. Another broadcast like "Bob::TakesOverTheWorld()" may require a totally different broadcast receiver order
    5. Any application using this system, can't know what's happening when doing a broadcast, and therefore can't
       add any special hacks to work around issues possible with certain system configurations, which are also not
       known due to the dynamic nature of the system. New plugins can add new dock widget required new special behaviour.
    6. Adding any restrictions to this chaotic system would artificially limit it's use or would add dependencies where no
       dependencies are required
    "
- "SceneGraphTreeModel::GetModelIndexForSceneNode()" is using "QModelIndexList", "QModelIndexList" is causing troubles in Visual
  Studio when mixing release/debug builds. Right now, when debugging, the application will crash when calling the destructor of
  "QModelIndexList" because the elements were allocated within the release build version of Qt, while the elements are destroyed
  by using the debug build version of our project. This is a known issue of Visual Studio and the approach of different release/debug
  versions. When feeding Google with "QModelIndexList crash" I can see that this situation is known. The only solution I found was written by
  clever persons saying "just don't mix release/debug". The ultimate solution. On the other hand, what when this is no option
  because this "solution" would spread like a fire through the complete project and all client projects using the engine? Meaning, we
  can't just change suddenly to a totally other approach just because there's now one part were this would be required for a clean solution.
  Using only debug versions in debug mode would mean that this must be done for all projects. Including external dependencies: Current number
  of build external libraries for all platform combinations multiplicated by two. This means we also have to add such debug
  versions into the SDK. Meaning we have to change the current CMake based debug system to support building the project twice, one in
  release and one in debug build, before creating the SDK installer. As for me, I don't have the time to stop everything for some weeks in
  order to hammer out all the necessary details, testing everything and praying there are no additional side effects. In the end this would
  also mean that when someone is debugging his own PixelLight based application, the debugging would be horrible slow because PixelLight and
  everything is in debug build mode as well. We had tried this long time ago, and it was really painful slow this way, so that debugging an
  own application was not practical any more when this application gets a bit more complex. So, beside the time which would be required to
  do "just don't mix release/debug", there would also be major drawbacks we already know of.
  -> Why I'am writing such a roman, again? I just don't want that someone is telling me that I'am adding ugly hacks without thinking
    following consequences through. Or that I'am going the "complicated way".
  -> Within "SceneGraphTreeModel", overwritten the virtual method "QAbstractItemModel::match()" by using the Qt implementation which is now
     using the same Visual Studio runtime as we're using.
  -> I'am now able to debug again without spending weeks in fuzzing around and adding more issues, while not being able to continue with the
     PixelLight developemnt itself just because of this one single problem in here. We should try to avoid using "QModelIndexList", since working with
     Qt this is the first found issue. If there's a similar issue which can't be solved that easily there's still the option to use debug build
     versions of Qt inside "PLFrontendQt", then using this within a custom application. PixelLight itself does not depend on Qt. But adding a debug
     version of "PLFrontendQt" and Qt within the public SDK isn't that easy as mentioned.
  -> As far as I'am concerned the just reopend, old, release/debug topic is already closed again. Right now there's far to much work to be done
     with required concrete visible results so that there's no time to spend time on this topic. No discussion, please, I'am already far behind my
     time schedule and the reason for this is not that I'am right now writing such detail entries for later analysis. For now, it just has to work.



>> 29.01.2012
[SW]
PLFrontendQt:
- PLTreeItems: Add Tooltip information about the Attributes for the first column.



>> 29.01.2012
[CO]
PLFrontendQt:
- "DockWidgetSceneGraph::UpdateTreeView()": Ensure that at least the current selection remains
- "SceneGraphTreeModel::SceneGraphNodeModifierTreeItem" needs to be informed about the destruction of it's object



>> 28.01.2012
[SW]
PLFrontendQt:
- SceneGraphTreeModel: Added the Method GetModelIndexForSceneNode to get an QModelIndex from an PLScene::SceneNode instance.
  To find the item in the model the memory address of the PLScene::SceneNode item is currently used for comparison.
  If there is a better way to identify a SceneNode exclusivly without relaying on a memory address then inform me
- Added Helper.h which contains an template class which makes it easier to store an pointer into an QVariant and get the value back.
  (The template class is a copy from http://blog.bigpixel.ro/2010/04/storing-pointer-in-qvariant/)
- DockWidgetSceneGraph: Added the missing part of the SelectObject implementation



>> 25.01.2012
[CO]
- Log enhancements
  - Bugfix: "Log::Write()" as soon as the internal log message backup buffer was full, the log was flushed always with each new entry
  - By default, the log buffers now 1000 instead of just 10 messages, we're not that memory restricted, even on mobile devices :D
  - Added "EventNewEntry"-event
- Added "Queue::Top()"
- Added "Stack::Bottom()"
- "Queue" and "Stack" are now iterable as well
- "ScriptManager" is now also using "ClassManager::EventClassUnloaded"
- Bugfix: "LoadableType" was not destroying it's loaders
- "LoadableManager" is now also using "ClassManager::EventClassUnloaded"
PLFrontendQt:
- Added log dock widget
- Added scene graph context menu



>> 22.01.2012
[SW]
PLFrontendQt:
- Renamed PLDynVarFloatTreeItem to PLDynVarNativNumericTypeTreeItem. This Item now handles more numeric base types (float, double, signed/unsigned integers in 8 16 32 and 64 Bit)
- Extended the Delegate to set proper min/max ranges to the QSpinBox for 8/16 singed/unsigned integers.
	(Note for 64Bit signed/unsinged integers there is no spinbox)
- Added Tree Items for Vector3i/2i and Vector4



>> 21.01.2012
[SW]
PLFrontendQt:
- Renamed SceneNodeInfoDelegate to PLTreeItemsDelegate because this delegate is mainly usefull for models which uses internally PLDynVarTreeItems
- Added PLDynVarVector2TreeItem and PLDynVarEnumTreeItem
- PLDynVarColorTreeItem is now also useable for PLGraphics::Color4
- Extended the Delegate to create a Combobox editor for Enum values



>> 20.01.2012
[CO]
- "Runtime::ScanDirectoryPlugins()" & "CoreApplication::OnInitPlugins()" & "FrontendApplication::OnInitPlugins()" no longer search within a "Plugins"-directory.
  Those directories had been removed several month ago because they were just trouble, especially under Linux. In case one really needs such a directory, it's no
  problem to add the one-line-code within the user application.
PLFrontendQt:
- RTTI browser: "ClassInfoAttributeTreeItem": Added "Type" and "Default" information (quite useful e.g. when scripting)
PLScriptBindings:
- "ScriptBinding_PL_Timing": Added "IsPaused()" and "Pause()"



>> 19.01.2012
[CO]
PLFrontendQt:
- "DockWidgetSceneRenderer": Added same item delegate as Stephan did in "DockWidgetObject"



>> 19.01.2012
[SW]
PLFrontendQt:
- Reviewed all QObject::eventFilter usage and in all cases we now doesn't filter out events which we handle to add additional handling
- Added setting an ItemDelegate for the TreeView used bei the DockWidgetObject.
  This ItemDelegate adds additional (rudimentary) features when handling edits:
    - Showing a color chooser button for rtti members which represent an Color (currently only when the typ is Color3)
    - Showing a spin edit box when floating point values should be edit with directly setting the value to the rtti member when changing the value in the edit control.



>> 18.01.2012
[CO]
PLScriptBindings:
- "ScriptBinding_PL_Timing": Added "GetTimeScaleFactor()" and "SetTimeScaleFactor()"



>> 17.01.2012
[CO]
- "ObjectBase" is now using a reference counter. I want to be able to create RTTI class instances from within a script to be able to access loose C++ components,
  and when this instance is no longer referenced by the script it has to be destroyed automatically. When I added script support several month ago, I didn't touch
  this because it would have been to many changes at once - also I tried to find another solution without touching "PLCore::ObjectBase". I was unable to find another
  solution not involving several ugly and error prone hacks. This has to be a feature directly implemented within "PLCore::ObjectBase" to keep things simple.
  -> When just using C++, this change is uncritical because it only has an influence in case this reference counting is really used
  -> To be on the safe side, we now have to add a reference whenever we created an RTTI instance, else when passing this object to a script, it would be destroyed by
     the scripted automatically. Because I don't think that we're able to (or want to) add some thousands "AddReference()" without forgetting a single one, "ObjectBase"
     is not directly derived from "RefCount<ObjectBase>". Instead the interface is reimplemented, but with an initial reference count of 1 and the additional method
     "SoftRelease()" releasing a reference without destroying the instance automatically. This way we can use "ObjectBase" as usual, and when creating an RTTI class
     instance we call "SoftRelease()" before we pass the object pointer into the script so that the script is now fully responsible for it's the object.
  -> I'am of course not totally happy with this solution because having an initial reference count of 1 is inconsistent to "RefCount". "SoftRelease()" can also be
     misused. But I'am afraid there's no other solution, except saying "It's impossible to create an RTTI class instance from within a script"... but this solution
     was not acceptable for me either because it's limiting the use of scripting.
PLScriptBindings:
- Added "Object *ScriptBinding_PL_ClassManager::Create(String sClass, String sParameters)" and
  "Object *ScriptBinding_PL_ClassManager::CreateByConstructor(String sClass, String sConstructor, String sConstructorParameters, String sParameters)"
  making it possible to create RTTI class instance via script
PLScriptLua:
- "LuaUserData": Implemented Lua __tostring metamethod callback (called when Lua tries to convert the user data into a string)
- "RTTIObjectPointer" gets now informed when it's assigned object gets destroyed



>> 16.01.2012
[SW]
PLFrontendQt:
- FrontendMainWindow: Made the windows version of the native OS event handling the same as under linux.
  Because, we don't do a event filtering here, so there is no reason to hide some native OS events from Qt.
  Under windows it seems that for the events WM_ENTERSIZEMOVE/WM_EXITSIZEMOVE it doesn't break something obviously in Qt, but to be an the save side it is better to not hide any native OS events from Qt.
  (Maybe Qt does react on these events to do some "performance" tweaks regarding resizeing the toplevel window by the user)
  We only add additional handling for not Qt components when certain native OS events occures, because Qt itself doesn't provide any useful events for the problem we try to solve here (e.g. the camera spinns around while the user moves/resizes the window).



>> 14.01.2012
[CO]
PLFrontendQt:
- "DockWidgetManager": Exposed "ShowDockWidget()" & "GetFirstDockWidget()" & "HideDockWidgets()" & "DestroyDockWidgets()" to the RTTI



>> 14.01.2012
[SW]
PLFrontendQt:
- FrontendMainWindow: added linux part of an workaround to avoid that the "render window" process mouse move input events while the user moves/resize the toplevel window.
  Added also a workaround for the same problem when the user drags an DockWidget. The only thing which can't be worked around is that the "render window" processes mouse input events while the user resize a DockWidget.
  This is nearly impossible to solve, because in this case no widget gets an focus in/out event. A solution might be to disable processing the mouse input
  events from the main mouse pointer (also used by the windowing system) by PLInput when the mouse cursor leaves the area of the render window (leave event).



>> 12.01.2012
[CO]
- Added "Script::GetAssociatedFilenames()" and implemented the method within the Lua backend
PLFrontendQt:
- "FrontendMainWindow": Do only start the timer when the initialization phase is over
- "FrontendMainWindow::~FrontendMainWindow()": Stop the timer at once, safe is safe
- Added "FrontendMainWindow::SetUpdateInterval()"



>> 08.01.2012
[CO]
- "LoadableManager": Added "GetTypesByExtension()" and "GetLoadersByExtension()"
- "LoadableType": Added "GetLoadersByExtension()"
- Fixed confusing path style inconsistencies within "ApplicationContext"
  -> "GetAppDirectory()": The documentation stated that this method returns "C:\MyApplication", while it was acutally "file://C:/MyApplication"
      and e.g. "GetExecutableFilename()" returned a native path style
  -> "ApplicationContext": "SetStartupDirectory()", "SetLogFilename()" and "SetConfigFilename()" have to ensure that native path style is stored internally
     as the documentation states
- "ApplicationContext": "GetAppDirectory()" points to the application directory, e.g. "C:\MyApplication" on Windows. This single method was fine when
  we only supported 32 bit. Back then this was equal to the directory the executable was in. When adding 64 bit support there was need to put the binaries,
  including the executable, within a separate directory to be able to switch between 32/64 bit while still sharing the same data. Now, "GetAppDirectory()"
  points to e.g. "C:\MyApplication" while for 32 bit the executable is e.g. within "C:\MyApplication\x86". But its also possible that there are situations
  were both point to one and the same directory. This means that there's need for another method explicitly returning the directory the executable is in.
  -> Added "GetExecutableDirectory()"
-> When writing the unit tests for this class, Jens Schmer noticed those confusing inconsistencies and partly missing documentation about path style etc.
- "CoreApplication::OnInitPlugins()" & "FrontendApplication::OnInitPlugins()": There's no guarantee that the application executable directory is the same
  as the application startup directory
  -> If the application executable directory is not the same as the application startup directory, do also scan the application startup directory
  -> This behaviour is quite useful because it allows development of plugins which can be tested within e.g. PLViewer without copying files around,
     just set the current directory to your plugin directory when launching the viewer application
PLFrontendQt:
- "SceneGraphTreeModel": Do not show scene nodes or scene node modifiers with a set "Automatic"-flag within a GUI (yes, this all way planned over years *g*)
- "DockWidgetSceneRenderer" & "DockWidgetObject": Usability: Resize the first tree view column given to the size of its contents



>> 08.01.2012
[SW]
PLFrontendQt:
- Added FilterWidgetWithFilterTypSelector
- Added fallback icon fÃ¼r the filter type selector icon
- Renamed ClassListSortAndFilterModel to TreeSortAndFilterProxyModel, because this proxy model is useable for all Tree like models/views
- In the DockWidgetSceneGraph the tree can now be filtered with the new FilterWidgetWithFilterTypSelector either bei SceneNode name oder class name



>> 07.01.2012
[CO]
PLFrontendQt:
- Sadly, it appears that Qt's signal/slot mechanisms can't be used without QObject/Q_OBJECT. But we don't want to do a multiple inheritance
  like "class DockWidgetSceneGraph : public QObject, public DockWidgetScene" either because this can cause serious casting issues. Casting may
  work in simple cases... but I just had one of those situations were I wondered for a second why my "DockWidgetSceneGraph" data was messy, tried
  to remove the multiple inheritance at once and the issue was gone. So, we need to add another class just to be able to use Qt's signal/slot mechanisms.
  We can't use an embedded class for this either because Qt's MOC doesn't like this. :/
  -> Added "DockWidgetSceneGraphQObject" and "DockWidgetSceneRendererQObject"
- "DockWidgetSceneGraph": Added "SetSceneContainer"-broadcast
- "DockWidgetSceneGraph" is now asking his colleagues via "GetSceneContainer()" whether or not one of them knows the currently used scene container



>> 06.01.2012
[SW]
- PLFrontendQt: Added ClassListWidget which adds an filter line on top of the data view.
  The used filter widget is a copy of the FilterWidget class used by the Qt designer, with some minor modification.



>> 06.01.2012
[CO]
- "RegEx::Match()": Added early escape test: In case we try matching when we are already at the end of the string, we know the result without doing any matches
PLFrontendQt:
- There's no longer need to tell new instanced RTTI dock widgets about current states they might be interested in. They are autonomously communicating with each
  other and asking their fellows for required information. This way we can add new features without e.g. touching PLViewerQt.



>> 05.01.2012
[SW]
- PLFrontendQt: the items in the ClassInfoModel now shows a proper Tooltip



>> 05.01.2012
[CO]
- Added "Object::SignalDestroyed"-signal which is emitted when the object is destroyed. This means 8 additional bytes per "PLCore::Object"-instance on a 32 bit machine,
  but I was unable to think of any other decent way for this. There are situations were one needs to know when an RTTI object has been killed. An example for such a
  situation is "PLFrontendQt::DockWidgetObject" were the GUI has to be informed about the murder of it's fosterling.
  -> At first I tried the following solution:
    - Within "ClassManager" added
          Event<const Object*> EventObjectCreated;    /**< An object has been created (do not destroy the given instance), if you have another option, don't use this event to get this information in order to keep the internal overhead to a minimum */
          Event<const Object*> EventObjectDestroyed;  /**< An object has been destroyed (the object may already be invalid, do not destroy the given instance), if you have another option, don't use this event to get this information in order to keep the internal overhead to a minimum */
    - Within "Object" constructor/destructor added
      Object::Object()
      {
          ClassManager::GetInstance()->EventObjectCreated(this);
      }
      Object::~Object()
      {
          ClassManager::GetInstance()->EventObjectDestroyed(this);
      }
    - This way, the "PLCore::Object"-instance would not have gained 8 bytes more weight... but I assume the runtime overhead would have run faster out of control as I could have
      sayed "bad idea".
- Fixed invalid cast within
  SimpleList<ValueType>::SimpleList(const Container<ValueType> &lstSource, uint32 nStart, uint32 nCount)
  -> GCC found it
- When using "StringBuffer::GetNumOfBytes()" one has now to specify the internal string format. The previous approach was highly dangerous leading in worst case
  bug combination within a buffer overflow.
PLFrontendQt:
- Replaced the "SelectSceneNode" broadcast by the more generic "SelectObject"
- "DockWidgetSceneGraph::QtSlotTreeViewDoubleClicked()" now also reacts on selected scene node modifier
- "DockWidgetObject" supports now the generic "SelectObject" broadcast
- Removed "DockWidgetSceneNode" because there's currently no difference to the more generic "DockWidgetObject"
- "DockWidgetObject" is now using the new "PLCore::Object::SignalDestroyed"-signal
- "DockWidgetSceneRenderer" is now using the new "PLScene::SceneRenderer::EventDestroyed"-event
- "DockWidgetSceneRenderer": When the encapsulated Qt dock widget gets shown, there's a scene renderer refresh when required
- "DockWidgetManager::ShowDockWidget()": "pQDockWidget->raise();" was missing, now the Qt dock widget comes into foreground as indented



>> 04.01.2012
[SW]
- Implemented linux part of System::GetModuleFilenameByMemoryAddress(). It is using the glibc extension dladdr. On a short search it seems that this method
  exists also under Android 2.2 and up and Mac OS X 10.3 and up. Due lack of devel environment for those platform i can't check if this is true
- PLFrontendQt: moved the ClassInfoItemRoles enum back to the header
    The ClassInfoWidget now hides tabs for class items which are empty. And the Items in the tabs are now sorted.
    Fixed adding items for Properties
    Added MOdel items for Constructor and Methods (currently they return the signature given by the GetSignature Method for testing as tooltip)



>> 04.01.2012
[CO]
- "ClassManager": Renamed "GetModule()" into "GetModuleByID()"
- "ClassManager": Added "GetModuleByName()"
- "Module::GetFilename()" now returns a native style path, documented this behaviour
- Added "System::GetModuleFilenameByMemoryAddress()": We give this method a pointer to a memory address located in a certain shared library
  or executable, and we want to know the absolute filename of this shared library or executable.
- "ClassManager::RegisterModule()": Changed signatur parameter "uint32 nModuleID" into "const uint32 *pnModuleID". This way we have the module
  ID as well as a memory address inside the shared library or executable the module is implemented ("memory anchor"). We can now use this memory
  address together with the new "System::GetModuleFilenameByMemoryAddress()" to get the module filename.
  -> At least on Windows, "Module::GetFilename()" no longer returns an empty string for modules directly loaded at program start by the operation system
  -> Currently, the Linux implementation just returns a null pointer (nothing highly dramatical, I have no time to check this on another platform)
- "Frontend": Renamed "SetPositionSize()" into "SetWindowPositionSize()" to make clear that this is about the window, not the client area we're usually
  interested in
- "Frontend": Added "GetWindowPositionSize()", the counterpart of "SetWindowPositionSize()"
PLFrontendQt:
- Review of "ClassInfoModel", "ClassListModel", "HeaderTreeItem": Only the usual code combing to enable my eyes to locate code faster by jumping to usual places,
  no change in functionality
- "ClassInfoModel", "ClassListModel": Fixed Visual Studio 2010 compiler warnings like
    "warning C4482: nonstandard extension used: enum 'PLCore::EMemberType' used in qualified name"
- Added "ClassInfoWidget" & "RTTIBrowserWidget" from an RTTI browser example Stephan Wezel gave me, those are reusable GUI building blocks
- Added "DockWidgetRTTIBrowser" which is just a tiny helper class making it possible to create an RTTI browser dock widget instance at once
    -> WOW, Stephans RTTI browser works like a charm. By using it, it's finally possible (again) to browse through the RTTI in order to see which classes,
       attributes etc. are available. This information is quite useful when manipulating scene files within a text editor, adding user properties within 3ds Max,
       writing scripts... it's a kind of interactive realtime documentation. :D
- RTTI browser: Best to show and work only with class names including namespaces (unique names, this way we also don't have to explain to the user
  technical stuff when to use a namespace and when not, for the user it's just a name :)
- RTTI browser: Everything is derived from "PLCore::Object", expand this level by default when showing the class hierarchy
- "DockWidgetSceneGraph": Send broadcast when double clicked, not clicked. Same behaviour as in RTTI browser or PLViewerQt 3D viewport.
- General GUI titles: It's probably common to use something like "Scene Graph" instead of "Scene graph"
- RTTI browser: Module view: Added module filename within the tooltip (important information so one can see exactly where this modules comes from)
- "Frontend": Methods like "GetMousePositionX()" are now using the central widget of the Qt main window instead of the Qt main window itself. This way there are
  no issues when adding dock widgets to the Qt main window because the frontend itself is only concerned about the central widget and is not interested in the
  GUI stuff around it.



>> 03.01.2012
[SW]
PLFrontendQt:
- Added models for RTTI "browsing"



>> 03.01.2012
[CO]
PLFrontendQt:
- Added project description
- Added PixelLight RTTI dock widget manager
- "DockWidget": By default, when someone is closing the dock widget Qt hides instead of deletes it
  -> We could write
         setAttribute(Qt::WA_DeleteOnClose);	// Delete the dock widget instead of hiding it when someone is closing it
     to change this behaviour, but when "reopening" the previously made changes to the widget layout would be gone and
     we don't want this. So, long story short conclusion, don't change the default behaviour in here.
- "DockWidgetManager": Implemented dock widget broadcast by mirroring the "PLCore::Object"-interface. This is a quite universal way for a communication
  with and between the dock widgets... and e.g. scripts like Lua can participate in the communication...
- Dock widgets: Added first broadcast "SelectSceneNode": A RTTI method which is called when a scene node is selected
- "DockWidget": Added the same communication interface as in "DockWidgetManager", but the emitting dock widget is excluded and one does not have to make
  a dock widget manager test in order to broadcast something. This communication infrastructure is important, so, it has to be as easy to use and robust as
  possible.
- "DockWidgetSceneGraph" & "DockWidgetSceneNode" must take into account that the used scene node can be destroyed at any time
- "SceneGraphNodeTreeItem" (within "SceneGraphTreeModel.cpp"): We must take into account that the used scene node can be destroyed at any time. For now
  I tried to make as few changes as possible to remove the crash in this situation. Added the following comment within "SceneGraphNodeTreeItem::OnDestroy()":
      "Review this situation when the scene node get's killed, update the tree view. Maybe we don't need
       to have an own event handler for each and every tree item and a single one for the whole tree is enough.
       (maybe we just need to know that an item is now invalid due to removal, then rebuild the tree?)"
  so it can be seen what's going on. Currently this results in empty tree view entries, but better than a crash because we can see what happend.



>> 31.12.2011
[CO]
PLFrontendQt:
- "DataModels::SceneGraphTreeModel::GetQImage()": For some reason, "QImage" appears to be BGR instead of RGB although the documentation states otherwise
  (maybe a little/big endian thing?). Double checked "PLGraphics::Image" to ensure it's no bug, and I can't imagine that it's a Qt bug either. Now the icons
  look correct.
- Added "DockWidgetSceneRenderer"
- "DockWidget": Delete the dock widget instead of hiding it when someone is closing it
- "FrontendMainWindow::mousePressEvent(QMouseEvent *)": [HACK] As soon as there's a Qt dock widget there are focus issues?
  -> Central widget has the focus, click in dock widget, click back in central widget and no focus change?
     Even when destroying the dock widget the focus is now completely messed up?
  -> When adding "setFocus()", all those issues are gone... but why is there such an issue in the first
     place? I was unable to find anything in the Qt documentation and other approaches didn't work either. :/
  -> Spend some hours in trying to figure out what's going on, but I finally have to go on and so this current solution must do the job until someone else has
     a better solution or an explanation for this behaviour. Can be tested in "PLViewerQt".
- Another funny Qt dock widget behaviour: Central widget has the focus, moving the mouse to the docked dock widget and dragging it out so that it is floating and
  while doing so the central widget has still the focus, when stopping the action the focus jumps to the dock widget. Why hasn't the dock widget the focus at
  once when clicking with the mouse onto it in order to start the floating step? I'am starting to remember why I don't like to work with GUI stuff. :/



>> 30.12.2011
[CO]
PLFrontendQt:
- Added abstract PixelLight RTTI class "DockWidget" encapsulating a Qt dock widget. While PLFrontendQt already offers several basic building blocks one can use
  within a Qt project, the goal of those RTTI dock widgets is to provide something high level. One can imagine those guys as ready-to-be-used components which
  just need to be instanced to add new dockable features to a Qt main window. A RTTI dock widget has to be as simple as possible in it's usage and e.g. has to
  provide a decent default behaviour. That's why I talked about "high level", they take away a certain amount of freedom, but give you something to see usable
  results at once in a generic way. By writing e.g.
    const PLCore::Class *pClass = PLCore::ClassManager::GetInstance()->GetClass("PLFrontendQt::DockWidgetSceneGraph");
    if (pClass)
        pClass->Create(PLCore::Params<PLCore::Object*, QWidget*>(pQtMainWindow)));
  one has at once a new dock widget within the Qt main window which can be used to work with the default application scene graph. Due to the PixelLight RTTI
  new RTTI dock widgets can be added easily and then e.g. automatically be used within PLViewerQt. For example, within my master thesis I'am going to need
  special GUI elements to e.g. manipulate transfer function. Now, all I have to do is implementing such a new RTTI dock widget and I'am ready-to-go within
  PLViewerQt... and can also reuse those new RTTI dock widgets in other applications as well... :D
  I'am sure that in the end some RTTI dock widgets have to interact with each other. Similar to the intends of Android. Shouldn't be a problem by using the
  PixelLight RTTI, but that's for the next implementation step. For now it was only important to have the fundamental idea up and running to see whether or not it can work.
  Right now it looks like it's working pretty well without being complex... the PixelLight RTTI and Qt are doing all the hard work as well as the basic building
  blocks Stephan Wezel already wrote.
- Added "DockWidgetObject", "DockWidgetScene", "DockWidgetSceneNode" and "DockWidgetSceneGraph" dock widget RTTI classes to have something to start with. Currently
  the interface is quite basic and will be enhanced. I'am sure a lot more of those fellows will follow over time.



>> 30.12.2011
[SW]
PLFrontendQt:
- When setting the start SceneNode for the SceneGraphTreeModel the user can now specify if the start node should be hidden. The same parameter is also added to QPLDebugDialog::SetContext



>> 29.12.2011
[CO]
- "Frontend": The "GetImpl()"-method needs to be public because it might be required to e.g. access the Qt frontend
PLFrontendQt:
- Added missing "ressources.qrc" processing within the Visual Studio project file
- "FrontendMainWindow": To make it possible to add e.g. a menu bar, it's required to render only into the "central widget". By default there's no central widget -
  added "FrontendRenderWindow" for the actual render window and embedded it into "FrontendMainWindow" as central widget.
- "QPLRenderWindow" is now derived from "FrontendRenderWindow"
- "FrontendMainWindow::timerEvent()": When performing the update step, we need to check whether the frontend is still valid and running, if not we have to shut
  down our application
- Added static helper class "ConstructFileFilter" for constructing file filters for "QFileDialog"



>> 28.12.2011
[CO]
PLFrontendOS:
- "FrontendAndroid": "GetX()", "GetY()", "GetWidth()" and "GetHeight()": Lookout! We need to use the current content rectangle of the window, not the window surface
  because the OS may add something like a virtual back-key to the window surface. If we directly use the window surface something like the FPS display on the bottom
  of the screen might be cut off.



>> 25.12.2011
[CO]
- Over the last past days, Stephan reported some issues with RTTI classes being instanced multiple times. A known issue. Added Stephans patches adding some more
  compiler checks and finally did the export/import refactoring discussed some time ago. The required compiler/definition checks are getting more complex
  as we add support for more platforms and compiler versions. PLCore now defines "PL_GENERIC_API_EXPORT" and "PL_GENERIC_RTTI_EXPORT" for export as
  well as "PL_GENERIC_API_IMPORT" and "PL_GENERIC_RTTI_IMPORT" for import. Instead of performing the compiler/definition check in every project, those
  projects should now use this new definitions. Updated the projects performing export/import and removed no longer required files:
    - "PLDatabase": Removed "PLDatabaseLinux.h" & "PLDatabaseWindows.h"
    - "PLMath": Removed "PLMathLinux.h" & "PLMathWindows.h"
    - "PLGraphics": Removed "PLGraphicsLinux.h" & "PLGraphicsWindows.h"
    - "PLInput": Removed "PLInputLinux.h" & "PLInputWindows.h"
    - "PLGui": Removed "PLGuiLinux.h" & "PLGuiWindows.h"
    - "PLRenderer": Removed "PLRendererLinux.h" & "PLRendererWindows.h"
    - "PLMesh": Removed "PLMeshLinux.h" & "PLMeshWindows.h"
    - "PLScene": Removed "PLSceneLinux.h" & "PLSceneWindows.h"
    - "PLEngine": Removed "PLEngineLinux.h" & "PLEngineWindows.h"
    - "PLPhysics": Removed "PLPhysicsLinux.h" & "PLPhysicsWindows.h"
    - "PLSound": Removed "PLSoundLinux.h" & "PLSoundWindows.h"
    - "PLIRC": Removed "PLIRCLinux.h" & "PLIRCWindows.h"
    - "PLJabber": Removed "PLJabberLinux.h" & "PLJabberWindows.h"
    - "PLParticleGroups": Removed "PLParticleGroupsLinux.h" & "PLParticleGroupsWindows.h"
    - "PLSPARK_PL": Removed "PLSPARK_PLLinux.h" & "PLSPARK_PLWindows.h"
    - "PLlibRocket": Removed "PLlibRocketLinux.h" & "PLlibRocketWindows.h"
    - "PLCompositing": Removed "PLCompositingLinux.h" & "PLCompositingWindows.h"
    - "PLGuiXmlText": Removed "PLGuiXmlTextLinux.h" & "PLGuiXmlTextWindows.h"
    - "PLFrontendPLGui": Removed "PLFrontendPLGuiLinux.h" & "PLFrontendPLGuiWindows.h"
    - "PLDatabaseSQLite": Removed "PLDatabaseSQLiteLinux.h" & "PLDatabaseSQLiteWindows.h"
    - "PLDatabaseMySQL": Removed "PLDatabaseMySQLLinux.h" & "PLDatabaseMySQLWindows.h"
    - "PLDatabaseNull": Removed "PLDatabaseNullLinux.h" & "PLDatabaseNullWindows.h"
    - "PLDatabasePostgreSQL": Removed "PLDatabasePostgreSQLLinux.h" & "PLDatabasePostgreSQLWindows.h"
    - "PLScriptV8": Removed "PLScriptV8Linux.h" & "PLScriptV8Windows.h"
    - "PLScriptPython": Removed "PLScriptPythonLinux.h" & "PLScriptPythonWindows.h"
    - "PLScriptNull": Removed "PLScriptNullLinux.h" & "PLScriptNullWindows.h"
    - "PLScriptLua": Removed "PLScriptLuaLinux.h" & "PLScriptLuaWindows.h"
    - "PLScriptAngelScript": Removed "PLScriptAngelScriptLinux.h" & "PLScriptAngelScriptWindows.h"
    - "99TestPlugin": Removed "99TestPluginLinux.h" & "99TestPluginWindows.h"



>> 20.12.2011
[CO]
- "String"-class: Added "String &Insert(char nCharacter, uint32 nPos)" and "String &Insert(wchar_t nCharacter, uint32 nPos)" (there were already such
  "Replace()"-method variants)
- Bugfix within script implementation "PLScriptLua::RTTIObjectPointer::NewIndexMetamethod()": We can't just use "lua_tostring(pLuaState, 3)" because Lua
  will give us e.g. for a boolean type just an empty string, meaning that within a Lua script something intuitive like "MyRTTIObject.MyBooleanAttribute = true"
  would not work. Handled this Lua behaviour.



>> 15.12.2011
[CO]
- "Url": Added more examples within the documentation in order to be able to understand what the URL-class will do with provided data
- "System::GetCurrentDir()": Enhanced documentation to make it possible to understand it's behaviour
- When Thomas MÃ¼hsam worked on PLInstall, he noticed that the behaviour is different across multiple methods dealing with filenames and
  paths. I finally took the time to have a look into it by documenting behaviour of some methods in more detail and adding more examples.
  One typical confusion is whether there's a "/" at the end of a path - this is usually up to the user and e.g. the "Url"-class will not force
  a certain approach onto the user. Another confusion is whether not not there has to be a "file://" for every local path. This is another thing
  handled by the "Url"-class. For example "Url::CutFilename()" will omit the protocol for a local path (e.g. the result will not be
  "file://C:/Programs/App/"). I was unable to find an explanation for this within the documentation or diary, but I'am sure there's a good
  reason for this. Changing the behaviour of such a fundamental class on the fly is a no go, so I don't touch this right now. The overall
  URL handling in PixelLight is determined by the "Url"-class and other components of PixelLight should not try to break with "Url"-class behaviour.
- Reviewed the relatively new "Runtime"-class and ensured that the different methods return the paths in the same format
- "Runtime": The "Data"-methods no longer have a "/" at the end to have a similar behaviour across this class
- "LogFormatterText::Open()": Reverted the change from "19.10.2011", UTF8 within logs is trouble we best avoid... there are tools out there still
  having issues with UTF8 and UTF8 is in general more complex and for a simple text log those additional efforts and troubles are not justifiable. Wrote
  a hint into the first log line so that no one wonders when a cryptic Unicode character from a none English language doesn't show up correctly.



>> 10.12.2011
[CO]
- "MemoryManager": Made the methods inline in order to give the compiler a chance to optimize out function calls. Of course, for this it's required to include
  "standard"-headers into PixelLight headers which is potentially dangerous when it comes to cross-platform because usually this makes at least on one platform
  problems in a certain header include combination. But these memory operations are totally basic building blocks, same topic as in PLMath diary entry "15.11.2011"
  regarding to the "PLMath::Math"-class with fundamental math building blocks. So, this must be worth the rest. It's still better then directly using the
  "standard"-function because in case there are serious issues on a platform in the future, it's quite easy to resolve them because only this one header has to
  be touched. I added as usual a long comment explaining why this header is including "standard"-headers and also a long dirary entry so everyone can see that
  this isn't an inline-mood. :D
-> By the way, the first PixelLight diary, this one, just reached 10.000> lines... sure, there are spaces and one could play around with the line size, but hey,
   10.000> lines. Took just 9> years...
- Reviewed commit 1786dd0e5be679c566891d5aae62a6c38771df50 (see PLCore diary entry "03.12.2011")
  -> Looks fine in general, except that "PLCore::System" is already providing the required information, removed "ARCHITEXTUREANDBITSIZE_STRING" definition
  -> "LinuxCommon.cmake" was using "CMAKETOOLS_TARGET_ARCH" while it should have used "CMAKETOOLS_TARGET_ARCHBITSIZE"
  -> "PLCore::Systen::GetPlatformArchitecture()" returns for instance 'x86', 'x64', 'armeabi', 'armeabi-v7a' and so on (as extensively documented). Yes, the
     technical proper name for x64 would be "x86 architecture with 64 bit extensions", but that's far to technical and something like "x86_64" is more difficult
     to read and name during a conversation as the marketing term "x64". That's why e.g. the runtime subdirectory is named "x64", not "x86_64".



>> 07.12.2011
[CO]
- "SystemAndroid": Added "GetAndroidApp()" and "SetAndroidApp()"
- "SystemAndroid": Made some methods inline



>> 06.12.2011
[CO]
- While adding more unit tests, Jens Schmer found another bug within the container classes. When down resizing an full array, the number of elements within
  the array was not the new maximum number of elements, it was the new maximum number of elements -1. Interessting that this never caused any problems. Cool
  that we now have someone testing thru the classes in detail via unit tests. :D
- The implementation of "Class::GetDerivedClasses()" was
	const List<const Class*> Class::GetDerivedClasses() const
	{
		// Get list of derived classes
		List<const Class*> lstClasses;
		ClassManager::GetInstance()->GetClasses(lstClasses, m_pClassImpl->GetClassName(), NonRecursive, NoBase, IncludeAbstract);
		return lstClasses;
	}
  -> This is clearly quite ineffective, especially because it's a linked listed. Changed the signature of this comfort method into
     "void GetDerivedClasses(List<const Class*> &lstClasses) const"
     meaning that there is no longer a temporary coping around and such a signature is not totally unusual.
  -> Within PixelLight itself, this method is never used, so, no other updates were necessary



>> 03.12.2011
[SW]
- The GetRegistryDirectory Method checks if the path read from the "registry" exists and returns an empty string if not.
  Under linux added ARCHITEXTUREANDBITSIZE_STRING define which holds the architecture and bitsize string (e.g. x86 for 32bit x86 code or x64 for 64bit x86 code).
  The string from this define gets appended to the standard install paths of pixellight.



>> 03.12.2011
[CO]
- More inline within PLCore: "String", "Class", "ClassImpl", "ClassManager", "MemberDesc", "Module", "DynEvent", "EventDesc", "EventHandlerDesc", "ConstructorDesc",
 "FuncDesc", "ParamsParser", "ParamsParserXml", "VarDesc", "ApplicationContext", "CoreApplication", "Config", "Frontend", "FrontendApplication", "FrontendContext",
 "FrontendImpl", "Log", "LogFormatter", "LogFormatterHtml", "Buffer", "Connection", "Host", "Socket", "SocketAddress", "HttpClient", "HttpHeader", "Registry",
 "ScriptManager", "Runtime", "Pipe", "Process", "Chunk", "CommandLine", "CommandLineOption", "HTMLParser", "Loadable", "LoadableManager", "LoadableType", "Loader",
 "Localization", "LocalizationGroup", "LocalizationText", "ProfileGroupElement", "Time", "Version", "XmlAttribute", "XmlBase", "XmlComment", "XmlDeclaration",
 "XmlDocument", "XmlElement", "XmlNode", "XmlText", "XmlUnknown"



>> 30.11.2011
[CO]
- PLFrontendOS: Added empty "OSWindowMacOSX"-class as start point for the Cocoa (Objective-C API) port (X11 can be used on Mac OS X, but it's best to avoid using it
  to avoid compatibility trouble)
- PLFrontendOS: Renamed "XDnDFileDropHelper" into "Linux_XDnDFileDropHelper" to make clear that this helper class is Linux related



>> 29.11.2011
[CO]
- Feature request "ID: 3443487" (http://sourceforge.net/tracker/index.php?func=detail&aid=3443487&group_id=507544&atid=2063685): Added critical section support to
  the mutex implementation. This is a Windows specific thingy:
  - "Mutex":            Lock/unlock across multiple processes
  - "Critical Section": Lock/unlock only inside the same process
  -> Default has to be "Mutex" to be on the safe universal side
- PLFrontendQt: Visual Studio project file: Disabled annoying "warning C4127: conditional expression is constant"-warning, it's within the Qt
  headers were we can't change anything in there :/
- Added "CriticalSection"-class, a simple comfort class derived from mutex
- "FileObject", "File", "Directory", "Url", "System", "DynLib", "Mutex", "Semaphore", "Thread", "FileSearch", "Timing", "Tokenizer", "RegEx": Everything reasonable
  to be inline is now inline to give the compiler a chance to optimize out expensive function calls. I'am sure that over the time more of such changes will follow.



>> 26.11.2011
[CO]
- As feared yesterday, my "Socket::GetNumOfWaitingBytes()"-method wasn't really correct. As mentioned, my network topic experience is near to zero and to be honest,
  I don't have the time to get into it in detail because I already have to manage all other topics at once. Sadly, my day has only 24 hours - so, we have to rely on
  teamwork to get everything done. That's why I'am totally happy that within the bug tracker there's response (ID: 3442166) pointing me into the right direction. :D
  -> Renamed "Socket::GetNumOfWaitingBytes()" into "Socket::IsDataWaiting()"
- Bugfix (ID: 3442054 - http://sourceforge.net/tracker/index.php?func=detail&aid=3442054&group_id=507544&atid=2063682 ): "PLCore::Connection::Receive()" called
 "PLCore::Connection::OnReceive()" with the fixed buffer size, instead of with the number of received bytes
    -> Also reviewed this class and checked whether or not the comments are detailed enough
- While working on PLUnitTests, Jens Schmer noticed several issues and inconsistencies. I asked him to mark everything he's noticing, not only real bugs, but also
  usability stuff like when a method behaves another way as expected when reading the method name and documentation. I try to have a look at each point, one
  after another without, hopefully, breaking anything or introducing new issues.
  -> "Container"-class: Have a look at the following methods:
    virtual ValueType &Add() = 0;
    virtual ValueType &Add(const ValueType &Element) = 0;
    virtual ValueType &AddAtIndex(int nIndex) = 0;
    virtual bool AddAtIndex(const ValueType &Element, int nIndex) = 0;
    The last one has another return value as the other methods. That's definitly unexpected. Changed "virtual bool AddAtIndex(const ValueType &Element, int nIndex) = 0;"
    into "virtual bool AddAtIndex(const ValueType &Element, int nIndex) = 0;". As far as I can see, this method is never used, so, it should be safe to make this change.
  -> "Container"-class: Making a container to a copy of an empty container didn't work, the result has to be a empty container
  -> "Container"-class: Using the "Compare()"-method with two empty containers returned 'false' instead of 'true'



>> 25.11.2011
[CO]
- There's a first feature request at http://sourceforge.net/tracker/?group_id=507544&atid=2063685 "Socket::IsArrivalData() - ID: 3439371"
  -> I waited several days to give other team members the option to handle the request, but I'am sure that it's no good idea to have such open minor feature
     requests for several weeks...
  -> Added "Socket::GetNumOfWaitingBytes()" returning the number of bytes waiting to be received (non-blocking request)
  -> I have only a little bit of experience in network related topics, so, if I totally messed it up please tell me :D
- "PLFrontendOS::FrontendAndroid()": It's now required to provide the constructor with a frontend context instance. This way, it's e.g. possible to tell
  the frontend about the RTTI class name of the application to start.



>> 24.11.2011
[CO]
- Bugfix: "PLCoreLinux.cpp": The implementation of "wcscasecmp" and "wcsncasecmp" was broken (Mac OS X or Android don't have such primitive "standard" functions)
  -> "wcscasecmp": http://linux.die.net/man/3/wcscasecmp states
     "The wcscasecmp() function returns zero if the wide-character strings at s1 and s2 are equal except for case distinctions. It returns a positive integer if s1
      is greater than s2, ignoring case. It returns a negative integer if s1 is smaller than s2, ignoring case"



>> 16.11.2011
[CO]
PLScriptBindings:
- Exposed "PLCore::ClassManager::ScanPlugins"-feature to scripts
- Exposed "PLCore::System::GetPlatformArchitecture"-feature to scripts
PLScriptLua:
- Bugfix: "RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()": Boolean and string values were not handled correctly



>> 13.11.2011
[CO]
- Thomas MÃ¼hsam noticed that "System::GetCurrentDir()" returned, unlike many other methods, a native style instead path of an uniform style path and also sayed that
  this makes directly comparing paths impossible (this resulted in a discussion about interfaces :). It's first required to check in which form the given path is,
  and then converting them into an universal form so they can be compared. Searched the PLCore diary for the reason why this method is returning a native
  style path... it turns out that over the years, this had been changed multiple times:
  - "17.04.2008": I changed it from native to uniform with the argument now also Thomas MÃ¼hsam mentioned
  - "03.08.2010": Stefan Buschmann changed it from uniform to native form, I wasn't able to find an explanation for the change, but I'am sure there's a good one
    (no offence, I just try to understand changes in order to avoid a continues back and forth change and questions over the years)
  -> Because there were now issues and discussions, again, about the representation of paths, I reviewed the topic. The change from "03.08.2010" was probably done
     to keep everything as "close-to-metal" as possible, to avoid dozens back and forth conversion. While "it's always uniform across all platforms" would be nice
     for the API user, it wouldn't be that good in respect of the overal performance and the user wouldn't have a chance to influence this. Were not already done,
     documented the methods "passing thru" native style path.
- "SystemWindows::GetCurrentDir()" & "SystemLinux::GetCurrentDir()" were using "Url(sDir).GetNativePath()" while other similar methods directly returnd the OS style
  path wihouth touching it, changed it
- Linux port: Added several "String::FromUTF8()" when passing an OS "char"-String through the interface to don't loose Unicode data. Would be nice if someone could
  review this and similar places to ensure that we never convert an Linux UTF8 string into an ASCII string by accident...



>> 12.11.2011
[CO]
- "PLScriptV8" & "PLScriptAngelScript" & "PLScriptPython" & "PLFrontendMozilla" & "PLFrontendActiveX": Updated x64 Visual Studio project settings



>> 11.11.2011
[CO]
- "PLFrontendQt" & "PLFrontendPLGui" & "PLFrontendNull" & "PLScriptBindings" & "PLScriptNull" & "PLScriptLua": Updated x64 Visual Studio project settings



>> 04.11.2011
[CO]
- Fixed bug 3433006 (http://sourceforge.net/tracker/?func=detail&aid=3433006&group_id=507544&atid=2063682): The return value of "FileObject::GenericMove()"
  and "FileObject::GenericCopy()" was always "false"
- I had to add "GetInstance()" and "HasInstance()" to the interfaces of singleton implementations. This solution enhances the compability with legacy compilers
  like GCC 4.2.1 used on Mac OS X 10.6.
  -> The C++11 feature "extern template" (C++11, see e.g. http://www2.research.att.com/~bs/C++0xFAQ.html#extern-templates) can only be used on modern compilers like GCC 4.6
  -> We can't break legacy compiler support, especially when only the singletons are responsible for the break
  -> See PLCore::Singleton for more details about singletons
- Removed the "compiler, please keep my symbols"-hacks (see e.g. PLCore diary entry 23.10.2011), after the change from above, they are no longer required



>> 02.11.2011
[CO]
- "System"-class: Added "GetPlatformArchitecture()"
- String implementation: "ResetLocaleToC()": In case the current set locale is already "C" (the default if no one has messed around with the current set
  locale), we don't have to do anything



>> 01.11.2011
[CO]
- "Runtime"-class: Added "SetDirectory()" and "GetPLCoreSharedLibraryDirectory()", made "GetPLCoreSharedLibraryName()" public



>> 31.10.2011
[CO]
- "NULL_HANDLE" and "INVALID_HANDLE" are no longer classic definitions, instead they are now constants of the type "PLCore::handle" to give the compiler
  the chance to perform a type check
- Fixed bug 3431174 (http://sourceforge.net/tracker/index.php?func=detail&aid=3431174&group_id=507544&atid=2063682): Within the "PLCore::System"-constructor,
  the main thread was created incorrectly. Also reviewed the thread constructors.
- "System"-constructor cleanup: Removed "[HACK] Force the linker to keep the "Profiling"-class (don't strip it away)" because it's now within "PLCore.cpp"
  together with the rest of the same issues (see PLCore diary entry 23.10.2011)



>> 27.10.2011
[CO]
- "System": Added "GetSharedLibraryPrefix()" and "GetSharedLibraryExtension()"
- Added "SystemMacOSX" which is derived from "SystemLinux"
- "SystemWindows::GetPlatform()" now returns "Windows" instead of "Win32"/"Win64" to make it similar to "Linux", "Android" and "MacOSX". I try to avoid
  such breaking changes, but this one was necessary do deal with all the supported platforms in an uniform way.
- "System": Added "GetPlatformBitArchitecture()"
-> It's hightly recommended to make a clean build of PixelLight in order to avoid issues when using plugin files from before this change



>> 26.10.2011
[CO]
- "SystemLinux::GetPlatform()" & "SystemLinux::GetOS()": Added Mac OS X handling (it's not worth to derive an own class, yet)
- "ScriptManager::CreateFromFile()": Enhanced the method documentation in order to avoid problems like the one at
  http://dev.pixellight.org/forum/viewtopic.php?f=6&t=103



>> 25.10.2011
[CO]
- "Runtime::GetSystemDirectory()": We really need to check for the registry, first: When building for Linux, there are fixed build in locations like
  "/home/bob/pixellight/cmakeout/Base/PLCore/" and build executables will link against those shared libraries -> You'll receive
  "/home/bob/pixellight/cmakeout/Base/PLCore/" as PL system directory, not e.g. "/home/bob/pixellight/Bin-Linux/Runtime/x86" as expected.



ï»¿>> 23.10.2011
[CO]
- Interesting, just tried to build PixelLight on MS Windows by using CMake to create the Visual Studio projects files and then, as usually build PL with VC...
  but within PLMath the linker told me that a few "PLCore::Log" singleton symbols were missing. They were stripped way... I double checked the compiler
  settings, but they look the same, meaning the one created by CMake and the one within the Git repository I'll use during the development. Interesting,
  same compiler, same settings, but different results (maybe it's the order in which the files are compiled? :). Added the "usual hack" within "PLCore.cpp"
  to force the compiler to keep the required symbols.
- Implemented "DynLibLinux::GetAbsPath()"



>> 22.10.2011
[CO]
- "EventDesc::GetSignal()" & "EventHandlerDesc::GetSlot()" & "VarDesc::GetAttribute()": Gave in a null pointer into the not documented
  pointer parameter and got a crash. This should never happen. Changed the pointer parameter into a reference parameter.
- "VarDesc": Added "GetDefault()"-method to make it possible to request the default value of an attribute without the need to have an attribute
  instance in order to get this information
- "Object": Added "SetAttribute(const String &sName, const DynVar *pVar)". This is a comfort method allowing to write e.g.
    pFirstObject->SetAttribute("MyAttribute", pSecondObject->GetAttribute("MyAttribute"));
  instead of
    DynVar *pDynVar = pSecondObject->GetAttribute();
    if (pDynVar)
      pFirstObject->SetAttribute("MyAttribute", *pDynVar);
    In case there's no such attribute in "pSecondObject", nothing happens at all.



>> 21.10.2011
[CO]
- More Unicode related issues within the PixelLight forum: http://dev.pixellight.org/forum/viewtopic.php?f=6&t=91
  -> The next scheduled PixelLight release is in two days, so no big complete refactoring of for example the tokenizer.
     Only implementation completion and minor required updates.
  -> "BufferedReader": Added "GetStringFormat()"
  -> "BufferedReaderFile::ReadFromStream()": Implemented Unicode support
  -> "BufferedReader": "GetChar()" & "ReadChar()" now return "int" instead of "char" (identical to "File::GetC()")
  -> "Tokenizer::GetNextToken()": Implemented Unicode support
  -> Optimization: "Tokenizer::StreamIsChar()" read again from the string, although the current character was already available.
     Removed this function.



>> 20.10.2011
[CO]
- Exposed "ApplicationContext" to the RTTI
- "System::GetCurrentDir()" & "ApplicationContext::GetAppDirectory()": On Android, those are empty strings and just writing e.g.
    cApplicationContext.GetAppDirectory() + "/Data"
  resulted within "/Data", which was not correct. When working on the Android port, I catched this case and used e.g. "Data" in
  case the application directory was empty. Now that the Android port is working, I'am cleaning up and removing situations resulting
  in to many stuff to take into account when using the PixelLigth API. In case "System::GetCurrentDir()" & "ApplicationContext::GetAppDirectory()"
  have internally an emtpy string, '.' is returned meaning that
    cApplicationContext.GetAppDirectory() + "/Data"
  will result in "./Data" which is fine.



>> 19.10.2011
[CO]
- "FileWindows::PutS()" didn't take Unicode into account (... as well as some other functions in this class...)
- "File::Open()": Added string encoding format parameter
- Text based log formatter implementations are now using UTF-8 instead of ASCII
- "File::GetContentAsString()": Removed string encoding format parameter because it's now defined by "File::Open()"
- "File::GetContentAsString()": Added UTF8 support
- "LoadableManager::OpenFile()": Added string encoding format parameter
- "ScriptManager::CreateFromFile()": Added string encoding format parameter
- Fixed spelling error: "LogFormater" -> "LogFormatter"



>> 16.10.2011
[CO]
- "Socket": Fixed "warning C4244: 'initializing' : conversion from 'SOCKET' to 'int', possible loss of data" when compiling for 64 bit



>> 15.10.2011
[CO]
- "Object::SetAttribute(const String &sName, const DynVar *pVar)" & "DynVar::SetVar(const DynVar *pValue)" & "Type<T>::ConvertFromVar(const DynVar *pValue)":
  It was not documented whether or not "pValue" can be a null pointer, in case one passed into a null pointer it just crashed. This is not obvious to
  the API user. Changed it into a reference to make clear that it must be valid.
- "ClassReal::~ClassReal()" & "ClassReal::DeInitClass()" & "ClassManager::~ClassManager()": The class manager may have already been destroyed (random static
  de-initialization order), we need to take this situation into account



>> 14.10.2011
[CO]
- The extern template related changes I did yesterday solved my linker issue on Mac OS X. It turns out that on the Linux port, the extern
  template usage was not correct and caused multiple template instances all over PLCore. Tested it on Linux and Mac OS X as well as Windows, no
  more issues. :D
- New platform, new data type issues: "handle" was defined by using "unsigned long" on Linux and "unsigned int" on MS Windows. Now it's
  "unsigned __int32" on 32 bit, "unsigned __int64" on 64 bit, on all platforms. I hope this is causing less issues across multiple platforms and
  bit sizes.
- "Thread::GetID()" now returns "handle" instead of "uint32" (e.g. on MS Windows, "HANDLE" is a pointer... so 32 bit might not do the job)



>> 13.10.2011
[CO]
- When linking PLCore on Mac OS X, the linker complains about multiple symbols for "Singleton<Log>" and fails to link.
  After a day of stumbling around on the unfamiliar Mac OS X, I had no real glue what's going on... because the Apple GCC 4.2 is heavily
  out-of-date I compiled GCC 4.6.1 for the used system, and supected that the out-of-date Apple ld linker caused this problem (so I played
  around with GNU binutils etc). After talking with Stephan Wezel about the observed issues, he gave me the tip to check whether the "extern"
  in front of "template class" is really there when compling the source code under Mac OS X. So, I first read some more stuff about C++11
  extern template, looked how it's currently used... and the usage looked wrong. Under Linux (the Mac OS X port is just reusing the
  Linux port :), when compiling PLCore, there was no "extern" in front of "template class", and I guess that this means that everywhere this
  header was included, a new singleton template instance was created (just inside PLCore!) - this would at least explain why the Apple linker
  complained about multiple instances. Changed it. At this time, the changes are only tested on MS Windows. Tomorrow I'll do more tests and
  really hope that this solves the issue.



>> 11.10.2011
[CO]
- Yesterday, a fellow student had isses to get PixelLight up and running - as it turns out, there were PixelLight runtime configuration issues, again.
  Just like within the forum post http://dev.pixellight.org/forum/viewtopic.php?f=6&t=68 the MS Windows PATH environment variable was set correctly... but
  the registry key was missing. So, while the MS Windows PATH environment variable is usually no big deal and there's not really a way around it, this
  mandatory registry key on the other hand is a constant source of errors and frustration. So, I had a look into it.
  As it turned out, I already had a solution at "18.08.2011" but didn't see at this time that this also could be used to make the mandatory registry key
  only optional. The "Runtime::GetSystemDirectory()"-method is now also using the PLCore shared library in order to find the PixelLight runtime directory.
  Only when using a static version of PLCore, we have to use the registry key as last available option. Usually the dynamic shared library of PLCore is used,
  and so there's usually no need for this registry key and no problem in case it's not there.



>> 07.10.2011
[CO]
- "Runtime::ScanDirectoryPluginsAndData()" & "Frontend::Run()": In case of a total failure, there's now also the hint
    "Is the PixelLight runtime registered correctly? (see e.g. "PixelLightBuild.pdf" for details)"
  within the message to give at least a hint what's usually wrong when this failure happens. Of course, this means that an end-user will see this message as well... but
  on the other side, when delivering an application, the PixelLight runtime is usually directly put in the same directory as the executable so that everything can be found
  (= no chance that this message can occure).



>> 05.10.2011
[CO]
- Loadable: Renamed "Load()"-method using a filename into "LoadByFileame()"
- Loadable: Renamed "Save()"-method using a filename into "SaveByFileame()"
- Loadable: Renamed "Load()"-method using a file into "LoadByFile()"
- Loadable: Renamed "Save()"-method using a file into "SaveByFile()"
-> This change was necessary to make it possible to expose this methods to the RTTI (method names must be unique for this)
-> I fist thought about just renaming the file versions, but in the end I decided to be consiquent even if the method is now a little bit longer... but therefore one
   can guess what the method expects as parameters (and it's consitent to "GetByIndex()" & "GetByName()" and so on).
- PLFrontendOS: Added Android frontend (still some details to hammer out)



>> 04.10.2011
[CO]
- Windows: PLFrontendQt includes simplification: "Include\Qt" instead of "Include\Qt\Qt" (when building Qt, an additional install step was required to make real Qt headers,
  not headers just redirecting into the "src"-directory)
- "ClassReal::InitClass()" and "ClassDummy::InitClass()" didn't register the properties of the base class as expected. While all methods and so on from the base class and
  the base class of the base class and so on were registered, only the "own" properties of the base class were added to a derived class. Meaning that a derived class was missing
  properties of the base class it's base class was derived from. This looks like a bug (if it's no bug, it's a odd behaviour). Fixed it.
  (noticed it when implementing "PLAssimp::MeshLoader" and "PLAssimp::SceneLoader")



>> 27.09.2011
[CO]
- More fine tuning on "PLFrontendOS" & "PLFrontendQt" & "PLFrontendPLGui": When making the window visible, it's now also made active at once. If this is not done, debugging
  in Visual Studio doesn't make that much fun because the frontend window appears, a breakpoint is reached - but Visual Studio doesn't automatically come into foreground and
  gets the focus, the frontend window is still on the top and you may even not notice that you've reached a breakpoint. I think, when implementing the frontends, I delayed
  the window activation until everything is initialized so e.g. input controls are correctly activated/deactivated when the window gets active/inactive. Due to the progress
  in frontend fine tuning, this delay is no longer required.
- "DynLibLinux::Load()": If a shared libarary failed to load in dynamically, the application completly shut down. Fixed that.



>> 26.09.2011
[CO]
- "LoadableManager::OpenFile()" now resolves "./" because we always want to work with absolute paths so the user can easily figure out the absolute path later on by using "cFile.GetUrl()"
- "FrontendApplication::OnInitData()" & "CoreApplication::OnInitData()": The application and current directories should have the highest priority of all base directories because the application data is
  most likly in those directories



>> 16.09.2011
[CO]
- Added "ConsoleAndroid" which is derived from "ConsoleLinux" and just overrides the "Print()"-implementation. Even on Android, it's possible to write into the console, meaning "stdout"... but it's somewhat
  complicated to "see" this output when starting an apk file (meaning: not starting an native application via shell). In this console implementation, messages are not only written into the console,
  the Android in-kernel log buffer is used as well (use Androids "logcat" utility to access this system log).
- "SystemAndroid" now also overrides "GetConsole()" in order to make it possible to toggle the used console implementation ("ConsoleAndroid"/"ConsoleLinux")



>> 14.09.2011
[CO]
- Android port: Added "FileSearchAndroid" implementation
- Bugfix (Linux): "PLFrontendOS::OSWindowLinux::GetX()" & "PLFrontendOS::OSWindowLinux::GetY()" were not returning the window position correctly (window decoration issue). Tested it now several times,
  and when restarting an application, the previous window position and size is now restored correctly (even when using two monitors).



>> 13.09.2011
[CO]
- Bugfix: "PLFrontendOS::OSWindowWindows::SetPositionSize()": The MS Windows function "MoveWindow()" sets the window size, not the window client area size
  -> We have to calculate this window size basing on the given client area size
- Bugfix: "PLFrontendPLGui" was not returning and setting the window size correctly (the window border must be ignored)
- "PLCore::FrontendConfig" and "PLRenderer::Config" have now the same default size (800x600 still feels quite fine during development)
- "Frontend::Run()": By default, this method is now allowed to show an urgent message to the user in case of a failure (see also dirary entry "23.08.2011")
- Android port: "SystemLinux::UrgentMessage()" writes into the Android kernel log buffer
- Added "SystemAndroid" which is derived from "SystemLinux". In here, an "AAssetManager"-instance can be set for example by the Android frontend and received
  for instance by a special Android file implementation.
- Added "FileAndroid" using the Android asset manager (implementation is not yet tested)



>> 12.09.2011
[CO]
- "String"-class: Do never ever pass a null pointer into "strdup" because the behaviour isn't specified in POSIX (http://pubs.opengroup.org/onlinepubs/9699919799/functions/strdup.html)
  -> On MS Windows and Linux a null pointer will be returned, on Android it just crashes...
- "Log"-class Android: In verbose mode, messages are not written into the console (there isn't easy access to it on Android), instead the Android in-kernel log buffer is used (use Androids "logcat"
  utility to access this system log)



>> 06.09.2011
[CO]
- Android port related: The Android NDK has no support for "mbtowc()", added the implementation from http://bsd.unixdev.net/4.5BSD/src/usr.libexec/dictd/mbtowc.c
  http://bsd.unixdev.net/4.5BSD/src/usr.libexec/dictd/mbrtowc.c



>> 05.09.2011
[CO]
- The Intel C++ compiler has no support for nullptr + fixed some issues detected by this compiler
- Fixed "warning #82: storage class is not first"-warnings of the Intel C++ compiler when using warn level 4



>> 04.09.2011
[CO]
- When building with CMake, it's now possible to disable the ZIP support in order to remove the zlib external dependency. Please note that it's *not* recommended to disable the ZIP
  support and this option does only exist to make it easier to create minimal builds which are really helpful when starting with a new platform support. In such a situation, it can
  be really frustrating to deal with external dependencies when you just want to make the first step and want to see "anything" - but just can't because you first have to compile
  the external dependencies and pray that you did everything correct: Correct compiler & linker settings, e.g. correct ARM architecture and so on. If e.g. any linker issue occur,
  and you don't use any external dependency at all (in theory, at this very moment there's still the libpcre external depencency, at least at the moment) - you know that the problem
  is somewhere within your project and not within an external dependency. :D



>> 31.08.2011
[CO]
- Android port related: "MutexLinux::TryLock()":  There's no implementation of "pthread_mutex_timedlock()" within the Android NDK, even if the function is listed within the headers.
  Depending on the API level, it's defined out, meaning no compiler error when using API level 8, but a compiler error when using API level 9 (some sources stating this is an error
  within the shipped "pthread.h"-header). For Android, we have to fallback to "pthread_mutex_lock()" (right now, I don't want to spend hours to find a work around).



>> 30.08.2011
[CO]
- Android port related: Even if there's a "wchar.h"-header, wchar_t is officially not supported by Android (no problem, wchar_t is for Windows, UTF-8 for Linux and the string
  class handles both as well as ASCII). Added a "wcscasecmp()" & "wcsncasecmp()" implementation within "PLCoreLinuxWrapper.h" & "PLCoreLinux.cpp" used when compiling for Android.
- Android port related: "PLCoreLinux.cpp": The Android NDK has no support for "wcstof()". Added the implementation from http://www.opensource.apple.com/source/Libc/Libc-320/locale/FreeBSD/wcstof.c
  with minor adjustments to make it compile (no time to reimplement something on my one, and it's also not worth it, there's other stuff to do instead of reimplementing
  the c standard library...).
- Android port related: The Android NDK has no support for "wcstoumax()". Added the implementation from http://www.opensource.apple.com/source/Libc/Libc-320/locale/FreeBSD/wcstoumax.c
  with minor adjustments to make it compile.
- Android port related: "PLCore/ConsoleLinux.cpp": The Android NDK has no "term.h", but "termios.h" works (validating Linux build next time when I switch the OS, but not at this very
  moment and not for every minor change, even when a change breakes something under Linux for a short period)
- Android port related: "PLCore::ThreadLinux::Terminate()": "pthread_cancel()" is not supported by the Android NDK. "android-ndk-r6/docs/system/libc/OVERVIEW.html" states:
  "pthread_cancel() will *not* be supported in Bionic, because doing this would involve making the C library significantly bigger for very little benefit."



>> 29.08.2011
[CO]
- "Core/MemoryManager.cpp": For "memcpy()" etc. "string.h" has to be included when compiling for Android (wow, now I'm glad that we even encapsulated such primitive functions,
   else there would be more than just this file to update...)
- Android port related: "ConsoleLinux::ClearScreen()" in here, we don't need to use the curses library and can go a more portable way
- Android port related: "ConsoleLinux::GetCursorPosition()" & "ConsoleLinux::SetCursorPosition()": There's no native curses library on Android, and compiling one
  just for this usually never used function would be overkill. So, right now, those two methods are not supported when using the Android port (already spend far too much
  time on this curses library issue!).



>> 23.08.2011
[CO]
- Qt: It appears that there's going something funny on in here... The PixelLight Linux external packages of Qt Stephan Wezel created, don't need the "src" because the includes
  are real includes and not just references. When downloading the Qt sources and looking into e.g. "Qt\4.7.1\include\QtCore\qvector.h" I see "#include "../../src/corelib/tools/qvector.h".
  When now building Qt on MS Windows using the options
    "configure -platform win32-msvc2010 -release -opensource -fast -sse -sse2 -no-qt3support -no-scripttools -no-stl -nomake examples -nomake demos -no-openssl -no-webkit -no-phonon -no-style-motif -no-style-cde -no-style-cleanlooks -no-style-plastique -no-sql-sqlite -qt-style-windowsvista -D NOMINMAX -D VC_EXTRA_LEAN -D WIN32 -D _WINDOWS -D _CRT_NONSTDC_NO_WARNINGS -D _CRT_SECURE_NO_WARNINGS -D _CRT_SECURE_NO_DEPRECATE -D _CRT_NONSTDC_NO_DEPRECATE -D _ATL_SECURE_NO_DEPRECATE -D _CRT_NON_CONFORMING_SWPRINTFS -D STRSAFE_NO_DEPRECATE -D _UNICODE -D UNICODE"
  I still see the same within the include files, and no new, modified includes appeared. I can copy out the files from "Qt\4.7.1\src\" - but this seems odd. If this would be the
  preferred way to use Qt, why is there an include directory in the first place? Did I messed up with the Qt compile configuration? Does the Qt build system handles things in another
  way under Linux? Maybe the includes are handled during "install" on Linux? So, until it's clear what's going on, we need to use OS dependent handling. :/
  (no time right now to spend hours with this issue)
- "System": Added "UrgentMessage()"-method for a primitive way (e.g. by using a message box) to be able to tell the user that something went terrible wrong
- "Runtime::ScanDirectoryPluginsAndData()": By default, this method shows an urgent message to the user in case of a failure



>> 21.08.2011
[CO]
- Renamed "PLCore::CoreGeneralConfig" into "PLCore::CoreConfig"
- "Frontend": Added "GetX()" & "GetY()"
- "Frontend": Added "SetPositionSize()". "Frontend::SetPositionSize()" will do the rest of the job like checking for minimal size, ensuring that the frontend is always within
  the screen when using this method and so on.
- "FrontendApplication": By default, this application implementation will automatically restore the frontend position and size of the previous session. Although an application
  shouldn't care about the frontend, from the usability point of view, it's handy when the applications window is at the same position and size of the previous program
  execution. Because the frontend layer itself should be slim and shouldn't come with it's own configuration file, the only option I was able to think of was to make this to a
  task of an application.
- The frontend implementations now delay making the window visible until "Redraw()" or "SetPositionSize()" was called or the initialization was completed. This gives e.g.
  "FrontendApplication" an opportunity to set the frontend position and size before the window gets visible. If this is not done, the frontend window will be shown at first at a
  default position and then jumps to the position and size of the previous session. I was of course aware of this issue when designing the system, but didn't found a compact solution
  for this and therefore decided to have a look into it when the rest is up and running. This doesn't look&feel good, but at the point the frontend window is created there's no
  information available were to e.g. place the window. On the other hand, the frontend window should become visible as soon as possible after the program started so that the
  user can see that the application is now really running. So, in my humble opinion this solution is ok because the frontend implementation has to decide how to deal with this.
- "Frontend": Added "GetTitle()" & "SetTitle()"



>> 19.08.2011
[CO]
- "Frontend": Added "IsMouseOver()"
- "Frontend": Added "GetMousePositionX()" & "GetMousePositionY()"
- "PLFrontendOS::OSWindowWindows" fine-tuning: As soon as the MS Windows function "ShowWindow()" is called, the window gets visible at once... with a nasty white content which is
  somewhat blending when you're working in a dark room. It's like a flash. I did some research but didn't found an answer how to avoid drawing at all... I can remember that previous
  Windows versions just did draw nothing when provinding a null-brush in the window class resulting in the untouchen window background. The only solution that worked for me is to
  just give the window class a black brush and then after the window was made visible within WM_CREATE just catch the WM_ERASEBKGND in order to avoid overdraw (= flickering). Another
  solution might have been to just delay the window show until the render loop starts... but this would mean that, after the user started the application, he would see no reaction at
  all... even if it's just for a few milliseconds, but even then one might start the application again because it feld like the application didn't started at all.
- Removed "AbstractFrontend::OnDisplayMode()". For e.g. "PLRenderer::RendererApplication" it's the same as "OnFullscreenMode()" and I can't think of a real difference - this method just
  says "something related to fullscreen mode has been changed".
- "Frontend": Added "RefreshFullscreen()"



>> 18.08.2011
[CO]
- Renamed the "Core"-class into "Runtime" because it's all about the runtime (even the version information)
- "Runtime"-class: Added "IsDebugVersion()" returning whether or not a debug version of PixelLight is used
- "Runtime"-class: Added "GetType()" detecting automatically the type of the currently used PixelLight runtime installation. Every PixelLight based project using the PixelLight
  runtime needs at least the dynamic "PLCore"-library (the static library is not really within the runtime, it's for developers only). So, in order to automatically detect whether it's a local
  or a system-installed runtime, I just load in the PLCore module and check whether or not it's within the same directory as the running process ("System::GetExecutableFilename()" :).
- Renamed "Runtime::GetDirectory()" into "Runtime::GetSystemDirectory()" and renamed "Runtime::GetDataDirectory()" into "Runtime::GetSystemDataDirectory()" to make clear that this is the
  system installed runtime (there can be a local and system runtime at the same time, although this is not recommended)
- "Runtime"-class: Added "GetLocalDirectory()" and "GetLocalDataDirectory()", the counterparts to "GetSystemDirectory()" and "GetSystemDataDirectory()"
- "Runtime"-class: Added "GetDirectory()" and "GetDataDirectory()", et voila, there are those two methods, again. But unlike the previous implementation, those two guys return the
  PixelLight runtime used by the running process. This means, those methods "automatically" detect the "correct" PixelLight runtime. While it's still possible to explicitly request the
  directory of the local or system PixelLight runtime, it's hightly recommended to only use the automatic PixelLight runtime detection to avoid using possibly incompatible binaries.
- "Runtime"-class: Added a directory parameter to "ScanDirectoryPlugins()" and "ScanDirectoryData" to make it possible to use for example the result of "GetDirectory()", "GetLocalDirectory()"
  or "GetSystemDirectory()". If an empty string is provided, the result of "GetDirectory()" will be used, resulting in an "autodetection".
- "Runtime"-class: Added comfort method "ScanDirectoryPluginsAndData()". In case you don't care about technical details and just want the stuff runnable, then just call this method and be happy.
  The PixelLight runtime to use is detected automatically, all available compatible plugins are registered as well as compatible data.
- "Frontend::Run()": This was a complex one... answering the question who's responsible to initialize the important PixelLight runtime related stuff. Until now, this was only done
  within "CoreApplication::OnInitPlugins()" and "CoreApplication::OnInitData()" - but the frontend stuff is above this application process and is also already using PixelLight runtime
  features like dynamically loaded frontend implementation plugins. Yesterday I experimented with several possible solutions, but one was more complex as the next one. Until now, there
  was also the configuration setting "CoreGeneralConfig::UsePixelLightRuntime", but the configuration system is already using the RTTI (and I still think that this solution is really cool
  and unique compared to other, definitely more complex configuration systems) to let the user decide from the outside whether or not to use the PixelLight runtime. I don't know why, but
  until a few hours ago I didn't really realize that this option is somewhat pointless - because the configuration system is already using this information in order to load in this
  information. Also, this approach, having this option, was quite error prone because when deploying an application it's "really" easy to forget to set this option to 0 to avoid conflicts
  with an installed PixelLight SDK. On the other hand, when starting an application, the OS is in fact deciding for us which PixelLight runtime to use. When the PLCore shared library etc.
  are in the same directory as the executable, those shared libraries are used instead of the ones of an installed PixelLight SDK (I know that there are variations over different OS, but
  even under Linux we have configured the binares this way so one can "just" extract a package and start it at once without configuring the whole system). The only problem was the dynamic
  loading of plugins... which wasn't a problem after all because the OS decides for us whether to use a "local PixelLight runtime" or an installed "system PixelLight runtime". We just have
  to detect which type of PixelLight runtime was chosen by the OS and then load plugins from this PixelLight runtime. Only from this one. So, by creating a package and putting everything
  into it one needs in order to execute the application without any installed PixelLight SDK, one already sayed that a "local" runtime has to be used. No need to confirm this decision again
  by manipulation the "CoreGeneralConfig::UsePixelLightRuntime"-option. Mixing different PixelLight runtimes would be evil anyway. Long story, minor changes:
  -> Removed "Runtime::ScanDirectoryPlugins()" within "Frontend::Run()" (had a [TODO])
  -> "pl_module_application"- and "pl_module_application_frontend"-macros: Added "Runtime::ScanDirectoryPluginsAndData()" right after "PLMain", before anything else is done
  -> Added "Runtime::ScanDirectoryPluginsAndData()" at some other places as well ("Runtime::ScanDirectoryPlugins()" was already used several times, so this change isn't something new)
- Removed "CoreGeneralConfig::DelayedPluginLoading"-option (by default, this feature is always active)
- Removed "CoreGeneralConfig::UsePixelLightRuntime"-option (now done automatically and due to delayed plugin loading the required time is no longer worth talking about)
- "FrontendApplication": This application class reimplements "OnInitPlugins()" & "OnInitData()" because in here, the PixelLight runtime initialization is the job of a higher being
- Bugfix: "ClassManager::LoadModuleDelayed()" was setting no "Name", "Vendor", "License" and "Description" information
- Bugfix: "ClassManager::RegisterClass()": When a dummy class of a dummy module is replaced by a real class, the (previously) dummy class has to be removed from the dummy module because
  a class can only be within one module at the same time
- "CoreApplication"-constructor: In here, the default application data subdir was set to
    m_sAppDataSubdir = System::GetInstance()->GetDataDirName(m_sName);
  While this looks logically at first, it becomes somewhat annoying (otherwise I wouldn't have had noticed and touched it!) after working with it for some time and e.g. doing several experiments.
  Let me explain it in detail: Take the "50RendererTriangle"-sample for instance, by default the application data subdir for my debug version is "C:\Users\COfenberg\AppData\Roaming\50RendererTriangleD"
  and for the release version it's "C:\Users\COfenberg\AppData\Roaming\50RendererTriangle". Now create some more experimental applications to play around with PixelLight by using
  as few instructions as possible in order to figure out how everything works... after a while, one may find the "AppDataSubdir"-option and when looking into the "Roaming"-directory
  one may notice that it's full spam like "50RendererTriangle", "50RendererTriangleD", "XTest", "123Test" and so on... and it is now probably a little bit hard to figure out what's trash and
  what's from an important none PixelLight application. Also, each and every PixelLight sample application had "SetAppDataSubdir(System::GetInstance()->GetDataDirName("PixelLight"))" in
  it and such stuff may be confusing when just starting to get into PixelLight based development.
  -> For those reasons, I decided to make "SetAppDataSubdir(System::GetInstance()->GetDataDirName("PixelLight"))" to the default setting. This way, the samples are even more compact
     (yes, just one row and x nested method calls, but as mentioned, those may be confusing for beginners) but more important, if one "forgets" to set this to an individual setting, everything
     will be thrown into the "PixelLight"-directory. Later on, it's probably easier to remember that something was "PixelLight"-based and easier to find and remove spam-files... by e.g.
     just removing the one single "PixelLight"-directory completely.



>> 17.08.2011
[CO]
- The frontend stuff is working quite well and solves some prior design issues. This approach also answers the question how to use the application framework within e.g. the Qt based
  editor in order to manage the PixelLight part while the Qt editor does all the rest like main loop and window handling. The PixelLight editor kickoff was on 10.08.2011, primarily
  to see what's required for the tool. It will certainly take some time until this tool is usable, so, the goal wasn't to have a ready-to-use-editor in PL 0.9.8. Until now, e.g.
  PLFrontendQt had to reimplement a lot of application framework features because the application framework was heavily tied to PLGui and also did stuff like the main loop internally.
  (this is still possible, but derived application classes like the renderer application now follow another approach)
  As seen within the PixelLight editor project, it's now possible to just write a thin layered frontend implementation working as a kind of gate between the Qt framework primarily used
  within the editor, and the PixelLight framework, primarily used in PixelLight *g*. Each side shouldn't concern too much about the other one - in fact, Qt doesn't know anything about
  PixelLight and verce versa.
  Now that it's clear that the frontend design is the way to go, time to complete the system.
- Added "FrontendContext"-class. This class is derived from "ApplicationContext" and adds frontend related stuff. The parameters of the "Frontend::Run()"-method were just an overkill
  and there was another issue as well: To be flexible, the frontend system already is using the RTTI and when e.g. PLFrontendPLGui open it's window, the standard data packages must
  already be registered. Also, a frontend may want to set a windows position and size to the one used during the previous seasson, meaning it needs to be able to use a configuration.
  During the frontend initialization, errors may occur, so, log is required as well. Sadly, all those stuff is handled within "PLCore::CoreApplication" which is still ok for applications
  not using the frontend stuff at all... but "PLCore::FrontendApplication" has to hand over the control over this important infrastructure features to the frontend. The frontend itself
  hands over this stuff to the "FrontendContext"-class which is instanced and filled outside the frontend system and is just passed into the system.
  Of course, some information is now stored within two distinct systems (frontend and application), but I in my humble opinion that's ok for this system. Take "PLCore::FrontendApplication"
  for example, as the name of this class indicates, this is the base class for applications running within a frontend (the application host). The main loop as well as other logic is handed
  over to a host in order to become passive. Although a frontend application is always running within a frontend, it shouldn't care about the frontend. Just write our application as if there
  wouldn't be any "outer world". By following this philosophy as close as possible and only accessing frontend features when really neccessary, you enhance the chance that your application
  can be embedded within other applications like browsers such as MS Internet Explorer or Mozilla Firefox without problems. So, in order to get e.g. the executable filename, one just asks
  the application framework for it, not the frontend system feeding this information into the embedded application.
- "FrontendContext::Run()" now has just a frontend context as parameter
- Removed "FrontendContext::Run()" versions with traditional C-arguments. It has shown that those version are not required. For e.g. QApplication of Qt using this traditional C-arguments,
  one can reconstruct them out of the universal form... no, it's not a performance problem nor intricate. It's intricate to have 3 method versions to be implemented all over the place and
  in case of e.g. the Qt base editor, one doesn't use the "FrontendContext::Run()"-method at all.
- "FrontendContext" has a name which is used as default whenever a name is required (log, configuration, window title and so on). When using the macro "pl_module_application" or
  "pl_module_application_frontend" this name is automatically set to the module name of the executable. "FrontendApplication" is using this name to set the default application name ("SetName()")
  and default application title ("SetTitle()"). This name is often sufficient - removed "SetName()" & "SetTitle()" usage within e.g. the sample applications.
- PLFrontendPLGui: PLGui requires some images stored within "Standard.zip", it's the responsibility of this frontend to ensure it has all it needs



>> 16.08.2011
[CO]
- Added abstract context class "AbstractContext". All over PixelLight, "context"-classes are used in order to group important information or components. This abstract context
  class was introduced to make it easier to identify such context classes.



>> 15.08.2011
[CO]
- "ApplicationContext::SetExecutableFilename()": The default (meaning you can choose another way if you want to) application directory layout now looks as follows:
  - "Application Directory"
    - "Data" (put all data you need in here)
    - "x86" (put all x86 executables and binaries in here)
    - "x64" (put all x64 executables and binaries in here)
  ... I worked with such a layout for years within other projects and never had real problems to use x86 & x64 together during development. With this layout it should
  also be absolutly clear that the executables and binares are decoupled from the data. In PixelLight release 0.9.8 there are several structual changes, so, it's probably
  better do to this "64 bit support"-related one in this release as well so that the next released don't have so many structural changes.



>> 14.08.2011
[CO]
- "PLFrontendOS::OSWindowWindows" & "PLFrontendOS::OSWindowLinux" & "PLFrontendPLGui::Frontend" & "PLFrontendQt::FrontendMainWindow" are now calling "AbstractFrontend::OnSize()"



>> 13.08.2011
[CO]
- "PLFrontend::OSWindowWindows" & "PLFrontend::OSWindowLinux" now react on AltGr-Return as well (same behavior across all frontend implementations)
- "Frontend": Added "IsMouseVisible()" and "SetMouseVisible()" ("PLFrontendOS::OSWindowLinux" part not yet implemented)
- "Frontend": Added "SetTrapMouse()"
- "AbstractFrontend": Added "OnDrop()" ("PLFrontendOS::OSWindowLinux" part not yet implemented). I'am not going to reimplement PLGui as frontend, but this feature is another
  useful one and I reduce it's usage to simple strings (for more complex stuff one has to use a GUI system!).



>> 12.08.2011
[CO]
- "CoreApplication::Run()" now implements the lifecycle as well
- "PLFrontendMozilla" & "PLFrontendActiveX" now also call the "OnRun()"-method (for none embedded frontends this is done automatically within "PLCore::Frontend::Run()")
- The program entry point "PLMain" is now ignored when the definition "_WINDLL" and/or "_USRDLL" is set... this should make it more comfortable to deliver an application as shared
  library (easier to embedd into other applications) instead of an executable. Those two definitions are MS Windows definitions, as far as I know, Linux has no equivalent...
  but we need something to test against... so I just defined those two definitions within "CMakeTools_Apps.cmake" for Linux as well (I was just to lazy to invent totally
  new definition names).



>> 11.08.2011
[CO]
- String: Sadly, we can't use uint16 in order to let the compiler decide whether to use a whar_t or a uint16 version of a method. For instance, when using PixelLight within the
  Qt Creator (without changing all used default settings!), whar_t is defined as unsigned short. :/



>> 08.08.2011
[CO]
- "Frontend": Added virtual "OnRun()"-method. This method is called just before the frontend calls it's run-method in order to enter it's main-loop. Use this method for instance
  to pre-process command line arguments.
- "FrontendPixelLight" is now using the new "OnRun()"-method in order to fill the application context just like "CoreApplication::Run()" does
- "Frontend": Exposed the class to the RTTI
- "Class": Added "Create()"-method creating an object by using a given constructor name and typeless constructor parameters
- Implemented frontend arguments... I'am not really happy with the current solution because it just looks complicated. I tried some other approaches but this one was the best one.
  Maybe I find another, better solution later on - but for now it works and is quite flexible. I'am really happy that I introduced the "pl_module_application" & "pl_module_application_frontend"
  macros because they're hiding the complex frontend run call. Within the samples the frontend call is only done once within "45ScriptApplication" without this "standard use case"-macros.
[SW]
- "PLFrontendOS": added toggle fullscreen support and and setting window icon to linux X11 part
- "PLFrontendQt": added support for setting the application/window icon



>> 07.08.2011
[CO]
- Updated "PLFrontendQt::QPLRenderWindow". Drawing and updating states are now two distinct things for the frontend & application framework, so, "PLFrontendQt::QPLRenderWindow"
  has now only care about drawing.
- Moved the "PLCore::Timing"-update from "FrontendApplication::OnUpdate()" into the frontend implementations. "PLCore::Timing" can limit the update rate to a fixed one like
  60, meaning that the update process doesn't run more than 60 times per second. An application (the slave) shouldn't care about such a topic and the frontend (the master) should
  have control over this one as well. Please note that it is allowed that the logic update and draw update have different intervalls (but again, the application side doesn't care
  about this :).
- "Frontend": Added fullscreen mode support and implemented it for "PLFrontendOS::OSWindowWindows" (implementations for the other frontends will follow)
- "PLFrontendPLGui": Implemented fullscreen mode support
- "PLFrontendQt": Implemented fullscreen mode support
- "FrontendApplication::GetFrontend()" now returns a reference instead of a pointer. An "FrontendApplication"-instance is always running within a frontend, else the system becomes
  artificially complex. Therefore, the result of "GetFrontend()" must always be valid and there's no need for null pointer tests trashing the code.



>> 06.08.2011
[CO]
- Linux: Changed the type of "handle" from "int" to "unsigned long" (shouldn't really be a difference in the used bit length... even on 64 bit "long" is usually only 32 bit long...)
- Added "Core::ScanRuntimeDirectoryPlugins()" because the same stuff was done in "CoreApplication::OnInitPlugins()", "PLCore::Frontend::CreateInstance()", the sample "40ScriptHelloWorld"
  not using the application framework at all, "PLFrontendQt::Application::InitCore()" and so on.
- Added "Core::ScanRuntimeDirectoryData()", more stuff not only useful for "CoreApplication::OnInitData()"
- MS Windows: "PLFrontendOS" is now using the standard PixelLight icon for the main window of this frontend
- MS Windows: If a process has an own icon, "PLFrontendOS" is now using it instead of the standard PixelLight icon
- "PLFrontendQt": Removed unused "Application::ScanFSArchives()"-method
- Added "AbstractFrontend", same purpose as "AbstractLifecycle" => one and the same interface for the same task
- "AbstractFrontend": Added "OnUpdate()"-method. Drawing and updating states are now two distinct things for the frontend & application framework.



>> 05.08.2011
[CO]
- "Frontend": Added versions of the "Run()"-method using traditional C-arguments (char/wchar_t). Some frontends, like the Qt one, want to have the original C-arguments or someone
  may want to run a frontend by providing it with traditional C-arguments.
- "Frontend": Made a clear distinction between "Redraw()" and "Ping()"
- "Frontend": Added "RedrawAndPing()"-method first calling "Redraw()", then "Ping()"... probably an important use case... :D
PLFrontendQt:
- Implemented correct application lifecycle and "Ping()"-method (by the way, just noticed Qt's "QCoreApplication", so, "PLCore::CoreApplication" is probably really a decent name)
- Instead of performing an immediate hard-coded repainting of the frontend within "FrontendMainWindow::timerEvent()", Qt is now asked politly to update (and repaint) the widget.
  This way, the main window stays always responsive - but now I had "white flickering" due to some Qt overdraw. After using same settings as in Qt's QGLWidget, the "white flickering"
  had gone... but now there's "black flickering" from time to time. When debugging, it's clear that Qt still draws something into the window. After over a hour of research
  I wasn't able to figure out what's going on. The concept is ok, drawing only within Qt's "paintEvent()" and a redraw-timer only asks Qt politly to update (and repaint) the widget
  instead of directly draw (which wasn't working that well, messed up Qt's event processing). Time to stop working on this "detail" for now in order to finish the frontend work.
- ... I wasn't able to stop thinking about the "black flickering"-issue... and found a solution:
  -> Set "Qt::WA_OpaquePaintEvent"-attribute
  -> Overwrite "QPaintDevice::paintEngine()"-method and just return a null pointer
  ... the flickering is now gone and the whole main window is responding and behaving quite fine...



>> 04.08.2011
[CO]
- Renamed "ConsoleApplication" into "CoreApplication" so that one can guess the name of this class by just knowing the component name it's in
  (it's also the base/core class of the application framework, so "core" maybe more suitable then "console")
- "AbstractFrontendLifecycle" really solved some nasty design issues when it comes to application lifecyle control. Time that also "CoreApplication"
  is using this interface so that frontends can control the applications in a proper way (e.g. deactivating input control as soon as the application gets
  paused because it e.g. lost the focus). For this, renamed "AbstractFrontendLifecycle" into "AbstractLifecycle".
- Derived "CoreApplication" from "AbstractLifecycle". When possible, I try to avoid using multi-inheritance but in this case I see no other decent option -
  sadly C++ has no Java like "implements". :/
  -> Renamed "CoreApplication::Init()" into "CoreApplication::OnStart()", the "AbstractLifecycle" equivalent called as soon as something is started (not same as instanced)
  -> Renamed "CoreApplication::DeInit()" into "CoreApplication::OnStop()", the "AbstractLifecycle" equivalent called as soon as something is stopped (not same as destroyed)
- "FrontendPixelLight" is now calling all "AbstractLifecycle"-methods of it's petted application
- "Frontend": Added "Ping()"-method to give the frontend a chance to process OS messages. There are situations (like current load screen implementations) were an application
  may do some heavy work without letting the frontend a chance to process OS messages. In such situations, it may be wise to call this method from time to time to give the
  frontend a chance to do some message processing. Whenever possible, don't use this method, do heavy work within e.g. threads.
PLFrontendPLGui:
- Moved "ModTrapMouse", "PreviewWidget", "RenderWidget", "RenderWindow" and "WindowConnection" from "PLEngine" into "PLFrontendPLGui"
- Implemented correct application lifecycle and "Ping()"-method
PLFrontendOS:
- The application lifecycle is now handled within the OS dependent implementation (e.g. "OSWindowWindows") instead of within "Frontend"... I hope this way the order is
  always correct... hopefully... eventually... *g*
- When moving/sizing the window, the application will also be paused during this period (WM_EXITSIZEMOVE/WM_ENTERSIZEMOVE MS Windows events)... it's just annyoing when you move
  or size a window and the controlled scene camera is spinning around while you do so...



>> 03.08.2011
[CO]
PLFrontend:
- "PLFrontendNull", "PLFrontendOS", "PLFrontendPLGui", "PLFrontendQt" and "PLFrontendActiveX" (testing it within the MS Internet Explorer) are now up and running
  ("PLFrontendMozilla" is still broken)
- Added "PLFrontend::Frontend::Run()" to start an application inside a frontend. This is only required for executables and not if an application is running e.g. within
  a browser. When using it, it looks like this:
    int PLMain(const PLCore::String &sFilename, const PLCore::Array<PLCore::String> &lstArguments)
    {
        return PLFrontend::Frontend::Run("PLFrontendOS::Frontend", "Application", sFilename, lstArguments);
    }
- When the work on the frontend stuff is complete, PixelLight applications are usually "frontendless", meaning when compiling it as an executable, you as application developer
  choose the frontend to use (or not if you just don't care about GUI). Additionally, in the future it should be possible to just recompile the application as shared library in
  order to be able to embed it within other applications like a browser. To make this as easy as possible, I added the macro "pl_module_application_frontend" (yeah, too long
  name, again... but it's only required once within a project and therefore a speaking name is fine) and when using it, the main C++ file usually looks like this:
    #include <PLFrontend/FrontendMain.h>
    pl_module_application_frontend("50RendererTriangle", "Application", "PLFrontendPLGui::Frontend")
        pl_module_vendor("Copyright (C) 2002-2012 by The PixelLight Team")
        pl_module_license("GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version")
        pl_module_description("PixelLight triangle sample")
    pl_module_end
  ... should be quite handy to use ("pl_module" is usually already used, so not much additional work, it's even less work!). :D
  There's also a shorter macro:
    "pl_module_application("50RendererTriangle", "Application")
  Which will use the frontend "PLFrontendOS::Frontend" as default. This totally primitive frontend is sufficient for many applications.
PLFrontend<>PLCore
- Merged PLFrontend into PLCore... another new project which didn't make it long on it's own. :D
  Just like PLScript, PLFrontend was started as a separate project to see whether or not the idea/concept is working and then to see how it's integrating into the system as a whole.
  The PLFrontend concept turned out to be the key in making PixelLight really easy runnable within other applications like browsers. As such, it feels just right to put it directly
  into PLCore - it doesn't introduce new dependencies and is also not really a huge component.



>> 02.08.2011
[CO]
PLFrontend:
- Added "FrontendApplication" & "AbstractFrontendLifecycle" and started on the frontend design
PLFrontendPLGui:
- Moved "SNGui" from "PLEngine" to "PLFrontendPLGui" because it's using PLGui



>> 01.08.2011
PLFrontend:
[CO]
- Started the PLFrontend project (kind of "PLPlugin"-project successor)... now that scripting is working, it's finally time to attack another big design task.
  When we started the development of the PixelLight engine on 16 September 2002, we just had one single project: "PLEngine"
  This project just used a quite simple OS window to render stuff into it. Back then, the world was more simple regarding to required supported platforms.
  Providing support to be able to render into multiple OS windows was really a cool feature because most engines were just able to render into a single
  OS window. Over the years, the GUI stuff was moved into an own, platform independent, GUI library called PLGui. All other PixelLight projects were build
  on the top of it. PLGui is currently already within it's third (!) reincarnation.
  In the last past 9 years, the world has dramatically evolved regarding to the platforms one should really support and the current PixelLight design regarding
  to GUI handling does no longer really completely satisfies the changed needs. Now those are the requirements to be fulfilled:
  -> Be able to have absolutely no GUI at all, e.g. for server side applications or applications rendering just into a buffer *currently there's always a PLGui dependency*
  -> A quite primitive OS window for applications requiring no GUI handling, except for the OS window it's running in *PLGui is an overkill for this use case*
  -> "PLGui": PixelLight own GUI system (OS & ingame) perfectly integrated into the complete system, stuff like scripting doesn't need wrappers, it just works out of the box *currently used way*
  -> Be able to just use third party GUI systems like Qt for front-ends *currently there's always a PLGui dependency*
    -> The PixelLight editor will be Qt based because getting PLGui to the point were it's possible to write such an complex editor is just impossible with a team of two
       active spare-time developers (we already tried it years ago *PixelLab* and it was a total failure :/)
  -> Be able to embed an PixelLight application into another application, meaning another GUI system has the control and we're just a slave
    -> Be able to run in a web browser (e.g. by using "Java Web Start"/"JNLP" or/and by writing special browser plugins)
    -> Be able to run on mobile devices, e.g. Android based
    -> Be able to use ActiveX under MS Windows to embed 3D stuff into e.g. a MFC dialog (we already had to do this for a project some years ago)
    ... scripting is especially useful for the first two mentioned embed-points. This way, an application developer doesn't need to care about the target platform and is just
        writing some scripts...
  Ok, as you can see, a whole bunch of new requirements since the start of the PixelLight engine. In "Docs\Diagrams\PixelLight_PackageDiagram.png" I outlined how it will probably
  look when PLFrontend is up and running.
  Please note that the PLFrontend approach doesn't mean that I abandon the PLGui project, but having the whole system be dependent of a GUI system is not working any more with
  the changed requirements. Also, while the third reincarnation of Stefans PLGui is really cool and can be used for OS and ingame and has, by using the PL RTTI, automatic support
  for scripting and therefore integrates itself perfectly into the whole system... PLGui is still missing some features and fine-tuning. Sadly, such a GUI system is a huge task
  and currently, as already mentioned, there are only two active spare-time developers. Personally, I finally want to get PixelLight to the point were it's possible to create
  simple prototype applications in a matter of minutes by using e.g. a Lua script to load in a scene and adding some interaction - and then be able to run this on multiple
  platforms/targets. So, my focus is on that instead of taking over the development of Stefans PLGui (I already ruined the previous second reincarnation and don't want to repeat
  this experience). I really hope that in the future there's someone continuing the development of PLGui because especially the scripting-argument is a really cool argument for PLGui!
  (connecting e.g. libRocket or Qt to the PL RTTI and scripting system will be probably lot of work while it's no work at all with PLGui!)
  ... enough introduction and explanation why there's need for the PLFrontend project. Let's go to work...
- Added the (currently empty) frontend plugins
  - "PLFrontendNull": The usual dummy project doing nothing at all
  - "PLFrontendOS": Just a totally primitve OS window
  - "PLFrontendPLGui": PLGui connection
  - "PLFrontendQt": Qt connection (the new "PLQt")
  - "PLFrontendActiveX": ActiveX connection (the new "PLPluginActiveX")
  - "PLFrontendMozilla": Mozilla connection  (the new "PLPluginMozilla")
  ... while "PLFrontendNull", "PLFrontendOS", "PLFrontendActiveX" and "PLFrontendMozilla" are intended to be 100% loose dynamic plugins, "PLFrontendPLGui" and "PLFrontendQt" are
  of course also such plugins, but one is usually going to also use those libraries directly within an application (meaning linking aginst them).
- Copied the diaries of "PLPlugin", "PLPluginActiveX" and "PLPluginMozilla" into this diary because PLFrontend will be the successor of the "PLPlugin"-project... which is not limited
  to "PixelLight application as a plugin for e.g. a browser" but will also cover the "PixelLight application as executable" use case. Meaning, in the future it will be possible to just
  recompile a C++ PixelLight as shared library and then be able to use it in any available frontend.
- Using "PLPlugin::Plugin" as start point for the class "Frontend"
- Renamed "PLPluginActiveX" (still working, just tested it :) into "PLFrontendActiveX"
- Renamed "PLQt" into "PLFrontendQt"
- Renamed "PLPluginMozilla" into "PLFrontendMozilla", when testing it with Firefox 5.0 the browser didn't want to load it (sayed something about corrupt... before I did the changes...)...
  I'll check it later when PLFrontend is working as a whole...
- Removed "PLPlugin", it's been replaced by "PLFrontend"



>> 02.07.2011
[CO]
PLQt:
- Added empty project "PLQt". In the next steps, PLQt (https://sourceforge.net/projects/pixellight/) from Stephan Wezel will be integrated directly into the PixelLight
  Git repository and SDK because e.g. the editor will be Qt based. I currently use Qt 4.7.0 and I know that there's already a newer version available... but I already
  had Qt 4.7.0 compiled for VisualStudio 2010 (to avoid using VC 2008 within the PL SDK) a while ago and right now I don't want to spend time in recompiling Qt, again.
- Moved "QtStringAdapter" from PLGeneral into PLQt
- Integrated PLQt, I'am sure it's not yet final and that over time, there will be multiple simplifications



>> 31.07.2011
[CO]
- Exposed "ConsoleApplication::Exit()" to the RTTI



>> 30.07.2011
[CO]
- "PLScriptLua::RTTIObjectSignalMethodPointer::EventCallback": "TypeRef" was missing



>> 27.07.2011
[CO]
- Using PLCore to check whether or not "override" from C++0x (see e.g. http://www2.research.att.com/~bs/C++0xFAQ.html#override) will cause any problems
  -> By using "override", the compiler found the following: "Constructor" implemented the virtual method "GetDesc()" and a comment stated that it's a
     "DynFunc"-method. Ok, the name is a "DynFunc"-method, but the signature is "const FuncDesc *DynFunc::GetDesc() const" while the other signature is
     "const ConstructorDesc *Constructor::GetDesc()". "ConstructorDesc" is not derived from "DynFunc". To be fair, to the compiler would also have found it without "override"
     if "Constructor::GetDesc()" would have been declared as constant as well, but it wasn't. So, "override" really did the trick and exactly such errors are the reason
     why I'am so interested in this language feature in the first place. I'am sure that there are some more of such errors in the hundred thousends lines of code... :D
     If I'am not totally wrong and missed something, "Constructor::GetDesc()" is a dead method. Removed it.
  -> In the dungeon demo, I found at once an error using this new language feature: The "Application::LoadScene" signature had changed, but the dungeon demo wasn't updated...
     I'am starting to really like "override" :D
- PixelLight was already using "extern templates" which are part of C++0x (http://www2.research.att.com/~bs/C++0xFAQ.html#extern-templates)... added comments to avoid confusion...



>> 26.07.2011
[CO]
- "LoadableType::AddLoader()" fixed log messages ("[Info]: Loader 'PLAssimp::SceneLoader3DGameStudio': Format 'mdl' is already used by loader 'PLAssimp::SceneLoader3DGameStudio")
- "Loadable::Load()"/"Loadable::Save()": Moved the "IsDerivedFrom()" security check into "LoadableManager::RegisterClasses()"
- Renamed "LoadableType::GetLoader(uint32 nIndex)" into "LoadableType::GetLoaderByIndex(uint32 nIndex)"
- Renamed "LoadableType::GetLoader(const String &sExtension)" into "LoadableType::GetLoaderByExtension(const String &sExtension)"
- Renamed "LoadableManager::GetLoader(uint32 nIndex)" into "LoadableManager::GetLoaderByIndex(uint32 nIndex)"
- Renamed "LoadableManager::GetLoader(const String &sExtension)" into "LoadableManager::GetLoaderByExtension(const String &sExtension)"
- Renamed "LoadableManager::GetType(uint32 nIndex)" into "LoadableManager::GetTypeByIndex(uint32 nIndex)"
- Renamed "LoadableManager::GetType(const String &sName)" into "LoadableManager::GetTypeByName(const String &sName)"
- Added "LoadableType::GetLoaderForLoadingByFile()" which currently is using, as before, just the filename extension to find the proper loader
- "LoadableType::GetLoaderForLoadingByFile()": If there's no loader for the given file extension, the complete file extension is checked as well (file format extensions like
  "mesh.xml" can now be used as well)
- Added "System::GetSeparator()" returning the directory separator used by the operation system (e.g. '/' on Linux, '\' on Windows)... interesting that such a method was still
  missing...
- Added "File::CFileModeToAccessFlags" translating a given C file mode ("r", "r+", "w", "w+", "a", "a+", "t", "r+t" etc. used for e.g. "fopen") into access flags



>> 25.07.2011
[CO]
- "Url": "GetTitle()" and "GetExtension()": For a filename like "archive.tar.gz" the method "GetTitle()" returns "archive.tar" and "GetExtension()" returns "gz". While this is
  ok/standard for some use cases, there are also situations were "archive" as title and "tar.gz" as extension is desired/standard. I checked other libraries/frameworks like Qt
  in order to see how they deal with this topic. In Qt, they offer the following methods:
    "QFileInfo::baseName()"="archive"
    "QFileInfo::completeBaseName()"=archive.tar"
    "QFileInfo::suffix()"="gz"
    "QFileInfo::completeSuffix()"="tar.gz"
  This naming convention sounds reasonable and at least "suffix()" is handled the same way as PL's "GetExtension()".
  -> Added some more comments to avoid confusion (or at least reduce it) when dealing with filenames like "archive.tar.gz"
  -> Renamed "GetTitle()" into "GetCompleteTitle()" returning "archive.tar"
  -> Added "GetTitle()" returning "archive"
  -> Added "GetCompleteExtension()" returning "tar.gz" and also added "CutCompleteExtension()"



>> 21.07.2011
[CO]
- PLGeneral->PLCore - done



>> 19.07.2011
[CO]
- Merged PLGeneral (started before 25.11.2003) into PLCore (started: 05.02.2008) because both are completely fundamental and it's not that clear which project was for which
  components. When looking e.g. at the PixelLight component diagram one can see that every other project is already using PLCore and not even the most primitive sample within
  the SDK is using just PLGeneral. This may be a sign that this is in fact one component which was just splitted into two projects. A year ago or so, there were already
  discussions whether or not e.g. the log should be part of PLGeneral and PLCore. In the end, the log was moved into PLGeneral although the log formater classes are in fact
  loose dynamic plugins, but were now not able to be implemented in this way because the RTTI was introduced within PLCore. Of course, that's nothing dramatic, but on the other
  hand it would be cool to e.g. write a special log formater within a loose plugin and then select it within a configuration file. While modulation is a really useful thing,
  PixelLight now consists of 13 of primary modules and loose plugins and when looking at user feedback it looks like that some people have some issues with this. I'am not going to
  merge everything into a single "PixelLight"-project as seen in several engines out there. There was a reason for this individual modules: To make everything as flexible as
  possible which is especially nowadays really important due to the mass of available target platforms. But it seems to be reasonable to simplify PixelLight were ever possible
  to avoid comments like "PixelLight is a monster" in the future. This was one reason why I moved weeks ago the 100% dynamic plugin projects into the "Plugins"-directory so everyone
  can see at once that those are optional and nothing build in. The core of PixelLight is in fact slim and most features are just plugged-in! (which may be one of the reasons why
  there are people thinking that PixelLight is really complicated because they seem to be used to have everything thrown statically together in one huge blob)
  -> The PixelLight base now consists of 12 modules as well as 38 optional modules aka plugins aka extensions aka addons, this should still be more then enough modularisation.
  -> Due to the current examines at university, I'am pretty sure that I will need several days to update the rest of PixelLight...



>> 10.07.2011
[CO]
- Moved PLIRC and PLJabber from the PLNetwork directory into the PLPlugins directory because it's nothing the PixelLight core is
  using and in fact, until now it isn't used at all. So, this is definitively a plugin/extension/addon.
- Removed PLNetwork project. It has now been empty since "23.10.2009" and there are no signs that this will change in the near feature.
  The basic stuff like sockets were already within the PLGeneral project and even some more hight level constructs like server-client
  classes. Since the public release of PixelLight, there were several user questions asking why PLNetwork is empty, and why there's an empty
  project at all. So, to avoid this confused (but understandable) question in the future, PLNetwork is now gone. If there's really
  need for an individual network component in the future, the project can be added in no time.
-> Moved the entries of the PLNetwork diary into the PLGeneral diary



>> 03.07.2011
[CO]
PLCore:
- Within "Rtti.h", "__NT__" ("#define __NT__	PLCore::NullType") was defined... which usually stands for "Windows NT" in system headers. Until now, there were
  no problems with that, but today this changed when using Qt to compile something under Linux.
  Within the Qt header file "qglobal.h" there's the following line
    "#elif !defined(SAG_COM) && (defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__))"
  ... and now, when including a PixelLight header using the RTTI before a Qt header is included, Windows headers are included inside Qt. I thought about renaming
  "#define __NT__	PLCore::NullType" into "_PLNT_" or so, but on the other hand, maybe there's an OS header using "_PLNT_" or another definition as well? To avoid
  any further troubles in here, I just removed this definition.



>> 02.07.2011
[CO]
- Moved "QtStringAdapter" from PLGeneral into PLQt



>> 27.06.2011
[CO]
PLCore:
- "PLScriptLua::RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()": Added some quotation mark checks. If the string content is "Name="Bob"" the resulting parameter
  string will be "Param0="Name="Bob""" and the parser will have troubles with it and will take "Name=" instead of "Name="Bob"" for the value of "Param0". After this change,
  the resulting parameter string is now "Param0='Name="Bob"'".



>> 21.06.2011
[CO]
PLCore:
- When testing the Dungeon demo under Linux, I noticed that the "Object" RTTI methods (but only those?) were not exported correctly when using GCC. Found the "bug" within my
  change from "04.06.2011" when I removed the per instance cost of RTTI methods... the RTTI method instantiation was wrong. I still think that this is the right way because
  tons of those methods will come in the future!
  After a look into how Stefan did it with the RTTI constructors I was able to fix the issue, more or less. It looks like now, that more stuff is connected to the RTTI the
  template instantiation issue strikes back (we already had it multiple times under Linux). Interesting that everything runs that smoothly under MS Windows.
  Maybe it's better to do as many RTTI related definitions as possible in the cpp files instead of the header files? As far as I can see, for constructor and method definitions
  this wouldn't be problem - except that the RTTI stuff would be more scattered over two files (although there's already "pl_implement_class" in the cpp files...).   
  This would probably also make the life of the compiler a little bit easier... the more complex derived classes from derived classes get, the more work for the compiler
  (the slow down is really notable when compiling). Right now, I don't want to work too much on the RTTI - I already did way more changes as I wanted. It's not
  really my field and I'll have other stuff on my TODO-list (but I really had to do something about the most important issues to be able to go on with other parts in a decent way).
  So a kind of patchwork has do to the job for now: In important RTTI classes, I'll added a define around the constructor and method definitions so that they are only considered
  when compiling the project they are in. This solved my current template instantiation issue under Linux - for now.
  Ps. By the way, I just noticed that the Windows version of the Dungeon executable is after this change only 230 KiB instead of 395 KiB... I assume that this massive template
  instantiation within the header files really has a notable impact on everything. :/



>> 18.06.2011
[CO]
PLCore:
- Added "DynSignature"-interface and derived "DynEvent", "DynEventHandler", "DynFunc" and "DynParams" from this new interface. Previously, those interfaces had
  only a "GetSignature()"-method in order to request the signature description as string. With the introduction of script support there was a need to get concrete
  type ID information of return and parameters for proper exchange of data between script and C++. Of course, it would have been possible to just parse the already
  available signature-string, but this would have been a little bit uncomfortable.
- PLScriptLua: Added new static method "RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()" which returns the current Lua function parameters on the Lua
  stack as string. This was my motivation for the "DynSignature"-interface because this new method is used by "RTTIObjectMethodPointer" and "RTTIObjectSignalPointer"
  and type ID information is used internally.
- PLScriptLua: Solved another reference issue. Well, not directly an issue with references in general, more an issue about their usage in scripts with strings.
  Strings are somewhat of a special case, at least within their usage. It's possible that there's a RTTI method with a "Object*(const PLGeneral::String&)"-signature
  meaning that the parameter is a reference. Within scripts, strings are fundamental and therefore it should be possible to use such a RTTI method by writing for instance
    this:GetSceneNode():GetByName("Soldier")
  so that the script programmer doesn't need to care whether or not the required RTTI method parameter is in fact a reference instead of a string. Of course, a real
  reference a parameter should still also be possible as well. To solve this issue, whenever the script programmer provides a string, but a RTTI method is expecting
  a reference or a pointer, this given string is stored within a string-list on the heap during the function call. By doing so, the reference/pointer has a valid address.
  -> Some weeks ago, I was afraid that we can't keep the "const PLGeneral::String&"-concept and had to change it into "PLGeneral::String" in order to use such methods
     within scripts. But the solution within PLScriptLua solves this issue and the PixelLight interfaces don't need to be rewritten. The solution also introduces no
	 extreme runtime overhead because the string class is quite optimized internally and is using e.g. the "copy-on-write"-concept. So, those temporary strings on the
	 runtime stack don't really hurt much.
- "PLScriptLua::RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()": If a RTTI signature demands more parameters as the script programmer provided, we need to add
  the missing parameters because if there's a reference parameter it really needs a valid address
- "Script": Added namespace support for global variables. By using namespaces, one can e.g. define that all script variables an editor is able to show have to be
  within a "public"-Namespace (just an example, there's no such thing fixed build in within PLCore!). In this editor-example, the user is then able to get and set script
  variables just like RTTI attributes, but the other script variables which are e.g. within the global namespace are hidden.
  Currently, this namespace support is only implemented within PLScriptLua... the next scheduled PixelLight release is near and so I really have to work focused.
- "Script": Due to namespace support for global variables, I had to change the "GetGlobalVariables()"-signature. This method no longer returns a list of found global variables,
  instead a list to be filled up has to be provided as parameter.
- "Script": Added support for global script functions which are inside a namespace. Currently, this namespace support is only implemented within PLScriptLua.
- "pl_class_internal"-macro: Added "__pl_rtti_export(PLCORE_RTTI_EXPORT)" within the RTTI macro to make it possible to expose "Object"-methods to the RTTI
- "Object": Renamed "IsInstanceOf(const Class &cClass)" into "IsInstanceOfByReference(const Class &cClass)" to make it possible to expose the
  "IsInstanceOf(const PLGeneral::String &sClass)" method to the RTTI (this version of the method is the more often used one)
- "Object": Exposed several methods to the RTTI... this makes it for instance possible to construct the names of methods/attributes etc. to be called from inside a script
   dynamically inside the script...



>> 17.06.2011
[CO]
PLCore:
- "Script": Added support for "Object&"
- "DynEvent": "Connect()" and "Disconnect()" required a pointer as parameter, but there was no documentation whether or not a null pointer was allowed.
  When providing a null pointer, the implementation crashed because there was no test for a null pointer. Before I start adding pointless pointer
  checks, I just change the methods so their using references as parameters as done in other PixelLight parts. By the way, connecting event handlers
  looks now also the same as when doing the same in Lua scripts. *g*



>> 16.06.2011
[CO]
PLCore:
- There was an issue when using a reference type as RTTI method result... this was the reason why I hadn't yet exposed methods like
    SceneNode &GetSceneNode() const;
  to the RTTI. It took me several hours to wrap my head around the type traits Stefan wrote (no critics, the system is really genial... but the topic is just not really
  my expertice, I'am more the graphics programmer type :) and several more hours for attempts and experiments to get reference types as return values up and running.
  When I finally had an working solution, I reduced my number of code changes to the bare minimum in order to reduce the risk to introduce new bugs or to mess everything
  up. I really had to do a change in order to be able to continue exposing methods to the RTTI... the alternative to just forbid the usage of pointers wasn't a real
  solution for me.
  The problem was the following: The internal system stores within the parameters class the parameters, and also copies them around like
    cP.Return = (*this)(cP.Param0);
  as long as the type is no reference, everything is just fine. But as soon as there was a reference type hell broke loose because a when copying one reference into another,
  not the address of the referenced object is copied but instead the value. Within the system, this reference behaviour results in another behaviour as the desired one. My
  solution is the introduction of a "storage" type within the type definitions. Usually, meaning for 99% of all types, the storage type is identical to the real type. For
  reference types, the real type is a reference (as before) - but the storage type is a pointer. This way it's possible to internally copy around the parameter in the correct
  way. There are also the two new type methods "ConvertRealToStorage()" and "ConvertStorageToReal()" which are used to convert the types when necessary. I hope the compiler
  is clever enough to notice when this results in copying one variable into itself without any further change - in this case, this change would introduce no new additional work
  to be done. The example code from above now looks like this
    cP.Return = Type<R>::ConvertRealToStorage((*this)(Type<T0>::ConvertStorageToReal(cP.Param0)));
  and from the outside, as long as not accessing "Return", "Param0" etc. directly, the user will not notice that his reference is internally handled as pointer. With this change,
  it's now possible to expose methods with a reference type as result to the RTTI - meaning to also enable it's usage within scripts.
  ... the last days were really exhausting because due to university, I had to get into the topic and solve the issue at night and during lectures. But I really wanted to have this
  issue solved within the upcoming PixelLight 0.9.7 release because it's quite fundamental for scripting. Now that it's up and running, I think it was worth the effort. :D
- PLScriptLua: Added "TypeRef" support for method results
- ... now that I have GCC 4.6.1 installed, removed the following hack within Event.h
    // [HACK] This is currently necessary to avoid the following strange compiler error:
    //		    undefined reference to `vtable for PLCore::Functor<void, PLCore::Module const*, ...>
    #ifdef GCC
        static Functor<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> DummyFunctor;
    #endif
  in order to check whether or not this is still the case... made a fresh build without the hack and there were no more problems. :)
  So, I let the hack out... there's no point in supporting buggy old compilers. For example in GCC 4.5.2 the nullptr emulation was no longer working due to a GCC bug. So, if you
  encounter any compiler issues, just use an up-to-date compiler (if there's one :) instead of spending time to hack around compiler bugs.
- "Func.h": Removed debug-output in case of a signature mismatch. The "new" RTTI 2 is now working since over a year within PixelLight and does really a fantastic job. I assume it's
  about time to remove this scaffold (which, over the time caused some debug/release include issues).
- Minor "SignatureString::GetSignatureID()" implementation change to make the life of the string class a little bit more comfortable. I know, this doesn't really have a directly
  measurable impact... but when I see something that can be optimized without messing everything up (especially when it's within the core), I do it because in the end, all sums up...
- Removed
    typedef Func<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> _Func;
  etc. in e.g.
    FuncFunPtr<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> : public Func<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> {
  because it really looks like dead code (wasn't able to find any usage of it).



>> 14.06.2011
[CO]
PLCore:
- "ConsoleApplication": The "Init()"-method documentation stated that it's calling "OnInit()", and the "DeInit()"-method documentation stated that it's calling
  "OnDeInit()"... but those two methods are actually called by the "ConsoleApplication::Run()"-method. I had a look into this diary to see the intended behaviour
  and found the description within the "06.08.2010"-entry from Stefan Buschmann (I'am really glad that we're writing diaries :). The implementation is correct,
  but the documentation wasn't. Fixed that.
- "Script:" Added "IsGlobalFunction()" so one can check whether or not there's a certain global script function before calling it. Background: When calling a global
  script function, the script backend usually writes an error into the log when the given global script function wasn't found. I still think that this behaviour is
  useful. When using optional global script functions, it's a good idea to check whether there's such a global script function by using "IsGlobalFunction()".
- PLScriptBindings: Changed the default value of "UpdateFunction", containing the name of the script function to be called, from "Update" into "OnUpdate"
 (same name as in "PLEngine::ScriptApplication")
- "PLEngine::ScriptApplication" and "PLScriptBindings::SNMScript" have now both the script entry points "OnInit()", "OnUpdate()" and "OnDeInit()".
  The name of the optional script function called by C++ by one of these entry points is an RTTI atribute, meaning that e.g. a scipt can manipulate
  it's own entry points! Wow, the script-stuff is getting pretty flexible. *g*



>> 12.06.2011
[CO]
PLCore:
- Merged PLScript into PLCore. When starting PLScript on "25.04.2011" I had no real idea were the script voyage would end. Back then, I decided to
  create an own project for script support - this has proven to be useful when starting a new component. Now that the Lua backend of PLScript has
  nearly all features I wanted I start to play around with it a little more... and it's a little bit annoying to add PLScript to the VC project solutions.
  Right now, PLScript consists just of a handful of classes and it doesn't look as if a lot more script classes will come. The "magic" happens in the RTTI
  system and within the general PLCore infrastructure. Scripts exist to make the world a little bit less complex, so, it's probably a good idea to make using
  scripts within the PixelLight C++ API less complex as well by directly adding the scripting-feature into PLCore. The PLScript documentation will still be an
  own document because the PLCore documentation is already comprehensive and contains more advanced stuff which will probably shock many people which are just
  looking for e.g. "How to use Lua within PixelLight". *g*



>> 11.06.2011
[CO]
PLCore:
- PLScriptLua: A Lua script can now connect a RTTI signal with a Lua function



>> 10.06.2011
[CO]
PLCore:
- "DynParams": Added "GetReturnTypeID()", "GetNumOfParameters()" and "GetParameterTypeID()" in order to make it possible to get some more
  information about parameters if one has just access to the "DynParams" interface
- Added "FuncGenFunPtr" and "FuncGenMemPtr" using functions/methods with the signature "Signature<void, DynParams&, void*>". There are situations were it's not
  possible to, e.g. create a typed event handler because the types are unknown to compile time. Those two new functor implementations are using a generic
  function/method and pass the parameters by using "DynParams".
- "DynParams": Added "GetPointerToReturnValue()" and "GetPointerToParameterValue()" to make it possible to set a return value or to get a parameter if one has
  just access to the "DynParams" interface. It's of course no good idea to use generic void* pointers to access the data and whenever possible typed access should
  be used instead... but there are situations were it's really required to be generic because the types are not known to compile time.
  Here's an example of a generic function:
    void GenericFunction(DynParams &cDynParams, void *pUserData)
    {
        // Get the value of the first parameter
        String sMessage = (cDynParams.GetParameterTypeID(0) == TypeString) ? *((String*)cDynParams.GetPointerToParameterValue(0)) : "";

        // Set return value
        if (cDynParams.GetReturnTypeID() == TypeInt32)
            *((int*)cDynParams.GetPointerToReturnValue()) = 42;
    }
  This function can then be used in the following way:
    FuncGenFunPtr<int, String> cFunctor(&GenericFunction);
    int nResult = cFunctor("He ho!");
  As you can see, using a generic function is just like using any other functor, except that the target function has a generic signature. The user
  data pointer enables the user to pass on additional data... this is a quite common approach (although it also has to be used with precaution).
- "DynEvent": Added "CreateGenericEventHandler()" which creates a generic event handler which is compatible with the dynamic event. Sadly this is only
  possible for global functions and not for class methods because we don't have any class type information available. But for my use-case it will do the job.
  Here's an example of a generic function:
    void GenericFunction(DynParams &cDynParams, void *pUserData)
    {
        // Get the value of the first parameter
        String sMessage = (cDynParams.GetParameterTypeID(0) == TypeString) ? *((String*)cDynParams.GetPointerToParameterValue(0)) : "";
    }
  And here's an example of how the new "DynEvent::CreateGenericEventHandler()"-method can be used:
    Event<String> cMyEvent;
    DynEventHandler *pDynEventHandler = cMyEvent.CreateGenericEventHandler(&GenericFunction);
    if (pDynEventHandler) {
        cMyEvent.Connect(pDynEventHandler);
        cMyEvent("He ho!");
        delete pDynEventHandler;
    }
  ... this means that if one has just access to the "DynEvent" interface, it's now possible to create an event handler which is informed when the event
  is emitted.
- PLScriptLua: RTTI signals now have some build in methods. When writing e.g.
    object.MySignal.Connect(object.OnMyEvent)
  the RTTI slot "OnMyEvent" of our RTTI class instance "object" is connected with the RTTI signal "MySignal" of our RTTI class instance "object".
  To disconnect, just use "Disconnect" instead of "Connect".



>> 09.06.2011
[CO]
PLCore:
- Until now, the constructor of RTTI signals was demanding a pointer back to their owner object. When looking at the "pl_slot_<x>"-macros, one could
  see that this provided constructor parameter was not used and I have no glue why it's there - because signals are internally just events (as also stated
  within the documentation). If there's need to know where an event came from, this information has to be provided in the event definition. Events should be as
  lightweight as possible, so storing e.g. an additional pointer within the event instance would probably not be the best idea. 
- PLScript: Lua is now an recommended external dependency and will be the script backend which is within the official PixelLight SDK. The answer for "Why Lua
  and not Python, JavaScript or AngelScript?!" is quite simple: Right now, the Lua backend is the most advanced one because Lua and it's C-API is mostly
  intuitively to use and there are tons of useful information all over the net how to integrate Lua into a "game engine". Lua is also the most compact
  of all of those mentioned script languages - the Windows dll is only 124 KiB while v8 (used for JavaScript) is 2,354 KiB! The syntax of Lua is also
  good to read and something like OOP can be done without totally unreadable tricks as required for JavaScript (did some OOP experiments within "44ScriptOOP").
- PLScript: Added "ScriptManager::GetScriptLanguageExtension()" which returns the filename extension of a given script language
- PLScriptNull: The null backend has no load and runnable scripts -> removed the "null" and "NULL" formats



>> 06.06.2011
[CO]
PLCore:
- PLScriptLua: Something like "sceneNode:SetActive(true)" is now handled correctly, meaning the boolean value "true"



>> 05.06.2011
[CO]
- *breaking change* "ElementManager": Renamed "Get(uint32 nIndex)" into "GetByIndex(uint32 nIndex)" and "Get(const String &sName)" into
  "GetByName(const String &sName)". There were already situations were the compiler wasn't able to distinguish between these two methods
  and upcoming changes/features would cause even more problems.
PLCore:
- Exposed "ConsoleApplication" to the RTTI
- Until now, C++ methods exposed to the RTTI had to be non-constant. Due to the script support, RTTI methods will now be heavily used and it's not that
  comfortable to be forced to change a method signature just to be able to expose it to the RTTI. So, within the "__pl_method_meth"-macro I cast away the
  const within the method pointer using a good old C-style cast to be as flexible as possible in here. I don't think that this introduces any security risks
  because the RTTI method just points to the real C++ method, and in there the const is still there and the compiler will blame you as usual if a non mutable
  member attribute is changed within a constant method.
- *breaking change* "ResourceManager": Renamed "Get(uint32 nIndex)" into "GetByIndex(uint32 nIndex)" and "Get(const String &sName)" into
  "GetByName(const String &sName)" (same change as in "PLGeneral::ElementManager")
- PLScriptBindings: Added "ScriptBinding_PL"
- PLScript: Removed experimental "ScriptBindingScene" because it's no longer needed. Write e.g.
      PL.GetApplication():GetScene():GetByName("Soldier")
  within a Lua script to get the scene node "Soldier". Something like
    PL.GetApplication():GetScene():GetByName("MySubscene"):GetByName("Soldier")
  will work of course as well... WOW! Stefans RTTI is *really* powerful and most script bindings will come practically
  for free... I just added
      pl_method_1(GetByName, SceneNode*, PLGeneral::String, "Returns a scene node by using the given name, can be a null pointer", "")
  within the RTTI class interface of "PLScene::SceneContainer" in order to be able to access the C++ method from inside a script.
  To avoid issues when exposing C++ methods to the RTTI I'am afraid we need to change something like
     void SetFilename(const PLGeneral::String &sValue)
  into
     void SetFilename(PLGeneral::String sValue)
  because "const PLGeneral::String &" is of course a reference, and the RTTI is using it this way (which is correct!). This is becoming a problem
  when there's no real "PLGeneral::String" instance on the method calling side... which is true for scripting. Before I start to hack around, I probably
  just change it as seen above... there's no real need for passing in a string reference anyway because the string class internally just shares
  a string buffer and therefore "copying" one string into another is blazing fast.
  -> I'am sure the "PL.GetApplication()" way is the right one for PixelLight. It results in only a few global functions (they introduce script
     initialization costs!) and the rest is completely dynamic by just using RTTI class instances (they introduce no script initialization costs!).
	 Exposing new features to script languages only requires a single, simple line of C++ code, and this line is even not just there for scripting,
	 it's generic. So, there's no need for thousands of "script proxies"/"script wrappers" in order to expose C++ stuff to scripting languages as seen
	 in many other engines with script support.
  -> In the next few days I should really spend more time on university stuff, but then I probably will start exposing the most important C++ methods
     to the RTTI (exposing this stuff doesn't blow up the memory footprint of RTTI class instances). 
	 When I'am done with it, the Lua support should already be quite usable... as for the Python, JavaScript and AngelScript support ... well,
	 I first have to figure out how to access RTTI objects in a decent way using those script APIs. The strongly typed AngelScript already produced some
	 headaches. For now, it's important to me that at least one scripting language is usable, so I focus on this point.
- PLScript: Removed experimental "ScriptBindingSceneRendererTool" because it's no longer needed. Write e.g.
      PL.GetApplication():GetSceneRendererTool():SetPassAttribute("DeferredDOF", "Flags", "Inactive")
  within a Lua script.
- PLScriptBindings: Renamed "ScriptBindingLog" into "ScriptBinding_PL_Log", "ScriptBindingTiming" into "ScriptBinding_PL_Timing" and
  "ScriptBindingSystemConsole" into "ScriptBinding_PL_System_Console" so one can directly see the resulting script namespace (I'am not sure whether or
  not the current solution will stay this way)



>> 04.06.2011
[CO]
PLCore:
- Adding a RTTI class method came with the cost of 8 bytes (32 bit build) per RTTI class instance. While e.g. RTTI class attributes really require
  per RTTI class instance data, RTTI class methods don't need per RTTI class instance data... at least as long as such a method is not called. When
  calling a RTTI class method, the RTTI class instance is required, but only then.
  One may say: "8 bytes - who cares about a few bytes?", but considering that those 8 bytes are per method and per class instance this really sums up.
  Until now, RTTI class methods were not used that often within PixelLight, so, this wasn't a real problem. For the script support, those RTTI class
  methods play an important role and I'am quite sure that all over the place a lot of RTTI class methods will be added in order to use RTTI class
  instances e.g. within scripts. With this in mind, those 8 bytes really hurt.
  So, before I start to add a lot of RTTI class methods for script support, I stopped and had a look into how to reduce the RTTI class method per
  instance memory costs. RTTI class methods are now static, meaning they only introduce a memory cost for the RTTI class itself which is not critical
  because there's only one such class instance per class. :D
  When requesting a callable RTTI class method, an instance of such an object is created on the fly. In short, memory was traded for additional memory
  allocation/deallocation - but I really think it's ok and maybe there will be more internal optimisations later.
  -> This change means, that something like
       "cMyObject.MethodTest()" or "cMyObject.MethodTest.Call(PLCore::Params<void, int, float>(20, 1.1f))"
     for calling the method "Test" though it's RTTI wrapper is no longer possible. But that's not really a loss because in those situations it's possible
     to directly call the C++ method anyway.
  -> This change also means that within constructors, it's no longer required to initialize RTTI class methods by writing e.g. "MethodLoad(this)". This makes
     exposing methods to the RTTI easier because it's only required to add e.g.
       pl_method_2(Load, bool, Chunk&, PLGeneral::File&, "Load method", "")
     within the RTTI class definition in order to access the method "Load" though the RTTI.
  -> And the most important meaning of this change: Add as many RTTI class methods as you want, your RTTI class instance won't grow into the kilobytes through that. :D
- "Object::GetMethod()" returns now "DynFuncPtr" instead of "DynFunc*"
- "Object::GetMethods()" no longer returns a list instance, instead a list instance to be filled has to be provided as parameter.
  This change avoids unnecessary copying around. Because the RTTI stuff is fundamental, it really has to be as performant as possible...
  even if this means that the interface of "Class::GetMethods()" is not identical to "Object::GetMethods()".
- Stephan found a cleanup bug within my delayed shared library loading implementation... in the case that a class dummy can't be registered because there's
  already a class dummy or even the real class, no one destroyed the created dummy class instance. This is now handled within "ClassManager::RegisterClass()".
  Uff, simple principle, that many implementation bugs - not that I had expected it otherwise... but I really hope that was the last one.
- The type ID of "TypePtr" and "TypeRef" was set to -1 instead of an unique value
- PLScriptLua is now able to deal with RTTI class instances derived from "PLCore::Object" instead of just direct pointers
  to "PLCore::Object". The current solution is not really a good one, but for now it works. I hope I'am able to figure out
  a more waterproof solution.



>> 03.06.2011
[CO]
PLCore:
-> Stephan Wezel made a PLProject refactoring (see PLProject diary for details), delayed shared library loading is now also working under Linux
   because PLProject adds the class information into the plugin-file
- PLScriptBindings: Added "ScriptBindingSceneRendererTool"... The "making of" of the dungeon demo is now done via a
  Lua script. Still experimental, but the wires begin to tie up.



>> 02.06.2011
[CO]
PLCore:
-> After an university lecture etc. maraton of two weeks and some non script related PixelLight work, back to the script stuff. :)
- PLScript: "Script::SetGlobalVariable()" has now as parameter the more generic "PLCore::DynVar" instead of "PLGeneral::String"
- PLScript: Renamed "Script::GetGlobalVariableType()" into "Script::GetGlobalVariableTypeID()" so that it's similar to e.g. "PLCore::Var::GetTypeID()"
- PLScriptLua: "Script::SetGlobalVariable()" now also supports "PLCore::Object*" and is able to add new global variables
  (one can use e.g. "Script::IsGlobalVariable()" to check whether or not there's such a variable before setting one to avoid adding a new
  global variable if this is not desired)
- "PLScriptBindings::SNMScript" now adds the global variable "this" to the script so that it's able to access "this" RTTI class instance,
  meaning the script scene node modifier
- PLScriptV8 & PLScriptPython: "Script::SetGlobalVariable()" is now able to add new global variables



>> 29.05.2011
[CO]
- Added "Stopwatch::Stopwatch(bool bStartAtOnce)" to make it possible to use the stopwatch in a more compact way
- "StringBufferManager::ReleaseStringBuffer()": Activated the string buffer management under MS Windows because, especially when
  debugging, this adds a real performance boost like e.g. 2 sec instead of 20 sec to start an application in debug mode.
  (so, this string management is nothing optional - without it, it's just painful to debug more complex applications)
  Under Linux, I currently just get a segment fault when starting an application with enabled string buffer management - so it's deactivated
  under Linux for now because I don't have the time to do intensive debugging at the moment, but I really need to be able to do decend debugging
  under MS Windows...
- Ok, "StringBufferManager::ReleaseStringBuffer()" is now working under Linux as well... there was a really stupied bug which caused the UTF8
  string buffer to lie about it's type...
PLCore:
- Added parameters to the plugin relevant "ClassManager"-methods to make it possible to e.g. disable delayed shared library loading
- Added an option to "ConsoleApplication" to make it possible to configure whether or not it's allowed to perform delayed shared library loading to
  speed up the program start ("DelayedPluginLoading" within the configuration file)
- The "ClassManager"-destructor has to destroy the class implementation dummies, the real classes are destroyed automatically by the RTTI system
  (see "pl_class" -> "__pl_guard"). Stephan Wezel helped me in identifying those (hopefully) last bugs in the refactored "Class"-class and helped
  testing the stuff under Linux as well as fixing some details, a huge thank's for the motivating support. :D
-> It looks like the delayed shared library loading is really working quite fine and it's finally fun again to do debugging because the program start
   doesn't take half a minute. I hope I'am now able to focus back to complete the scripting stuff and fix some general bugs like the one described at
   http://dev.pixellight.org/forum/viewtopic.php?f=6&t=48&p=153#p153
   ... the time until the next planned PixelLight release is running, but it was really important to me to speed up the program start time in order
   to be able to debug in a resonable way.



>> 28.05.2011
[CO]
PLCore:
- Continued "Delayed shared library loading"-refactoring: Currently, "LoadableManager" forces many plugins to be loaded in order to register
  loader instances. To delay the plugin loading, "Loader" is now just a proxy and "LoaderImpl" the real loader implementation. This way, the available
  loader implementations are registered correctly, but the actual loader implementations which require to load in the shared library are only
  created when really required.
- The RTTI interface for "Object" was defined as
    pl_class_internal(Object, "PLCore", "", "Object base class")
  and the result was that the base class of "Object" was "" instead of <no base class>, meaning an empty string. I changed it to
    pl_class_internal(Object, "PLCore", , "Object base class")
  ... although it looks somewhat strange, it's correct this way.
- "ClassImpl::GetBaseClass()" is no longer calling "InitClass()" to enhance the chance that a RTTI class is never initialized



>> 26.05.2011
[CO]
PLCore:
- Started "Class" refactoring... There are now a lot of PixelLight plugins within the Git repository and by default, they are all loaded within
  "ConsoleApplication::OnInitPlugins()" so that it's possible to create RTTI class instances. While this behaviour is quite comfortable
  because plugins can be used automatically by just throwing the loose plugins into a scanned directory, it's also quite slow at program start.
  (although there are already several internal optimizations in place like delayed RTTI class initialization!)
  Usually only a few plugins are really used during runtime, but in order to be able to create RTTI class instances it's required that the system
  knows which RTTI classes are actually available. Currently, this requires to load in the shared library which may cause the loading of other
  shared libraries. (domino effect) Due to the increasing number of loose PixelLight plugins, the program start time starts to get annoying long
  - especially in debug mode. My plan was to focus on the script implementation, but I'am not able to try out and debug stuff in reasonable time
  because each program start takes several seconds, even if there's actually not happening much in an application. Of course, it would be possible
  to just "deactivate" plugins, but such hacking around would cost time as well and would be error prone. So, it's probably time to add another
  RTTI initialization speed up optimization: Delayed shared library loading
  This was actually planned for several years, but there were always more important things to do - like getting the RTTI to the point were it's
  really cool and powerful. Stefan accomplished that. The "new" RTTI system is now several months in use and works really well, so, it's now probably
  really time to implement this delayed shared library loading thingy to speed up the program start when there are a lot of optional loose plugins
  available. (which is now the case)
  The delayed shared library loading should be transparent to the user, meaning that it should happen automatically on the fly so that the user don't
  need to care about it. So, as the first refactoring step I applied the bridge design pattern to "Class" and moved the previous implementation
  into the implementor "ClassReal". The RTTI system still creates automatically class instances, but they are now derived from "ClassReal" instead
  of "Class" which is now just a class implementation wrapper. Looks like everything is still working as before. This change makes it possible to
  secretly change the internal class implementation... the next step is to add class metadata into the "plugin" file and when loading a plugin,
  this metadata is used to create dummy class instances without actually loading the shared libraries the RTTI classes are implemented in. The real
  RTTI class instance is only created by loading in the shared library when really required, e.g. when an instance of the RTTI class has to be created.
  In this case, the internal class implementation is changed - but the "Class" instance the user is working with will be still the same. This should
  speed up the program start.
- Added "pl_module_delayed()"-macro and the plugin file option "Delayed" which is "true" by default
- Renamed "ClassManager::LoadPluginLibrary()" into "ClassManager::LoadModule()" and made it public
- Add RTTI class metadata within the XML plugin file
- Wow, already done! Delayed shared library loading is working! The startup time of e.g. "01Application" is now better.
  (it's of course only faster when not all available plugins are used)
-> I'll do some more testing before I upload this change (although the next two days I'am quite busy with university, again :/)



>> 24.05.2011
[CO]
- The "DynLib" implementations were not unloading the dynamic OS library automatically. I thought about this issue to figure out whether
  it's acutally a "feature", but this really looks like an adverse behaviour because e.g. something like "File" is closing the opened file
  automatically.
PLCore:
- "ClassManager": Moved plugin file format version 1 loading code from "LoadPlugin()" into a separate method "LoadPluginV1()"
- "ClassManager": Moved plugin library loading code from "LoadPluginV1()" into a separate method "LoadPluginLibrary()"
- "ClassManager": There was a memory leak during plugin library loading: The ownership of the created instance of the dynamic
  library was given to the created "Module" instance, but "Module" never destroyed the given instance of the dynamic library.
- "ClassManager": No one was destroying the module instances, so this is now done within the "ClassManager"-destructor
- Made the "Module" constructor and destructor private because only the class manager is responsible for managing the modules
- The "Module" destructor was virtual, but there's no reason for that



>> 22.05.2011
[CO]
PLCore:
- PLScript: Woho, the demo "Scripts.scene" comes to live... "ScriptsScene.lua" is already up and running and is manipulating a scene
  node by using a Lua script. It's still everything experimental to see what's possible and how it may work as a whole
  system.
- Added PLScriptBindings plugin which exposes certain parts of PixelLight to script languages. This means that the script bindings
  are a 100% loose plugin and are not within the core. First I thought about adding some basic script bindings directly into PLScript and
  other script bindings into the PLEngine project which brings together the individual components to an easy usable framework. But
  this way the standard PixelLight script bindings would be scattered over multiple projects and there would also be the risk that the
  completly optional script support may accidentally grow into the core over the time. This way, it will probably also easier for other
  people to contribute to the script bindings part.



>> 21.05.2011
[CO]
PLCore:
- "TypeObjectPtr" & "TypePtr" & "TypeRef": "ConvertFromVar()" is now using "GetUIntPtr()" instead of "GetInt()" (this was a [TODO] point)
- PLScript: Worked on "PLCore::Object*" support



>> 19.05.2011
[CO]
PLCore:
- DynEvent: Added "void Emit(const PLGeneral::String &sParams)" and "void Emit(const PLGeneral::XmlElement &cElement)" to make it possible to emit
  events when one just has a DynEvent pointer
- Added "GetNumOfParameters()" and "GetParameterTypeID()" to "DynEvent" to make it possible to request some more information about the dynamic function
- Warning, breaking event change: I had to change "void Emit(_T0 t0, _T1 t1)" into "void operator ()(_T0 t0, _T1 t1)" etc. because when not doing so, the compiler
  failed to see the difference between e.g. "Emit(String)" and "Emit(String)", ok, maybe there isn't one. This issue has to do with the
  "void Emit(const PLGeneral::String &sParams)" change above - but those non typed call methods are really required. I don't wanted to rename those methods
  into e.g. "void EmitString(const PLGeneral::String &sParams)" because it felt unnatural to me and by the way, "DynEvent" is quite similar to "DynFunc" -
  at least within the usage. Whenever possible I try to avoid such breaking changes, but sometimes they are required to avoid that stuff gets uggly.
  So, to call e.g. an event named "MyEvent" call "MyEvent()" (if you have ever used boost, you are already familiar with this way :) instead of "MyEvent.Emit()".
- PLScriptLua: Calling RTTI object methods within Lua scripts is working... currently only slow progress because the university is using most of my available
  time. But I still try to get the script support up and running until the next scheduled PixelLight release. :D
- PLScriptLua: Calling RTTI object signals within Lua scripts is working



>> 17.05.2011
[CO]
PLCore:
- PLScript: Added "Script::PushArgument(PLCore::Object *pObject)" and an experimental Lua implementation to get an idea how to access RTTI objects
  directly within scripts *work in progress*



>> 16.05.2011
[CO]
- Removed "long" methods within the "String" and "Tokenizer" classes to avoid compiler issues with 64 bit data types
  (a compiler may actually define a 64 bit data type as long, and then there's no way to distinguish long from long *g*)



>> 13.05.2011
[CO]
- "String": Added "int64"-support
PLCore:
- "PLCoreDefinitions.h": Added "TypeInvalid"
- PLScript: "Script:" Added support for global variables. At first I thought about adding "GetGlobalVariable()" & "SetGlobalVariable()" versions
  for the supported primitive data types - but this would result in a total copy'n'past overkill within the internal implementations. Those
  string methods should do the job (the internal implementations try to don't change the script variable type).
- PLScript: Renamed "Script::AddDynamicFunction()" into "Script::AddGlobalFunction()" and "Script::RemoveAllDynamicFunctions()" into "Script::RemoveAllGlobalFunctions()"



>> 12.05.2011
[CO]
PLCore:
- Added "GetNumOfParameters()" and "GetParameterTypeID()" to "DynFunc" to make it possible to request some more information about the dynamic function
- Added "PLScriptLua::Script::LuaStackDump()" which writes the current Lua stack content into the log



>> 11.05.2011
[CO]
PLCore:
- PLScript: The "ScriptManager" creates now instances of all found "ScriptBinding" classes
- PLScript: Added "Script::AddBindings()" to bind all available "ScriptBinding" instances at once
- PLScript: By default, "ScriptManager::Create()" and "ScriptManager::CreateFromFile()" binds all available "ScriptBinding" instances at once



>> 08.05.2011
[CO]
- A while ago, Stephan reported me an issue with double slashes within filenames - finally I found some time to have a look into it.
  Something like "PLGeneral::File("e:\\1//Test.jpg").Exists()" failes. Because I wasn't sure whether or not this behaviour is "correct"
  (the filename looks kinda messy) I first tested the same with boost by writing "boost::filesystem::exists("e:\\1//Test.jpg")" and with
  Qt by writing "QFile("e:\\1//Test.jpg").exists()" and "QUrl("e:\\1//Test.jpg").isValid()". For boost and Qt a filename like
  "e:\\1//Test.jpg" is totally fine.  	
  Next I tried to find a description which behaviour is "correct". As usual, found first information at Wikipedia:
    "http://en.wikipedia.org/wiki/URL_normalization" (from 2011-05-08)
      "Removing duplicate slashes Paths which include two adjacent slashes should be converted to one. Example:
       http://www.example.com/foo//bar.html â http://www.example.com/foo/bar.html "
  I wasn't able to find this in standards like RFC 3986 (http://tools.ietf.org/html/rfc3986#section-6) - but I was searching only a few
  minutes. After this research I "assume" that removing duplicate slashes is fine, at least this way there's within PixelLight the same
  behaviour as in boost or Qt.
  -> Made a minor change within the "Url::SetValue()" implementation.
PLCore:
- PLScript: The AngelScript add on source codes are now within "External\Optional\AngelScript\add_on" directory instead within the to download external package.
  CMake told me that it wasn't able to find those add on source codes... because it was checking BEFORE downloading and extracting the external package. Maybe
  it's possible to change the CMake script... but that's somewhat too dangerous for me and usually really time consuming to get it right.



>> 07.05.2011
[CO]
PLCore:
- Implemented "PLScriptPython::Script::AddDynamicFunction()" namespace by using Python dictionaries... probably not the best solution but for
  now I just want to have it up and running to get an idea of concepts multiple scripting languages are sharing. Maybe I'll replace "namespace"
  later by "module".
- Implemented "PLScriptV8::Script::AddDynamicFunction()" namespace by using V8 object template
- Implemented "PLScriptAngelScript::Script::AddDynamicFunction()" namespace. It looks like that AngelScript (2.20.2) has currently no support
  for namespaces... so right now I'am doing an ugly hack: e.g. "PL.Timing.GetTimeDifference()" is written within scripts as "PL_Timing_GetTimeDifference()". :/
-> Ok, the namespace support for global functions is now implemented within all script backends... although I'am really not happy with the current
   AngelScript solution (e.g. "PL_Timing_GetTimeDifference()" instead of "PL.Timing.GetTimeDifference()") and Python solution
   e.g. "PL[âTimingâ][âGetTimeDifferenceâ]()" instead of "PL.Timing.GetTimeDifference()"). It's really time consuming to do the research into multiple script
   API's at the same time and on those two issues I already spend several hours without a decent solution. So, if there's someone who knows a better solution...
-> Right now my candidates for the "recommended PixelLight script language" are JavaScript and Lua. Lua is quite compact while JavaScript is a web-standard which
   could be somewhat beneficial for PixelLight, especially regarding to the browser plugin. AngelScript looks somethat unfinished although I like the API in
   general. Python is just a monster. *g*
- PLScript: "Script": Added string versions of "PushArgument()" and "GetReturn()". Adding support for this within PLScriptAngelScript was some hard work because unlike
  JavaScript (V8), Python and Lua, within AngelScript strings are just "add_on" and not everything is documented as detailed as I wished for and I wasn't able
  to find real help via google as well. So I had to guess, review the AngelScript source codes and perform some debugging... I really hope that I didn't miss
  anything...



>> 06.05.2011
[CO]
PLCore:
- PLScript: Added "ScriptBinding" which is actually a blank RTTI class. RTTI classes which are only used for "script binding" should be
  derived from this class. This doesn't mean that it will be impossible to bind any other RTTI class instance to a script - but usually
  it's useful to have such an abstract base class...
- PLScript: "Script::AddDynamicFunction()": Added namespace as last optional parameter (backend implementations will follow)
- PLScript: Added "Script::AddBinding()" which adds a script binding to connect the given RTTI class instance with this script (currently only RTTI
  methods are used)
- Implemented "PLScriptLua::Script::AddDynamicFunction()" namespace by using Lua tables



>> 02.05.2011
[CO]
PLCore:
- "DynFunc": Added "GetReturnTypeID()" to make it possible to figure out the return type (e.g. "TypeNull" for "void()" or "TypeInt" for "int()")
  of a dynamic function
- Python backend: Implemented "AddDynamicFunction()" and "RemoveAllDynamicFunctions()"
- V8 (JavaScript) backend: Implemented "AddDynamicFunction()" and "RemoveAllDynamicFunctions()"
-> The Lua, Python, AngelScript and JavaScript backends are now equal in the implemented behaviour. It's possible to call script functions
   from the C++ side, and it's also possible to call C++ functions from the script side. I'am quite sure that this isn't everything one
   requires when working with script engines, but it's a start. I have to take a break for a couple of days due to university stuff, then
   I continue working on PLScript.



>> 01.05.2011
[CO]
PLCore:
- AngelScript backend: Implemented "AddDynamicFunction()" and "RemoveAllDynamicFunctions()"
- Python backend: Calling Python functions is working



>> 30.04.2011
[CO]
- "String": Added pointer constructor "String(void *pValue)"
PLCore:
- "Functor"-Templates: Added "Clone()"-Implementation
- "DynFunc": Added protected copy constructor and copy operator to avoid misuse, made the default constructor protected as well to avoid confusion
- "DynFunc": Added "PLGeneral::String" and "PLGeneral::XmlElement" parameter versions of "CallWithReturn()". When using
  "DynFunc::Call(const PLGeneral::String &sParams)" or "DynFunc::Call(const PLGeneral::XmlElement &sParams)" there's absolutely no chance to get any
  function return values because there's no type information. Currently I'am using "DynFunc::Call(const PLGeneral::String &sParams)" within the work
  in progress PLScript to let a script call a given C++ function/method and really need at least a string representation of the result which I can give
  back to the script API. I really hope that those "CallWithReturn()" template methods don't backfire... right now it appears that there are no side
  effects during template instantiation. I could have added the string return directly into the already existing methods, but I wasn't comfortable
  with that.
- PLScript: Added script support for functors/functoids so that it's possible to call C++ functions or member methods from inside scripts...
  as well as other script functions because the functors are hiding this detail.
  The method "Script::AddDynamicFunction()" is used to register functors while "Script::RemoveAllDynamicFunctions()" can be used to remove
  all registerd functors. The Lua implementation is already working. Please note that this is still highly experimental and I don't know
  whether or not the script interfaces are completly changed later.



>> 29.04.2011
[CO]
- Added "File::GetContentAsString()"
PLCore:
- Moved "OpenFile()" from "Loader" into "LoadableManager" because it's kind of universal
- Moved "LoadStringFromFile()" from "PLRenderer::EffectPass" into "LoadableManager" because it's kind of universal
- "SignatureString": "PLGeneral::String GetSignatureID()" constructed internally the signature string on every call. But during runtime, this
  must only be done once and then the signature can just be reused. So, the internal signature string is now static to enhance performance. I
  double-checked the change, used the debugger a few times on it to see and think through the performed steps and tested the existing PixelLight
  projects as well. It looks like that this change has no side effects.
- PLScript: Added "GetScriptLanguage()", "GetSourceCode()" and "SetSourceCode()" to "Script" (similar to "PLRenderer::Shader")
- PLScript: Added "FuncScriptPtr" which is a version of "PLCore::FuncFunPtr"/"PLCore::FuncMemPtr" for script functions. This means that script functions
  can be called in the same way as all other functions/methods (e.g. RTTI methods) can be called. This template is using
  the "Script" methods "BeginCall()", "PushArgument()", "EndCall()" and "GetReturn()" to call script functions. Calling Lua and AngelScript
  functions is already implemented and working. Those mentioned script function calling methods are currently public although it's not recommended
  to call them without using "FuncScriptPtr", but currently I see no change to hide those methods from the user. But this is just my first attempt to
  get things up and running... next stop: Implementing the same for Python and JavaScript. (calling C/C++ methods from scripts will follow as well)
- PLScript: Calling JavaScript functions is working... although the implementation is currently somewhat poor... having some issues getting into the V8-API...



>> 28.04.2011
[CO]
- "FileWindows::GetSize()" is now using the MS Windows API functions "_filelength" and "_fileno"
PLCore:
- PLScript: As requested within the PixelLight forum at: http://dev.pixellight.org/forum/viewtopic.php?f=3&t=45
  ... I'll also added a script backend for AngelScript (like the others, just a skeleton right now!). Ok, four script languages should really
  be enough to get a good script interface.



>> 26.04.2011
[CO]
PLCore:
- PLScript: Compiled 32 bit versions of Lua, Python and V8 (JavaScript engine) for Windows and Linux. Configurated everything so that the script
  projects can be compiled and are able to run.
  Next stop: Concrete script implementations :D



>> 25.04.2011
[CO]
PLCore:
- Started the PLScript project. As usual there's a null backend and I'll implement backends for Lua, JavaScript and Python in parallel.



>> 19.04.2011
[CO]
- Removed "_DEBUG" preprocessor tests within the String and String Buffer class



>> 15.04.2011
[CO]
- Premier: First entry within the tracker ("Bugs"-category) at http://sourceforge.net/tracker/?group_id=507544
  -> Bugfix (ID: 3286541): "PLGeneral::XmlElement::GetLastAttribute()" was returning the first instead of the last attribute



>> 10.04.2011
[CO]
PLCore:
- "ConsoleApplication::OnInitData()" is now using English as the default language instead of the current system locale, this makes things more predictable



>> 08.04.2011
[CO]
PLCore:
- Added "ResourceManager::EventResourceRemoved"-event which is called when a resource is going to be removed



>> 09.03.2011
[CO]
- Url-class: Nearly over a year ago, a client reported that a client reported (jap :) that UNC (Uniform Naming Convention aka Universal
  Naming Convention) support was not working. At this time, I never had heard of UNC before and there was not really time to look into it
  in more detail - so, a hack on the client side had to do the job. Today, why ever, I was really curious what's the issue with UNC.
  After looking what exactly UNC is all about (I usually don't have to do anything with network related stuff), I made some experiments
  (also with "QUrl" from Qt) and figured out, that the only problem seemed to be within the "Url::SetValue()"-method while parsing the
  given URL. After spending some hours to get into regular expressions again and looking for pitfalls that may occur, I added UNC parsing
  support to the Url-class. Now, the following works for me
    System::GetInstance()->SetCurrentDir("\\\\COFENBERG-PC\\Users\\COfenberg\\UNC_Test");
  As well as
    File cFile("\\\\COFENBERG-PC\\Users\\COfenberg\\UNC_Test\\Test.txt");
    if (cFile.Open(File::FileRead|File::FileText)) {
        String sText = cFile.GetS();	// -> sText = "Hello" :D
    }
  I don't know whether or not my change within "Url::SetValue()" is perfect... in general, I wanted to keep the required implementation change 
  as compact as possible.



>> 02.03.2011
[CO]
- As noticed by a PixelLight user, the data type returned by "System::GetMicroseconds()" was "uint32" which is critical for the stored data
  and "unsigned long" is commonly used instead. So, methods like "System::GetMicroseconds()" are now using "uint64" instead of "uint32".
  It's really cool to get feedback on how to improve PixelLight, keep up providing feedback! :D



>> 26.02.2011
[CO]
- StringBufferASCII is now using "memcpy" instead of "strncpy" because "memcpy" is usually slightly faster as "strncpy"
  (checked usual implementations of those functions). Within this class, it's guaranteed that the values are correct, so there's no security
  risk in using "memcpy". I know, the difference is not really measurable, but I always try to squish out everything possible out of such
  basic implementations.
- StringBufferUnicode is now using "memcpy" instead of "wcsncpy"
- Added some more String constructors to make it easier and "more intiutive" to create a string out of a number
- Had a look into "sprintf" (a variation is used within "String::Format()") and "itoa" (non-standard extension to the standard C). In certain
  situations, "sprintf" has no chance to come near to the performance of "itoa" - which is obvious because "sprintf" is more universal and powerful.
  The following example took 880 ms
    for (int i=0; i<100000; i++)
        String sMyString = String::Format("The number %d is fantastic!", 42);
  while the following example took 129 ms
    for (int i=0; i<100000; i++)
        String sMyString = String("The number ") + 42 + " is fantastic!";
  after using "itoa" in the internal String implementation. I think there's a notable performance difference in the second version which is worth to
  talk about. :D



>> 25.02.2011
[CO]
PLCore:
- "ConsoleApplication": Moved "Write some general information into the log"-step from "OnInit()" to "OnInitLog()". It was a little bit
  confusing that initial information like "Log-system started" was written somewhere at the end of the initialization phase.



>> 22.02.2011
[CO]
PLCore:
- "ConsoleApplication::OnInitPlugins()": The PixelLight runtime directory is now also scanned non-recursively for plugins. This is quite useful
  for projects which can be used completely dynamically, but can also be used in other C++ projects to access certain features. This behaviour is
  also symmetric to the application directory scan.



>> 17.02.2011
[CO]
- Program entry point within "Main.h": Removed "setlocale(LC_ALL, "");" because I don't think that it's a good idea to use "setlocale".
  This is up to the user and the user is also responsible for the consequences when changing the current locale...
- String internals: Sadly, the current set locale is of course also an issue on all operation systems. It would be fantastic if we never
  ever would come into contact with "setlocale" at all, but sadly, the user can and possibly WILL change the current set locale and then
  hell breaks lose because e.g. "42.21" will be written as "42,21" and possibility written e.g. into a XML file... on another side "42,21"
  is read from the same XML file and boom, invalid floating point number due to the use of another locale. To be honest, I really hate this
  topic but sadly, I can't just completely ignore it forever.
  Today I was remembered, again, why we decided to wrap EVERYTHING within PixelLight so more complex projects can use a consistent framework...
  Just an example: MSVC has some cool string functions like "_sprintf_l", on Linux there are some similar functions allowing you to directly
  provide the locale to use as a parameter (other systems like Android OS, don't offer such stuff, of course!), instead of using an ugly global
  setting. But sadly, there's no standard for that. So I backup the current set locale by using "strdup" before changing it (evil dynamic memory
  management, but currently I see no other simple solution)... but wait, now VC tells me the following:
    "warning C4996: 'strdup': The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strdup. See online help for details."
  Cool, the VC compiler tells me "Do NOT use POSIX, it's evil!". Because I don't like dozens of "#ifdefs" either, I just
  suppressed this stupid warning. Low level C/C++, one just must love it! *gruml*
  Sadly I'am afraid that the locale changes from today are no real solution, and something like a locale class is required... but for now, I
  just have enough of this topic...



>> 01.01.2011
[CO]
- Renamed the method "Mutex::Lock()" with a timeout as parameter into "Mutex::TryLock()" so one can see that it's really wise to
  check whether or not a lock was actually received
- Added "PLGeneral::MutexGuard" helper class using the really cool "Scoped Locking"-idiom which can make the code more compact while
  also increasing the maintainability
- Renamed the method "Semaphore::Lock()" with a timeout as parameter into "Semaphore::TryLock()" so one can see that it's really wise to
  check whether or not a lock was actually received...



>> 29.12.2010
[CO]
- Removed "String::Unknown"-definition, it was only used once internally and less variations are usually the better choice
- Removed "String::UTF8"-definition
- Removed "utf8" data type
- "String": Refactoring of the UTF8 support, in fact reduced the support to the two methods "GetUTF8()" and "SetUTF8()"
- "QtStringAdapter" is now using UTF8 instead of wchar_t to avoid the need to recompile Qt or PixelLight with other compiler settings



>> 18.12.2010
[CO]
- "PLGeneralWindows.h": If "_MSC_VER" (VisualStudio) or "_WCHAR_T_DEFINED" is not defined, "wctype.h" will be included for
  "wchar_t". Now PLGeneral can be used within for example QtCreator at once.
- Added a static adapter class within PLGeneral for mapping Qt strings to PixelLight strings and vice versa



>> 17.12.2010
[CO]
- Added unicode support to "FileLinux", "FileSearchLinux", "ConsoleLinux", "DynLibLinux", "SystemLinux", "FileStdStream", "Log",
  "ConsoleWindows" and "Process"



>> 12.12.2010
[CO]
PLCore:
- Loadable-System: At the PixelLight mailing list (pixellight@lists.pixellight.org), a discussion about case-sensitive file-extensions
  came up. In general, while for instance UNIX like systems have case-sensitive file systems, MS Windows does not. At the
  beginning of the development of PixelLight, we made the design decision that PixelLight should be case-sensitive in general
  to avoid porting problems across multiple-platforms. Naturally, for MS Windows only users, this leads to confusion when
  they try to load in, for example an image named "MyImage.JPG", and nothing happens although the jpg file format is supported.
  The reason behind this is, that the file extension is used to figure out which loadable implementation is responsible for
  loading the concrete data. In this case, "jpg" tells the (plugin based) system to use "PLGraphics::ImageLoaderJPG" to load
  in the data. The extension string test is case-sensitive, and as such, "JPG" is unknown to the system.
  Ideas came up to add an option to make the extension case handling configurable, or to make file extensions in general case-insensitive.
  I did some research on the topic to see how other developers handle this situation or think about this - as expected, there are a lot
  of different opinions about "what's best".
  I thought about the issue, and I see the point that this can be a problem using a lot of content - to be honest, from time to time
  I have some "problems" with this as well. For example, "The Compressonator" (http://ati.amd.com/developer/compressonator.html) from ATI (ok,
  AMD nowadays *g*) always wants to write "DDS" instead of "dds" as file extension.
  In my opinion, I still think that it's no good idea to weaken the "PixelLight is in general case-sensitive" design decision and adding a huge
  comment that this is the one and only place within PixelLight were it's handled by using strategy A instead of strategy B. I really think that, on
  the long term, this will cause more problems than solving them.
  Fortunately, the loadable system already supports multiple aliases for one and the same file format. For example "PLGraphics::ImageLoaderJPG"
  can be addressed by using "jpg", "jpeg", "jpe", "jif", "jfif" or "jfi" as jpg file extension. So, why not add "JPG", "JPEG", "JPE", "JIF", "JFIF"
  and "JFI" as well? Of course, something like "JpG" will still not be recognized, but I can't remember a program using this case convention... and
  as a computer scientist, I love orderliness and don't really want to support spelling chaos intentionally. I saw that some other developers are
  using this solution as well, and I think it's a good compromise - it doesn't weaken a general system design decision by adding an exception, but
  it allows to use for example "JPG" instead of just "jpg", too.




/*********************************************************\
 *  The entries below are in German only
\*********************************************************/



>> 06.12.2010
[CO]
PLCore:
- DynEvent um "GetNumOfConnects()"-Methode erweitert, bei z.B. Profiling ist es hin und wieder interessant zu
  erfahren wie viele Connections gerade vorhanden sind



>> 04.12.2010
[CO]
- Beim Ã¼ber die Codes "schweifen" (hin und wieder passiert mir soetwas unbeabsichtigt *g*) vielen mir in der String Klasse ein
  paar Stellen wie z.B. "if (pszFormat && strlen(pszFormat))" auf. Sinn ist hier eigentlich nur rauszufinden ob direkt das erste
  Zeichen im String eine terminierende Null ist - die String lÃ¤nge braucht man hier gar nicht. Ãnderte diese Stellen daher in
  "if (pszFormat && pszFormat[0] != '\0')" - spart einen Funktionsaufruf und Ã¤ndert die komplexitÃ¤t hier von n zu 1 da nicht mehr
  im String nach '\0' gesucht werden muss. Interessant das mir das noch nicht vorher ins Auge gestochen ist. *g*



>> 29.11.2010
[CO]
- "Stopwatch::Stop()"-Bugfix: Wenn die Stopuhr gerade nicht lÃ¤uft, und man "Stop()" aufruft sollte natÃ¼rlich "0" als gemessene
  Zeit zurÃ¼ckgegeben werden...
-> Die im Tagebucheintrag vom "30.10.2010" angesprochenen String Optimierungen angepackt...
- StringBuffer: "Append()" hinzugefÃ¼gt, wenn immer mÃ¶glich wird in der String-Implementation nun "Append()" verwendet da dessen
  Implementation einfacher gehalten ist (wodurch Optimierungen und bessere Performance leichter zu realisieren sind)
- StringBuffer um "m_nMaxLength"-Variable erweitert, damit ist es nun mÃ¶glich, dass ein String Buffer intern grÃ¶Ãer ist als der
  tatsÃ¤chlich gespeicherte String. Hintergrund ist, das Speichermanagement teuer ist und derzeit die String Klasse fÃ¼r ein paar
  Dinge performancemÃ¤Ãig leider unbrauchbar ist. Da wir meist nur ASCII nutzen, konzentriere ich mich erstmal auf Optimierungen
  fÃ¼r ASCII Strings - aufgrund des Umfangs der String Klasse, wird es sicherlich nen bischn dauern bis alles etwas flotter geht.
  Oft werden mehrere Strings konkateniert, hier zeigte die String Klasse performance mÃ¤Ãig deutliche schwÃ¤chen. Sinnfreies aber
  einfaches Beispiel:
    String sString;
    for (int i=0; i<100000; i++)
      sString += 'a';
  Vor dem Beginn der Performance optimierungen dauerte das im Release Modus unglaubliche 2995 ms. Nach dem einbauen von "Append()"
  noch 2757 ms, und sobald bei "Append()" intern Speicher fÃ¼r zukÃ¼nfige Zeichen reserviert und dann genutzt wurde nur noch
  47 ms. Das zeigt denke ich, dass es Sinnvoll ist diese Optimierung weiterzuverfolgen da es doch schon ein deutlicher Unterschied ist -
  gerade bei groÃen Datenmengen! (der Code wird dadurch aber leider nicht einfacher oder gar weniger :/)
- StringBufferManager hinzugefÃ¼gt. ZukÃ¼nftig sollten StringBuffer-Instanzen nur noch hierÃ¼ber erfragt, und sobald nicht mehr benÃ¶tigt
  hierhin zurÃ¼ckgegeben werden. Sobald man einen StringBuffer benÃ¶tigt, fragt man einfach den StringBufferManager nach einer StringBuffer
  Instanz die eine bestimmte String lÃ¤nge halten kann... es obliegt dann dem StringBufferManager zu entscheiden ob man einen Buffer
  mit GENAU der lÃ¤nge zurÃ¼ckbekommt, oder einen Buffer der *mehr* halten kann. Es ist ebenfalls dem StringBufferManager Ã¼berlassen ob
  er gerade nicht benÃ¶tigte StringBuffer Instanzen buffert statt sofort zu lÃ¶schen, um dann diese wiederverwenden zu kÃ¶nnen um dynamisches
  Speicher anlegen/freigeben zu reduzieren. Durch den StringBufferManager wurde hier und da die Implementation der String Klasse etwas einfacher. :D
  Die StringBuffer-Klasse hat eine statische Instanz von StringBufferManager und StringBufferManager speichert gerade nicht benÃ¶tigte
  StringBuffer Instanzen zwischen - das ist momentan eher noch Experimentiell und sicherlich definitiv nicht optimal (u.a. weil die statische initialisierungs
  und deinitialisierungs Reihenfolge ja nicht festgelegt werden kann), lÃ¤uft aber bereits halbwechs ordentlich und reduziert das dynamische anlegen
  und freigeben von Speicher zur Laufzeit.
-> Uff, das waren nun fast 14 Stunden am StÃ¼ck mit Strings jonglieren, aber ich denke es ist schonmal besser als vorher, vorallem wurde die Implementation
   an einigen Stellen deutlich Ã¼berschauberer. Das mit Strings intern mehr Speicher geben + StringBufferManager wollte ich nun schon seit Jahren mal
   ausprobieren... und da mir wiedermal aufviel wie laaaam die String Klasse stellenweise ist/war, hatte ich mich nun endlich einfach mal drangesetzt und
   es durchgezogen. Ich merke hier bei mir nun eine allgemeine leichte Performance verbesserung... wie gehofft. :D
   Morgen mal noch etwas weitertesten, aber bisher siehts so aus als ob sich durch das interne String-Refactoring (das Interface nach AuÃen hin hat sich
   nicht verÃ¤ndert!) keine total Ã¼blen Bugs eingeschlichen hÃ¤tten die sofort alles zum Crashen bringen.



>> 14.11.2010
[SB]
- String::Format(): Hier gab es einen Bug, da nicht darauf geachtet wurde, dass laut Dokumentation die Funktion
  _vscprintf (und alle anderen Funktionen dieser Art) das Handle fÃ¼r die Argumentenliste "zerstÃ¶rt". Daher muss
  nach dem Aufruf von _vscprintf die Argumentenliste beendet und dann wieder neu geÃ¶ffnet werden. Unter 32 Bit Linux
  sowie unter Windows gab es hier niemals irgendwelche Probleme, aber unter 64 Bit Linux stÃ¼rzte das ganze hier auf
  mysteriÃ¶se Art und Weise ab. WÃ¤re schon nett, wenn solche Dinge dann vielleicht nicht nur irgendwo in der Doku versteckt
  wÃ¤ren, sondern auch verlÃ¤sslich abstÃ¼rzen wÃ¼rden, damit sowas nicht vÃ¶llig unentdeckt bleiben kann ;-)
  Zu diesem Fehler: http://bytes.com/topic/c/answers/572931-segmentation-fault-vsnprintf-lib64-tls-libc-so-6-a



>> 04.11.2010
[SB]
- XmlAttribute: Die Funktion sscanf_s ist eine Microsoft-Erweiterung und daher
  unter anderen Systemen nicht vorhanden. Habe das daher erstmal in sscanf()
  umgewandelt, vielleicht kÃ¶nnte man hier natÃ¼rlich auch eine von unseren
  bereits vorhandenen Varianten verwenden, um Strings in Zahlen zu konvertieren?
  Die String-Klasse hat soetwas ja schon, alleine schon daher wÃ¼rde ich daher
  empfehlen, in Zukunft mÃ¶glichst auf low-level String-Funktionen zu verzichten.



>> 30.10.2010
[CO]
- Wie mit Stefan besprochen: TinyXML AbhÃ¤ngigkeit entfernt. Das hatten wir nun bereits seit etlichen Jahren angedacht... TinyXML ist zwar
  wirklich super, aber unsere eigenen AnsprÃ¼che verÃ¤ndern sich Ã¼ber die Zeit so das immer mehr Ãnderungen in TinyXML nÃ¶tig wurden um es in
  PL noch richtig nutzen zu kÃ¶nnen. Die XML Wrapper Schicht an sich war auch noch nie sooo toll da diese Overhead hinzufÃ¼gte. Nachdem Stefan
  nun probleme beim Einladen groÃer XML Dateien hatte, entschlossen wir uns dazu, die TinyXML AbhÃ¤ngigkeit nun zu entfernen um mehr Kontrolle
  Ã¼ber die XML Implementation zu haben und z.B. einfacher Problemen nachgehen zu kÃ¶nnen. Der Kern des XML Parsers basiert auf TinyXML damit ich
  nicht ganz bei 0 anfangen musste und auf einen Ã¼ber viele Jahre hinweg ausgereiften XML Parser aufbauen kann, ich denke das die Implementation
  auf Dauer allerdings immer weiter von TinyXML abdriften wird.
  Das war nun zwar ca. 2 Tage Arbeiten an Grundlagen-Klassen, aber ich denke es hat sich gelohnt da unsere grundliegenste Komponente nun von
  einer externen lib weniger AbhÃ¤ngt was das Cross-Compiling etwas einfacher macht. Die erzeugte PLGeneral dll ist bei mir um 10 KB kleiner geworden
  da weniger Redundanter Code vorhanden ist (mehrere String Klassen etc. da jede lib das nochmal selbst implementiert).
  -> Weis noch nicht ob Unicode XML Dateien schon korrekt funktionieren, da mÃ¼sste man etwas testen und gegebenenfalls ausbessern
  -> Das XML Laden (XmlDocument::Load) ist im Augenblick etwas langsamer als vorher da unsere String Klasse bei z.B. "sMyString +=" immer einen internen
     neuen String erzeugt... hier sollte man wohl demnÃ¤chst kleinere Optimierungen machen so das der interne String immer etwas mehr Speicher belegt
     als eigentlich nÃ¶tig ist, was dann aber ein performanteres anhÃ¤ngen von weiteren Zeichen oder kurzen Strings ermÃ¶glicht.
  -> Am XML Interface hat sich zwar nicht wirklich was groÃartig verÃ¤ndert, unter der Haupe gabs allerdings einiges an Ãnderungen... darum wÃ¤re es gut
     wenn jemand das nochmal kritisch durchgeht (auch z.B. die Copy-Operatoren) und testet.



>> 24.10.2010
[SB]
- Time: Wenn man Zeiten als String abspeichert, mÃ¶chte man diese manchmal auch gerne wieder einlesen. Da das Format
  hier ja sehr strikt ist, dÃ¼rfte dies auch ohne weiteres mÃ¶glich sein, daher habe ich FromString() so implementiert,
  dass es die von ToString() ausgegebenen Time-Strings parsen kann und somit Zeiten auch als Strings Ã¼bergeben
  werden kÃ¶nnen.



>> 11.10.2010
[CO]
- String: < und > Operatoren fÃ¼r ASCII waren fehlerhaft Implementiert. StringBuffer::IsLessThan() und StringBuffer::IsGreaterThan()
  wurden, warum auch immer, mit einer String lÃ¤nge von 0 aufgerufen... interessant das dies bisher noch nicht aufgefallen war, und das
  obwohl die String-Tests die umfangreichsten aller Tests sind. :/ (ok, die ASCII, UTF8 und Unicode kombinationsmÃ¶glichkeiten machen
  es nicht einfacher das mÃ¶glichst Wasserdicht zu testen)



>> 20.09.2010
[SB]
- HttpServer: Methoden zum Senden von Daten nach HttpServerConnection verschoben, wo sie auch hingehÃ¶ren.
  Eine Server-Klasse sollten eigentlich nur Connections verwalten, die eigentliche Kommunikation
  zwischen zwei Hosts passiert aber immer in einer Connection, daher sollte die FunktionalitÃ¤t dieser
  Kommunikation auch dort definiert werden. Dies macht auch die Verwendung und den Zugriff auf eine Connection
  einfacher, ansonsten gibt es immer Probleme mit der Sichtbarkeit und der Vererbung von der Server-Klasse.



>> 16.09.2010
[CO]
- "PLGeneralWindows.h" um MinGW Support erweitert



>> 22.08.2010
[CO]
- Huch, die "FileWindows::CopyTo"-Implementation war fehlerhaft, die Windows Funktion "CopyFile" erwartet als zweiten Parameter,
  die Ziel URL inklusive Dateiname, Ã¼bergeben wurde allerdings URL ohne Dateiname...
- "FileLinux::CopyTo" war noch nicht implementiert... selbst nach lÃ¤ngeren Suchen konnte ich allerdings keine c-Funktion fÃ¼r Dateien
  kopieren finden, per Hand eine neue Datei erzeugen und dann die Daten selbst umkopieren war mir etwas zu doof...
  die jetztige Implementation Ã¼ber "system" ist allerdings genauso doof :/ (aber wenigstens lÃ¤ufts)



>> 16.08.2010
[SB]
PLCore:
- ConsoleApplication: Basispfad fÃ¼r Daten, die direkt im Runtime-Verzeichnis liegen, korrigiert.
  Das mit den Paketen ist ja schÃ¶n und gut, aber es ist super unpraktisch, damit zu arbeiten, wenn man z.B. gerade
  an den darin enthaltenen Daten selbst arbeiten will, da man dann stÃ¤ndig alles entpacken und wieder packen mÃ¼sste.
  Darum sollte es zumindest die MÃ¶glichkeit geben, die Daten aus einem Zip-File einfach an Ort und Stelle zu entpacken,
  und danach sollte noch alles so laufen wie mit dem Zip-File. Da aber die Zip-Files selber im Unterverzeichnis "Data"
  liegen, musste dieses natÃ¼rlich noch dem Runtime-Pfad hinzugefÃ¼gt werden, damit das klappt.



>> 15.08.2010
[SB]
PLCore:
- Core: Unter Linux wird nun die Umgebungsvariable PL_RUNTIME ausgelesen.
  Wenn diese gesetzt ist, wird das darin enthaltene Verzeichnis als
  PixelLight-Runtime verwendet, ansonsten wird in /usr/ und /usr/local gesucht.
  Um dies mÃ¶glichst einfach zu machen, gibt es ausserdem das Script profile,
  welches dieses Verzeichnis ausgehend vom aktuellen Verzeichnis setzt.
  NatÃ¼rlich kann man auch in seiner .profile oder .bashrc-Datei im
  Homeverzeichnis diese Variable automatisch beim Systemstart setzen lassen,
  damit man dies nicht immer wieder per Hand ausfÃ¼hren muss.
  Somit ist es nun wieder mÃ¶glich, einfach so aus den Sourcen heraus zu
  arbeiten, ohne immer mittels "make install" das SDK im System installieren
  zu mÃ¼ssen.



>> 12.08.2010
[SB]
PLCore:
- Core: Unter Linux wird nun erst geschaut, ob "/usr/local/share/pixellight/Runtime" existiert, wenn ja, wird dieses
  als Runtime-Directory verwendet, ansonsten wird angenommen, dass ein global installiertes Runtime im Pfad
  "/usr/share/pixellight/Runtime" zu finden ist. Bei mir hat das damit schonmal geklappt, dass die Plugins aus
  diesem lokalen Runtime verwendet wurden, die konnten dann aber nicht geladen werden, weil wohl die automatisch
  geladenen dynamischen Bibliotheken, welche sich entsprechend in /usr/local/lib/ befinden, nicht automatisch
  geladen werden konnten. Dies lÃ¤sst sich aber durch ausfÃ¼hren des Befehls "ldconfig /usr/local/lib" beheben.
  Momentan besteht dann noch das Problem, dass jetzt die dynamischen AbhÃ¤ngigkeiten wie Cg, Newton oder OpenAL
  natÃ¼rlich nicht gefunden werden kÃ¶nnen.



>> 07.08.2010
[SB]
PLCore:
- ConsoleApplication: OnDeInit() wird wie OnInit() nun auÃerhalb aufgerufen, damit es sicher als letztes aufgerufen wird.



>> 09.08.2010
[CO]
- "UTF8Tools::GetNumOfStringBytes" um "nCount" erweitert
- "StringBufferUTF8::LastIndexOf(const char szString[]..." war fehlerhaft implementiert, daher erstmal eine funktionierende
  LÃ¶sung eingebaut, die allerdings sicherlich nicht die Effizienteste ist
- "StringBufferUTF8::GetSubstring" implementiert
-> Nun geht "Url(sFilename).GetExtension()" wenn "sFilename" ein UTF8-String ist
- "String::Compare" & "String::CompareNoCase" & "String::Insert" um UTF8 Support erweitert
- "FileWindows::Open(" um Unicode-Support erweitert
- UTF8Tools Warnungen beseitigt wo ich halbwechs sicher bin das die Beseitigung keine Seiteneffekte hat



>> 06.08.2010
[SB]
PLCore:
- ConsoleApplication: OnInit(), also die fÃ¼r die eigentliche Applikation bestimmte lokale Init-Methode, wird nun
  nicht mehr im Rahmen von Init() aufgerufen, sondern ist fest in der Run-Methode verdrahtet. Hintergrund ist,
  dass diese Methode als aller letztes aufgerufen werden muss, damit sie einen Sinn ergibt, alle Basisklassen
  mÃ¼ssen also die Chance haben, sich vorher komplett inizialisiert zu haben. Das wÃ¼rde aber heiÃen, dass niemand
  einfach Init() von der Basisklasse aufrufen kann, sondern immer alles neu implementieren mÃ¼sste, damit die
  Reihenfolge stimmt. Darum musste OnInit() verschoben werden, damit dies nicht mehr nÃ¶tig ist.



>> 05.08.2010
[CO]
PLCore:
- LoadableManager ist kein Loadable mehr, Kopie der alten Version liegt im Archive (Removed_LoadableFromLoadablaManager_05082010)



>> 05.08.2010
[SB]
PLCore:
- ConsoleApplication: LastCrashed und Speichern/Laden von LoadableManager-Pfaden entfernt.



>> 04.08.2010
[SB]
- System: GetDataDirName() hinzugefÃ¼gt. Diese Methode wandelt den Ã¼bergebenen Namen fÃ¼r das Unterverzeichnis im
  User-Data-Dir in ein fÃ¼r das OS typisches Format um. Aus "PixelLight" wird dann unter Linux ".pixellight", unter
  Windows wird der Name nicht verÃ¤ndert und bleibt bei "PixelLight".
PLCore:
- ConsoleApplication: Behandlung von Log- und Config-Dateien implementiert. Die Schwierigkeit hierbei ist es,
  gleichzeitig ein vernÃ¼nftiges Standardverhalten zu implementieren, und es trotzdem dem Applikationsprogrammierer
  mÃ¶glichst einfach zu machen, spÃ¤ter alles abzuÃ¤ndern oder ganz auszuschalten, ohne dass er dafÃ¼r groÃe Teile
  komplett neu schreiben muss. Es gibt daher fÃ¼r das meiste jetzt Optionen in ConsoleApplication, die verwendet
  werden kÃ¶nnen, um Standardeinstellungen abzuÃ¤ndern:
  - MultiUser: Gibt an, ob Config und Log im User-Verzeichnis gespeichert werden sollen
  - AppDataSubdir: Gibt das Unterverzeichnis im DataDir an (wenn leergelassen, wird es in Run() auf der Applikationsnamen gesetzt)
  - LogName: Dateiname fÃ¼r Log (wenn leergelassen, wird Applikationsname mit '.log' verwendet)
  - ConfigName: Dateiname fÃ¼r Config (wenn leergelassen, wird Applikationsname mit '.cfg' verwendet)
  HierÃ¼ber kann man also ziemlich einfach z.B. den Dateinamen von Log oder Config abÃ¤ndern, ohne gleich die
  gesamte Main-Methode neuschreiben zu mÃ¼ssen. Wenn z.B. LogName oder ConfigName auf "" gesetzt werden, heiÃt das,
  dass diese Datei Ã¼berhaupt nicht verwendet werden soll. ZusÃ¤tzlich gibt es auch noch die Kommandozeilen-Optionen,
  die in jedem Fall vorrang haben (will jemand auch das nicht, sollte er die Option im Konstruktor entfernen).
- ConsoleApplication: Es wird nun alles bereits im Konstruktor gesetzt, damit es mÃ¶glichst einfach wird, das Verhalten
  zu verÃ¤ndern, indem man einfach im Konstruktor alles so setzt, wie man das haben will. Der einzige dadurch notwendig
  gewordene Hack besteht darin, dass beim SpÃ¤teren Aufruf von SetName() auch noch automatisch die Dateinamen fÃ¼r Log
  und Config angepasst werden, falls diese so aussehen, als wÃ¤ren sie noch auf ihren Default-Wert gesetzt.
- ConsoleApplication: Wenn die Konfigurationsdatei nicht geladen werden konnte, wird jetzt in einem zweiten Schritt
  dennoch der Dateiname gesetzt, damit eine neu erzeugte Config spÃ¤ter gespeichert werden kann. Hierbei wird es wieder
  erst mit dem User-Data-Dir versucht, dann mit dem Applikationsverzeichnis. Wenn der ConfigName auf "" steht, wird
  gar keine Config verwendet. Ein auf der Kommandzeile Ã¼bergebener Pfad hat immer Vorrang, und wenn er nicht
  existiert oder fehlerhaft ist, so werden trotzdem keine Standardpfade mehr versucht. Analog zur Config auch die
  Log-Methode angepasst, nur dass hier kein Dateiname gesetzt wird, wenn das Log nicht zu Ã¶ffnen ging (ergibt hier
  keinen Sinn).
- ConsoleApplication: Option 'UseRuntime' hinzugefÃ¼gt, die bestimmt, ob automatisch nach einer installierten
  PixelLight-Runtime gesucht werden soll, von der dann die Plugins und Datenpakete verwendet werden. Wie bisher
  kann das auch Ã¼ber die Config-Option eingestellt werden, wenn diese gefunden wird, wird diese Flag entsprechend
  gesetzt.
- ConsoleApplication: Weitere virtuelle Methoden eingebaut, um dem Programmierer mÃ¶glichst viele MÃ¶glichkeiten zu
  geben, das Standardverhalten der Applikation abzuÃ¤ndern:
  - OnInitCmdLine() wird nach dem Parsen der Kommandozeile aufgerufen und ist dafÃ¼r da, die gesetzen Optionen abzufragen
  - OnInitPlugins() wird nach dem Laden der Config aufgerufen und ist zum Laden der Plugins da
  - OnInitData() wird nach OnInitPlugins() aufgerufen und ist zum Setzen der Datenpfade da
- Methode ScanPackages() aus GuiApplication direkt nach LoadableManager verschoben. Da diese Funktion recht universell
  ist und sicherlich auch ausserhalb des Application-Frameworks verwendet werden kann, sollte sie auch gleich im
  LoadableManager vorliegen, auf dem sie ja auch operiert. Name und Kommentar analog zu ClassManager::ScanPlugins()
  angepasst.
- Core: Der Runtime-Pfad unter Linux ist nun erstmal festgelegt auf "/usr/share/pixellight/Runtime". SpÃ¤ter kÃ¶nnte
  man hier vielleicht noch anhand der aktuell verwendeten Bibliothek oder deren Version unterscheiden... (kÃ¶nnten
  ja theoretisch mal mehrere Runtimes gleichzeitig installiert sein)
- Folgende Config-Items von EngineGeneralConfig nach CoreConfigGroup verschoben, da sie universell fÃ¼r alle
  Applikationen wichtig sind: UsePixelLightRuntime, FirstRun, LastCrashedMessage, LastCrashed, Language.
  Dabei LoadLibsFromRuntime in UsePixelLightRuntime umbenannt, da es hier nicht nur um die Libs geht (wobei man hier
  genauer von Plugins sprechen sollte), sondern gleichzeitig auch um die Daten im Runtime-Verzeichnis.
- Alles wichtige von GuiApplication nach ConsoleApplication verschoben.



>> 03.08.2010
[SB]
- System: GetCurrentDir() gibt das aktuelle Verzeichnis nun im Native-Format zurÃ¼ck statt wie bisher im URL-Format.
- System: ZusÃ¤tzlich zu GetUserHomeDir() gibt es nun auch noch GetUserDataDir(). Hier wird das Verzeichnis zurÃ¼ckgegeben,
  in das die Konfiguration der Applikation geschrieben werden soll. Unter Linux sind Home- und Data-Dir identisch,
  unter Windows wird hier der Ordner "Anwendungsdaten" im Home-Verzeichnis zurÃ¼ckgegeben.
PLCore:
- Application Ã¼berarbeitet. Statt "About" gibt es nun "Version", welches man bei den meisten Applikationen als
  Kommandozeilenoption finden kann (-a fÃ¼r about eher nicht). Die eigentliche FunktionalitÃ¤t wurde von Run()
  in die virtuellen Methoden Init(), Main() und DeInit() verschoben, da es ansonsten fÃ¼r abgeleitete Klassen
  nicht mÃ¶glich ist, das Verhalten der Applikation zu modifizieren (z.B. wenn Ã¼berhaupt kein Log geÃ¶ffnet oder
  die Kommandozeile nicht geparsed werden soll - das ist in der bisherigen LÃ¶sung nicht zu verhindern).
  Die Idee dabei ist, dass in den drei Methoden Init(), Main() und DeInit() das eigentliche GerÃ¼st fÃ¼r die
  AusfÃ¼hrung der Applikation implementiert wird, dies wird also von der jeweilige Basisklasse (z.B. Application,
  GuiApplication oder SceneApplication) entsprechend modifiziert. Konkrete Programm-Applikationen dagegen sollten
  diese Methoden dagegen mÃ¶glichst nicht mehr verÃ¤ndern mÃ¼ssen, sondern statt dessen nur einzelne Schritte verÃ¤ndern,
  welche in zusÃ¤tzlichen virtuellen Methoden bereitgestellt werden (z.B. OnRun(), OnInitLog() etc.). Diese
  Methoden werden von den Basisapplikationen aus aufgerufen. Nur wenn man wirklich grundlegend die Arbeitsweise
  der Applikation Ã¤ndern will, muss man dann Main() etc. anpassen.
- Neue Application-Klasse in ConsoleApplication umbenannt. Diese Ãnderung wollte ich sowieso machen, damit man nicht
  mehr stÃ¤ndig das Problem mit gleichen Namen hat, da wir die Klassen in konkreten Programm ja auch immer "Application"
  nennen, und das daher immer in Konflikt gerÃ¤t. Ausserdem wird es so leichter, die Klassen nach und nach umzustellen,
  da erstmal beides nebeneinander existieren kann.
- ConsoleApplication: Option m_bMultiUser hinzugefÃ¼gt, mit der bestimmt wird, ob das Multi-User-Environment des Systems
  verwendet werden soll, oder nicht. In dem Falle wird immer zuerst versucht, z.B. Config oder Log-Dateien im
  entsprechenden User-Verzeichnis abzulegen, erst dann wird als Fallback z.B. das Application- oder das aktuelle
  Verzeichnis verwendet. Diese Option ist standardmÃ¤Ãig eingeschaltet und sollte wohl nur noch in SonderfÃ¤llen
  ausgeschaltet werden, da alle aktuellen Systeme mittlerweile darauf ausgelegt sind.



>> 02.08.2010
[SB]
- SystemLinux: GetProgramName() implementiert, so dass nun genauso wie unter Windows der absolute Pfad zur Bin-Datei
  zurÃ¼ckgegeben wird, gleichgÃ¼ltig von wo das Programm aufgerufen wurde. Der in args[0] Ã¼bergebene Pfad ist leider
  relativ zur aktuellen Position und hilft daher nicht wirklich weiter, wenn es darum geht, den Pfad zu extrahieren
  um dann z.B. relativ dazu Datenpfade herausfinden zu kÃ¶nnen. Mittels der PID kann aber der absolute Pfad einer
  Applikation relativ leicht abgefragt werden. DafÃ¼r wurde nun SetProgramName() entfernt, da dies nur eine NotlÃ¶sung
  war, damit den Wert aus arg[0] Ã¼bergeben zu kÃ¶nnen.
- SystemLinux: GetUserHomeDir() scheint richtig zu funktionieren, daher eingebaut und TODO entfernt.
- System: GetProgramName() in GetExecutableFilename() umbenannt, da dies wesentlich eindeutiger ist.
- Log: ConsoleOutputActive in Verbose umbenannt. "Keep it simple" darf ruhig auch mal auf Namen angewendet werden :-)
- Log: Kommentare etwas Ã¼berarbeitet.
PLCore:
- ApplicationContext hinzugefÃ¼gt. Damit die Application-Klasse mÃ¶glichst Ã¼bersichtlich bleibt, sollten hier nicht
  so viele Daten und Methoden auf einem Haufen sein, denn das macht es immer gleich um einiges schwerer, den
  Aufbau einer Klasse zu verstehen. Die Laufzeit-Informationen der Klasse, also z.B. die wichtigen Verzeichnisse
  sowie die Ã¼bergebenen Parameter, wurden daher in die neue Context-Klasse verschoben. Die Daten, die dagegen die
  Applikation selber bestimmen (wie z.B. Name und Titel) bleiben aber in der Klasse selbst.
- Application: Name hinzugefÃ¼gt. Bisher gab es nur den Titel, der Name einer Applikation sollte aber auch noch
  gesetzt werden, da dieser meist kÃ¼rzer ist als der ausgeschriebene Titel. Wenn kein Name angegeben wird, so wird
  der Name aus dem Dateinamen der Applikation extrahiert (z.B. "TestApp.exe" -> "TestApp").



>> 01.08.2010
[SB]
- Eigene Versionsnummer von PLGeneral entfernt.
[SB]
PLCore:
- Config-Klassen in eigenes Verzeichnis "Config" verschoben. Bitte die Application-Verzeichnisse nicht immer mit
  zusÃ¤tzlichen Klassen belasten, insbesondere, wenn diese ganz locker auch fÃ¼r sich selber stehen kÃ¶nnen.
- Timer-Klassen entfernt, da veraltet und zur Zeit sowieso nicht mehr verwendet. In PLGui liegen ja schon Timer-Klassen
  bereit, wenn man das also mal braucht, mÃ¼sste man sich nur noch einmal vernÃ¼nftig Ã¼berlegen, wie man darauf ausserhalb
  von PLGui am besten zugreifen kÃ¶nnte.



>> 24.07.2010
[SB]
- ConsoleLinux: Wenn Dateibefehle verwendet werden, um auf die Konsole zu schreiben, sollte der Dateipuffer immer geleert werden, damit die
  Ausgabe sofort erfolgt. Habe daher hier fflush(stdout) hinzugefÃ¼gt.



>> 17.07.2010
[CO]
- "XmlNode::GetNextSiblingElement" & "XmlNode::GetFirstChildElement": RÃ¼ckgabetyp sollte XmlElement und nicht XmlNode sein
PLCore:
- XML basierendes Chunk PixelLight Dateiformat hinzugefÃ¼gt, Dateiendung ist "xchunk" statt "chunk" fÃ¼r BinÃ¤re Dateien



>> 15.07.2010
[CO]
- Bugfix in verschiedenen Projekten: Verwendung von XmlNode GetFirstChild/IterateChildren war Fehlerhaft da oft auf XmlElement
  gecasted wurde ohne vorher zu prÃ¼fen ob es Ã¼berhaupt XmlElement ist, im Falle von XmlComment bekam man so dann einen Crash
PLCore:
- Nachdem ich die letzten Stunden damit verbrachte die Projekte und Daten entsprechend anzupassen... Suchpfade wie besprochen
  aus dem Loadable Manager entfernt. ZukÃ¼nftig muss man also z.B. "Data/Textures/MyTexture.dds" statt "MyTexture.dds" schreiben.



>> 07.07.2010
[CO]
- "String::GetUInt32()": Statt "atol" wird nun "strtoul" verwendet da sich scheinbar das Verhalten von "atol"
  unter Linux/Windows unterscheidet und z.B. unter Linux das umwandeln in uint32 nicht klappte wenn die Zahlen
  zu groÃ waren



>> 06.07.2010
[SB]
- Bug in FileLinux::IsFile() behoben.



>> 08.06.2010
[CO]
PLCore:
- LoadableManager::OnClassLoaded: Hier darf die Klasse wirklich nur in eine Liste eingetragen werden, da man noch nichtmal
  davon ausgehen kann das "IsDerivedFrom" immer funktioniert da z.B. eine benÃ¶tigte Basisklasse erst etwas spÃ¤ter registriert
  werden kÃ¶nnte... das war bei mir unter Linux natÃ¼rlich gerade der Fall, und dann war einfach der Loadable Type "Scene"
  unbekannt und es konnten keine Szenen eingeladen werden.



>> 02.06.2010
[SB]
PLCore:
- Bei der Verwendung von Enums im RTTI wird nun nicht mehr stur der Basistypus verwendet, da dies dazu fÃ¼hren wÃ¼rde,
  dass z.B. bei Methoden auch die Signatur so verÃ¤ndert wird, dass Ã¼berall der Basistypus erwartet wird (Bsp.: Wird eine
  Methode, oder ein Event z.B. mit der Signatur(void, EnumType<EEnum>) angemeldet, so wÃ¼rde fÃ¼r die tatsÃ¤chliche Methode
  die Signatur (void, int) erwartet). Das ist verwirrend, daher wurde die Behandlung von Enums nun so verÃ¤ndert, dass
  jetzt Ã¼berall der tatsÃ¤chliche Enum-Typus verwendet wird.
- Neuer Typ-Wrapper EnumTypePlain<> eingebaut, der fÃ¼r direkte Enum-Typen verwendet wird, also solche, die nicht am
  RTTI angemeldet wurden. Wenn man nun bspw. Type<EEnum> schreibt, wird intern Type< EnumTypePlain<EEnum> > verwendet,
  welches es ermÃ¶glicht, dieses als Typus im RTTI zu verwenden (dann hat man natÃ¼rlich z.B. keine Umwandlung in Strings
  unter Verwendung der Enum-Namen, kann aber ansonsten diesen Typus wie gewohnt verwenden).
- RTTI-Makros fÃ¼r Enums angepasst: Normale enums werden nun ohne den Basistypus deklariert, also z.B. pl_enum(EEnum)
  statt pl_enum(EEnum, int). Nur in dem speziellen Fall, dass "unechte" Enums z.B. mit floats erzeugt werden sollen,
  muss auch der Basistyp mit angegeben werden, hierfÃ¼r kann nun das Makro pl_enum_direct() verwendet werden.
  Es ist zu beachten, dass der Name in enums nun nicht mehr vÃ¶llig frei gewÃ¤hlt werden kann, sondern immer der angegebene
  Typus unter dem exakten Namen auch existieren muss (also entweder ein echtes enum oder z.B. eine leere Klasse). Damit
  sind einige beabsichtigte oder unbeabsichtige Unstimmigkeiten, die es bisher gab (z.B. Enum hieÃ EFlag wurde aber
  als EStyle angemeldet) nicht mehr mÃ¶glich.



>> 01.06.2010
[SB]
PLCore:
- RTTI: Bei der Verwendung von Enums z.B. in Events kam es bislang noch zu Fehlermeldungen durch den Compiler.
  Der Grund dafÃ¼r war, dass noch nicht Ã¼berall konsequent die tatsÃ¤chlichen Typen verwendet wurden, welche von
  Type::_Type ermittelt werden (bei Var<T> war dies schon der Fall, aber bei allen Functoid- und Event-Typen noch nicht).
  Wenn bspw. ein Enum verwendet wird, ist der Typus ja EnumType<T> - dies ist aber nur ein Pseudo-Typus, der nicht wirklich
  verwendet werden darf (EnumType<T> als Parameter in einer Funktion ergibt keinen Sinn). Daher wird in Type::_Type der
  Typus auf den jeweiligen tatsÃ¤chlichen Typus gemappt, dieser Typus muss dann verwendet werden.
  Als Faustregel kann festgehalten werden: In Template-Parametern sollte immer der Eingabetyp unverÃ¤ndert weitergereicht
  werden, erst wenn es zur Verwendung kommt (z.B. als Variable oder als Funktionsparameter), muss dann der jeweilige
  korrekte Typ verwendet werden.



>> 30.05.2010
[SB]
PLCore:
- RTTI: Beim Einbinden von RTTI-Klassen in andere Projekte, kam es zu dem Problem, dass diese Klassen dann mehrfach
  am System angemeldet wurden, weil die entsprechenden Template-Klassen vom Compiler dann mehrfach instanziiert werden
  (in jedem Projekt, in dem die Klassen eingebunden werden, also nicht nur in dem Projekt, das sie exportiert).
  Aufgrund der RTTI-Makros ist es leider nicht einfach mÃ¶glich, diese Templates dann zu exportieren, darum wurden die
  RTTI-Makros nun so erweitert, dass man wie bei DLL-Exports eine Definition dafÃ¼r verwendet, um festzustellen, ob die
  jeweilige Klasse gerade importiert oder exportiert wird. FÃ¼r solche Projekte, die niemals in andere Projekte eingebunden
  werden (z.B. reine Plugins, die nur dynamisch Ã¼ber das Plugin-System eingeladen werden, oder Applikation, die gar nicht
  in andere Projekte eingeladen werden), kann das Makro pl_rtti_export verwendet werden. Alle anderen Bibliotheken sollten
  im Header-Datei Ã¤hnlich zu PLXXX_API ein Makro definieren, das jeweils auf 1 oder 0 gesetzt wird fÃ¼r Import oder Export.
  Die Projekte wurden entsprechend umgestellt.



>> 27.05.2010
[SB]
PLCore:
- Workaround fÃ¼r Linux bzw. GCC eingebaut, da es leider sonst folgenden, ziemlich dubiosen Linker-Fehler gibt:
    ../../../PLBase/PLCore/libPLCoreStat.a(ClassManager.cpp.o):
    In function `PLCore::Event<PLCore::Module const*, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType>::Emit(PLCore::Module const*) const':
    ClassManager.cpp:(.text._ZNK6PLCore5EventIPKNS_6ModuleENS_8NullTypeES4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_E4EmitES3_[PLCore::Event<PLCore::Module const*, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType>::Emit(PLCore::Module const*) const]+0x1a):
    undefined reference to `vtable for PLCore::Functor<void, PLCore::Module const*, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType>'
  Dieser Fehler ist wirklich sehr eigenartig, weshalb ich annehme, dass es sich um einen Fehler im Compiler handeln kÃ¶nnte:
    - Der Fehler tritt z.B. mit Event<Module*>, Event<int> und allen anderen Typen auf
    - Der Fehler tritt *nicht* mit Event<Class*> auf, den Grund hierfÃ¼r konnte ich aber nicht finden
    - Der Fehler tritt auf, sobald der Operator () vom Functor aufgerufen werden soll
    - Sobald der entsprechende Functor<T> in der Klasse Event oder in einer Methode instanziiert wird, verschwindet der
      Fehler. Es muss aber eine richtige Instanz sein, eine Typendeklaration, ein Zeiger oder eine Referenz reichen hier
      nicht aus, was wirklich eigenartig ist
    - Wenn statt des Functor()-Aufrufes eine neue Methode im EventHandler eingebaut wird, die wiederum Functor()
      aufruft, tritt der Fehler ebenso auf und kann ebenso behoben werden, indem dann in der neuen Methode innerhalb von
      EventHandler der Functor instanziiert wird. Komischer Weise reicht hier aber eine Instanziierung innerhalb der Klasse
      dann nicht mehr aus (zumal hier ja der Functor auch bereits instanziiert wird!).
  Es scheint also so, als ob unter bestimmten Voraussetzungen die Template-Klasse vom Compiler nicht richtig instanziiert
  wird, weshalb es dann zu dieser wenig hilfreichen Fehlermeldung kommt (diese Fehlermeldung wird normaler Weise darauf
  zurÃ¼ckgefÃ¼hrt, wenn z.B. eine virtuelle Methode, meist z.B. ein virtueller Destruktor, nicht implementiert wurde. Dies
  scheint mir hier aber nicht der Grund zu sein, zumal hier der Zusammenhang mit Templates besteht. Darum und aufgrund
  der unlogisch wirkenden Verhaltensweisen des Fehlers, halte ich einen Compiler-Bug fÃ¼r mÃ¶glich).
  -> Als Workaround wird nun der Functor in der Emit-Methode einmal statisch instanziiert. Habe dafÃ¼r im CMake-Projekt
  auch gleiche eine neue PrÃ¤prozessor-Definition eingefÃ¼gt, die mitteilt, wenn der GCC zum Compilieren verwendet wird
  (ifdef LINUX wÃ¤re hier eigentlich falsch, darum lieber ifdef GCC, zumal man theoretisch auch den GCC fÃ¼r Windows
  verwenden kann).
- CMake-Projekt so angepasst, dass PLCoreStat nur noch von PLGeneralStat abhÃ¤ngig ist, und nicht mehr wie bisher von
  PLGeneral.
- ClassManager::GetClasses() gibt nun keine Liste mehr zurÃ¼ck, sondern fÃ¼llt eine Ã¼bergeben Liste, um unnÃ¶tige Kopier-
  operationen zu vermeiden.



>> 27.05.2010
[CO]
- Log liegt wieder in PLGeneral. Diesmal allerdings in einem eigenen "Log" Verzeichnis und nicht ans RTTI angeschlossen.
  "LogFormaterConsole" entfernt, das Log kann auf Wunsch nun direkt in die Standard OS Konsole schreiben.
PLCore:
- Log liegt wieder in PLGeneral
- "Application::Run": Hier wird nun das Log anhand von Kommandozeilen Parametern initialisiert, ich denke es ist das beste das
  direkt hier zu machen statt z.B. erst in "PLGui::GuiApplication"
- "Application::OnPrintVersion()" in "Application::OnPrintAbout()" umbenannt damit es keine Konflikte mit "v" als Kommendozeilen
  Parameter fÃ¼r "Verbose" gibt (uh, "v" scheint nen Standard-Parameter zu sein http://de.wikipedia.org/wiki/Verbose :)



>> 25.05.2010
[SB]
- String::GetUInt64(): _wtoi64 gibt es leider unter Linux nicht. Habe da nun statt dessen wcstoumax() verwendet,
  welches hoffentlich die richtige Funktion dafÃ¼r ist. Leider gibt es die wiederum unter Windows nicht, jedenfalls
  konnte ich das nicht finden, obwohl es eigentlich zum ISO-Standard gehÃ¶ren sollte, und musste darum hier leider
  eine Fallunterscheidung einbauen.



>> 24.05.2010
[CO]
- Bugfix: "ElementManager<AType>::SetElementName": Umbenannte Elemente sollten nur in m_mapElements eingefÃ¼gt werden, wenn
  diese kurz zurvor ausgetragen wurden
PLCore:
- Bugfix: "ResourceManager<AType>::SetResourceName": Umbenannte Elemente sollten nur in m_mapResources eingefÃ¼gt werden, wenn
  diese kurz zurvor ausgetragen wurden



>> 23.05.2010
[CO]
- Da der Typ "handle" als "unsigned int" definiert ist, ist es unter 64 Bit Ã¼bersetzt, 64 Bit statt 32 Bit groÃ.
  "INVALID_HANDLE" wird daher nun 32/64 Bit abhÃ¤ngig definiert. (scheinbar nur fÃ¼r Windows nÃ¶tig)



>> 22.05.2010
[CO]
- String Klasse um Operatoren fÃ¼r uint32 und uint64 erweitert. Unter Windows nutzte ich dafÃ¼r die Erweiterungen "I32"
  und "I64", unter Linux einfach nur "u" und "llu" - habe im Code fÃ¼r Linux als Kommentar alternativen eingefÃ¼gt die
  man eventuell noch testen kÃ¶nnte.
PLCore:
- "Type<T*>", "Type<T&>" und "Type<Object*>": ConvertToString/ConvertFromString arbeitet nun mit uint32/uint64.
  Ãber die Definition "X64_ARCHITECTURE" wird bei uns festgelegt das es 64 Bit ist, "X64" war mir dann Namenskonflikt
  mÃ¤Ãig doch etwas zu Riskant. :D



>> 21.05.2010
[SB]
PLCore:
- TypeInfo: Neben IsEnumType() gibt es nun ebenfalls IsFlagType(), um Flags von Enums unterscheiden zu kÃ¶nnen.
  Im Falle von Flags gibt IsEnumType() nun dort auch 'false' zurÃ¼ck - das scheint mir ein wenig logischer, natÃ¼rlich
  muss man hier aber wissen, dass auch bei IsFlagType() == 'true' die Methoden zum Auslesen der Enums natÃ¼rlich
  funktionieren. Mann kÃ¶nnte das auch anders herum machen, so dass IsEnumType() in beiden FÃ¤llen 'true' zurÃ¼ckgibt, dann
  wÃ¼rde man "Flag" sozusagen als Sonderfall von "Enum" ansehen. Momentan habe ich es aber wie oben beschrieben gelÃ¶st.
- Class: ClassName (Name mit Namespace) wird nun noch gesondert als String gespeichert, damit beim Zugriff darauf nicht
  immer dynamisch neue Strings zusammengestellt werden mÃ¼ssen.
- Log, LoadableManager und Localization: Template-Instanz so verÃ¤ndert, dass es sich auch mit gcc compilieren lÃ¤sst.
  Bei so einer expliziten Instanziierung von Templates ist zu beachten, dass es nicht erlaubt ist, diese innerhalb
  eines fremden Namespaces vorzunehmen. Da Singleton zum namespace PLGeneral gehÃ¶rt, muss also eine Spezialisierung
  innerhalb von PLGeneral oder ausserhalb aller Namespaces vorgenommen werden, aber *nicht* z.B. innerhalb von PLCore.
  Wie so oft geht dies zwar unter VC, unter z.B. dem gcc aber nicht, daher sollte hier in Zukunft darauf geachtet werden,
  Template-Instanziierungen immer ausserhalb fremder Namespaces vorzunehmen.



>> 20.05.2010
[CO]
- Das alte RTTI aus PLGeneral entfernt... manohman, das waren 2 verdammt heftige Wochen. Im groÃen und ganzen lÃ¤uft nun alles
  wieder, natÃ¼rlich steht nun noch weiteres Bugfixing an bis alles wieder so rund lÃ¤uft wie vor der groÃen Umstellung. Interessant
  ist, dass es am Ende nun wirklich 2 Wochen Arbeit waren, so wie am Anfang pi*daumen geschÃ¤tzt. *g*
PLCore:
- LoadableManager: Neue Klassen werden erst dann, wenn diese benÃ¶tigt werden korrekt Eingetragen. TrÃ¤gt man sofort bei
  erhalten des ClassManager::EventClassLoaded Ereignisses ein, so kann es sein das eine Klasse noch nicht vollstÃ¤ndig
  initialisiert ist und dann die Loader Registierung nicht klappt.
- LoadableType speichert nun ebenfalls die RTTI Klasse von der alle Loader Implementationen dieses Types abgeleitet sein
  mÃ¼ssen. Diese Klasse wird z.B. in Loadable verwendet um zu sehen ob der Loader Typ, der Ã¼ber eine Dateiendung ermittelt
  wurde, wirklich zum Loadable Typ passt der gerade eingeladen werden soll... sonst kÃ¶nnte man einem Mesh sagen es solle
  sich doch bitte aus diesem Bild hier laden - klar, probieren kann ich es als Benutzer immer noch, das System grinst mich
  in dem Fall aber nur dÃ¤mlich an. *g*



>> 19.05.2010
[CO]
PLCore:
- Loadable System von "PLGeneral::Parameters" befreit. Gestern Abend schwierte mir im Kopf eine Loader-LÃ¶sung herum die mit
  RTTI Methoden arbeitet, heute in aller frÃ¼h setzte ich das mal um und passte entsprechend alle Loader an. Das Ergebnis
  gefÃ¤llt mir sogar... Die einzelnen Loader-Basis Klassen wie z.B. "ConfigLoader" sind nun superschlank, ja praktisch leer.
  Die konkreten Loader-Implementationen wie z.B. "ConfigLoaderPL" sind nun ebenfalls etwas schlanker da dort keine Dynamischen
  Parameter mehr geparst werden. Es gibt nun einfach Ã¶ffentliche Load/Save Methoden, die man also auch ganz ohne RTTI nutzen kann.
  Ebenfalls kann es LoadParams/SaveParams Methoden geben - wenn ein Format noch besondere Optionen anbietet, wie z.B. welche
  Kompression beim Speichern verwendet werden soll. Wenn man es ganz wild treiben will, kann man die Methoden Namen auch frei
  wÃ¤hlen, beim Resourcen-Laden muss man dann allerdings die Methoden Namen angeben. Es stehen nun also deutlich mehr NutzungsmÃ¶glichkeiten
  zur VerfÃ¼gung und die Implementationen sind schlanker geworden + man kann in den RTTI Methoden Kommentaren nachlesen was es
  fÃ¼r weitere besondere Format abhÃ¤ngige Parameter gibt und was die machen.



>> 17.05.2010
[CO]
- PixelLight ist nun soweit auf das neue RTTI umgestellt, nun folgen nur noch AufrÃ¤umarbeiten & Bugfixing
- "Log" von PLGeneral nach PLCore verschoben
PLCore:
- "Log" von PLGeneral nach PLCore verschoben



>> 16.05.2010
[SB]
PLCore:
- ClassManager: GetClasses() kann nun auch nur Klassen aus einem bestimmten Modul zurÃ¼ckgeben. Damit ist diese Methode
  nun immer mehr zur zentralen Such-Funktion fÃ¼r Klassen geworden, was ich auch ganz sinnvoll finde. Kommentare an
  anderen Stellen eingefÃ¼gt, um auf diese zentrale Suchfunktion hinzuweisen.



>> 16.05.2010
[CO]
PLCore:
- PLCore::Object::IsInstanceOf in der Art erweitert das ebenfalls "true" zurÃ¼ckgegeben wird wenn die beiden zu testenden
  Klassen identisch sind



>> 15.05.2010
[SB]
PLCore:
- RTTI: Ein mit ModifyAttr Ã¼berschriebenes Attribut setzt nun den Default-Value in AbhÃ¤ngigkeit vom Storage-Type
  des Basis-Attributes. Wenn das Basis-Attribut also den GetSet-Storage gesetzt hat, wird auch im Ã¼berschriebenen
  Attribut der Default-Wert *nicht* mehr gesetzt, so dass es nicht mehr zu Problemen im Konstruktor kommen sollte.
  Ist dagegen DirectValue als Basis-Storage gesetzt, so wird der Default-Wert gesetzt, da es hier keine Probleme gibt.
  Ich habe es zwar noch nicht ausprobiert, aber das ganze sollte auch Ã¼ber beliebig viele Ebenen funktionieren,
  da der StorageType der Basisklasse hier jeweils durchgereicht wird :-)
- Constructor: IsDefaultConstructor() eingebaut
- Class: HasConstructor() und HasDefaultConstructor() eingebaut
- Class: IsDerivedFrom() gibt nun bei der eigenen Klasse "false" zurÃ¼ck, damit der Name exakt stimmt
- ClassManager: GetDerivedClasses() akzeptiert nun mehrere Parameter, mit denen man bestimmten kann, ob die Basisklasse
  selbst mit aufgefÃ¼hrt werden soll, ob rekursiv oder nicht rekursiv gesucht wird, sowie ob abstrakte Klassen, also solche
  ohne Konstrukturen, mit aufgefÃ¼hrt werden sollen oder nicht.
- Class und ClassManager: Das Auflisten der abgeleiteten Klassen wurde noch einmal grÃ¼ndlich Ã¼berarbeitet. Es ist nun die
  von Christian eingebaute LÃ¶sung, die nur auf den Namen operiert, verwendet worden, da mir aufgefallen ist, dass das
  InitClass()-Schema in Bezug auf abgeleitete Klassen ja gar nicht richtig funktionieren kann. Denn wenn die Klasse
  initialisiert wird, trÃ¤gt sie sich zwar in die Liste ihrer Basisklasse ein, aber damit kann man ja noch nicht sicherstellen,
  dass die eigenen abgeleiteten Klassen bereits initialisiert wurden. Die Liste an abgeleiteten Klassen bleibt also leer,
  da man die entsprechenden Klassen vorher initialisieren mÃ¼sste, womit sich die Katze in den Schwanz beiÃt ;-)
  Darum wurde die Liste von abgeleiteten Klassen nun aus Class entfernt, statt dessen wird die Suchmethode aus
  ClassManager verwendet, um an die Liste von abgeleiteten Klassen zu kommen, wenn diese abgefragt wird.
- ClassManager: GetDerivedClasses() in GetClasses() umbenannt.



>> 14.05.2010
[SB]
PLCore:
- NullType nach TypeTraits.h verschoben
- InvalidType in TypeTraits.h hinzugefÃ¼gt. Dies ist ein Template, das alle nicht unterstÃ¼tzten Typen reprÃ¤sentiert
- TypeTraits: Einige Templates hinzugefÃ¼gt, um den Typus eines, Ã¤h, Typus festzustellen:
  - IsConvertible, mit dem man feststellen kann, ob zwei Typen ineinander konvertierbar sind.
  - IsEnum, mit dem man feststellen kann, ob es sich bei einem Typen um ein enum handelt
  - TypeClassification, welches Informationen Ã¼ber den Typus in Form von bools in einer Klasse speichert
  - CheckType, welches den geeigneten Typus fÃ¼r nicht-standard-Typen auswÃ¤hlt (z.B. <int> fÃ¼r enums)
  - IsBaseClass, welches ermittelt, ob eine Klasse eine Basisklasse einer anderen Klasse ist
  - CheckBaseClass, welches einen Compiler-Fehler hervorruft, wenn eine Klasse nicht von einer Basisklasse abgeleitet ist
- Type und DefaultValue: Es werden nun die neuen Templates verwendet, um neben den Standardtypen weitere, nicht-standard-Typen
  zu unterstÃ¼tzen. So werden nun z.B. auch enums unterstÃ¼tzt, in diesem Falle wird der Typus einfach wie ein int behandelt.
  So etwas wie Event<EEnum> sollte daher nun verwendet werden kÃ¶nnen.
- RTTI: Es wird nun ein Compilerfehler erzeugt, wenn im RTTI-Makro nicht angegebene Klasse nicht von der angegebenen
  Basisklasse abgeleitet wurde. Damit werden nun Fehler leichter entdeckt, z.B. wenn die Klasse selbst als Basisklasse
  angegeben wurde etc. Was allerdings noch nicht entdeckt werden wÃ¼rde, wÃ¤re z.B., wenn zwar eine korrekte Basisklasse
  angegeben wurde, dazwischen aber noch weitere Klassen sind (z.B. A->B->C, und es wird angegeben, C sei von A abgeleitet!).



>> 11.05.2010
[CO]
PLCore:
- Bis auf SceneNode und SceneNodeModifier ist nun alles auf das neue PLCore2 umgestellt, also KlassenmÃ¤Ãig Halbzeit :D
- Wie in einer EMail besprochen: "type_flag" in "pl_flag_type", "type_enum" in "pl_enum_type" und "ret_type" in "pl_ret_type" umbenannt



>> 08.05.2010
[SB]
PLCore:
- TypeTraits.h hinzugefÃ¼gt: Hier wird es einige generelle templates geben, um Abfragen auf Typen zur Compile-Time
  zu ermÃ¶glichen.
- Rtti.h: Es waren noch einige Ãnderungen notwendig, damit das Projekt wieder mit gcc zu compilieren ist. Die
  erzeugten Storage-Templates fÃ¼r ein Attribut sind so geschrieben, dass sie nur valide sind, wenn der entsprechende
  Storage-Type auch wirklich ausgewÃ¤hlt wurde (es gibt z.B. keine Methoden GetMyVar()/SetMyVar(), wenn MyVar nicht
  mit dem Storage-Typus GetSet deklariert wurde). Im template-code wurde jedoch fÃ¼r jedes Attribut das entsprechende
  Template verwendet, wenn auch nur als Typus fÃ¼r andere Templates, wo es spÃ¤ter verworfen wurde. FÃ¼r den gcc reicht
  dies jedoch aus, um das Template zu spezialisieren, was natÃ¼rlich zu einem Fehler fÃ¼hrt. Aus diesem Grunde wird
  nun das template SpecializeIfEqual<> verwendet, welches eine Template-Class nur dann spezialisiert, wenn eine
  bestimmte Bedingung erfÃ¼llt ist. Damit lÃ¤sst sich PLCore2 nun auch unter Linux wieder compilieren.
- IntegralType nach TypeTraits.h verschoben
- Traits.h entfernt



>> 07.05.2010
[CO]
- "Chunk" und "Localization" samt dazugehÃ¶rigen Klassen von PLGeneral nach PLCore verschoben da hier RTTI FunktionalitÃ¤t
  benÃ¶tigt wird die zukÃ¼nftig erst ab PLCore zur VerfÃ¼gung steht. Habe das erstmal in einem "Tools"-Unterordner gelassen.
- "Loader"/"Loadable" von PLGeneral nach PLCore verschoben
- "Resource" von PLGeneral nach PLCore verschoben
PLCore:
- "Chunk" und "Localization" samt dazugehÃ¶rigen Klassen von PLGeneral nach PLCore verschoben da hier RTTI FunktionalitÃ¤t
  benÃ¶tigt wird die zukÃ¼nftig erst ab PLCore zur VerfÃ¼gung steht. Habe das erstmal in einem "Tools"-Unterordner gelassen.
- "Loader"/"Loadable" von PLGeneral nach PLCore verschoben
- "Resource" von PLGeneral nach PLCore verschoben
- Wie schon bei PLGeneral, hat nun auch PLCore eine statische Version da z.B. PLProject und der 3ds Max Exporter nun PLCore
  benÃ¶tigen, aber nicht von einer dll abhÃ¤ngig sein sollten. Hoffentlich hab ich "CMakeLists.txt" korrekt erweitert, naja
  werds spÃ¤testens beim nÃ¤chsten PL SDK Ã¼bersetzen merken. *g*



>> 06.05.2010
[CO]
PLCore:
- Umstellung von PixelLight auf PLCore2 begonnen
- "Core", "ThreadTimer", "Timer", "TimerImpl", "TimerWindows", "Config", "ConfigLoader", "ConfigLoaderPL", "CoreConfigGroup"
  vom alten PLCore ins neue kopiert damit sich die Umstellarbeiten auf das neue RTTI Konzentrieren kÃ¶nnen.
- Params um Copy-Constructor und Copy-Operator erweitert da ansonnsten an einigen Stellen der VisualStudio Team Edition Compiler
  Warnungen ausgab, wÃ¤hrend der *normale* VisualStudio Compiler nix sagte



>> 05.05.2010 (PLCore2)
[SB]
- RTTI: pl_enum_end() in pl_enum_end geÃ¤ndert
- RTTI: Fehler in pl_enum() behoben - wenn der Wert 0 definiert war, funktionierte die Umwandlung von Name->Wert nicht
  mehr, da hier eine Abfrage fehlte.
- RTTI: Die Behandlung von Flags und Enums musste noch einmal grÃ¼ndlich Ã¼berarbeitet werden, da es bspw. so nicht
  mÃ¶glich war, Enums in einer Klasse zu definieren und in der gleichen Klasse auch gleich zu verwenden. Daher habe
  ich die interne Verwaltung von Enums nun so verÃ¤ndert, dass das enum nicht mehr durch eine Spezialisierung
  von PLCore2::EnumType<> definiert wird, sondern statt dessen eine einfache Klasse erzeugt wird, die dann als
  Template-Parameter weitergereicht wird. Das vereinfacht vieles und bedeutet letztlich fÃ¼r die Anwendung:
  - pl_enum() kann nun prinzipiell Ã¼berall verwendet werden. Auch in Namespaces, und auch in Klassen :-)
  - pl_enum_value_namespace() wurde deswegen wieder entfernt, da es nicht mehr benÃ¶tigt wird
  - pl_enum_value_direct() wurde hinzugefÃ¼gt, dies kann verwendet werden, wenn der zu definierende Enum-Typ kein echter
    C++-Enum-Typ ist - letztlich kann dies verwendet werden, um beliebige Definitionen zu machen. Anwendungsfall sollte
    vor allem sein, wenn man enum definieren will, die nicht den Datentyp 'int' haben (z.B. float)
  - Ãberall, wo man auf ein enum zugreifen will, muss man nun zwanglÃ¤ufig auch das Makro type_enum() verwenden,
    da dies jetzt nicht mehr nur ein PLCore2::EnumType< > um den Namen legt, sondern auch den Namen so verÃ¤ndert,
    dass auf die erzeugte RTTI-Enum-Klasse verwiesen wird.
  - FÃ¼r den direkten Zugriff auf RTTI-Enums ist jetzt die Klasse PLCore2::EnumType< > zustÃ¤ndig. Wie eben erwÃ¤hnt muss
    hier immer type_enum() verwendet werden, um also z.B. die Anzahl an Elementen eines enums abzufragen, benutzt man
    also: type_enum(EnumName)::GetNumOfEnumValues();
- Bespiele fÃ¼r Enums erweitert: U.a. Verwendung von Enums in Klassen und Definition von float-enums.
- RTTI: Die Basisklasse muss in pl_class() nun ohne AnfÃ¼hrungszeichen angegeben werden.
- VarAccess und VarStorage noch einmal grÃ¼ndlich Ã¼berarbeitet und ein wenig Ã¼berschaubarer gemacht. Der zugrunde
  liegende Storage-Typ (z.B. StorageDirectValue oder StorageGetSet) wird nun so weit wie mÃ¶glich mitgereicht,
  damit dann an letzter Stelle das jeweilige Template anhand der Klasse entscheiden kann, was zu tun ist. Auch
  der StorageChoose wurde entsprechend umgeÃ¤ndert.
- Neben StorageDirectValue und StorageGetSet gibt es nun noch einen weiteren Storage-Typ: StorageModifyAttr.
  Dieser Typus kann verwendet werden, um Variablen in abgeleiteten Klassen zu Ã¼berschreiben, und dabei in die gleiche
  Variable zu schreiben. Es wird also eigentlich die Variable der Basisklasse verwendet, jedoch im RTTI die Daten aus
  der abgeleiteten Klasse verwendet (z.B. Default-Value, Enum etc.). Wenn dies verwendet werden soll, muss daher der
  Typus der Variablen in der Basisklasse und in der abgeleiteten Klasse identisch sein. Wenn statt dessen StorageDirectValue
  verwendet wird, ist es zwar auch mÃ¶glich, Variablen zu Ã¼berschreiben und dabei den Typus zu Ã¤ndern, dies sind dann
  jedoch in Wirklichkeit zwei Variablen, die nur den gleichen Namen haben.
- Beispiel fÃ¼r das Ãberschreiben von Variablen hinzugefÃ¼gt.
- RTTI: Auf vielfachen Wunsch einer einzelnen Person kann nun bei Enums zu jedem Wert auch noch eine Beschreibung
  mit angegeben werden. Diese kann bei statischem Zugriff Ã¼ber EnumType<T>::GetEnumDescription(sName), oder bei
  dynamischem Zugriff Ã¼ber DynTypeInfo::GetEnumDescription(sName) abgefragt werden.
- Var: Methode Default() hinzugefÃ¼gt. Die Methode gibt direkt den Default-Wert zurÃ¼ck, benutzt also direkt den
  jeweiligen Datentyp. Wie bei Get() und Set() ist diese Methode nur vorhanden, wenn man direkten Zugriff auf die
  Variable hat. Ãber DynVar gibt es die Methode GetDefault(), welche den Default-Value als String zurÃ¼ckgibt (ist
  nicht anders mÃ¶glich, da hier der tatsÃ¤chliche Datentyp noch nicht bekannt ist).



>> 04.05.2010 (PLCore2)
[SB]
- Var: Es kann jetzt auch der Default-Konstruktor verwendet werden.
- RTTI: 'pl_enum'-Makro erweitert, so dass die dadurch erzeugte EnumType-Klasse ein wenig mehr Komfort bietet.
- RTTI: 'pl_enum_base' eingebaut. Mit diesem Makro kÃ¶nnen bei der Deklaration eines Enum-Typs alle Werte eines anderen
  Enums Ã¼bernommen werden, hiermit kÃ¶nnen also Datentypen "erweitert" werden.
- RTTI: Neben 'pl_enum_value' gibt es nun auch 'pl_enum_value_namespace', das verwendet werden kann, wenn der enum-Typ
  innerhalb eines Names (oder auch einer Klasse) liegt. RTTI-Enums mÃ¼ssen immer im globalen Scope deklariert werden,
  also auch ausserhalb von namespaces, hiermit kÃ¶nnen jedoch dann auch solche Enums angemeldet werden, die selbst
  innerhalb eines namespaces liegen.
- Neue Klassen DynTypeInfo und TypeInfo erstellt. Diese sind im Gegensatz zu den Type<>-Klassen nicht statisch, sondern
  haben ein virtuelles Interface und kÃ¶nnen daher dynamisch (polymorph) verwendet werden. Dies wird wohl so aussehen,
  dass man von einer Variable per GetTypeInfo() eine Referenz auf ein solches TypeInfo-Objekt zurÃ¼ckbekommt, und
  davon dann noch einmal die wichtigsten Typen-Informationen abfragen kann. Hier noch einmal die ganzen Konvertierungs-
  funktionen einzubauen, scheint mir nicht sinnvoll, zumal man dies auch direkt innerhalb von Var machen kann, und
  es ausserdem hier schwierig wird, da der tatsÃ¤chliche Typ ja nicht bekannt ist. Deshalb kann man hier erstmal nur
  noch einmal Typ-ID und Namen abfragen.
- Var: GetType() hinzugefÃ¼gt, welche eine statische Instanz von TypeInfo<T> fÃ¼r den jeweiligen Daten zurÃ¼ckgibt.
- DynTypeInfo: Es kann nun neben dem eigentlichen Datentyp auch abgefragt werden, ob es sich um einen Enum-Datentyp
  handelt (Enum und Flag ist auf dieser Ebene das gleiche). Falls ja, kann abgefragt werden, welche Enum-Werte es gibt,
  hier bekommt man dann eine Liste von Namen zurÃ¼ck. Es ist leider nicht mÃ¶glich, hier auch gleich die Werte fÃ¼r
  die Enum-Namen abzufragen, aus dem Grunde, dass hierfÃ¼r ja der Datentyp bekannt sein mÃ¼sste. Um das zu erreichen,
  muss man also entweder Zugriff auf den jeweiligen Header haben und EnumType<ENUM> verwenden, oder den Umweg Ã¼ber
  eine Variable gehen, da man ja nun die Namen kennt, die man setzen kann.
- DynTypeInfo: Methode GetEnumValue() hinzugefÃ¼gt, mit der man nun doch auf den Wert eines Enum-Names zugreifen kann,
  allerdings nur als String (s.o., der Typus ist hier nicht bekannt). Das sollte jedoch helfen, um z.B. in einem Dialog
  neben dem Enum-Namen auch dessen Wert anzeigen zu kÃ¶nnen.
- Object: Umbenennung der Methoden, um mehrere oder alle Attribute eines Objektes gleichzeitig setzen oder auslesen
  zu kÃ¶nnen in SetValues()/GetValues() und SetValuesXml()/GetValuesXml(). Auch wenn man hier letztlich auf Attribute
  zugreift, sind diese Methoden mehr als reine zugriffsmethoden auf Attribute und stellen den Kern des RTTI dar. Daher
  sollten diese Methoden von den anderen Attribut-Methoden getrennt sein und zudem einen mÃ¶glichst einfachen und gut
  zu merkenden Namen haben :-)
- Object: Methoden SetAttributeDefault() und SetDefaultValues() hinzugefÃ¼gt. Diese Methoden setzen einen bzw. alle
  Attribute auf ihren jeweiligen Default-Wert.



>> 29.04.2010 (PLCore2)
[SB]
- Klassen kÃ¶nnen nun noch zusÃ¤tzliche Properties haben, also Key/Value-Pairs, die an einer *Klasse* (!) dranhÃ¤ngen
  und zur Laufzeit abgefragt werden kÃ¶nnen. Dies dient dazu, zusÃ¤tzliche Infos zu einer Klasse bereitzuhalten, bspw.
  kÃ¶nnen Loader so bekannt geben, welche Dateitypen sie unterstÃ¼tzen oder eine Klasse kann beliebige andere Infos
  Ã¼ber sich preisgeben. Properties kÃ¶nnen in abgeleiteten Klassen Ã¼berschrieben werden. Definiert werden Properties
  Ã¼ber das neue Makro pl_property. Leider mÃ¼ssen alle Properties innerhalb von pl_properties und pl_properties_end
  eingeklammert werden - anders war das mit den RTTI-Makros leider nicht zu lÃ¶sen, ohne dass es unnÃ¶tig kompliziert
  geworden wÃ¤re.
- RTTI: Analog zu 'pl_properties' und 'pl_properties_end' heiÃt es nun 'pl_class_end' anstelle von 'pl_class_end()',
  da es so einfach irgendwie netter aussieht.



>> 24.04.2010 (PLCore2)
[CO]
- Im "pl_module"-Makro "Unknown" Initialisierungen eingebaut da ansonnsten durch "ClassManager::RegisterModule" die
  Module Initialisierungen komplett Ã¼berschrieben werden und am Ende wieder leere Strings vorhanden waren :/



>> 23.04.2010 (PLCore2)
[CO]
- Params: "DefaultValue<x>::Default();" eingefÃ¼gt + RÃ¼ckgabewert im Konstruktor initialisiert



>> 23.04.2010 (PLCore2)
[SB]
- DynFunc, Func: Call(DynParams &cParams) erwartet ein Params-Objekt, welches nicht const ist. Unter Windows wird dies
  scheinbar auch akzeptiert, wenn man z.B. Call(Params<int, int>(10)) aufruft - zwar geht hier natÃ¼rlich z.B. der
  RÃ¼ckgabewert verloren, aber der Aufruf findet dennoch statt, und theoretisch kann man das auf dem Stack befindliche
  Params-Objekt wohl auch manipulieren, auch wenn man davon natÃ¼rlich im Nachhinein nichts mehr hat, weil man es nicht
  wieder auslesen kann :-) Unter Linux mit dem aktuellen gcc klappt dies allerdings nicht, hier wird ein so Ã¼bergebener
  Parameter wohl grundsÃ¤tzlich als const angesehen. Aus diesem Grund musste ich leider zusÃ¤tzlich noch eine zweite
  Methode hinzufÃ¼gen: Call(const DynParams &cParams). Die macht natÃ¼rlich das gleiche wie im nicht-const Fall, mit
  dem Unterschied, dass hier keine RÃ¼ckgabewerte geschrieben werden. Deswegen musste diese Methode nicht nur in DynFunc,
  sondern auch in allen 34 Spezialisierungen von Func<T> implementiert werden :-( Sollte jemandem hier eine einfachere
  LÃ¶sung einfallen, bitte Bescheid sagen...
- DynEvent, Event: Gleiche Problematik wie bei DynFunc, Func. Da Events jedoch niemals einen RÃ¼ckgabewert haben kÃ¶nnen,
  reicht es hier aus, wenn die Parameter immer als const Ã¼bergeben werden. Emit(DynParams&) wurde also Ã¼berall zu
  Emit(const DynParams&) gemacht.
- Constructor: Auch hier die gleiche Problematik. Ãberall wo nÃ¶tig wurde daher Create(DynParams&) in Create(const DynParams&)
  geÃ¤ndert. Auch an allen anderen Stellen, z.B. Object und Class, wurden nun wenn nÃ¶tig zweite Varianten der jeweiligen
  Methoden hinzugefÃ¼gt, damit man Ã¼berall Parameter sowohl const als auch nicht-const Ã¼bergeben kann.
- Func: Bei den Ãnderungen gab es noch einige kleinere Fehler, wo einfach von const nach non-const gecastet wurde, was
  hier definitiv nicht erwÃ¼nscht ist. Nun habe ich hoffentlich alles erwischt (bitte nochmal drÃ¼ber schauen!)
- Constructor: Hier gab es sogar ein noch grÃ¶Ãeres Problem, weil zwar der Aufruf im Prinzip nur ein const-Parameters
  benÃ¶tigt, jedoch der RÃ¼ckgabewert in diesem Fall ja intern verwendet wird. Ich habe das nun so gelÃ¶st, dass an einen
  Constructor immer const-Parameters Ã¼bergeben werden, diese intern aber kopiert werden und somit ein non-const
  Parameters-Objekt entsteht, welches an den Functoid weitergegeben wird. Dort ist dann der RÃ¼ckgabewert, also der Zeiger
  auf das neu erstellte Object, als Return-Value gespeichert, welches dann wiederum zurÃ¼ckgegeben werden kann. Nach
  meinen bisherigen Tests scheint das auch zu funktionieren, besonders schÃ¶n ist die LÃ¶sung natÃ¼rlich nicht.
- ClassManager und Class: Methode GetModule() eingebaut.
- ClassManager: Es wird nun bei duplizierten Klassennamen (Konflikten zwischen zwei Klassen gleichen Namens und
  Namespaces) eine Warnung ins Log geschrieben.
- Module: Name, Beschreibung usw. werden nun alle mit "Unknown" initialisiert. Sollte ein Projekt also nicht die Makros
  nutzen, um Infos Ã¼ber das Modul zu setzen, wird dieses in der Liste und z.B. im Log als "Unknown" auftauchen
- RTTI: Makro pl_current_module_id() hinzugefÃ¼gt als Shortcut, um die ID des aktuellen Modules abzufragen.
- RTTI: Slots werden nun, genauso wie Methoden, beim Anmelden am RTTI umbenannt. FÃ¼r den Slot "OnMyEvent" wird also
  jetzt ein Objekt namens 'SlotOnMyEvent' angelegt, dafÃ¼r wird der aufgerufenen Methode kein automatisches "On" mehr
  vornangestellt. Dies ist nun konsistent mit den Methoden, man gibt also einfach auch beim Slot den Namen der Methode
  an, die aufgerufen werden soll, und erhÃ¤lt ein Feld mit 'Slot' davor. Als Konvention fÃ¼r uns wÃ¼rde ich vorschlagen,
  dass alle Slots immer der Konvention "On[EventName]" folgen sollten.



>> 22.04.2010 (PLCore2)
[SB]
- Functor: Einige Fehler in den partiellen Spezialisierungen behoben (R statt void)
- DefaultValue: Fehlende Datentypen nachgetragen.
- Class, Object, RTTI: Wie Christian richtig anmerkte, war die Verwendung von Event/Signal und EventHandler/Slot noch
  nicht konsequent umgesetzt. Habe das nun behoben, es sollte nun also vÃ¶llig analog sein zu Attributes und Methods.
- DynEvent: virtual void Emit(DynParams&) war nicht als const deklariert - in den abgeleiteten Klassen aber schon, wodurch
  die virtuelle Funktion nicht korrekt Ã¼berschrieben wurde (sondern das natÃ¼rlich als neue Funktion galt).
- Class: GetAttribute(), GetMethod() etc. geben nun const-Zeiger auf die jeweiligen Descriptoren zurÃ¼ck. Zwar geschehen
  dann zwischenzeitlich const-casts, da man letztlich von dem Descriptor ja auch wieder auf das jeweilige Member-Objekt
  kommen kann, aber ich denke, das ist hier ok. Das mit const ist nicht immer so ganz sauber hinzubekommen, fÃ¼rchte ich.



>> 21.04.2010 (PLCore2)
[SB]
- Fehler behoben, die beim Ãbersetzen mit gcc unter Linux aufgedeckt wurden.
- PLCore2 lÃ¤sst sich nun unter Linux Ã¼bersetzen.



>> 15.04.2010 (PLCore2)
[SB]
- Class: Die Namen etc. mÃ¼ssen nun direkt im Konstruktor Ã¼bergeben werden, da ansonsten die Klasse bereits
  angemeldet wird, bevor ihre Daten gesetzt wurden, der Name ist also leer. Makros etc. entsprechend angepasst.
- Func: Einige Warnungen behoben
- Object: Wir nun auch beim RTTI angemeldet



>> 14.04.2010 (PLCore2)
[SB]
- RTTI-Makros: Probleme behoben, die auftraten, sobald das RTTI Ã¼ber mehr als eine Bibliothek hinweg verwendet wurde.
  Dies fÃ¼hrte zu unaufgelÃ¶sten externen Referenzen, diese Probleme wurden nun durch leichte Ãnderungen im RTTI behoben
  (hoffentlich auch fÃ¼r andere Compiler zu gebrauchen).
- RTTI-Makros: Die Basisklasse kann nun auch mit angegeben werden (*hust*)
- Basisklasse Config erstellt (noch leer).
- Basisklasse Application erstellt (noch leer).



>> 13.04.2010 (PLCore2)
[SB]
- Klasse Module erstellt, welche die Informationen Ã¼ber ein Modul speichert. FÃ¼r jedes Module (Applikation/Bibliothek) wird
  automatisch eine Instanz von Module erstellt und beim ClassManager angemeldet. Ein Module beinhaltet dann bspw. auch eine
  Liste aller Klassen, die zu diesem Modul gehÃ¶ren.
- FunktionalitÃ¤t zum Laden und Verwalten von Plugins hinzugefÃ¼gt.
- Type-Wrapper fÃ¼r Pointer-Typen hinzugefÃ¼gt.
- ClassManager: Events hinzugefÃ¼gt fÃ¼r das Anmelden/Abmelden von Klassen und Modulen. Dies kann z.B. verwendet, wenn eine
  Komponente darÃ¼ber informiert werden muss, wenn es neue Klassen von einer bestimmten Basisklasse gibt etc.
- RTTI: Eine Makros hinzugefÃ¼gt, die zwar nicht notwendig sind, aber die Definitionen besser zu lesen machen.
  ret_type() markiert einen RÃ¼ckgabewert und sollte fÃ¼r die Deklaration von Methoden verwendet werden, um den RÃ¼ckgabetyp
  von den Argument-Typen zu unterscheiden. type_enum() und type_flag() sind Wrapper-Makros, die anstelle der ansonsten
  recht langen und unÃ¼bersichtlichen Templates verwendet werden sollten.
- Weitere statische Datentypen zum RTTI hinzugefÃ¼gt: double, int8, int16, int32, uint8, uint16, uint32



>> 12.04.2010 (PLCore2)
[SB]
- Klassen-Template ModuleID hinzugefÃ¼gt, welches dafÃ¼r zustÃ¤ndig ist, jedem Modul (z.B. eine Applikation oder Bibliothek)
  eine eindeutige Modul-ID zu beschaffen.
- ModuleMain.h hinzugefÃ¼gt. Dieser Header sollte genau einmal in einem Projekt eingebunden werden und die darin enthaltenen
  Makros verwendet werden, um das Modul zu beschreiben (Name, Beschreibung etc.).
- Makros und Klassen fÃ¼r die Deklaration und Registrierung von Modulen hinzugefÃ¼gt.



>> 11.04.2010 (PLCore2)
[SB]
- Einige Fehler in Type<EnumType> behoben.
- Type<FlagType> implementiert (Flag-Types sind wie Enums, erlauben aber die Kombination von Werten).
- EnumTypes kann jetzt auch bei der Deklaration von Attributen verwendet werden (hier gab es noch kleinere Fehler, die
  das bisher verhinderten).
- Object, Class: Methoden hinzugefÃ¼gt, um den Typus von Objekten abzufragen und z.B. zu erfragen, ob eine Klasse von
  einer anderen abgeleitet ist oder ein Objekt von einem bestimmten Typus ist.



>> 10.04.2010 (PLCore2)
[SB]
- Klasse ParamParser erstellt und implementiert. Diese Helfer-Klasse kann verwendet werden, um Parameter-Strings
  zu parsen, wie z.B. "Param0=\"Hello\" Param1=10". Die Klasse bietet dann ein einfaches Interface, um Ã¼ber die
  gefundenen Parameter sowie ihrer Werte zu iterieren und diese auszulesen. Da diese FunktionalitÃ¤t an sehr verschiedenen
  Stellen benÃ¶tigt wird, sollte es hier eine wiederverwendbare Klasse geben :-)
- Params: Statische Funktion FromString hinzugefÃ¼gt, welche ein Params-Objekt mit den im String angegebenen Parametern
  erzeugt und zurÃ¼ckgibt. Damit ist es mÃ¶glich, bspw. eine Funktion mit den Parametern als String aufzurufen:
    cFunc.Call(Params<int, float>::FromString("Param0=10 Param1='1.5'")); // Parameter names are not important
- DynFunc, Func: Neue virtuelle Methode Call(const String&) hinzugefÃ¼gt, die es erlaubt, eine Methoden mit einem
  Parameter-String aufzurufen, ohne im Vorfeld die Signatur der Funktion kennen zu mÃ¼ssen.
- Klasse ParamParserXml erstellt und implementiert. Diese arbeitet analog zu ParamParser, lies die Parameter aber
  im XML-Format ein, z.B.:
    <?xml version=\"1.0\" ?>
    <Call Param0=\"1\" Param1=\"2.5\"/>
- Params: Statisch Funktion FromXML hinzugefÃ¼gt (analog zu FromString).
- DynFunc, Func: Neue virtuelle Methode Call(const XmlElement&) hinzugefÃ¼gt (analog zu String&).
- Var, Type: Werte kÃ¶nnen nun auch gesetzt werden, indem ein Pointer auf eine andere dynamische Variable gegeben wird,
  anstelle eines statischen Typs (Ã¤quivalent zu Func, wo DynParam Ã¼bergeben werden kann). Neben z.B. pVar->SetInt()
  gibt es nun also auch pVar->SetVar(pVar2).
- Objekt: Interface um einige Komfort-Funktionen erweitert, z.B. SetAttribute(), CallMethod() etc (AbkÃ¼rzungen fÃ¼r
  den lÃ¤ngeren Weg :-))
- Objekt: Methoden hinzugefÃ¼gt, um alle Variablen zu laden oder zu speichern (per String oder XML).



>> 08.04.2010 (PLCore2)
[SB]
- Neue Klasse MemberDesc erstellt. Dies ist die Basisklasse fÃ¼r alle Member einer Klasse wie z.B. Attribute, Method etc.
  Dies erleichtert es beispielsweise, Ã¼ber alle Member einer Klasse zu iterieren, ohne fÃ¼r jeden Member-Typus eine eigene
  Schleife schreiben zu mÃ¼ssen.
- Class: Methodik implementiert, um Member von Klassen in abgeleiteten Klassen zu vererben, die (hoffentlich) sowohl
  simpel als auch mÃ¤chtig ist. ZunÃ¤chst werden alle Member einer Klasse Ã¼ber Selbst-Initialisierung nur bei der Klasse
  selbst registriert und dort in einer Liste "eigener Member" gespeichert. Da hier das Static-Initialization-Dilemma
  einsetzt, die Reihenfolge in der sich die Member registrieren also nicht vorhergesehen werden kann, muss damit gerechnet
  werden, dass spÃ¤ter noch weitere Member der eigenen Klasse oder einer Basisklasse hinzukommen kÃ¶nnen. Um dieses Problem
  zu lÃ¶sen, gilt die Klasse zunÃ¤chst so lange als nicht initialisiert, bis versucht wird, auf die Member der Klasse
  zuzugreifen. Erst dann wird die Klasse initialisiert, was dazu fÃ¼hrt, dass sie alle ihre Member aufzÃ¤hlt und internen
  Listen von Attributen, Methoden etc. aufbaut, welche dann fÃ¼r den Zugriff auf die Member verwendet werden. Dabei werden
  auch die Member der Basisklassen mit aufgezÃ¤hlt, wodurch auch die Reihenfolge der Member die richtig ist. Wenn nun spÃ¤ter
  noch Member zu einer Klasse hinzugefÃ¼gt werden, die bereits initialisiert wurde, fÃ¼hrt dies dazu, dass diese Klasse sofort
  wieder de-initialisiert wird und dann wieder als nicht initialisiert gilt, bis ein Zugriff auf die Klasse erfolgt, der
  wieder zu einer Initialisierung fÃ¼hrt (wodurch dann auch wieder alle Member korrekt aufgelistet werden). Auf diese Weise
  sollte sichergestellt sein, dass immer alle Member bekannt sind, auch wenn diese sich erst spÃ¤ter angemeldet haben. Auch
  ist zu hoffen, dass eine Klasse nicht zu hÃ¤ufig initialisiert und wieder de-initialisiert werden muss, da dies eigentlich
  nur dann passieren kann, wenn eine Klasse zu frÃ¼h initialisiert wird (auf das RTTI sollte also mÃ¶glichst erst ab der
  Main-Funktion zugegriffen werden). Zudem fÃ¼hrt dieses System dazu, dass Klassen, auf die Ã¼berhaupt gar nicht zugegriffen
  wird im Laufe des Programmes, auch niemals ihre Member initialisieren mÃ¼ssen, was ein zusÃ¤tzlicher Gewinn ist :-)
- Class, Object: Methoden fÃ¼r den Zugriff auf alle Member hinzugefÃ¼gt (sowohl Listen aller Member sowie einzelne Member).



>> 07.04.2010 (PLCore2)
[SB]
- Klasse FuncDesc hinzugefÃ¼gt, welche einen Descriptor fÃ¼r Funktionen und Methoden innerhalb einer Klasse darstellt.
- RTTI-Makros fÃ¼r die Deklarations von Methoden hinzugefÃ¼gt.
- Klasse EventDesc hinzugefÃ¼gt, welche einen Descriptor fÃ¼r Events und Signals innerhalb einer Klasse darstellt.
- Klasse EventHandlerDesc hinzugefÃ¼gt, welche einen Descriptor fÃ¼r EventHandler und Slots innerhalb einer Klasse darstellt.
- RTTI-Makros fÃ¼r Events und EventHandlers hinzugefÃ¼gt. 
- Klasse Constructor wurde in FuncConstructor umbenannt, da dies auch nur ein spezieller Funtoid ist, der ein Objekt
  erzeugt.
- Neue Klassen Constructor und ConstructorDesc implementiert, welche sich analog zu Attributen und Methoden um die Deklaration
  von Konstruktoren in Klassen kÃ¼mmern. Constructor kann hier allerdings nicht komplett Analog zu den anderen genannten
  Klassen sein, da im Gegensatz zu Attributen und Methoden ein Constructor bei Class und nicht bei Object angesiedelt sein
  muss (ein Konstruktor wird von einer *Klasse* aufgerufen und gibt ein Objekt zurÃ¼ck, ein Constructor auf ein schon
  bestehendes Objekt anzuwenden, ergibt dagegen keinen Sinn). Daher unterscheidet sich die Klasse ConstructorDesc hier etwas
  von den anderen Konstruktoren, indem sie z.B. nicht nur den Konstruktor beschreibt (Name etc.), sondern gleichzeitig
  auch die Instanz des eigentlichen Konstruktor-Functoids beinhaltet. 
  so speichert bspw.
- RTTI-Makros fÃ¼r Konstruktoren hinzugefÃ¼gt.
- Methoden hinzugefÃ¼gt, um Instanzen von Klassen zu erzeugen:
  - ConstructorDesc stellt die Methode Create() zu verfÃ¼gung, welche den jeweiligen Konstruktor aufruft
  - Class hat drei weitere Create()-Methoden, mit denen alle Konstruktoren einer Klasse aufgerufen werden kÃ¶nnen.
    Hier kann entweder der Default-Konstruktor aufgerufen werden, oder es wird entweder per Namen oder per Signatur nach
    einem bestimmten Konstruktor gesucht.



>> 06.04.2010 (PLCore2)
[SB]
- Event und EventHandler implementiert. Ein Event-Handler verhÃ¤lt sich zunÃ¤chst einmal genau so wie ein Funktor, stellt
  aber zusÃ¤tzliche FunktionalitÃ¤t bereit, die es erlaubt, Events und EventHandler miteinander zu verknÃ¼pfen. Wenn ein
  Event ausgelÃ¶st wird, werden automatisch alle angemeldeten EventHandler aufgerufen. Events und EventHandler wissen
  Ã¼ber gegenseitige Verbindungen bescheid, so dass Verbindungen automatisch entfernt werden, wenn eine der beiden Seiten
  beispielsweise gelÃ¶scht wurde.
- Klassen Event und EventHandler so verÃ¤ndert, dass hier immer der RÃ¼ckgabetypus void festgelegt ist. WÃ¤hrend bei generellen
  Functoiden und Functoren ein beliebiger RÃ¼ckgabetypus verwendet werden kann, ergibt dies bei Events nicht so richtig
  viel Sinn. Was soll beispielsweise ein Event zurÃ¼ckgeben, wenn mehrere EventHandler aufgerufen wurden und jeder davon
  einen anderen RÃ¼ckgabewert zurÃ¼ckgeliefert hat? Der Einfachheit halber haben daher nun alle Events und EventHandler den
  RÃ¼ckgabetyp void.
- Kommentierung fÃ¼r RTTI-Makros erweitert.



>> 05.04.2010 (PLCore2)
[SB]
- Statische Funktions-Pointer (FuncFuncPtr) und Memberfunktions-Pointer (FuncMemPtr) als Ableitung von Func implementiert.
  Diese Funktions-Pointer, welche die Basis fÃ¼r Functoren sind, verhalten sich also genau so wie andere Functoide, tragen
  intern aber einen Zeigen auf eine Funktion mit sich herum :-)
- Functor implementiert. Ein Funktor ist ein spezieller Typus eines Functoids, der einen Zeiger auf eine andere
  Funktion beinhaltet. Wenn der Functor aufgerufen wird, ruft er die jeweils gespeicherte Funktion auf, stellt damit
  also eine Art generischen Funktionspointer dar.
- Func: Virtuelle Methode Clone() hinzugefÃ¼gt, die benÃ¶tigt wird, wenn eine Kopie eines Functoids angefertig werden soll.
  Dies wird von Functor verwendet, wenn eine Funktion einem Functor zugewiesen oder ein Functor kopiert werden soll.
- Basisklasse Constructor von ClassConstructor entfernt, statt dessen ClassConstructor in Constructor umbenannt.



>> 04.04.2010 (PLCore2)
[SB]
- Attributen mÃ¼ssen nun immer mit einen Zeiger auf das Object initialisiert werden. Das wÃ¤re zwar eigentlich nur fÃ¼r
  die Attribute notwendig, welche Get/Set-Methoden verwenden, aber dann wÃ¤re das ganze inkonsistent, weil manche Attribute
  initialisiert werden mÃ¼ssten, andere aber nicht. Es scheint mir daher sinnvoller, dies bei allen Attributen einheitlich
  zu gestalten, zumal man manchmal auch aus anderen GrÃ¼nden den Zeiger auf das Object gebrauchen kann.
- Variablen: Alle Klassen noch einmal durchgesehen und die Dokumentation Ã¼berarbeitet.
- Functor: Basisklasse DynFunc erstellt, diese Klasse steht allgemein fÃ¼r alle typisierten Funktionen bzw. Funktionsobjekte.
- Functor: Basisklasse DynParams erstellt, diese Klasse stellt die Basis fÃ¼r typisierte Parameter dar.
- "Functor" in "Func" umbenannt und alle Klassen und Ordner angepasst.
- Funktions-Objekte (Functoide) und Konstruktoren implementiert.



>> 29.03.2010 (PLCore2)
[SB]
- Type: Es werden nun keine Funktions-Templates, sondern statt dessen normale Funktionen mit festgelegten Namen verwendet.
  Jeder Typ muss hier die Umwandlungs-Funktionen fÃ¼r alle bekannten statischen Typen zur VerfÃ¼gung stellen (ConvertToInt(),
  ConvertFromInt() etc.). Dies ist notwendig, da es ansonsten nicht mÃ¶glich wÃ¤re, Standardtypen wie z.B. int in nicht-standard
  Typen umzuwandeln, da es ja bspw. kein Type<int>::ConvertToMyType() gibt. 
- Klasse Types entfernt, welche zuvor verwendet wurde, um zwischen Type-ID und Type-Name umzuwandeln. Leider sind diesem
  Mapping natÃ¼rlich die nicht-standard Typen unbekannt, weshalb das ganze System nicht sehr sinnvoll ist. Statt dessen hat
  nun jeder Typus die entsprechenden Methoden GetTypeID() und GetTypeName() zur VerfÃ¼gung zu stellen.
- Klasse Attribute in Var umbenannt.
- Klasse TypedVarDesc entfernt, da diese nicht wirklich notwendig ist zwischen VarDesc und VarDesc_VARNAME.
- Enumerations zum RTTI Typensystem hinzugefÃ¼gt.



>> 28.03.2010 (PLCore2)
[SB]
- Tools: Klasse CompileError erstellt. Dies ist ein Template, das verwendet werden kann, um Compiler-Fehler zu erzeugen.
  Hierbei gibt es zwei Versionen, das eine Mal wird der Fehler in jedem Fall erzeugt, das andere Mal hÃ¤ngt dies noch
  von einer Kondition ab (es wird nur dann ein Fehler generiert, wenn eine bestimmte Aussage zutrifft).



>> 27.03.2010 (PLCore2)
[SB]
- Die Helferklassen fÃ¼r Access und Storage wurden umbenannt und in eigene Header-Dateien verschoben: TypedAttrAccess.h and TypedAttrStorage.h
- Template Signatur erstellt (dieses stellt den 'Typus' von Funktionen dar)
- Basisklasse fÃ¼r Functoide und Konstruktoren erstellt (noch lange nicht einsatzbereit)



>> 26.03.2010 (PLCore2)
[SB]
- Klassen, in denen keine Attribute definiert wurden, werden nun auch korrekt am System angemeldet.
- Attribute kÃ¶nnen nun Default-Werte haben.
- Attribute kÃ¶nnen nun als read/write oder read-only definiert werden.
- Attribute haben nun Zuweisungs- und Conversion-Operatoren. Man kann daher nun z.B. direkt
  'AttrInt = 3' oder 'int nValue = AttrInt' schreiben.
- Helferklassen eingebaut, um den Storage-Type eine Attributes festzulegen:
  - StorageDirectValue speichert den Wert eines Attributes direkt innerhalb einer privaten Variable.
  - StorageGetSet ruft zum Setzen oder Abfragen des Wertes die jeweilige Get- oder Set-Methode des Objektes
    auf, hier wird der Wert also nur indirekt gesetzt und keine eigene Variable instanziiert.
  Bis jetzt ist nur StorageDirectValue implementiert.
- Externer Storage-Type wurde implementiert. HierfÃ¼r muss eine externe Klasse angegeben werden, welche die
  notwendigen Get()/Set()-Methoden fÃ¼r das jeweilige Attribut zur VerfÃ¼gung stellt. Diese Klasse wird dann
  vom Attribut verwendet, um auf den Inhalt der Variablen zuzugreifen, die eigentliche Speicherung der Daten
  kann innerhalb dieser Klasse also beliebig implementiert werden.



>> 25.03.2010 (PLCore2)
[SB]
- RTTI makros fÃ¼r Klassen und Attribute erstellt.
- Attr: GetDesc() wurde nun als virtuelle Funktion innerhalb der Basisklasse implementiert, somit ist es nun immer
  mÃ¶glich, an den Descriptor zu gelangen, sobald man einen Zeiger auf ein Attribut hat.
- Class: Namespace und Description hinzugefÃ¼gt.
- ClassManager hinzugefÃ¼gt.



>> 24.03.2010 (PLCore2)
[SB]
- Erste einfache template-basierte RTTI FunktionalitÃ¤t implementiert. Es ist bereits mÃ¶glich, Attribute von Klassen
  zu definieren und auf diese zuzugreifen. Alles ist komplett template-basiert, bisher wurden noch keinerlei Makros
  verwendet (natÃ¼rlich werden spÃ¤ter auch wieder Makros zur VerfÃ¼gung gestellt, um die Verwendung der Templates
  hinter einfacheren Konstrukten zu verstecken, aber die eigentlich FunktionalitÃ¤t wird hoffentlich nur auf
  Templates basieren und keine Makro-Tricks mehr beinhalten wie z.B. Pointer-Arithmetik zum Ausrechnen von
  Speicheradressen o.Ã¤.).
- Auflisten und Abfragen von Attribute-Descriptoren (bei der Klasse) und Attributen (beim Objekt) wurde implementiert.



>> 23.03.2010 (PLCore2)
[SB]
- Mit neuem System angefangen, daher erst einmal wieder in einem separaten Projekt (PLCore2), damit das alte PLCore
  zunÃ¤chst einmal parallel erhalten bleiben kann, ohne dass es Konflikte gibt.
- Mit neuem RTTI begonnen, welches dieses Mal zum GroÃteil auf C++ templates basieren soll:
  - Type eingebaut als statischen Wrapper fÃ¼r die C++ Datentypen
  - Types ist eine statische Helfer-Klasse, die es bspw. erlaubt, Type-IDs in Strings umzuwandeln u.Ã¤.
  - TypedAttr ist ein Class-Template fÃ¼r typisierte Attribute (also Variablen, die direkt einen Wert besitzen)
  - Attribute ist eine virtuelle Basisklasse fÃ¼r Attribute



>> 21.03.2010
[SB]
- HttpClient: Fehler bei der HTTP-Authentification behoben: Benutzername und Passwort wurden falsch Ã¼bermittelt, wodurch
  eine Anmeldung natÃ¼rlich nicht mÃ¶glich war. Ausserdem wird nun auch das HTTP-Verb "DELETE" unterstÃ¼tzt.



>> 14.03.2010
[CO]
- "Config", "ConfigLoader" und "ConfigLoaderPL" nach PLCore ins Application-Verzeichnis verschoben (siehe PLCore-Tagebuch
  fÃ¼r mehr Informationen)
PLCore:
- "Config", "ConfigLoader" und "ConfigLoaderPL" von PLGeneral nach PLCore ins Application-Verzeichnis verschoben. ZukÃ¼nftig
  sind "Konfigurationen" ausschlieÃlich in Verbindung mit Application-Instanzen zu sehen. Ich konnte keinen Grund finden,
  wieso z.B. die Renderer-Klasse ein Konfigurations-Objekt haben sollte - dafÃ¼r kann man genauso gut einfache Funktionen
  und oder das RTTI nutzen! "Konfiguration" sind eigentlich ja nur dann Interessant wenn man als Anwendungs-Programmierer Einstellungen
  "von AuÃen" Ã¼ber eine Text-Datei einstellbar haben will, oder Programm-Einstellungen wegspeichern und wiederherstellen will.
  Was es jedoch an relevanten Programm-Einstellungen gibt, weis eigentlich nur ein Anwendungs-Programmierer. Man kann schlecht
  *alles* was die einzelnen Komponenten an Variablen haben wegspeichern, das wÃ¼rde auch gar keinen Sinn machen. Als Anwendungs-Programmierer
  kann das sogar total lÃ¤stig und unerwÃ¼nscht werden wenn die "Engine" von sich aus Dateien rausschreibt - denn es kann sehr wohl
  auch mal Anwendungen geben die sich rein passiv zu verhalten haben, also nur von einer Festplatte lesen sollen, aber nix schreiben
  oder gar neue Dateien anlegen.
  Das Application-Framework bring natÃ¼rlich wieder so Konfigurations-Objekte rein, aber das ist ja alles als Vereinfachung gedacht so
  das man sich nicht mehr um alles kÃ¼mmern muss. Dies ist allerdings nicht fest in *PL verwurschtelt*, sondern man kann auch gut ohne
  diese Framework arbeiten und hat dann volle Kontrolle.
- "Config" ist kein Singleton mehr
- "Application" besitzt nun eine "Config"-Instanz. Das Konfigurations-System als solches ist also momentan noch so wie gehabt, nur das
  es kein Singleton mehr ist, sondern jede Application-Instanz eine eigene Konfigurations-Instanz besitzt. Des Weiteren nutzen nur noch
  Application-Instanzen Konfiguration und nicht mehr alle mÃ¶glichen PixelLight-Komponenten. Dies stellt daher denke ich schonmal
  eine Verbesserung da.



>> 22.01.2010
[SB]
PLCore:
- Application::GetApplication(): Export in DLL hinzugefÃ¼gt.



>> 19.01.2010
[SB]
- ThreadLinux: Wie es aussieht, ist die Thread-Implementation unter Linux noch so gut wie unbrauchbar. Leider kenne ich
  mich mit dem Threading ja auch so gut wie nicht aus, und mÃ¼sste mich da nun enorm einarbeiten, um das irgendwie brauchbar
  zu machen. Die schlimmsten Fehler habe ich nun aber erstmal korrigiert bzw. umgangen:
  - pthread_kill(m_nThreadID, SIGKILL) ist *nicht* geeignet, um einen Thread zu beenden. Das Signal beendet immer den
    gesamten Prozess, auch wenn es an einen bestimmten Thread eines Prozesses gesendet wird. Daher wurde nun bei uns jedes
    Mal das gesamte Programm beendet, wenn nur ein Thread oder z.B. ein Timer beendet werden sollte. Zum Beenden eines
    Threads verwende ich nun pthread_cancel(). Diese Fehler hat natÃ¼rlich dazu gefÃ¼hrt, dass das Programm stÃ¤ndig "abstÃ¼rzte",
    nun macht das alles schon einen deutlich stabileren Eindruck unter Linux :-)
  - Es gibt keinen timed-join Befehl in pthreads, also einen Befehl der bis zu einem bestimmten Timeout darauf wartet, dass
    ein Thread beendet wurde. Statt dessen hatte ich hier bisher einfach join verwendet, also ohne Timeout zu warten, was dann
    aber zu einem Einfrieren der Applikation fÃ¼hrt, wenn sich ein Thread nicht freiwillig beendet. Daher lasse ich diese
    Funktion nun erst einmal komplett fehlschlagen, damit das zumindest nicht mehr passieren kann, hier mÃ¼sste dann eine
    timed-join Operation implementiert werden, wofÃ¼r ich auch schon ein Beispiel gefunden habe.



>> 30.11.2009
[SB]
- Neue und umfangreiche HTTP-Implementation erstellt. Dies umfasst sowohl einen HTTP-Client, als auch einen minimalen
  Http-Server. Der Client ist um einiges umfangreicher als die alte HttpHandle-Klasse und kann HTTP/1.0 sowie HTTP/1.1.
  Damit ist auch die "Download fortsetzen"-Funktion mÃ¶glich, bzw. das auslesen beliebiger Teile einer Datei, sofern der
  Server das zulÃ¤sst, was die Verwendung der File-Klassen und Seek() einfacher und vor allem deutlich schneller machen
  sollte. Auch ist die Klasse ansonsten umfangreicher, z.B. werden alle HTTP-Fehlercodes verstanden und kÃ¶nnen entsprechend
  abgefragt werden etc. Daneben gibt es noch einen sehr minimalistischen HTTP-Server, der dazu verwendet werden kann, aus
  einem Programm heraus z.B. eine kleine WeboberflÃ¤che zur VerfÃ¼gung zu stellen. Die Server-Klasse ist dabei eine reine
  Basisklasse, die HTTP-Anfragen entgegennimmt und weiterleitet, von sich aus aber erstmal nur eine statische Seite
  anzeigt. Die eigentliche FunktionalitÃ¤t muss also in der abgeleiteten Klasse implementiert werden, z.B. was fÃ¼r
  Seiten auf welche URLs hin generiert werden sollen. Auch ist dies kein HTTP-Server in dem Sinne, dass er Dateien von
  der Festplatte lesen und auf HTTP bereitstellen wÃ¼rde, da der Anwendungsfall eher auf dynamisch generierte Web-Applikationen
  abzielt (z.B. als WeboberflÃ¤che fÃ¼r einen Spiele-Server). Allerdings wÃ¤re es recht einfach, dies in einer abgeleiteten
  Klasse zu implementieren :-)



>> 29.11.2009
[SB]
- Time: Die Monate werden nun von 1 an gezÃ¤hlt, statt wie bisher von 0. Es ist einfach vÃ¶llig unintuitiv, wenn nur die
  Monate ungewohnt bei 0 anfangen, der Rest aber wie gewohnt von 1 an gezÃ¤hlt wird. Habe das nun daher verÃ¤ndert und hoffe,
  dass ich alle Verwendungen in PL entsprechend korrekt angepasst habe (-1 entfernt wo nÃ¶tig und +1 hinzugefÃ¼gt wo nÃ¶tig).
  Allerdings wurde die Time-Klasse zum GlÃ¼ck bisher nicht so hÃ¤ufig verwendet, es dÃ¼rften also wohl nicht allzu viele
  mÃ¶gliche Fehlerstellen jetzt vorhanden sein.



>> 25.10.2009
[SB]
- Base64-Funktion nach Tools verschoben, da man diese Funktion spÃ¤ter noch einmal brauchen kÃ¶nnte.



>> 24.10.2009
[SB]
- Connection: Mir ist gerade aufgefallen, dass es nicht unbedingt immer erwÃ¼nscht ist, dass eine Connection automatisch alle
  Daten ausliest, die man ihr zuschicken will. Beispielsweise bei einem HTTP-Client wÃ¼rde man wohl erst den Header lesen,
  und dann entscheiden, ob man die Daten ausliest oder nicht (kÃ¶nnten ja auch groÃe Dateien sein). Aus diesem Grund kann
  nun per Option eingestellt werden, ob eine Connection automatisch alles liest, was ihr geschickt wird, oder ob dies
  manuell aufgerufen werden muss. DafÃ¼r die Option EReceiveMode sowie die Methoden Receive() und ReadLine() eingebaut.
  ReadLine liest Text-Daten vom Stream und gibt diese Zeilenweise zurÃ¼ck. Dabei wird das EOL-Zeichen nicht automatisch gelÃ¶scht,
  da dies in manchen Kontexten wichtig ist, dies muss daher ebenfalls manuell geschehen. Ebenso wird nun beim Senden von
  Strings (Send()) nicht mehr automatisch CRLF angehÃ¤ngt, da dies auch nicht immer erwÃ¼nscht ist. FÃ¼r Zeilenenden ist nun
  also die jeweilige Anwendung selbst verantwortlich.
- Buffer: Einige Fehler behoben. Beim zeilenweisen Auslesen werden nun sowohl CRLF als auch nur LF als Zeilenenden akzeptiert.
  ZusÃ¤tzliche Methode GetData() eingebaut, damit man auch auf den Inhalt des Buffers zugreifen kann.



>> 23.10.2009
[SB]
- Network: Habe die Basisklassen aus PLNetwork nach PLGeneral verschoben und noch einmal grÃ¼ndlich Ã¼berarbeitet.
  Es scheint mir sinnvoll, diese Basisklassen bereits in PLGeneral zu haben, denn mit Sockets alleine zu arbeiten
  ist ziemlich mÃ¼hsam und nicht sinnvoll, deswegen sollten immer diese Basisklassen verwendet werden, wenn es darum
  geht, NetzwerkfunktionalitÃ¤t einzubauen. Daher ergab die Trennung hier nicht viel Sinn, und eine weitere Bibliothek
  zu verwenden stellt immer eine zusÃ¤tzliche HÃ¼rde dar, daher ist es besser, diese Klassen gleich in PLGeneral verfÃ¼gbar
  zu haben. Die Netzwerk-Basisklassen bieten selber nur ein minimales Framework um Socket herum an, und durch die
  Ãberarbeitung wurde auch alles noch einmal deutlich schlanker und eleganter, so dass letztlich nur 5 zusÃ¤tzliche
  Klassen herausgekommen sind, die PLGeneral daher auch nicht unnÃ¶tig aufblÃ¤hen sollten :-)
PLNetwork:
- Netzwerk-Basisklassen nach PLGeneral verschoben. Dieses Projekt ist damit zwar erstmal leer, bleibt jedoch erhalten,
  da ich mir sicher bin, das man dafÃ¼r spÃ¤ter noch Verwendung haben wird. Beispielsweise kÃ¶nnten hier Basisklassen
  fÃ¼r typische Netzwerk-Komponenten erstellt werden (z.B. Messenger, Chat, ...), welche dann von spezialisierten Backends
  wie PLIRC oder PLJabber implementiert werden. Auch wird es natÃ¼rlich Basisklassen fÃ¼r die Netzwerksynchronisation brauchen,
  welche spÃ¤ter die Grundlage fÃ¼r die tatsÃ¤chliche NetzwerkfunktionalitÃ¤t in der Engine bieten wird. Daher ist es denke
  ich sinnvoll, dieses Projekt gleich beizubehalten, wenn es auch derzeit nicht genutzt wird.



>> 22.10.2009
[SB]
- String: Neue Methode RemoveLineEndings() eingebaut, die Markierungen fÃ¼r das Zeilenende ("\r" oder "\r\n") am
  Endes des Strings lÃ¶scht. Das ist insbesondere dann wichtig, wenn in einem Netzwerkprotokoll die Zeilenenden
  entscheidend sind und daher Strings nicht gleich "bereinigt" werden sollten.
PLNetwork:
- Buffer: Option m_bRemoveDelimiters hinzugefÃ¼gt. Damit kann festgelegt werden, ob die Zeilenenden in einem
  Protokoll automatisch entfernt werden sollen, oder in den zurÃ¼ckgegebenen Strings drin bleiben sollen. In manchen
  Protokollen ist es wichtig, dass diese Zeichen nicht entfernt werden, da z.B. eine Leerzeile eine besondere
  Bedeutung hat. Wenn die Zeilenenden aber entfernt werden, kÃ¶nnte nicht mehr zwischen eine leeren Zeile ("\r\n") und
  einem leeren String ("") unterschieden werden, der zurÃ¼ckgegeben wird um anzuzeigen, dass noch keine weitere Zeile
  gelesen wurde.



>> 20.10.2009
[SB]
- Time: Neue Methode GetDaysPerMonth() spendiert, um die Anzahl an Tagen in einem Monat abzufragen.



>> 18.10.2009
[SB]
- Habe meine alte Klasse 'HMLTParser' vom letzten Jahr wieder ausgegraben und reaktiviert :-) Diese Klasse hatte ich
  geschrieben, damit man eine HTML-Datei parsen und als Ergebnis einen XML-Syntaxbaum herausbekommen kann. Zwar hatte
  ich dann die gesamte HTML-Anwendungsidee verworfen und in dem Zusammenhang auch den Parser wieder gelÃ¶scht, aber
  da ich nun wieder einmal merke, wie praktisch es ab und zu wÃ¤re, HTML-Dateien einlesen zu kÃ¶nnen, habe ich die
  Klasse nun wiederhergestellt und noch ein wenig erweitert sowie ein paar Fehler behoben. Der Parser selbst sollte
  nun relativ robust sein, allerdings besteht natÃ¼rlich immer noch keine Garantie dafÃ¼r, dass er in der Lage ist, eine
  beliebige HTML-Seite fehlerfrei einzulesen. DafÃ¼r ist der HTML-Syntax viel zu unÃ¼bersichtlich und es gibt zu viele Arten
  von Erweiterungen Ã¼ber eingebettete Scripte etc. Nun werden allerdings Kommentare und einige andere Tags von vornherein
  ignoriert, daher dÃ¼rften einiger MaÃen wohlformatierte Seiten jetzt eigentlich problemlos eingelesen werden kÃ¶nnen. Also
  falls man mal in irgendeinem Zusammenhang HTML-Seiten einlesen bzw. parsen muss, gibt es dafÃ¼r nun eine Klasse, die man
  als Basis dafÃ¼r verwenden kann.



>> 16.10.2009
[SB]
- FileObject und Url: Methoden fÃ¼r den Zugriff auf URLs Ã¼berarbeitet. GetUrl_() in GetUrl() umbenannt, da denke ich die
  Verwendung und Bedeutung dieser Methode inzwischen klar festgelegt ist. In FileObject alle "AbkÃ¼rzungen" entfernt,
  um direkt auf den Dateinamen zuzugreifen, es muss nun also immer GetUrl() verwendet werden und von dort aus weitere
  Methoden, um die URL als String zu erhalten. Ich bin mittlerweile ein Freund davon, keine unnÃ¶tigen doppelten Funktionen
  irgendwo einzubauen, sondern lieber klar nur eine MÃ¶glichkeit zur VerfÃ¼gung zu stellen. Das sieht zwar manchmal nicht so
  hÃ¼bsch aus, ist dafÃ¼r aber verstÃ¤ndlicher und leichter nachzuvollziehen. SchlieÃlich GetWindow(), GetLinux() etc. wieder
  in GetWindowsPath(), GetLinuxPath() etc. umbenannt, denn der Name sollte schon irgendwie darauf hindeuten, was dort
  zurÃ¼ckgegeben wird (auch wenn "Path" nicht ganz korrekt ist, aber hier fehlt es halt an einem eindeutigen Ãberbegriff fÃ¼r
  Pfade, URLs etc.).



>> 03.09.2009
[CO]
PLCore:
- "Event::Emit()": Der Zeiger auf den nÃ¤chsten Event Handler wird nun auf dem Stack zwischengespeichert bevor der Functor
  aufgerufen wird... da man damit rechnen muss das innerhalb des Functors der aktuelle Event Handler gelÃ¶scht wird sollte
  man diesen dann nach dem Functor nicht mehr nutzen. Damit ist es nun mÃ¶glich in Functoren soweit problemlos Event Handler
  wÃ¤hrend eines Emits zu lÃ¶schen - neue hinzufÃ¼gen wird natÃ¼rlich je nach Situation immer noch fÃ¼r Anomalien sorgen.
  (aber wohl weniger wahrscheinlich welche die in Crashs resultieren :)



>> 26.08.2009
[CO]
PLCore:
- "TimerWindows::TimerFunction()": Ich hatte hier gerade das Problem das ein "einmalig Feuern Timer" mehrmals feuerte...
  kann mir das noch nicht richtig erklÃ¤ren, aber wenn ich in der Callback Funktion hier ZUERST den Timer stoppe und dann
  das Event abgebe geht das hier momentan. Seltsam seltsam...



>> 06.08.2009
[CO]
- "uint32" wird nun mit "__int32" definiert, das gleiche gilt fÃ¼r alle Ã¤hnlichen Typen
- "HashFunction" & "CompareFunction" um 64 Bit Datentypen erweitert... ansonnsten gibts Probleme wenn man in einer
  HashMap als SchlÃ¼ssel z.B. "UINT_PTR" unter 64 Bit nutzen will, dann weis der Compiler nicht was er nehmen soll



>> 02.08.2009
[CO]
- "RegEx": Neue Funktion: "WildcardToRegEx()": Wandelt einen gebenen String mit Wildcard in einen String mit RegulÃ¤ren
  Ausdruck um
- "Map": "GetKeyIterator()", "GetConstKeyIterator()", "GetEndKeyIterator()" & "GetConstEndKeyIterator()" hinzugefÃ¼gt
  damit man bei "Map" ebenfalls durch die SchlÃ¼ssel iterieren kann
- "HashMapKeyIterator" & "SimpleMapKeyIterator" hinzugefÃ¼gt



>> 20.06.2009
[SB]
PLCore:
- CMakeFiles.txt: TimerWindows darf aber bitteschÃ¶n auch nur unter Windows eingebunden werden :-)



>> 17.06.2009
[CO]
PLCore:
- "Timer", "TimerImpl", "TimerWindows" und "ThreadTimer" von PLGui3 hierhin kopiert, aber in PLGui3 noch genauso drinnen
  gelassen. Habe die Klassen erstmal in den Grundordner gelegt da mir kein brauchbarer Name fÃ¼r einen Unterordner einfiel
  - da kommen ja noch einige Klassen bei Zeiten hinzu und dann findet sich sicherlich ne nette Gruppe der sich der Timer
  anschlieÃen kann. :D
  Da "ThreadTimer::Run()" in einem Thread lÃ¤uft kann der Timer allerdings zu jeder Zeit feuern... etwas das sicherlich
  schnell Problematisch werden kann. Eventuell wÃ¤re ne art von "TimerManager"/"TimerScheduler" Klasse nett Ã¼ber die
  man die Timer Synchronisieren kann... also quasi in der Art "So Leute, wer bereit ist - FEEEUER!". *g*
  Was beim Threaded Timer auch noch ein Problem ist, ist das "Stoppen" da die genutzte "Sleep()" nicht unterbrochen
  wird und der Timer erstmal ablaufen muss.
- "ThreadTimer::StartTimer()" und "ThreadTimer::StopTimer()": Der Thread wird hier gestartet und "abgewÃ¼rgt", damit
  wird der Timer bei stop sofort angehalten. Damit verhÃ¤lt es sich wie "TimerWindows". Ich hatte mir zuerst die
  Windows Funktion "QueueUserAPC()" angeschaut aber irgendwie wurde das zuviel des guten.



>> 03.06.2009
[CO]
PLCore:
- "Application": Neue Funktion "IsRunning()" gibt zurÃ¼ck ob die Anwendung gerade lÃ¤uft



>> 10.05.2009
[CO]
- "ZipHandle::ReadCurrentFileInfo()": Autsch, hier hatten wir ein Ã¼bles Speicherleck wenn "m_cCurFile.m_nSizeFilename"
  0 war... denn hier muss noch ein Zeichen fÃ¼r \0 angehÃ¤ngt werden. Die String Klasse Ã¼bernimmt dann die Kontrolle
  Ã¼ber den Speicher, bekommt aber die Original SpeicherlÃ¤nge ohne +1 und denkt sich dann "hopala, leerer String!"
  und Ã¼bernimmt dann natÃ¼rlich nicht die Speicherkontrolle da der Speicher ja scheinbar leer ist. Und dann mÃ¼llt
  sich der Speicher langsam mit Herrenlosen frÃ¼hlich frei herumschwirrenden 1 Bytes voll.
- "ClassManager::LoadPlugin()" sollte auch mehrmals aufgerufen werden kÃ¶nnen ohne das es bereits vorhandene
  Module erneut hinzufÃ¼gt, baute daher einen entsprechenden Test ein.



>> 07.05.2009
[CO]
- "BinaryHeap", "BinominalHeap" und "FibonacciHeap" hatten Fehler so das der Compiler einem kryptische Fehler nur
   so um die Ohren schlug wenn man versuchte den "Comparer" durch einen eigenen zu ersetzen



>> 01.05.2009
[CO]
- "Bitset"-Konstruktor: Beseitigte eine Inkonsistenz zu "Array" und "Resize()": Die Standardeinstellungen von
  "bAdded" und "bInit" sind nun identisch. "Bitset" wird bis jetzt zum GlÃ¼ck sehr selten eingesetzt so das es
  nur wenige Stellen waren die einer PrÃ¼fung bedurften. (Ãnderung dieser Art sind ja immer sehr heikel :/)
- "Bitset" um superkomplexe "Reset()"-Funktion die es ebenfalls auch in "Array" gibt erweitert... setzt einfach
  die aktuelle Anzahl an Elementen auf null so das es einem "Clear()" gleichkommt, aber deutlich schneller ist da
  der angelegte Speicher erhalten bleibt. (hin und wieder sehr praktisch soetwas :)



>> 26.04.2009
[CO]
- "SystemWindows::GetOS()" erkennt nun auch Windows 7



>> 22.04.2009
[CO]
- Ãnderte einige Methoden der String-Klasse minimal so das die heute von Stefan festgestellten unschÃ¶nheiten beseitigt sind



>> 22.04.2009
[SB]
- RegEx: Workaround eingebaut, da String::Copy() mit der LÃ¤nge 0 den gesamten String zurÃ¼ckgibt anstelle der leeren Strings ("").
  Ich denke dies sollten wir dringend Ã¼berarbeiten, denn dieses Verhalten ergibt zwar Sinn, wenn man 0 nur als Defaultwert,
  sprich als "nicht angegeben" betrachtet, verhindert aber, dass man den Wert 0 als tatsÃ¤chliche LÃ¤nge eines Substrings angeben
  kann. Und dies fÃ¼hrt zu einem sehr ungewÃ¶hnlichen Verhalten, denn wenn ich z.B. alle Prefixes alles Strings mit sowas wie
  for (int i=3; i>=0; i--) sPrefix = sString.GetSubstring(0, i); abfrage, wÃ¼rde ich wohl eher ["abc", "ab", "a", ""] erwarten
  als ["abc", "ab", "a", "abc"] (siehe Test99).



>> 22.04.2009
[CO]
- "File": Neue Funktion: "GetMemoryBuffer()": Falls die Datei "im Speicher liegt" kann man sich hiermit direkt einen Zeiger auf
  den Speicher geben lassen. Ist zwar irgendwie "unschÃ¶n" aber "praktisch" da man dadurch in einigen FÃ¤llen die Performance
  in Anwendungen verbessern kann... denn wenn man "weis" das eine Datei bereits komplett im Speicher liegt und man die Datei im
  Speicher braucht um diese mit anderen Funktionen weiterzuverarbeiten - dann muss man nun nicht mehr einen "Zwischenbuffer"
  erzeugen, die ganze Datei "einlesen", Arbeit erledigen und "Zwischenbuffer" wieder freigeben... sondern man nutzt direkt
  den bereits die bereits im Speicher liegende Datei. :D



>> 16.04.2009
[SB]
PLPlugin:
- Fehlende AbhÃ¤ngigkeiten in der CMakeLists.txt hinzugefÃ¼gt.



>> 15.04.2009
[CO]
- Spendierte der "File"-Klasse einen weiteren Konstruktor dem man einen Buffer Ã¼bergeben kann... was hin und wieder
  ziemlich praktisch ist da "Dateien" dann nicht zwanghaft direkt von der Festplatte kommen mÃ¼ssen.
- "Base::SetVars()": In meinem RegulÃ¤ren Ausdruck war noch ein bÃ¶ser Fehler drinnen so das beim Wert ' am Ende stehen konnte...
  generell hab ich hier noch etwas Probleme mit " und ' richtig erkennen und habe das momentan etwas umstÃ¤ndlich gelÃ¶st -
  Stefan... falls du ne Idee hast wie man das alles zusammen in einem netten Ausdruck vereinen kÃ¶nnte... :D



>> 12.04.2009
[SB]
- System: Exit() hinzugefÃ¼gt, um die Applikation sofort beenden zu kÃ¶nnen. Dies ist natÃ¼rlich nur ein Wrapper fÃ¼r die jeweilige Systemfunktion.
PLCore:
- Application: Neue Methode OnKill() hinzugefÃ¼gt, die aufgerufen wird, wenn das Betriebssystem versucht, die Applikation zu beenden. StandardmÃ¤Ãig ist
  diese Methode so implementiert, dass sie sofort Exit() aufruft und die Applikation damit zwangsweise beendet. Durch Ãberschreiben dieser Methode kann
  aber z.B. dafÃ¼r gesorgt werden, dass erst einmal die aktuelle Aufgabe zu Ende gebracht wird und sich die Applikation hinterher ordentlich beendet.
- Application: Unter Linux wird nun das Signal SIGTERM aufgefangen und dann die Methode OnKill() aufgerufen.
- Application: Zugriffsmethoden fÃ¼r die Versions-Variable hinzugefÃ¼gt.
- Application: Einen statischen Pointer auf die aktuelle Application-Instanz hinzugefÃ¼gt. Wenn es anders geht, sollte dies zwar nicht unbedingt verwendet
  werden, aber solange man darauf achtet, immer nur *eine* Application zur Zeit zu haben, bietet dies nun eine sehr einfach Methode, um schnell an diese
  wichtige Application-Instanz und damit auf alle anderen Dinge darin heranzukommen :-)



>> 11.04.2009
[SB]
- CommandLine erweitert, um mÃ¶glichst viele der Ã¼blichen Kommandozeilen-Optionen abzudecken. Ich hoffe mal, mit dieser
  aufgebohrten Klasse kommt man weit genug und kann auch komplizierte Kommandozeilen-Optionen definieren, damit man da
  mÃ¶glichst nicht stÃ¤ndig wieder einen eigenen Parser schreiben muss. Es gÃ¤be natÃ¼rlich noch viel mehr MÃ¶glichkeiten, aber
  alles abzudecken wÃ¤re wirklich zu kompliziert und daher nicht mehr sinnvoll. Auch ist zu beachten, dass diese Klasse nun
  zwar vieles erlaubt, aber nicht alles auch auf PlausibilitÃ¤t prÃ¼ft (z.B. beim Festlegen von benÃ¶tigten und optionalen
  Parametern). Hier muss der Programmierer also noch selber darauf achten, dass er nicht unsinnige oder wiedersprÃ¼chliche
  Angaben macht. Die Ãnderungen im Detail:
  - Es gibt nun drei Typen von Optionen: Flags, Parameter und Argumente.
  - Ein Flag besteht nur aus einer Option (z.B. '-a' oder '--optiona') ohne weiterem Argument dahinter und
    kann einen kurzen sowie einen langen Namen haben.
  - Ein Parameter besteht aus einer Option und einem Argument dahinter (z.B. '-n <name>' oder '--name <name>').
    Die MÃ¶glichkeit, dass dieses Argument optional ist, besteht *nicht* (ich finde aber auch nicht, dass man das braucht).
  - Ein Argument wird ohne ohne Option davor angegeben (z.B. "app.exe <name>"). Hierbei werden die registrierten Argumente
    der Reihe nach durchgezÃ¤hlt, das erste angegebene Argument entspricht dem ersten in der Liste usw. Alle weiteren
    Ã¼bergebenen Argumente werden in einer zusÃ¤tzlichen Liste gespeichert und kÃ¶nnen Ã¼ber GetAdditionalArgument() abgefragt
	werden.
  - Alle Optionen kÃ¶nnen nun einen logischen Namen bekommen, z.B. "Name" fÃ¼r "-n" oder "--name". Das macht das Abfragen
    der Optionen einfacher und erlaubt es auch, die Flags spÃ¤ter zu verÃ¤ndern aber den logischen Namen dabei beizubehalten,
    wodurch man weniger im Code Ã¤ndern muss. Bei Parametern wird dieser Logische Name auch in der Hilfe mit angezeigt
    (z.B. --name <name>).
  - Optionen kÃ¶nnen nun zusÃ¤tzlich noch als "Required" definiert werden. In diesem Fall wird es als Fehler gewertet, wenn
    die jeweilige Option beim Starten des Programmes nicht angegeben wurde, weshalb dann das Programm nicht gestartet und
	statt dessen der Hilfetext ausgegeben wird.   
  - CommandLine::ShowHelp() an die Ãnderungen angepasst und erweitert. Alle Parameter werden geordnet angezeigt, unterteilt
    in Argumente und Optionen. Habe mich dabei an mÃ¶glichst Ã¼bliche Darstellungen gehalten, z.B. steht <arg> fÃ¼r ein
    benÃ¶tigtes Argument, [arg] fÃ¼r ein optionales. Am Anfang wird eine kurze Zusammenfassung (Synopsis) ausgegeben, hierbei
    wird auch der Dateiname des Programmes mit ausgegeben.
PLCore:
- Application: An Ãnderungen von CommandLine angepasst.



>> 10.04.2009
[CO]
- "Loader::OpenFile()"-Implementation etwas geÃ¤ndert so das weniger "File::IsFile()" aufrufe gemacht werden
 (langsam da Datei zugriff)
- "RegEx" etwas optimiert: "m_lstGroups" ist nun ein "Array", dadurch kann man von der schnellen "Reset"-Methode
  profitieren
- "Base::SetVars()" arbeitet nun mit RegulÃ¤ren AusdrÃ¼cken statt mit dem Tokenizer... und ist laut meinen intensiven
  Benchmarks die ich momentan betreibe sogar deutlich flotter. ("246 ms" statt "356 ms" Ladezeit in einem Projekt
  mit grÃ¶Ãerer Szene :)
  "static RegEx ..." mag zwar nicht Thread-Safe sein, aber das ist PixelLight in seiner Gesammtheit derzeit ohnehin
  nicht und das Beschleunigt die Sache. (ohne "static" beim Projekt von oben "280 ms"... und hier kommts wirklich
  knadenlos auf jede Millisekunde an :/)



>> 08.04.2009
[CO]
- Da das RTTI so grundliegend ist und sehr intensiv genutzt wird machte ich ein paar vorsichtige Optimierungen um
  soviel Performance wie mÃ¶glich rauszuholen. (muss leider sein :/) Die Ãnderungen hab ich einige male durchdacht
  und genau geprÃ¼ft damit ich blos nix klaput mache... Stefan, bitte zur Sicherheit auch nochmal Ã¼berfliegen.
- "ClassManager::RegisterClass()": Das langsame durchgehen der 'm_lstClasses'-Liste ob die Klasse schon
   Registriert ist kann man sich sparen, 'm_mapClasses'-Test reicht vÃ¶llig... + der Listen-Test brachte in
   meinen Tests immer das gleiche Ergebniss (nicht in Liste)
- "Class::HasBaseClass()": Hier braucht man keine Klassen-Namen vergleichen sondern kann direkt Klassen-Zeiger
   vergleichen, in der "String"-Variante wird der Test direkt Implementiert um einen Funktionsaufruf zu sparen
- "Base::IsInstanceOf()": Hier braucht man keine Klassen-Namen vergleichen sondern kann direkt Klassen-Zeiger
   vergleichen, in der "String"-Variante wird der Test direkt Implementiert um einen Funktionsaufruf zu sparen



>> 05.04.2009
[CO]
- "Tokenizer::StreamIsString()" nach "BufferedReader::IsString()" verschoben, dadurch kann man ein internes
  'GetSubstring()' nur fÃ¼r String vergleichen vermeiden (... performance...)
- "Tokenizer::StreamRead()": "m_nPosition++" aus der Schleife gezogen und zu "m_nPosition += nCount" gemacht
- "Tokenizer": "EndOfLine"-Definition fÃ¼r "\n" hinzugefÃ¼gt damit man statt 'm_sEndTag = "\n"' einfach
  "m_sEndTag = EndOfLine" schreiben kann was um einiges Effizienter ist da keine dynamische Speicherbehandlung :D
- "String": Das zuweisen von "char" oder "wchar_t", sprich einzelnen Zeichen optimiert so das wenn die Situation
  es zulÃ¤sst man keine dynamische Speicherbehandlung braucht
- "String": "GetChar()", "GetWideChar()", "GetInt()", "GetLong()", "GetFloat()" und "GetDouble()" Implementation
  Ã¼berarbeitet damit so effizient wie mÃ¶glich (keine xxx Funktionsaufrufe etc.)
- "StringBufferUnicode" & "StringBufferUnicode" & "StringBufferUTF8": Entfernte die "GetString()"-Methode da im
  grunde nur ein Umweg (= balast) in einem String-System das 'sehr eng verdrahtet' ist



>> 27.03.2009
[CO]
- "Bitset": Neue Funktion: "GetNumOfSetBits()": Gibt die Anzahl der auf "true" gesetzten Bits zurÃ¼ck



>> 25.03.2009
[CO]
- "Loader::OpenFile()" muss es natÃ¼rlich auch erlaubt sein Dateien beim Speichern neu zu erzeugen, hm, merkwÃ¼rdig das dies
  bis jetzt noch nicht aufgefallen war...
- "Loader::OpenFile()" sollte natÃ¼rlich auch ohne eingetragene "Basis Pfade" funktionieren, tat es aber bis jetzt nicht



>> 11.02.2009
[CO]
- Bitset: 'GetNumOfIntegers()' & 'GetIntegers()' hinzugefÃ¼gt damit man an die interne DatenreprÃ¤sentation rankommt...
  was hin und wieder hilfreich sein kann...



>> 06.02.2009
[CO]
- 'DynLib': Neue Funktion 'GetAbsPath()' -> Gib den absoluten Pfad der geladenen Dynamischen Bibliothek zurÃ¼ck



>> 30.01.2009
[CO]
- 'Singleton': 'DestroyInstance()'-Funktion hinzugefÃ¼gt mit der man manuell die ZerstÃ¶rung der Singleton-Instanz
  'befehlen' kann. Da das Singleton normalerweise erst 'gaanz am Ende automatisch' zerstÃ¶rt wird kann es zu
  problemen kommen wenn man eine Anwendung schreibt die in eine andere Eingebettet ist... + so kann man nie die
  von VC angebotenen Speicherleck Tests nutzen da dann immer angemeckert wird es gÃ¤be ein Speicherleck da die
  Singletons erst nach dem Test freigegeben werden. Auf dauer sollten wir versuchen soweit mÃ¶glich komplett auf
  Singletons zu verzichten... (einfach weil man nicht wirklich Kontrolle Ã¼ber erzeugung und lÃ¶schung hat :/)



>> 26.01.2009
[SB]
- ChunkLoaderPL: Fehler behoben, wodurch sich das Projekt unter Linux nicht mehr Ã¼bersetzen lieÃ.
  Statische Member einer Klasse mÃ¼ssen *immer* in einer .cpp Datei definiert werden, da diese als
  Symbol exportiert werden. Nur im Header einfÃ¼gen reicht nicht aus, da dann ein "undefined external
  symbol"-Fehler ausgelÃ¶st wird, wenn von ausserhalb der Projektes versucht wird, auf dieses Symbol
  zuzugreifen. Also bitte bei statischen Members immer eine Definition in einer .cpp Datei hinzufÃ¼gen
  (einzige Ausnahme sind Templates, da der Compiler das hier automatisch macht), oder statt dessen enums
  verwenden.



>> 25.01.2009
[CO]
- 'GetHexValue()' aus einem von Stefans Projekten nach 'ParseTools::ParseHexValue()' verschoben da man das durchaus Ã¶fters mal brauchen kann



>> 22.01.2009
[CO]
- 'Chunk'-Klasse hinzugefÃ¼gt die z.b. zum speichern von Keyframes genutzt werden kann



>> 14.01.2009
[SB]
- FileLinux: Die Klammerung war hier falsch, weshalb Verzeichnisse nicht mehr richtig erkannt wurden. Darum funktionierte PLProject nicht
  mehr richtig. Habe hier gleich die Fehlermeldungen ein wenig erweitert. Keine Ahnung, warum das noch nicht frÃ¼her aufgefallen ist ...



>> 01.01.2009
[CO]
- 'Timing::CheckUpdate()': Hier kann man nun optional einen Parameter Ã¼bergeben der im Falle eines FPS Limits zurÃ¼ckgibt wie lange man noch
  warten muss bis es Zeit fÃ¼r das nÃ¤chste Update ist. So kann man direkt diesen Wert fÃ¼r 'Sleep' nutzen anstatt '1'.
- 'Timing::Update()': FPS Limit wird nun auch ausgefÃ¼hrt wenn gerade 'freezed' aktiv ist



>> 03.12.2008
[SB]
PLCore:
- Neue Config-Klasse fÃ¼r PLCore hinzugefÃ¼gt und erst einmal nur die Einstellung "LoadLibsFromRuntime" aus PLEngine hierher verschoben.
  Ansonsten hat man das Problem, dass eine Applikation, die noch nicht von PLEngine abhÃ¤ngig ist, auch diese Option nicht kennt und daher
  nicht die Plugins im PL-Runtime sucht. Daher muss diese Einstellung so frÃ¼h wie mÃ¶glich kommen, damit ist das Problem erstmal behoben.
  Jetzt mÃ¼ssen wir mÃ¶glichst schnell die ganze Config-Problematik nochmal sauber angehen, ansonsten haben wir bald ein echtes Problem ...
PLPlugin:
- BasicSceneApplet entfernt. Dies wÃ¤re eine totale Verkomplizierung, wenn man hier nochmal eine extra Ableitungshierarchie
  aufmacht. Und damit kÃ¶nnte dann immer noch nicht eine Applikation zwischen Plugin und Exe 'geteilt' werden.
- Statt dessen hat PluginPixelLight nun direkt einen Zeiger auf eine Applikation, die dann eingebettet wird. Dank der
  Ãnderungen am Application-Framework kann nun generell jede Applikation (ab GuiApplication) in fremde Fenster eingebettet
  werden, dies wird hier nun einfach verwendet. Es wird eine Application wie gewohnt instanziiert, dann wird aber nicht
  Run() aufgerufen, sondern die Applikation in das Plugin-Window eingebettet. Als Test habe ich die Teapot-Application
  verwendet, die Application kann aber jetzt ganz einfach ausgetauscht werden.



>> 03.12.2008
[CO]
PLCore:
- "64 Bit 'Bugfix': Core::GetRuntimeDirectory()" vom "25.08.2008" rÃ¼ckgÃ¤ngig gemacht da Windows das
  'normalerweise' Automatisch macht.
  Im 3ds Max Scene Exporter muss der alte Hack drinnen bleiben da man auf einem 64 Bit OS ein 32 Bit PL SDK
  Installieren kann... und dann ein 64 Bit 3ds Max nutzt, das sucht dann nach dem Registry Eintrag um automatisch
  feststellen zu kÃ¶nnen wo der PLSceneViewer liegt - und findet das dann natÃ¼rlich nicht da es in einem
  "Magischen" 'Wow6432Node'-Unterordner abgelegt wurde. :D
PLPlugin:
- 64 Bit VC Projekt Einstellungen hinzugefÃ¼gt
PLPluginMozilla:
- 64 Bit VC Projekt Einstellungen hinzugefÃ¼gt



>> 29.11.2008
[CO]
- Var: 'GetFlagsFromString()' & 'GetStringFromFlags()' public gemacht da man diese FunktionalitÃ¤t auch von auÃen brauchen kann
- Da wir Ã¼berall 'PL_VAR_FLAGS' als 'uint32' handhaben stellte ich die paar Stellen die 'int' nutzten hier auch auf 'uint32' um... macht nicht
  wirklich einen unterschied da beides 32 Bit, aber so ists konsequent. :D



>> 16.10.2008
[CO]
PLPlugin:
- Projekt ist wieder Ã¼bersetzbar, aber noch nicht wirklich wieder lauffÃ¤hig. 'PL::Init()' etc. gibts nun nicht mehr, habe erstmal
  BasicSceneApplet angelegt - eine Klasse von 'BasicSceneApplication' abgeleitet die als 'Applet' fungieren soll.



>> 29.09.2008
[SB]
PLCore:
- Application: Verwaltung von Kommandozeilen-Optionen durch eine Instanz von CommandLine hinzugefÃ¼gt. Es werden ausserdem gleich
  einige Standardoptionen hinzugefÃ¼gt: "--version" zeigt Programmname und Version an, "--help" zeigt alle zur VerfÃ¼gung stehenden
  Optionen an. Das Verhalten dieser Kommandos kann wie Ã¼blich Ã¼ber virtuelle Funktionen Ã¼berschrieben werden.
  Ich mÃ¶chte es hier dem Programmierer so einfach wie mÃ¶glich machen und ausserdem dafÃ¼r sorgen, dass PL-Applikationen
  gleich so viel Komfort wie mÃ¶glich bieten. Oftmals stÃ¶Ãt man auf Programme, wo alles gut gemacht ist, aber dann fehlen solche
  Standarddinge wie "--version" oder Kommandozeilenoptionen Ã¼berhaupt. Bei PL ist das nun gleich standardmÃ¤Ãig drin, es sei denn
  ein Programmierer baut dies bewusst wieder aus, was natÃ¼rlich auch mÃ¶glich sein sollte (CommandLine.Clear()). 



>> 28.09.2008
[SB]
- CmdLineParser durch die neu implementierten Klassen CommandLine und CommandLineOption ersetzt. Das Prinzip bleibt zwar
  das gleiche, die Schnittstelle von CommandLine entspricht jedoch mehr unserem Ã¼blichen PL-Style als dies bei CmdLineParser
  der Fall war. So kÃ¶nnen bspw. die einzelnen Optionen Ã¼ber die Methoden AddOption und AddFlag hinzugefÃ¼gt werden, anstatt wie
  bisher alles in einen recht kryptischen String zu packen, der erst einmal geparsed werden musste. Optionen, die sowohl einen
  kurzen als auch einen langen Namen haben, gehÃ¶ren nun auch direkt zusammen. ZusÃ¤tzlich wird noch eine Beschreibung zu jeder
  Option gespeichert, was dazu benutzt wird, um automatisch einen Hilfetext auszugeben, in dem alle vorhandenen Optionen
  aufgezÃ¤hlt werden. In Verbindung mit dem Application-Framework kÃ¶nnen damit nun sehr einfach Kommandozeilenoptionen
  verwaltet werden, was ingesamt einen sehr guten Eindruck machen sollte, wenn jede PL-Applikation solche Standardfunktionen
  schon bietet, ohne das der Programmierer sich groÃ darum kÃ¼mmern muss. 
PLCore:
- Application: Der Executable-Dateiname und die Argumente werden jetzt nicht mehr im Constructor sondern bei Run Ã¼bergeben.
  Alle Projekte wurden entsprechend angepasst. Da bei dieser Reihenfolge ChangeIntoAppDirectory() nicht mehr vernÃ¼nftig von
  Aussen aufgerufen werden kann, habe ich dies nun erstmal in GuiApplication::OnInit() eingebaut. Dies sollte auf jeden Fall
  von der Application selbst entschieden werden, und nicht von Aussen aufgerufen werden.



>> 05.09.2008
[CO]
PLCore:
- Application: "GetName()" in "GetTitle()" umbenannt
- Application: "GetFilename()" in "GetExecutableFilename()" umbenannt
- Application: "OnHelp()" in "OnPrintHelp()" umbenannt
- Application: "OnVersion()" in "OnPrintVersion()" umbenannt
- Application: GetExitCode(), SetExitCode(), IsShutDown(), ShutDown(), OnShutDown() in PLGui::Application verschoben
- Application: Neue Funktion: GetStartupDirectory(), gib das aktuelle Verzeichniss zurÃ¼ck das beim aufruf des Applikation
  Verzeichnisses eingestellt war
- Application: 'OnInit()' in 'GuiApplication' verschoben
- Application: 'Title' muss nun Ã¼ber 'SetTitle()' gesetzt werden und kann nicht mehr direkt im Konstruktor Ã¼bergeben werden



>> 25.08.2008
[CO]
PLCore:
- 64 Bit 'Bugfix': Core::GetRuntimeDirectory(): Macht ein 32 Bit Programm bei einem 64 Bit OS in der Registry herum, so landen dessen
  EintrÃ¤ge in einem 'Wow6432Node'-Unterordner. Also statt 'SOFTWARE\\PixelLight\\PixelLight-SDK' dann
  'SOFTWARE\\Wow6432Node\\PixelLight\\PixelLight-SDK' ... nicht das es zu einfach wird. *g*



>> 24.08.2008
[CO]
- System: GetPlatform() gibt wieder 'Win32' oder 'Win64' zurÃ¼ck statt 'Windows' da hier eine feinere Unterscheidung z.B. beim Plugins laden
  hilfreich ist. Unter Linux wird derzeit wie gehabt 'Linux' zurÃ¼ckgegeben, ob wir hier dann auch 32/64 Bit unterscheidungen brauchen mÃ¼ssen
  wir uns spÃ¤ter mal genauer anschaun.



>> 23.08.2008
[CO]
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da fÃ¼r 32 Bit als auch fÃ¼r 64 Bit
PLNetwork:
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da fÃ¼r 32 Bit als auch fÃ¼r 64 Bit
PLCore:
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da fÃ¼r 32 Bit als auch fÃ¼r 64 Bit



>> 22.08.2008
[CO]
- Der 64 Bit Support von PLGeneral funktioniert nun. CMake Dateien schau ich mir als nÃ¤chstes an + ein paar Dinge mÃ¼sste man
  wohl umbenennen damit es 'Sauber' ist. 'SystemWin32' z.B. zu 'SystemWindows' da es fÃ¼r 'Win32' und 'Win64' nutzbar ist. :D



>> 21.08.2008
[CO]
- Fing an mich mit 64-Bit Support auseinander zu setzen. 'WIN64' wird zusÃ¤tzlich als Precompiler Definition hinzugefÃ¼gt.
  Bei zumindestens schonmal einer Stelle, und zwar in SystemWin32::GetCPUMhz() muss man nun mit 'WIN64' eine Fallunterscheidung machen.



>> 20.08.2008
[SB]
- HTMLParser wieder entfernt, da mir das alles nicht robust genug ist. Um Texte anzuzeigen, wird nun ein eigenes
  XML-Format verwendet, da muss man nicht die ganzen HTML-Probleme mit sich herumschleppen und das war auch relativ
  schnell und einfach implementiert. FÃ¼r "echtes" HTML kann man dann evtl. spÃ¤ter auf vernÃ¼nftige Bibliotheken setzen.



>> 12.08.2008
[CO]
- Ich entschloss mich dazu die "SimpleList"-Implementation noch ein StÃ¼ck radikaler zu machen... und hier auch keine virtuellen Funktionen
  einzusetzen so das nochmal 4 Byte fÃ¼r die Virtuelle-Tabelle wegfallen. Eine leere "SimpleList" Instanz ist nun also nur noch 4 Byte groÃ.
  "Iterable" und "Container" Funktionen sind wie gehabt da und lassen sich genauso nutzen, auch sind weiterhin Funktionen drinnen die
  Daten von "Container" Ã¼bernehmen kÃ¶nnen - nur kann man "SimpleList" nicht mehr auf "Container" oder gar "Iterable" casten. Da Sinn
  und Zweck dieser Implementation jedoch ist "so Speichereffizient wie irgend mÃ¶glich sein", kann man das denke ich rechtfertigen
  das diese Klasse etwas aus der "Container"-Reihe tanzt.
- Die internen Daten von "SimpleList" sind nun von auÃen Zugreifbar fÃ¼r maximale Optimierungs mÃ¶glichkeiten. Das ist zwar sehr unschÃ¶n
  und Riskant - aber diese Klasse sollte man eh nur nutzen wenn man genau weis was man will und warum. Die Vorteile Ã¼berwiegen hier
  wie man in PLCore::Event sehen kann die Nachteile finde ich.
PLCore:
- Dadurch das "SimpleList" von PLGeneral nun keine Virtuelle-Tabelle mehr besitzt wurden Event und EventHandler Instanzen noch
  kompakter. Vorher:
    Event        = 12 Byte
    EventHandler = 20 Byte
  nun
    Event        = 8 Byte
    EventHandler = 12 Byte
  ... ich denke NOCH weiter runter mit dem Speicherverbrauch ohne coole FunktionalitÃ¤t einbÃ¼Ãen zu mÃ¼ssen kÃ¶nnen wir nicht mehr.
  Event ist nun dank "SimpleList" also nur noch halb so 'groÃ' wie vorher, EventHandler sogar nur noch ein drittel so groÃ. :D
- Entfernte 'm_nNumOfHandlers' im Event, dadurch ist ein Event nun nur noch 4 Byte groÃ - mal schaun ob man da noch irgendwo
  reduzieren kann... *g*
  Das entfernen wurde mÃ¶glich da ich Zugriff auf die internen "SimpleList" Daten nun public machte - so kann man 'sehr Performant'
  Ã¼ber die Daten iterieren - genau das was man hier ssseeeeehr oft macht, und daher wÃ¤re das Ã¼ber einen Iterator gehen der intern
  Dynamsich erzeugt werden muss nicht zumutbar gewesen.



>> 11.08.2008
[CO]
- Bugfix: Directory::CreateRecursive(): Hier muss auf jedenfall noch 'GetRoot()' (zur Sicherheit fÃ¼gte ich auch noch 'GetProtocol()' ein)
  beim Pfad vorne eingefÃ¼gt werden - sonst kann es schnell zu Problemen kommen wenn ein absoluter Pfad Ã¼bergeben wurde. Viel mir
  gerade im 3ds Max Scene Exporter auf als 'neben' den gewÃ¼nschten Verzeichnissen auch noch 'sollten nicht da sein'-Verzeichnisse
  erzeugt wurden.



>> 10.08.2008
[CO]
- "SimpleList" angelegt. Da "List" einige Daten speichert um diverse Operationen zu beschleunigen, aber in ein paar Situationen
  man diese Operationen nicht braucht und lieber eine 'super Speicherschonende' Liste hÃ¤tte gibts nun "SimpleList". Startpunkt
  war "List" das ich schrittweise Umformte:
  - 'm_nNumOfElements' raus
  - 'm_pLastElement' raus
  - 'ListElement::pPreviousElement' raus
  -> dadurch ist SimpleList 8 Byte wenn leer im gegensatz zu "List" 16 Byte leer.
PLCore:
- Event und EventHandler Klassen von "List" auf das neue "SimpleList" umgestellt. Vorher
    Event        = 16 Byte
    EventHandler = 36 Byte
  jetzt
    Event        = 8 Byte (+ 4, siehe unten)
    EventHandler = 20 Byte
  -> Ãnderte an ein paar Stellen die Verwendung der Liste damit mÃ¶glichst keine 'ineffizienten' Operatoren genutzt werden.
  Spendierte Event 'm_nNumOfHandlers' das 'GetNumOfElements()' aufrufe bei SimpleList vermeitet - denn diese Operation ist nun
  langsam. Es lohnt denke ich hier aber 4 Byte fÃ¼r bessere Performance zu investieren, denn 'GetNumOfElements()' wÃ¤re sonst
  'sehr hÃ¤uftig' aufgerufen worden. Event ist nun also 12 Byte, aber immer noch 4 Byte kleiner als vorher (davon kÃ¶nnen wir uns
  ein Eis kaufen gehen *g*)... und bei jedem EventHandler den man einhÃ¤ngt spart man nochmal durch die schlankere "SimpleList"
  Implemenation. Lohnt sich also denke ich.



>> 09.08.2008
[CO]
- "PLGeneralStat.vcproj": Gib seine Objekt-Dateien nun in ein eigenes Build-Verzeichniss aus. Ich hatte in letzter Zeit stÃ¤ndig
  Linker fehler beim Ã¼bersetzen - jetzt weis ich auch warum. :D
- MODULE_LICENSE() hinzugefÃ¼gt fÃ¼r die Angabe der Lizenz. Mir war es wichtig das diese Information allerdings auch direkt im Modul
  Abrufbar ist - z.B. damit man Ã¼ber ein Plugin-GUI dann das dort auch bequem sehen kann.
- In Funktionen wie z.B. "ModuleID<T>::SetModuleName()" war der 'Ãberlaufschutz' nicht korrekt Implementiert, so mÃ¼sste das nun
  korrekt sein



>> 09.08.2008
[SB]
PLCore:
- Events: Mittels ConnectBind() kÃ¶nnen nun auch EventHandler an Events eines anderen Typs gebunden werden, wobei die
  Parameter analog zu bind() gebunden werden. Intern wird hier einfach ein EventHandler vom richtigen Typ erzeugt und
  mit dem Event verbunden. Damit dieser dynamisch erzeugte EventHandler auch wieder gelÃ¶scht wird, brauchte es leider
  eine Klasse mit virtuellem Destruktor, die in eine Liste beim EventHandler eingetragen wird. Dies wird aber nur dann
  benÃ¶tigt, wenn wirklich mal ein Event 'umgebogen' wird, im Normalfall bleibt die Liste leer. Ich hoffe, dass dies so
  am besten ist und damit Ã¼bereinstimmt, wie Events und Handlers grÃ¶Ãtenteils benutzt werden. Sollte sich herausstellen,
  dass man die meiste Zeit ConnectBind benutzt, sollte man sich vielleicht eine andere LÃ¶sung Ã¼berlegen, die 'teurer' ist
  fÃ¼r den Normalfall, dafÃ¼r aber 'billiger' fÃ¼r den Bind-Fall. Bitte beachten, dass die Functors und Events zur Zeit noch
  getestet werden, einiges ist noch nicht so stabil wie es sein soll (z.B. wenn man mal die falsche Anzahl Parameter Ã¼bergibt).
  Das Ã¼berarbeite ich gerade nochmal, die FunktionalitÃ¤t sollte aber so bleiben wie sie ist.



>> 08.08.2008
[CO]
- Loadable::Reload(): Funktionierte unter umstÃ¤nden nicht korrekt da direkt eine Referenz auf einen 'internen' String Ã¼bergeben
  wurde der wÃ¤hrend des Ladevorgangs verÃ¤ndert werden kann - und schon klappte das Neuladen nicht mehr. (altbekanntes "Problem" :)



>> 06.08.2008
[CO]
PLCore:
- 'ShutDown()' und 'IsShutDown()' Methoden in die 'Application'-Klasse eingebaut. Dies ist identisch zu dem was in
  der alten 'PLEngine::PL'-Klasse ist und das wie ich finde schon immer sehr gut funktionierte. FÃ¼gte desweiteren
  eine virtuelle 'OnShutDown'-Methode hinzu die innerhalb 'ShuwDown()' aufgerufen wird.
- 'Application'-Klasse: "OnRun()" Implementationen geben im 'normalfall' "GetExitCode()" zurÃ¼ck, nur im Fehlerfall was
  eigenes wie z.B. "-1" - so kann ein User der nur die Application Klassen nutzt Ã¼ber "SetExitCode()" einen Error Code
  setzen der zurÃ¼ckgegeben werden soll



>> 03.08.2008
[CO]
PLCore:
- 'Application'-Klasse um 'Name' erweitert, dies ist recht nÃ¼tzlich da man dann z.B. direkt anhand dieses Namens z.B.
  den Standard-Titel eines Fensters setzen kann.
- 'Base'-Verzeichniss mit alter Event und Functor Implementation gelÃ¶scht



>> 02.08.2008
[SB]
PLCore:
- Bind-FunktionalitÃ¤t fÃ¼r Funktoren hinzugefÃ¼gt. Damit ist es mÃ¶glich, Parameter eines Funktors zu binden, also
  auf einen festen Wert zu setzen und damit die Signatur einer Funktion zu verÃ¤ndern. Diese Implementation erlaubt
  es auch, Eingabeparameter und gebundene Werte frei festzulegen und damit die Reihenfolge, Anzahl und Art
  der Parameter des neu erzeugten Funktors fast beliebig bestimmen zu kÃ¶nnen. Ergebnis der Bind-Funktion ist
  ein Funktor, dessen Signatur durch die verwendeten Parameter komplett festgelegt ist und der daher selbst
  wieder typensicher ist.

  Anwendung:
    Beispielsweise kann man auf diese Weise einen weiteren Parameter hinzufÃ¼gen, um z.B. bei Events noch
    einen Zeiger auf das Objekt mitzuliefern, das dieses Event erzeugte (z.B. Window* oder SceneNode*).
    Durch die Verwendung von bind wird ein Funktor erzeugt, der wieder kompatibel zum Event des jeweiligen Objektes
    ist.

  Verwendung:
    bind(f, t0, t1, ...)
    - f: Eingabe-Funktor, der letztlich mit geÃ¤nderten Parametern aufgerufen wird
    - t0: Wert fÃ¼r Parameter 0
    - t1: Wert fÃ¼r Parameter 1
	- etc.

    Anstelle von echten Werten fÃ¼r Parameter kÃ¶nnen Platzhalter verwendet werden, um die Parameter
    des erzeugten Funktors durchzureichen:
	- _0: Platzhalter fÃ¼r Parameter 0
	- _1: Platzhalter fÃ¼r Parameter 1
	- etc.

  Beispiele:
	// Define a test functor of type void(int, float)
	Functor<void, int, float> f(Function);

	// Call directly
	f(1234, 0.25f);

	// Bind first parameter -> getting functor of type void(float)
	bind(f, 1234, _0)(0.25f);

	// Bind second parameter -> getting functor of type void(int)
	bind(f, _0, 0.25f)(1234);

	// Bind both parameters -> getting functor of type void()
	bind(f, 1234, 0.25f)();

	// Exchange parameters -> getting functor of type void(float, int)
	bind(f, _1, _0)(0.25f, 1234);

	// Just to show the resulting functor's type
	Functor<void, float> f2 = bind(f, 100, _0);
	f2(0.1f);



>> 29.07.2008
[SB]
PLCore:
- FunctorTools hinzugefÃ¼gt und Funktionen erstellt, um einen Funktor zu erzeugen. Das dient vor allem der
  Ãbersichtlichkeit, damit man nicht stÃ¤ndig die ganzen Template-Parameter schreiben muss, gerade wenn man
  spÃ¤ter mit bind etc. die Funktoren noch ineinander schachteln muss. Ich habe mich dabei an die Ã¼blichen
  Benennungen gehalten, die man in den meisten anderen Signal/Slot Implementationen findet: ptr_fun()
  erzeugt einen Funktor fÃ¼r eine statische Funktion, mem_fun() erzeugt einen Funktor fÃ¼r eine Memberfunktion.
- 'Types' in 'Traits' umbenannt, was eine Ã¼bliche Bezeichnung fÃ¼r solche Typendefinitions-Klassen ist. Die Klasse
  heisst nun FunctorTraits und wurde ausserdem in eine eigene Headerdatei ausgelagert, die allerdings "Traits.h" heiÃt.
  ZusÃ¤tzlich wurde auch noch Functor selbst in die Klasse aufgenommen, damit man alle benÃ¶tigten Datentypen dort beisammen hat.
- Analog zum Functor auch bei den Events Types in Traits umbenannt.
- Weitere Klassen umbenannt:
    FuncImpl   -> FunctorImpl (Dateiname ist trotzdem "Impl.h" und nicht "FunctorImpl.h", damit alle Impl's beisammen stehen)
    FuncTyped  -> ImplTyped
    FuncPtr    -> ImplFunPtr
    FuncMemPtr -> ImplMemPtr
  sowie
    FunctorTools -> Tools



>> 28.07.2008
[SB]
PLCore:
- Functor und Events nochmal Ã¼berarbeitet und Ã¼bersichtlicher gestaltet (mehrere Dateien).
- Beide Klassen sind nun erstmal so einfach wie mÃ¶glich gestaltet, dass heiÃt mÃ¶glichst wenig Ableitungen und
  dadurch auch weniger virtuelle Destruktoren. Mal schauen, ob es fÃ¼r das neue RTTI notwendig ist, diese Klassen doch
  noch einmal aufzubohren (und dadurch evtl. doch wieder einiges virtuell machen zu mÃ¼ssen), ich fÃ¤nde es aber schÃ¶n,
  wenn die Klassen so bleiben kÃ¶nnten, wie sie jetzt sind.
- ManagedEventHandler entfernt, da mir das nie wirklich gefallen hat (leicht unsicher, falls das falsch benutzt worden wÃ¤re).
  EventHandler sollten lieber als direktes Attribut einer Klasse instanziiert werden statt Ã¼ber new, und falls es doch
  jemand dynamisch braucht, muss er eben selber dafÃ¼r sorgen, dass die erzeugten Objekte auch wieder gelÃ¶scht werden.
- Sowohl Functor als auch EventHandler haben nun wieder einen Default Konstruktor. Es ist zwar schÃ¶n, wenn es keine Probleme
  gab ohne Default-Konstruktor, jedoch nimmt uns das die MÃ¶glichkeit, Funktoren oder EventHandler beispielsweise in einer
  Liste zu speichern oder in anderen Situationen, wo es notwendig ist, zunÃ¤chst einmal das Objekt Ã¼ber den Default-Konstruktor
  zu initialisieren und den wirklichen Wert erst spÃ¤ter zuzuweisen. Da beide Klassen so gestaltet sind, dass es problemlos
  mÃ¶glich ist, zunÃ¤chst einmal ein leeres Objekt zu erzeugen und erst spÃ¤ter einen Zeiger auf eine wirkliche Funktion zu setzen,
  sollten wir uns diese MÃ¶glichkeit nicht unnÃ¶tig verbauen. Abgesehen davon hat das Entfernen des Default-Konstruktors
  von EventHandler das Problem nicht wirklich gelÃ¶st, weil das eigentliche Problem im Functor lag und nicht im EventHandler,
  ein leerer Functor hÃ¤tte daher immernoch zum Crash gefÃ¼hrt. Das wurde nun behoben, da ein leerer Functor jetzt eine Null-Funktion
  aufruft, anstatt wie bisher einfach abzustÃ¼rzen :-)
- Ein EventHandler kann nun auch auf mehrere Events hÃ¶ren, womit es grÃ¶Ãtenteils wirklich unnÃ¶tig sein sollte, EventHandler dynamisch
  zu erzeugen. Christian: Bitte nochmal genau meine Implementation durchschauen, da bei so etwas leicht Fehler passieren (NxM Beziehung,
  beide Objekte mÃ¼ssen sich im Destruktor aus der Liste des jeweils anderen Objektes austragen, das wird leicht ganz schÃ¶n kniffelig).



>> 23.07.2008
[CO]
- Neue System-Funktion: 'GetUserHomeDir()' liefert das 'Home Directory' des aktuellen Benutzers zurÃ¼ck - dort kann/sollte
  man dann immer Dinge wie Konfigurationen, Screenshots etc. speichern so das dort wo das eigentliche Programm gespeichert
  ist NICHTS dynamisches gespeichert wird. Das ist unter Unix scheinbar so gÃ¤ngig + unter Vista wird da wie es aussieht
  auch Wert drauf gelegt... jedenfalls muss man dort dann erst Verzeichnissattibute Ã¤ndern bevor Logs etc. im Programm
  Verzeichniss geschrieben werden kÃ¶nnen...
  -> PLGeneral ist dadurch nun auch von 'Userenv.lib' AbhÃ¤ngig, das sollte aber kein Problem sein. Man hÃ¤tte sicherlich
     auch irgendwie in der Registry herumfummeln kÃ¶nnen, was aber nicht ganz so prall sein soll - dann lieber gleich
     Funktionen die das OS dafÃ¼r bereitstellt nutzen. :D
  -> Linux Implementation 'mÃ¼sste so passen', aber da ich es nicht testen konnte ist es Auskommentiert.



>> 21.07.2008
[SB]
- HTMLParser implementiert. Diese Klasse liest eine HTML-Datei ein und erzeugt daraus ein XML-Dokument. Besonders robust ist
  der Parser sicherlich nicht, allerdings habe ich versucht, viele typische Fehler in HTML-Dateien (z.B. falsch geschlossene Tags
  oder gemischter HTML und XML-Syntax) zu berÃ¼cksichtigen, so dass die Datei dennoch eingelesen werden kann. Die Klasse ist
  aber ein reiner Parser und beinhaltet keinerlei HTML-Semantik (was heiÃt, dass semantische Regeln, wie z.B. <li> kann nur in
  Listen vorkommen oder <tr> nur in Tabellen, nicht Ã¼berprÃ¼ft werden kÃ¶nnen). 



>> 18.07.2008
[CO]
- ClassManager::LoadPlugin(): Um Format Versions Informationen erweitert ('plugin'-Dateien)



>> 10.07.2008
[CO]
- ConfigLoaderPL & LocalizationLoaderPL: Um Format Versions Informationen erweitert



>> 09.07.2008
[CO]
- LoadableManagerLoaderPL: Um Format Versions Informationen erweitert. So wird es ZukÃ¼nftig dann in all unseren XML Formaten gehandhabt.
- Loader: Ein paar 'Standard Strings' hinzugefÃ¼gt



>> 08.07.2008
[SB]
- Statische Version von PLGeneral hinzugefÃ¼gt. Ich denke, PLGeneral und evtl. spÃ¤ter noch PLGui sollten erstmal als statische
  Bibliotheken ausreichen, damit man kleine Tools auch ohne AbhÃ¤ngigkeit von der PixelLight-Runtime schreiben kann (gerade
  auch wichtig fÃ¼r unsere internen Tools).



>> 04.07.2008
[CO]
PLCore:
- EventHandler: Standard Konstruktor entfernt da es ansonnsten einen Crash gibt wenn man einen nicht Initialisierten
  EventHandler nutzt - eine Situation die es auf jedenfall zu vermeiden gilt. Habe bei mir diesen Konstruktor schon seit
  Wochen auskommentiert und es gab keine Probleme.



>> 29.06.2008
[SB]
PLPluginMozilla:
- PLPluginMozilla implementiert.
- Anbindung an unsere abstrakte Plugin-Klasse vorgenommen und PixelLight-Plugin erfolgreich im
  Mozilla ausgefÃ¼hrt.



>> 28.06.2008
[SB]
PLPlugin:
- Projekt gestartet. PLPlugin stellt eine Schnittstelle zur VerfÃ¼gung, um PixelLight als Plugin in andere
  Umgebungen/Applikationen einzubinden. Also PixelLight als Plugin fÃ¼r z.B. Browser, nicht Plugins fÃ¼r PixelLight :-)
  Dazu wird eine abstrakte Plugin-Klasse bereitgestellt, die von konkreten Wrappern fÃ¼r verschiedene Plugin-Schnittstellen
  angesprochen wird. Von dieser Plugin-Klasse werden dann konkrete Plugins abgeleitet, z.B. das standard PixelLight-Plugin,
  das wir letztlich im Browser oder sonstwo sehen wollen.
- Basisklasse Plugin implementiert, die das abstrakte Plugin-Interface darstellt.
- Basisklasse PluginImpl implementiert, die nach dem Backend-Prinzip das Interface
  fÃ¼r konkrete Backends bereitstellt.
- PluginOpenGL als Testplugin implementiert, in dem eine minimale OpenGL Szene angezeigt wird.
- PluginPixelLight erstellt fÃ¼r das standard PixelLight-Plugin. 
- Das Triangle-Sample genommen und als vorlÃ¤ufiges PixelLight-Plugin implementiert :-)
PLPluginActiveX:
- PLPluginActiveX implementiert. Diese konkrete Implementation von PluginImpl
  stellt das ActiveX Backend fÃ¼r unsere eigene Plugin-Klasse dar.
- Den Wrapper auf die Verwendung unseres abstrakten Plugin-Interfaces umgestellt.
- Den OpenGL-Test hier entfernt und dafÃ¼r als PluginOpenGL in PLPlugin implementiert.
- Das PixelLight-Plugin lÃ¤uft nun zum ersten Mal korrekt im Browserfenster :-)



>> 24.06.2008
[SB]
PLPluginActiveX:
- Projekt gestartet. PLPluginActiveX ist ein Container und Wrapper fÃ¼r ActiveX, Ã¼ber den das PLPlugin-Interface unter
  ActiveX verwendet werden kann.
- ActiveX control erstellt und an unsere Projektstruktur angepasst. Einstellungen
  gefunden, die zur Einbindung von OpenGL erforderlich sind.
- Kleines OpenGL Testplugin implementiert.



>> 22.06.2008
[CO]
- System Klasse um 'GetCurrentThread()' erweitert - das nutzen wir in verschiedenen Vorlesungen des Ã¶fteren mal und kann ganz hilfreich sein.
  Rauszufinden wie man diese Funktion intern realisieren kann war allerdings etwas - knifflig. Leider scheint es weder bei Windows
  noch bei Linux mÃ¶glich zu sein an die Funktions Parameter zu kommen die man einem Thread beim erzeugen gegeben hat. Daher muss man
  das leider etwas umstÃ¤ndlicher anpacken um an die PixelLight Thread Instanz des aktuellen Threads zu kommen:
  - Unter Windows lÃ¤sst sich das mit 'Thread Local Storage' (TLS) realsieren, bis auf die unschÃ¶ne Globale Variable ganz ok wÃ¼rd ich sagen
  - Unter Linux kann man dafÃ¼r denke ich 'pthread_getspecific()' nutzen (fand das zuerst, und schaute dann obs unter Windows etwas
    Ã¤hnliches gibt :)
  Ich habe das direkt mal in 'PLPhysics::WorldThread' ausprobiert, klappt ganz wunderbar. :D
  Sobald die Linux Variante Implementiert ist wÃ¼rde ich gerne 'System::Sleep()' wieder nach 'Thread::Sleep()' verschieben da es fÃ¼r mich
  einfach dorthin gehÃ¶rt und man es in 'neuen Sprachen' wie Java oder C# ebenfalls in der Thread Klasse findet was ich sehr nett finde. Zwar
  ist 'System::GetInstance()->Sleep(100)' 'kompakter' zu schreiben als 'System::GetInstance()->GetCurrentThread()->Sleep(100)', aber irgendwie
  ist das einfach eine Thread Verwaltungs Funktion die fÃ¼r mich nix in der 'allgemeinen System'-Klasse zu suchen hat, auch wenn man diese auf
  dem aktuell laufenden Thread ausfÃ¼hrt. Bei Zeiten wÃ¼rde ich dann auch noch gerne eine 'Thread::Yield()'-Funktion hinzufÃ¼gen damit wir die
  meisten gÃ¤ngigen Thread Funktionen haben.
- Threads kÃ¶nnen nun auch einen von Menschen lesbaren Namen haben, gerade beim Debugging oder Thread Experimenten ist das sehr hilfreich
- Neue System Funktion: 'Yield()' -> veranlasst im Normallfall den aktuellen Thread den Prozessor aus der Hand zu geben, ebenfalls eine gÃ¤ngige
  Funktion. Habe das erstmal in die System Klasse eingebaut da dort auch die 'Sleep()'-Funktion ist. Hier mÃ¼ssten wir uns wie gesagt nochmals
  Ã¼berlegen ob wir das wirklich in der System Klasse lassen wollen oder nicht lieber in die Thread Klasse schieben damit die Thread Dinge
  beisammen sind... auch wenn diese Funktionen auf den 'aktuell laufenden Thread' arbeiten und nicht auf die Thread Instanz was ein klein wenig
  verwirrt, aber das ist auch bei Java und C# so. (im aktuellen Semester habe ich wie gesagt sehr viele Vorlesungen die sich mit Threads in
  verschiedensten Sprachen befassen :) Wir mÃ¼ssen uns das nicht sofort nochmal anguckn ob wir das in der System Klasse haben wollen oder das so
  machen wie es mittlerweile viele API's handhaben und das den "Umstieg auf PixelLight" etwas einfacher machen kÃ¶nnte. :)



>> 21.06.2008
[SB]
PLCore:
- Neue Klasse Core hinzugefÃ¼gt, die statische Funktionen bereitstellt, um Informationen Ã¼ber die gesamte
  PixelLight-Installation abzufragen (z.B. Installationspfad, Versionsnummer etc.). GetRuntimeDirectory
  wurde von PLEngine hierher verschoben, und Ã¼berall, wo der Installationspfad abgefragt wurde, wird nun
  diese Funktion verwendet (sowas sollte wenn mÃ¶glich immer zentral an einer Stelle sein und nich dupliziert
  werden).
- Die Informationen Ã¼ber das aktuelle SDK werden nun aus der Datei PixelLight.h genommen, die im Verzeichnis
  /PixelLight zu finden ist (siehe PLSDK)



>> 01.06.2008
[SB]
- RTTI: Es war immer noch ein Fehler beim Registrieren von Klassen vorhanden. Wenn die Liste der auf ihre Basisklassen
  wartenden Klassen durchgegangen wird, muÃ die Suche neugestartet werden, damit alle abgeleiteten Klassen auch initialisiert
  werden kÃ¶nnen. Hier war ein saublÃ¶der fehler drin, wodurch die Klassen meistens nicht initialisiert wurden.
  Aus irgend einem Grund ist die Reihenfolge der Initialisierungen unter VC anscheinend ziemlich optimal, so dass dieser
  Fehler da nicht wirklich aufgefallen ist - solange die Klassen in der richtigen Reihenfolge initialisiert werden
  (z.B. erst SceneNode, dann SceneContainer, dann SCPhysics) funktioniert ja alles korrekt. Beim Ãbersetzen mittels
  CMake ist die Reihenfolge, in der compiliert und gelinkt wird, jedoch eine andere, deswegen fiel der Bug hier ins Gewicht
  und beim AusfÃ¼hren konnten Klassen nicht gefunden werden, da diese nicht richtig am RTTI angemeldet wurden.
  Ich habe jetzt keine Probleme mehr feststellen kÃ¶nnen, auch wenn ich mit CMake das Ãbersetzen starte, funktionieren hinterher
  alle Samples korrekt und das dubiose Problem, dass z.B. "SceneNode" nicht gefunden wird, ist nicht mehr vorhanden. Ich hoffe
  mal, dass dies auch meine Probleme unter Linux lÃ¶st (dort wurden die Loader nicht gefunden, dÃ¼rfte ziemlich sicher das
  gleiche Problem gewesen sein). 
- RTTI: Da es sehr blÃ¶d ist, das RTTI zu debuggen, wenn es aus irgend einem Grund nicht richtig funktioniert, und man hier
  auch nicht einfach ins Log schreiben kann, da dies ebenfalls schon ein funktionierendes RTTI voraussetzt, habe ich ein neues
  Makro eingebaut, um das RTTI zu debuggen. Normaler Weise ist das deaktiviert, wenn man es aber aktiviert, werden RTTI-AktivitÃ¤ten
  mit einfachen stdio-Methoden in einer festgelegten Datei (C:\rtti.txt) geloggt. Das dÃ¼rfte es etwas vereinfachen, Problemen
  mit dem RTTI auf die Schliche zu kommen.



>> 22.05.2008
[CO]
- 'Informer' und 'Listener' Templates entfernt da wir zukÃ¼nftig wie von Stefan vorgeschlagen auf das 'Event'-Konzept setzen das ich mittlerweile
  auch sehr nett finde. Diese zwei Templates wurden nur von 'SceneNode' und 'SceneQuery' innerhalb von 'PLEngine' verwendet, hier werden nun
  'Events' genutzt.



>> 16.05.2008
[CO]
- Wie besprochen liegen System Konsolen Funktionen nun in einer eigenen Klasse die man Ã¼ber 'System::GerInstance().GetConsole()' bekommt
- XML-Klassen: Interessant. Mir viel gerade als ich Stefans Ãnderungen durchschaute zum ersten mal das 'XmlDocument::SetTabSize()' beim speichern
  Ã¼berhaupt keine Auswirkung hat da intern immer direkt "    " geschrieben wird. Als ich in den TinyXML Codes nachschaute sah ich das die
  das ebenfalls vergessen haben... oder es warum auch immer gewollt ist. Bei uns ist das jedenfalls nicht gewollt da ich keinen Grund finden
  kann warum die 'XmlDocument::SetTabSize()'-Einstellung ignoriert werden sollte. Darum ging ich die Funktionen die speichern nochmal durch
  und korrigierte das + nutzte '' anstatt "" wo nur ein Zeichen genutzt wird. (die String Klasse kann damit etwas Effizienter arbeiten :)
- XmlNode::GetDocument(): Auch hier war noch ein fieser Bug drinnen. Wow, Respekt, dieses Kerlchen hat sich aber ziemlich lange tapfer im
  Code halten kÃ¶nnen. *g*



>> 17.04.2008
[CO]
- SystemWin32::GetCurrentDir(): Gab das Verzeichniss 'Native' zurÃ¼ck. Da in der Dokumentation nix steht und in Programmen normalerweise
  wenn immer mÃ¶glich nicht mit 'Native' gearbeitet werden sollte Ã¤nderte ich das. Dies merkte ich durch 'LoadableType::GetRelativeFilePath()'
  das nicht mehr korrekt ging da alle Basis-Pfade im LoadableManager ein Protokoll vorne haben, aber das von 'System::GetCurrentDir()'
  keines hatte was hier nicht wirklich hilfreich ist. :D
- 'LoadableType::GetRelativeFilePath()': Da 'SystemWin32::GetCurrentDir() & CO' am Ende keinen Slash haben musste hier nun an einer Stelle
  '+1' eingefÃ¼gt werden. Nun arbeitet diese Funktion wieder korrekt.



>> 05.04.2008
[SB]
- PLMain so umgeÃ¤ndert, dass man nun immer den Dateinamen und die Parameter Ã¼bergeben bekommt. Das wird so auch
  an die Application-Klasse weitergegeben, so ist das einheitlich und man braucht sich nicht mehr zu fragen, ob
  Parameter[0] jetzt der Dateiname ist oder der erste Parameter. Damit dies unter allen System vernÃ¼nftig funktioniert,
  waren noch ein paar Anpassungen nÃ¶tig. Man kÃ¶nnte nun Ã¼berlegen, die Funktion GetProgramName() aus System herauszunehmen,
  damit man das nicht doppelt hat. NatÃ¼rlich kÃ¶nnte man das dann nur noch nutzen, wenn man auch die Application-Klasse
  nutzt (was man allerdings tun sollte, da es nur Vorteile bringt).
PLCore:
- Mit der Arbeit am Application-Framework begonnen. Die Klasse Application ist die Basisklasse und wrappt
  die Hauptfunktion des Programmes. Alles weitere wird durch Spezialisierungen in anderen Projekten (z.B. PLGui)
  hinzugefÃ¼gt.



>> 05.04.2008
[CO]
- ThreadLinux: Speichert intern das vom Benutzer gesetzte 'PriorityClass' und 'Priority' damit sich das rein von den RÃ¼ckgabewerten
  her wie unter Windows verhÃ¤lt. Linux selbst hat eine Funktion Namens 'pthread_setschedparam' zum setzen der Thread PrioritÃ¤t - allerdings
  ist 'SCHED_OTHER' als Default-Strategie gesetzt und in dem Fall sind keine Thread PrioritÃ¤ten zulÃ¤ssig da dies komplett der Kernel
  Ã¼bernimmt. Damit hat sich das mit den Thread PrioritÃ¤ten unter Linux also erledigt.



>> 05.03.2008
[SB]
- MuÃte die Verwendung des Null-Objektes noch etwas verÃ¤ndern: In (Standard-)C++ ist es nicht erlaubt, statische Member
  Ã¼ber Objekte anzusprechen. So etwas wie m_lstObjects->Null geht also nicht, es muÃ List<Object>::Null heiÃen. Leider
  scheint Visual C++ immer noch nicht standardkonform zu sein, da es hier keinerlei Fehler oder Warnungen gab. FÃ¼r den
  gcc dagegen ist m_lstObjects->Null ganz einfach unbekannt. Habe alles angepaÃt und hoffe, dass es nun so unter beiden
  Compilern funktioniert.



>> 05.03.2008
[CO]
- Wie besprochen geben nun die Container Referenzen statt Zeiger zurÃ¼ck... die Klassen waren schnell verÃ¤ndert, das hatte
  ich gestern bereits fertig -  alle Projekte entsprechend anzupassen war allerdings 'etwas' mehr Aufwand der sich allerdings
  definitiv gelohnt hat. Stellen wo Zeiger genutzt werden mÃ¼ssten unproblematisch sein da soetwas wie 'if (!...)' oder nur
  'if (...)' weiterhin klappt. Sollte allerdings in den Containern ohne Zeiger gespeichert sein, so kÃ¶nnen diese Abfragen
  teils immer noch Ã¼bersetzt werden - aber das was abgefragt wird ist dann nicht mehr ob das zurÃ¼ck bekommene Element gÃ¼ltig
  ist, sondern dann wird direkt der Wert dieses Elements getestet. Bei soetwas wie 'int' gespeichert meckert das dann natÃ¼rlich
  der Compiler nicht an - das kann ganz bÃ¶se nach hinten losgehen. Eine solche Stelle fand ich bereits, aber um 'alle' zu finden
  mÃ¼ssen wir Ã¼berall wo Container genutzt werden ohne Zeiger nochmal suchen und durchschauen. :/
  Bin schon schwer gespannt was ich so alles Ã¼bersehen habe... entweder findet es Stefan oder die Zeit. *g*



>> 03.03.2008
[SB]
- Neuer PLGeneral-Datentyp 'handle'. Es ist irgendwie blÃ¶d, stÃ¤ndig auf uint32 casten zu mÃ¼ssen oder gleich
  void-Pointer zu Ã¼bergeben, wenn es um System-Handles geht. Meistens sind diese auf einem System immer vom
  gleichen Datentyp, bei Windows wird HANDLE (DWORD) verwendet, bei Linux ist es meistens int. Daher definiere
  ich das nun in einem PLGeneral-Datentyp 'handle', der fÃ¼r alle Systemhandles verwendet werden soll. Ebenfalls
  wird auch INVALID_HANDLE je nach System fÃ¼r ungÃ¼ltige Handles definiert. Dieser Datentyp sollte nicht hÃ¤ufig
  Verwendung finden, aber manchmal braucht man eben auch die MÃ¶glichkeit, Ã¼ber unsere Datentypen wieder an
  System-Handles heranzukommen. Das kÃ¶nnen wir nun Ã¼ber diesen Datentyp machen, anstatt das vÃ¶llig undefiniert
  zu lassen oder fÃ¼r verschiedene Situationen unterschiedliche Datentypen zu definieren (wie frÃ¼her MODULE_HANDLE).
- FileStdStream erweitert: Es kann nun entweder ein beliebiger Stream-Pointer Ã¼bergeben werden (FILE*),
  oder ein File-Handle des jeweiligen Systems (int unter Linux, HANDLE unter Windows). Falls ein File-Handle
  Ã¼bergeben wird, muÃ hinterher die Datei noch geÃ¶ffnet werden, wobei die bekannten Flags (Read/Write/Text/etc.)
  verwendet werden kÃ¶nnen. Im Falle eines FILE*-Pointers mÃ¼ssen die Access-Flags, die verwendet wurden um die Datei
  zu Ã¶ffnen, mit Ã¼bergeben werden. Somit ist es mÃ¶glich, eine beliebige bereits geÃ¶ffnete oder sonstwie zurÃ¼ckgegebene
  Datei trotzdem Ã¼ber unseren File-Wrapper anzusprechen. Die Standard-Streams (in/out/err) sind da nur ein Beispiel,
  es kÃ¶nnen jetzt aber auch beliebige andere Dateien oder Pipes so verwendet werden.
- Statt void* wird nun FILE* Ã¼bergeben, da dieser Datentyp feststeht und sich auch nicht je nach System unterscheidet.

  Da dadurch jetzt leider schon in File <stdio.h> benÃ¶tigt wird, habe ich die FILE-Vordefinition in eine eigene
  Headerdatei ausgelagert, wo nach Windows und Linux unterschieden wird. Damit wird <stdio.h> wirklich nur da
  eingebunden, wo es unbedingt nÃ¶tig ist, ohne die Includes Ã¼berall mit #ifdef's zu verunstalten :-)
- File: Konstruktoren zum Ãffnen schon vorhanderer Streams/FileHandles via FileStdStream eingebaut bzw.
  Ã¶ffentlich gemacht.
- File: IsOpen() hinzugefÃ¼gt
- Ãberall Writeable durch Writable ersetzt. Es scheint zwar beides richtig zu sein, aber writable ist mir irgendwie
  gelÃ¤ufiger - und in meinem Dictionary ist diese Variante fettgedruckt :-)
- Neue Klasse Pipe eingebaut, Ã¼ber die System-Pipes (named und unnamed) erstellt und angesprochen werden kÃ¶nnen.
- Neue Klasse Process eingebaut, die benutzt werden kann, um externe Prozesse zu starten. Dabei kann die
  Ein- und Ausgabe umgeleitet werden und hinterher Ã¼ber unsere File-Klasse ausgelesen/geschrieben werden. Das ist
  eine FunktionalitÃ¤t, die man immer mal wieder braucht, und die mit OS-Funktionen ein absoluter Krampf ist. Darum
  mÃ¶chte ich gerne PLGeneral soweit vollstÃ¤ndig haben, dass man alles sowas schÃ¶n einfach und komfortabel damit machen
  kann :-)



>> 02.03.2008
[CO]
- Ãnderte in den Container-Klassen 'AType' zu 'ValueType' damit das hier Ã¼berall gleich geschrieben ist und somit
  Doxygen bei z.B. dem Iterator eine 'komplette' Klassenhierarchie zeigt und nicht nur die 'Container' Klassen
- Bugfix: Directory::CreateRecursive(): Trotz meiner bei der Implementation merkwÃ¼rdigerweise erfolgreichen Tests
  (eventuell nicht sonderliche pralle Test Situation erzeugt :) war die Implementation noch nicht ganz ok... Stefan
  hatte ja schon die korrekte Funktionsweise angezweifelt, so 'mÃ¼sste' es nun aber klappen.



>> 29.02.2008
[CO]
- "ConstIterator" hinzugefÃ¼gt, bin mir allerdings nicht sicher ob das den 'Todo'-Punkt
  "Const_Iterator (currently we can't return some lists)" korrekt behandelt. Hoffentlich geht das so halbwechs,
  wÃ¤hre heftig wenn wir nochmal komplette Iterator Implementationen fÃ¼r 'const' schreiben mÃ¼ssten. :/
  Wenn das passt, wÃ¤re es sicherlich ne gute Idee bei 'Iterable::GetIterator()' und 'Iterable::GetEndIterator()'
  das 'const' hinten heraus zunehmen + die mÃ¶glichkeit einen Iterator einem ConstIterator zuzuweisen.
  (anderst herum natÃ¼rlich nicht *g*)



>> 28.02.2008
[CO]
Alle Projekte:
- Nahm wie besprochen Ã¼berall dort wo 'inline' genutzt wird die Export Makros heraus. (siehe Eintrag 24.02.2008
  von Stefan) Damit man an diesen Stellen sehen kann das es absicht ist das hier kein Export Makro ist habe ich
  dort dann jeweils 'inline' reingeschrieben. (ist also nix 'funktionales', sondern als Hilfe/GedÃ¤chtnissstÃ¼tze
  gedacht)
PLGeneral:
- 'SubString' und 'Sub-String' in 'Substring' umbenannt da man diese Schreibweise heute am hÃ¤ufigsten antrifft
- String::String(const utf8 *pnValue) muss natÃ¼rlich raus da der Compiler hier nicht zwischen den zwei entsprechenden
  Konstruktoren unterscheiden kann (dank Default Einstellungen sieht das dann fÃ¼r ihn gleich aus :)
- String: "String operator +(utf8 nValue) const;" macht natÃ¼rlich nicht wirklich viel Sinn da dies eigentlich immer
  ein 'Array von utf8' ist, nahm es heraus. Das gleiche bei "String::operator +=(utf8 nValue)" und
  "friend String operator +(utf8 nValue, const String &sString)" und "GetUTF8Char()" und "Replace(utf8 nOld, utf8 nNew)".
  "SetCharacter()" mit UTF8 braucht natÃ¼rlich einen Zeiger.
- Bugfix: "String(const utf8 *pszString, bool bCopy, uint32 nLength, uint32 nNumOfBytes)": "UTF8Tools::GetNumOfCharacters()"
  sollte man natÃ¼rlich auch die Anzahl der Bytes mitgeben...
- "Functions.cpp": "HashFunction::Hash(const String &sKey)": Hier sollten Fallunterscheidungen fÃ¼r die verschiedenen
  Formate gemacht werden... das kÃ¶nnte allerdings schnell zu problemen fÃ¼hren wenn man Formate mischt und sich dann
  wundert wieso man 'bei doch eigentlich scheinbar gleichem String' unterschiedliche SchlÃ¼ssel bekommt. Das sollte
  man sich also dann eventuell nochmal genauer anschaun.
- RegEx: 'Mode' zu etwas universelleren Flags gemacht in denen 'Match' und 'Encoding' gespeichert wird, so braucht
  man fÃ¼r 'Encoding' keine weiteren Parameter. Setzt man kein spezielles 'Encoding'-Flag, so wird das interne
  String Format (ASCII oder UTF8) des Ã¼bergebenen Ausdrucks verwendet. 'Subject' bei 'Match()' wird in dieses
  interne RegEx Format 'gezwÃ¤ngt'. 'Meistens' macht man sich Ã¼ber 'Encoding' keine Gedanken und nutzt nur ASCII,
  in dem Fall kann man das auch hier wie gehabt als Benutzer ignorieren. :D
  UTF8 Support in RegEx Implementation eingebaut, allerdings funktioniert das noch nicht richtig da u.a.
  "UTF8Tools::Unescape()" noch Probleme mit soetwas wie "\\s*(\\w+)\\s*" hat was es dann zu z.B. "s*(w+)s*" umformt +
  einige entsprechenden Funktionen in der String-Klasse noch nicht richtig Implementiert sind. Aber der Anfang wÃ¤re
  gemacht, taste wir uns also mal voran bis das alles korrekt auch mit UTF8 lÃ¤uft...



>> 27.02.2008
[SB]
- Linux-Implementationen der Konsolen- und Memoryfunktionen getestet und wo nÃ¶tig angepasst. Die Datei /proc/meminfo
  sieht bei mir vÃ¶llig anders aus als offenbar in dem Beispiel, da sollte man sich also offenbar nicht drauf verlassen,
  dass der x-te Wert das und das bedeutet. Deswegen Parse ich nun nach den entsprechenden Strings. Worauf ich mich allerdings
  verlasse ist, dass der Wert immer in Kilobyte angegeben ist - hoffe, das ist auch so, ansonsten mÃ¼sste man auch noch nach
  "kB|MB|B" parsen.
- System::ConsolePrint hinzugefÃ¼gt, damit alle Konsolenfunktionen beisammen sind und man nicht nur, um eine kleine
  Konsolenausgabe tÃ¤tigen zu kÃ¶nnen, auch noch File einbinden muss. So wird die Funktion auch gefunden, ansonsten wÃ¼rde
  man sich wohl wundern, dass zwar alle mÃ¶glichen Konsolenfunktionen in System zu finden sind, nur ein simples Print fehlt.



>> 27.02.2008
[CO]
- Bugfix: "XmlBase::XmlBase(void *pData)", "((XmlBase*)m_pData)"... autsch, das sollte natÃ¼rlich
  "((TiXmlBase*)m_pData)" heiÃen, muss irgendwann einmal durcheinander gekommen sein... gab natÃ¼rlich ein
  Speicherleck + ein Test wie 'GetFirstChild() == GetLastChild()' um zu sehen obs nur ein Kind gibt ging natÃ¼rlich
  nicht da jedesmal ein anderer PL XML Knoten zurÃ¼ckgegeben wurde.
- Iteratoren: Ãberarbeitete die Implementation nochmal so das Iteratoren beliebig 'kopiert' werden kÃ¶nnen. Intern
  wird Ã¤hnlich wie bei bei den Strings gearbeitet - Implementationen werden gemeinsam genutzt so lange das mÃ¶glich
  ist und erst wenn sich etwas Ã¤ndert muss 'geklont' werden. Ansonnsten hÃ¤tte man einen ziemlichen Overhead in der
  'Standard Anwendung' z.B. "Iterator<int> cIterator = lstMyList.GetIterator()" da intern dann mehrmals dynamisch
  Speicher angelegt und wieder freigegeben werden mÃ¼sste.
- Neue Funktion: System::SetConsoleCursorPosition(): Wie von Stefan gewÃ¼nscht eine Funktion zum setzen des
  Konsolen Cursors. FÃ¼gte auch 'GetConsoleCursorPosition()' hinzu damit das vollstÃ¤ndig ist.
  Die Linux Implementationen von 'ClearConsoleScreen() & SetConsoleCursorPosition()' mÃ¼sste man noch testen - hab
  hier mal den Weg Ã¼ber ANSI Sequenzen gewÃ¤hlt, diese LÃ¶sung findet man im Internet recht hÃ¤ufig. FÃ¼r
  'GetConsoleCursorPosition()' konnte ich auch nach lÃ¤ngerem Suchen keine einfache akzeptable LÃ¶sung finden.
- SystemWin32: 'GetComputerName()' und 'GetUserName()' ermitteln den nÃ¶tigen Speicher nun automatisch passend.
  'GetProgramName()' hat leider weiterhin eine 'feste' grÃ¶Ãe die ich allerdings von '1024' auf 'MAX_PATH' setzte
  da ich fÃ¼r 'GetModuleFileName()' nix finden konnte das einem zurÃ¼ck gibt wieviel Speicher man denn nun eigentlich
  wirklich braucht.
- System-Klasse um einige Funktionen erweitert Ã¼ber die man Informationen Ã¼ber den Speicher bekommen kann. Dies dÃ¼rfte
  praktisch fÃ¼r Resource Manager sein da diese solche Informationen nutzen kÃ¶nnen um rauszufinden wann es sinnvoll
  ist etwas lÃ¤nger nicht mehr genutzte Resourcen Ã¼ber Bord zu werfen. Diese Funktionen 'kÃ¶nnte' man auch in
  'MemoryManager' halten, allerdings passt es doch am Ende etwas besser in die 'System'-Klasse. Habe in der
  'MemoryManager'-Klasse allerdings ein kleines Kommentar eingefÃ¼gt falls jemand dort zuerst nach diesen Funktionen
  suchen sollte. Die Windows Implementation ist 'sehr' einfach, bei der Linux Implementation ist es ein 'wenig'
  mehr (wie irgendwie fast immer...) aber immer noch im bereich des ertrÃ¤glichen. Den Linux Code mÃ¼sste man noch
  testen ob das so korrekt lÃ¤uft.
  Da es recht viele Funktionen fÃ¼r Speicher Informationen sind Ã¼berlegte ich zuerst ob man diese Informationen nicht
  besser gesammelt in einer Struktur speichert, entschloss mich dann aber dagegen da es Ã¼ber Funktionen irgendwie
  'schÃ¶ner' zu nutzen ist.



>> 26.02.2008
[CO]
- CmdLineParser::CmdArrayToString(): "int argc, const char **argv"-Parameter zu "const Array<String> &lstArray"
  gemacht... das ist universeller so herum. Ansonnsten hÃ¤tte man etwas fÃ¼r 'wchar_t' und 'utf8' hinzufÃ¼gen mÃ¼ssen...
  "#include <string.h>" hinterherwink *g*



>> 24.02.2008
[SB]
- Seit den letzten Ãnderungen lieÃ sich die Engine bei mir unter Windows nicht mehr compilieren, da es beim
  Linken unresolved references auf Tools::FloatToUInt32 und Tools::UInt32ToFloat gab. Das Problem konnte
  durch das Entfernen von PLGENERAL_API vor diesen Funktionen behoben werden. Ich nehme an, dass das
  deswegen erst jetzt auftritt, weil in PLGeneral nun der Header selbst nicht mehr eingebunden wird und
  der Compiler diese Funktionen daher nicht mehr sieht und somit auch nicht compilieren und exportieren kann.
  Da die Funktionen als inline deklariert sind, sollte hier aber sowieso nichts export werden, sondern erst
  beim Einbinden durch den Compiler an die entsprechende Stelle eingesetzt werden. Damit da nichts durcheinander
  kommt (und das inline dadurch nutzlos wird), sollte bei Inline-Funktionen also kÃ¼nftig kein Export-Makro
  mehr verwendet werden.



>> 23.02.2008
[CO]
- PLMain(): 'MODULE_HANDLE hModule' ersatzlos heraus genommen da wir selbst es noch nirgends verwendet haben
  und ich im Augenblick auch nicht wÃ¼sste wofÃ¼r wir das noch brauchen - zumal es dies unter Linux scheinbar
  erst gar nicht gibt. Sollte ein Windows Nutzer es mal fÃ¼r etwas spezielles brauchen, muss er einfach die
  entsprechende Windows Funktion nutzen um an den Module/Instanz-Handle zu kommen... in dem Fall macht er dann
  eh etwas Platform spezifisches. :D
  "PLGeneralLinuxIncludes.h" kÃ¶nnte man nun herausnehmen da komplett leer.
- Habe in PLMain() 'lstArgs' zu 'lstArguments' gemacht, 'args' ist zwar 'gelÃ¤ufig'... aber das muss hier nicht
  sein diese zwanghafte AbkÃ¼rzung. Wird eh nur selten genutzt und daher ist "Schreibaufwand" kein Argument,
  lesbarkeit aber schon. :D
- ParseIntegerArray(), ParseFloatArray(), ParseDoubleArray(), GetFlagsFromString() und GetStringFromFlags() von
  der 'Tools'-Klasse in eine neue 'ParseTools'-Klasse verschoben die sich im 'String'-Ordner befindet
- 'Tools::FlipRB3()'-Funktion in 'PLGraphics::Color3' verschoben + dieses Funktion heiÃt dort nun 'SwapRB'
- 'Tools::FlipRB4()'-Funktion in 'PLGraphics::Color4' verschoben + dieses Funktion heiÃt dort nun 'SwapRB'
- Ein paar Copy-Operators und Copy-Constructors hinzugefÃ¼gt
- Ein paar Copy-Operators und Copy-Constructors entfernt da unnÃ¶tig, sprich, die automatische erzeugten sind
  vÃ¶llig ausreichend. Klassen: Version, Time



>> 18.02.2008
[CO]
- Directory::CreateRecursive() Implementation nochmal Ã¼berarbeitet so das nur Url-Funktionen genutzt werden



>> 17.02.2008
[SB]
- PLGeneral lÃ¤Ãt sich nun wieder unter Linux Ã¼bersetzen. Und manchmal frage ich mich wirklich, wozu ich
  Dinge dokumentiere ...
  Aus FileWin32.h:
    // Hmmmpf, not nice. But better than to include <stdio.h>, and as it must only work on Windows, it might be ok :-)
    struct _iobuf;
   typedef struct _iobuf FILE;
  Hier habe ich doch explizit geschrieben, dass dieser Hack *nur unter Windows* funktionieren wird. Deswegen steht
  da auch "as it must only work on Windows". Und darum war auch im Linux-Header entsprechend <stdio.h> eingebunden,
  weil das da nunmal leider nicht so geht (evtl. kann man es dort anders vordefinieren, aber da die Header da zig
  if's und defines enthalten, wird dies wohl auf jedem System anders aussehen). Und nun wird einfach dieser Kommentar
  kopiert, "Windows" durch "Linux" ersetzt und geglaubt, so ginge das.
  Entschuldigung, aber sowas verstehe ich einfach nicht. Kann man nicht bitte mal vor dem Ãndern davon ausgehen, dass
  andere Programmierer (ich, in diesem Falle) sich auch etwas *dabei denken*, was sie schreiben, und es somit wohl einen
  *Grund* hat, wenn die Forward-Declaration zwar im Windows-Header drin ist, aber im Linux Header nicht? Und wenn man dann
  trotzdem meint, dass das alles Quatsch ist und man das Ã¤ndern muss, dann *muss* man das bitte auch unter Linux Ã¼bersetzen
  und dort ausprobieren, und nicht einfach davon ausgehen, dass das schon gehen wird (insbesondere dann, wenn ich im Kommentar
  extra darauf hingewiesen habe, dass dies so nur unter Windows geht).
- Var.cpp: Habe ebenfalls die Ãnderung mit PLGeneralLinuxWrapper.h wieder rÃ¼ckgÃ¤ngig machen mÃ¼ssen, da es eben
  '_atoi64' unter Linux leider nicht gibt. Wo die Information herkommen soll, dass es diese Funktion unter Linux
  nun auch in stdlib.h geben 'mÃ¼sste', ist mir schleierhaft, eine Suche per Google gibt jedenfalls nur zig mal die
  Information, dass es das unter Linux eben nicht gibt. Vielleicht kÃ¶nnten wir das nun einfach mal so lassen, und
  nicht in einem halben Jahr wieder behaupten, dass es nun gehen mÃ¼sste, ohne auszutesten, dass das auch wirklich so ist.



>> 17.02.2008
[CO]
- LogFormaterConsole: Nutzt wieder 'printf' direkt anstatt 'File::StandardOutput' da es ansonnsten dank der statischen
  De-initialisierungs Reihenfolge in PLSampleChat einen Crash beim beenden geben kann :/
PLNetwork:
- Copy-Operators und Copy-Constructors hinzugefÃ¼gt



>> 16.02.2008
[CO]
- File: ESeek andere Werte vergeben damit diese mit SEEK_CUR, SEEK_END, SEEK_SET aus 'stdio.h' zusammenpassen, das ist sicherlich
  eine gute Sache... in z.B. 'PLSoundFMOD/SoundManagerFMOD.cpp' musste man extra 'stdio.h' einbinden 'nur' um an diese Definitionen
  zu kommen was ich irgendwie dÃ¤mlich fand. ("Mit Kanonen auf Spatzen schieÃen")
- Var.cpp: Nahm den speziellen Linux Include '#include "PLGeneral/PLGeneralLinuxWrapper.h"' heraus, auch dort 'mÃ¼sste' '_atoi64'
  in 'stdlib.h' definiert sein
- System: Neue Funktion: GetConsoleCharacter(): Liest ein einziges Zeichen von der Konsole, fÃ¼r die Linux Fassung musste ich mal
  wieder Code 'aus dem Internet' nehmen... das so einfache Dinge so kompliert und nicht Plattform unabhÃ¤ngig sein mÃ¼ssen. *gruml*
  Wie Ã¼blich wieder ausfÃ¼hrlich dazu geschrieben woher das kommt.
- System: Neue Funktion: ClearConsoleScreen(): 'LÃ¶scht' den Inhalt der Konsole, ebenfalls etwas sehr praktisches... aber auch wieder
  etwas das obwohl so Grundliegend, nicht wirklich so einfach ist daher auch hier wieder 'gefundener Code' sammt woher er kommt...
- FileHttp genauso wie die anderen File Implementationen alles private gemacht da man da von auÃen nicht mehr rankommen kÃ¶nnen sollte
  (es sprichts nichts dagegen, oder?)
- SystemWin32::GetEnvironmentVariable(): Nahm das [TODO] heraus und erweiterte das Kommentar 'etwas' damit man nachvollziehen kann
  warum das so 'merkwÃ¼rdig' aussieht... das ist eine reine Optimierung. (nicht Performance 'kritisch', aber wenns mÃ¶glich ist...)
  WÃ¼rde man nur "GetEnvironmentVariableW(sName.GetUnicode(), NULL, 0)" schreiben, mÃ¼sste 'sName' intern zwanghaft in Unicode
  konvertiert werden auch wenn das Ã¼berhaupt nicht nÃ¶tig ist da ASCII gegeben ist und eine solche Umgebungs Variable nicht
  existiert, existiert diese muss dann natÃ¼rlich konvertiert werden da wir nicht vorher feststellen kÃ¶nnen ob fÃ¼r den Wert
  ASCII reicht oder nicht. (wÃ¼rd ich also gerne so lassen auch wenns 'ErbsenzÃ¤hlerei' ist, das zeigt das man da mit liebe
  fÃ¼rs Detail rangeht :)
- Directory::CreateRecursive() Implementiert. Weis nicht ob das mit "System::GetInstance()->GetCurrentDir()" so prall ist, wÃ¼sste
  aber im Augenblick nicht wie man das anderst machen sollte, auf jedenfall funktioniert es recht gut.
- 'Directory.h': "PLGeneral/File/FileSearch.h" durch 'Forward declaration' ersetzt. Ich erwÃ¤hne es da ich mir gerade nicht sicher
  bin ob das so absicht war oder nicht. (Regel sollte sein 'Forward declaration' wo geht, das hÃ¤lt die Compile dauer + das neu
  Compilieren bei Header Ãnderungen schÃ¶n niedrig was die ProduktivitÃ¤t steigert, bei der Sache bin ich wirklich stark hinterher
  da es sich wirklich auszahlt *g*)



>> 15.02.2008
[CO]
- Klassen im 'Container'-Ordner nochmal durchgeschaut (hauptsÃ¤chlich nur Zeilen umbrÃ¼che)
- Heap & Map und Implementierungen um Copy-Operator und Copy-Constructor erweitert, auch wenn diese erstmal nicht Implementiert
  und daher private sind. Diese Operationen sind nicht ganz ohne... man kÃ¶nnte zwar einen Iterator nutzen, aber dann hÃ¤tte man
  nur 'Werte' aber ohne die dazu gehÃ¶renden 'SchlÃ¼ssel' - da muss ich mir noch etwas Einfallen lassen.
  Aber so ist's schonmal besser als Ã¼berhaupt nix drinnen zu haben... dadurch viel sofort ein Bug im 'FileAccess' Copy-Constructor
  auf der bereits eifrig den nicht vorhandenen HashMap Copy-Constructor nutzte. :/
- SimpleMap: Speziellen Copy-Operator hinzugefÃ¼gt, im grunde wÃ¼rde der automatische reichen wie beim automatischen Copy-Constructor,
  aber der RÃ¼ckgabewert sollte hier ein universelles 'Map' sein
- HashMap: Speziellen Copy-Constructor und Copy-Operator hinzugefÃ¼gt, wird bereits von 'FileAccess' verwendet
- File: "Standard Stream"-Dateien, nÃ¤chster Anlauf nach Stefans Idee - klappt denke ich so recht gut und ist Ã¼berschaubar.
  Habe dies als File Implementation Namens 'FileStdStream' realisiert damit das sauber Implementiert ist und es nicht zu viele
  SonderfÃ¤lle gibt die man stÃ¤ndig Abfragen muss.
- System: GetTime(), GetMilliseconds() und GetMicroseconds() Funktionen runter zu Sleep() verschoben damit Funktionen mit gleichen
  oder zumindestens sehr Ã¤hnlichen Jobs 'rÃ¤umlich' beisammen sind
- System: Neue Funktion: IsConsoleKeyHit(): '_kbhit()' Funktion die bei Konsolen Anwendungen recht praktisch sein kann. PLSoundTest
  nutzt diese Funktion bereits. Dort wurde bisher 'im Internet gefundener' Code direkt verwendet - forschte etwas nach woher dieser
  Code stammte und es stellte sich heraus das dieser Code auf flipcode (es ruhe in Frieden) verÃ¶ffentlicht wurde und recht bekannt
  ist. FÃ¼gte beim Linux Port ausfÃ¼hrliche Copyright Informationen hinzu. (nutzen 'mÃ¼sste' man es kÃ¶nnen)



>> 14.02.2008
[CO]
- SystemLinux::GetCurrentDir(): Ist nun nicht mehr auf 'MAXPATHLEN' beschrÃ¤nkt sondern ist Dynamisch
- Ging die System und XML Klassen nochmal ganz genau durch und fÃ¼gte wo nÃ¶tig Copy-Constructor und Copy-Operator
  hinzu. In z.B. 'DynLibLinux' ist dies jedoch nicht wirklich nÃ¶tig da der User da nicht rankommt. (oder sollen wir
  hier dann trotzdem soetwas hinzufÃ¼gen?)
  Schaute auch das jede Anweisung in einer eigenen Zeile steht - das machts einfacher wenn man mal einen Break-Point
  setzen will auch wenn das die Anzahl der Zeilen etwas aufblÃ¤ht, die Vorteile Ã¼berwiegen.
- File-Klassen nochmal genau durchgeschaut
- FileSearchImpl: 'm_pSearch' herausgenommen (bin mir zu 99% sicher das dies noch ein alter Ãberbleibsel war :)
- FileSearch: Copy-Operator hinzugefÃ¼gt... hier erwÃ¤hne ich es da es etwas umfangreicher ist, auch im Copy-Constructor
  Ã¤nderte ich eine kleinigkeit. (sah etwas merkwÃ¼rdig aus, funktionell natÃ¼rlich kein Unterschied)
- FileObject: Destruktor virtuell gemacht
- FileAccess: 'NullEntry' zu einer Ã¶ffentlichen Klassenvariable gemacht damit man von auÃen testen kann ob das als Ergebniss
  zurÃ¼ck kam + FileAccess braucht weniger Speicher (das erste Argument war ausschlag geben *g*)
- SocketAddress: "SocketAddress::SocketAddress(const String &sHost, uint32 nPort)" auskommentieren Code entfernt, schien mir
  wirklich 'tot' zu sein (sprich Nutzlos :)
- 'CmdLineParser' vom 'Tools'- in den 'String'-Ordner verschoben da es dort viel besser reinpasst, ist ja nur ein einfaches
  String Parsing. (also wÃ¼rde ich wohl auch genau in diesem Ordner danach suchen :)
  Wollte auch zuerst die 'Localization'-Klassen in den 'String'-Ordner verschieben da diese ebenfalls 'nur' dazu da sind um
  einen String von einer Sprache in eine andere zu bringen... aber da diese Klassen bereits das Loadable-System nutzen das
  zukÃ¼nftig wie es aussieht in PLCore liegen wird, wird das Localization-System wohl auch mit in PLCore wandern mÃ¼ssen. Bei
  Zeiten sollten wir mal fÃ¼r das Localization-System ein Loader Plugin schreiben das die Sprachen/Ãbersetzungen aus einer
  Datenbank ausliest. *g*
PLNetwork:
- 'SocketAddress' und 'Socket' heraus genommen da diese mittlerweile in PLGeneral liegen. (oder gabs einen speziellen Grund wieso
  das auch dort noch lag?) Wenn ich das richtig sehe gibts kein 'Socket::Create()' mehr und das wird inter automatisch erzeugt,
  darum entfernte ich die entsprechenden Funktions aufrufe.



>> 13.02.2008
[CO]
- File: Um "Standard Stream"-Dateien erweitert... das bot sich direkt an das "Dinge auf Konsole ausgeben"  hierÃ¼ber zu
  realisieren anstatt seperate Funktionen z.B. in die System-Klasse zu stecken. (kÃ¶nnten wir natÃ¼rlich immer noch, aber ich denke
  das ist erstmal unnÃ¶tig) Intern ist das sowieso so realisiert + damit kommen andere Dinge wie man im Punkt unten sehen kann
  'for free'... hat also durchaus seine VorzÃ¼ge. *g*
  Erweiterte dafÃ¼r "EAccess" in der File Klasse damit das ohne groÃe Ãnderungen ins Interface passt. In "File::Open()",
  "FileWin32::Open()" und "FileWin32::Linux()" musste etwas Code eingefÃ¼gt werden - Stefan, schau dir das bitte genau an, nicht
  das diese Ãnderung Ã¼berhaupt nicht ins Konzept passt und alles durcheinander bringt. Hatte mir schon Ã¼berlegt ob eine extra
  "StandardStream"-Datei Implementation angebracht wÃ¤re... aber irgendwie war mir das dann mit Kanonen auf Spatzen geschossen.
- "Print()"-Funktion aus den XML Klassen genommen da sich dies nun Ã¼ber eine "Standard Stream"-Datei realisieren lÃ¤sst.
  In der PLBaseTest Funktion "XmlTest::Test()" kann man sehen wie das Schreiben 'in die Konsole' darÃ¼ber zu realisieren ist.
- XmlDocument: "LoadFile()" und "SaveFile()" Funktionen in "Load()" und "Save()" umbenannt damit das konsistent zu den anderen
  Funktionen ist.



>> 12.02.2008
[CO]
- Iteratoren wie besprochen umgeschrieben so das diese problemlos immer auf dem Stack liegen kÃ¶nnen damit man kein 'delete' mehr
  nutzen muss was man ja leider schnell mal vergisst. Alle Projekte entsprechend angepasst und darauf geachtet das die Iteratoren
  immer im kleinst mÃ¶glichen Bereich genutzt werden damit so wenig wie mÃ¶glich schief gehen kann. DafÃ¼r habe ich hier und da auch
  extra BlÃ¶cke hinzugefÃ¼gt was ich allerdings nicht 'schlimm' finde da es fÃ¼r mehr 'Sicherheit' sorgt, (Thematik verÃ¤nderung der
  Datenstruktur auf die der Iterator gerade arbeitet) das ersetzt praktisch das 'delete'. :)
  Im Iterator Copy-Constructor ist momentan noch ein kleiner Hack drinnen der den konstanten Parameter auf nicht Konstant umbiegt
  damit dort die Iterator Implementation zurÃ¼ck gesetzt werden kann - macht man den Parameter nicht Konstant erhÃ¤lt man tonnenweise
  Compiler Warnungen... momentan weis ich noch nicht wie man das anderst lÃ¶sen kÃ¶nnte. (bei nicht konstant kann man ein TemporÃ¤res
  Objekt Ã¤ndern das der Compiler nicht mag da Seiteneffekte mÃ¶glich)
  Aber die Bedienung der Iteratoren ist so nun auf jedenfall 'deutlich' Eleganter und weniger Speicherleck anfÃ¤llig. :D



>> 09.02.2008
[CO]
Gelaber:
- Nachdem ich gestern meine letzte PrÃ¼fung im total Ã¼berfÃ¼llten 3'ten Semester geschrieben habe kann ich nun
  ENDLICH wieder mehr an PL machen. Am 17.03.2008 gehts dann weiter mit dem 4'ten Semester das hoffentlich nicht
  mehr so heftig wird wie das aktuelle. Bis dahin nur noch PL und daher wieder mehr Tagebuch EintrÃ¤ge meinerseits. :D
Alle Projekte:
- Auf Visual Studio 2008 umgestellt damit man 'relativ problemlos' auch unter Vista arbeiten kann ohne erstmal
  die Entwicklungsumgebung mit x Vista-Patches vollzudrÃ¶hnen die dann doch nicht gehen (zumindestens bei mir nicht)
- In den 'sln'-Dateien hat sich nix groÃ geÃ¤ndert, nur die Versionsnummer:
      Microsoft Visual Studio Solution File, Format Version 9.00
      # Visual Studio 2005
  wurde zu
      Microsoft Visual Studio Solution File, Format Version 10.00
      # Visual Studio 2008
  In den 'vcproj'-Dateien hat sich zum GlÃ¼ck auch nicht wirklich viel verÃ¤ndert. In "<VisualStudioProject"
      Version="8,00" wurde zu Version="9,00"
  und
      TargetFrameworkVersion="131072"
  kam neu hinzu.
-     <Tool
          Name="VCWebDeploymentTool"
      />
  Wurde automatisch entfernt da "Web deployment to the local IIS server is no longer supported", fÃ¼r was auch
  immer das gut war, nicht mehr unterstÃ¼tzt wird - wir werden es sicher nicht vermissen. *g*
- Bei "<Tool Name="VCLinkerTool"" gibts zwei neue Optionen die automatisch hinzugefÃ¼gt wurden:
      RandomizedBaseAddress="1"
      DataExecutionPrevention="0"
- "Data Execution Prevention (DEP)" auf "Image is compatible with DEP (/NXCOMPAT)" gestellt, das ist eine gute Sache
  und sollte bei uns keine Probleme geben (konnte jedenfalls keine feststellen)
- Folgende Warnung erschien nun Ã¶fters mal:
      "Command line warning D9035 : option 'Wp64' has been deprecated and will be removed in a future release"
  Da diese Meldung leider wie es aussieht nicht Deaktivierbar ist und das 'etwas' stÃ¶rrend ist deaktivierte
  ich "/Wp64 (Detect 64-Bit Portability Issues)". 64 Bit Compilieren ist momentan bei uns kein Thema... und falls
  man das doch mal ausprobieren will muss sich einer von uns erstmal ein 64 Bit Windows Installieren (zum Testen)
  + den 64 Bit VC Compiler. (sehe momentan aber keinen Grund das zu tun, gibt wichtigeres momentan :)
- Ging die Projekt-AbhÃ¤ngigkeiten (Menu bar -> Project -> Project Build Order... -> Dependencies)
  nochmal durch und korrigierte wo nÃ¶tig. Damit geht das komplett Ãbersetzen wieder beim ersten mal sauber durch
  ohne das Fehlermeldungen kommen das z.B. 'PLGeneral.lib' nicht gefunden werden konnte da z.B. PLNetwork vorher
  'fertig wurde' mit dem Ãbersetzen. (Multi-Threading sei dank *g*)
- "LINK : warning LNK4224: /OPT:NOWIN98 is no longer supported;  ignored" -> "Optimize for Windows98"
  auf Default gesetzt... das UnterstÃ¼tzen wir eh nicht. (selbst MS hat mittlerweie den Support dafÃ¼r
  fallen gelassen)
PLGeneral:
- "LIBCMT,MSVCRT" zu den zu ignorierenden Bibliotheken hinzugefÃ¼gt um Linker Warnungen zu beseitigen
- "PLGeneralWin32Includes.h": WINVER und _WIN32_WINNT werden, falls bereits Definiert, 'undefiniert' - ansonnsten
  bekam ich hier unter Vista mit VC 2008 Warnungen
- TinyXML: Neuste Version 2.5.3 (intern steht bereits 2.5.4) aus dem Repository genommen und mit VC 2005 Ã¼bersetzt.
  "TiXmlBase::PutString()" wurde mittlerweile in "TiXmlBase::EncodeString()" umbenannt und Ã¶ffentlich gemacht - darum
  haben wir nun nur noch 3 anstatt 4 eigene Ãnderungen in TinyXML. :D
  FÃ¼r Linux und VC7 mÃ¼sste man das noch Ã¼bersetzen.
PLNetwork:
- Warnung "warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead.
  To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details." beseitigt indem ich 'strncpy'
  durch 'MemoryManager::Copy' ersetzte - da wird nicht lange gezÃ¶gert *g*



>> 05.02.2008
[SB]
PLCore:
- Auf Basis der Funktoren ein Event-System im Signal/Slot bzw. Event/Delegate Stil erstellt.
  Das ganze funktioniert so:
    void TestEvent(int nParam) { /* do something here */ }
  Event<int> cEvent;
  EventHandler<int> cHandler1(TestEvent);
  cEvent.Connect(&cHandler1);
  cEvent.Emit(1);
  Dabei ist zu beachten, dass ein EventHandler natÃ¼rlich ein ganz normales Objekt ist, das dementsprechend verwaltet werden muÃ.
  Wenn man also z.B. ein EventHandler per new erzeugt, muÃ man diesen auch wieder lÃ¶schen. Um das zu vereinfachen, gibt es
  die Basisklasse EventObserver und die spezialisierte Klasse ManagedEventHandler. Wann immer ein ManagedEventHandler fÃ¼r eine
  Memberfunktion einer Klasse erzeugt wird, die von EventObserver abgeleitet ist, kÃ¼mmert sich diese automatisch um das spÃ¤tere
  LÃ¶schen des Handlers:
    class Test : public EventObserver {
      Test() {
        // Diese Instanz wird automatisch spÃ¤ter gelÃ¶scht
        g_pMainWindow.OnAlienEvent.Connect(new ManagedEventHandler<int>(&Test::OnAlien, this));
    }
    void OnAlien(int nParam) {
    }
  }
- Projekt PLCore begonnen und zunÃ¤chst Functor und Event dorthin verschoben.



>> 04.02.2008
[SB]
WOW. Mit den C++ Templates kann man echt viele tolle Dinge machen - man muÃ nur aufpassen, auf dem Weg dahin
nicht Amok zu laufen ;-)
- Habe meinen ersten Test von Funktionsobjekten entfernt und durch eine neue Implementation ersetzt. Es ist jetzt
  nicht mehr nÃ¶tig, die Anzahl der Parameter beim Template mit anzugeben - das merkt das Template nun von selbst.
  Auch kann man jetzt die Klasse Functor direkt verwenden, und der einfach einen beliebigen gÃ¼ltigen Zeiger
  auf eine Funktion hineingeben - egal ob statisch oder Memberfunktion einer Klasse. Beispiel:
  Functor<int, int> cFunc(TestFunction);
  Functor<int, int> cFunc(&Class::TestMethod, &cObject);
  int nRes = cFunc(10);
  Dank vieler verrÃ¼ckter Template-Tricks mÃ¼Ãte das ganze Typensicher sein - man kann die Klasse also nicht austricksen
  und z.B. einen Zeiger auf ein Objekt falschen Typs hineingeben oder aus einem int(int) ein int(float) machen.
  Es war jetzt auch nicht mehr nÃ¶tig, noch Makros zu verwenden - das ganze geht komplett nur mit Templates. Allerdings
  steht zur Zeit noch der Test aus, ob auch alle Compiler die wir verwenden das ganze mÃ¶gen (VC8 mag es jedenfalls).
  Da der ganze Template-Mechanismus beim Compilieren ablÃ¤uft braucht Ã¼brigens auch keine Angst zu entstehen, dass das
  ganze ein zu groÃer Overhead wÃ¤re und daher die Performance beeintrÃ¤chtigen kÃ¶nnte. Die ganzen Hilfsklassen sind nur
  dafÃ¼r da, damit der Compiler die richtigen Typen zur richtigen Zeit findet, da sie aber weder Daten beinhalten noch
  jemals Instanzen davon erzeugt werden, bleibt davon zur Laufzeit nichts mehr Ã¼brig :-) Das ganze reduziert sich
  dann auf das Dereferenzieren zweier Pointer :-) 



>> 22.01.2008
[CO]
Alle Projekte:
- Ãberall den Style der Konstruktor Initialisierer-Liste wie vor geraumer Zeit besprochen angepasst



>> 22.01.2008
[CO]
- ClassManager::LoadPlugin(): Hier hatte sich ein Fehler eingeschlichen so das manche Plugins nicht gefunden
  werden konnten. Man kann innerhalb der '.plugin'-Datei auch absolute dll-Pfade nutzen, z.b. zu Testzwecken -
  ansonnsten sind die dll's IMMER relativ zum Verzeichniss in dem sich die '.plugin'-Datei befindet.



>> 19.01.2008
[CO]
- FÃ¼gte wie von Stefan gewÃ¼nscht eine 'Set'-Funktion zur 'Map'-Klasse + deren Implementationen hinzu. Lies die 'Add'
  und 'Remove' Funktionen jedoch drinnen da ich finde das diese durchaus ihre Existenzberechtigung haben. (sonst hÃ¤tten
  wir wohl schon vvviiiiel frÃ¼her die 'Set'-Funktion eingebaut :)
  Z.B. kann man Ã¼ber 'Add' mehrmals den gleichen SchlÃ¼ssel einfÃ¼gen, das verhÃ¤lt sich im Grunde dann wie ein 'Stack' +
  'Replace' ersetzt wirklich nur einen Wert wenn dieser bereits in der Map war, ansonnsten wird nix gemacht.
- PLMain: Unicode-Support fÃ¼r die Kommandozeilen-Parameter hinzugefÃ¼gt, fÃ¼r Linux kÃ¶nnte ich nix spezielles finden...



>> 18.01.2008
[CO]
Alle Projekte:
- Ãberall "Predefinitions" durch "Forward declarations" ersetzt
- Ein paar unnÃ¶tige Includes entfernt ("Include-Sparsamkeit" ist mir extrem wichtig :)
- "uint32 HashFunction::Hash(const char szKey[])" und "uint32 HashFunction::Hash(const String &sKey)":
  Variable 'g' in die Schleife gezogen + die Zuweisung in der Abfrage entfernt
- Alle 'doxyfile'-Dateien an die 'Doc'-Ordner verschiebung angepasst
- "Config/" in Dateinamen beim Laden/Speichern von Konfigurationen entfernt, das regelt das Loadable System
  intern selbst wo diese Dateien standardmÃ¤Ãig landen
PLGeneral:
- Bugfix: Fand gerade den Grund dafÃ¼r das es z.B. beim laden der Szene 'PhysicsPlayground.scene' Crashte:
  "FileWin32::Open()": Hier konnte es eine Situation geben in der 'szMode' nicht Initialisiert wurde. In dieser
  kombination muss 'ungÃ¼ltig' zurÃ¼ck gegeben werden. ("FileLinux" natÃ¼rlich das gleiche)
    (!(nAccess & File::FileWrite) && !(nAccess & File::FileCreate) && !(nAccess & File::FileAppend))
- Bugfix: "FileWin32::Open()": Bei folgender Kombination klappte das noch nicht wie erwartet:
    (nAccess & File::FileWrite) && !(nAccess & File::FileCreate) && !(nAccess & File::FileAppend)
  Wenn man nicht "FileRead" gesetzt hatte gab die Funktion 'ungÃ¼ltig' zurÃ¼ck obwohl eine Datei bereits
  existierte in die man hÃ¤tte schreiben kÃ¶nnen. Daher wird hier nun erstmal geprÃ¼ft ob die Datei bereits
  vorhanden ist, wenn ja kann man den "w"-Modus nutzen, ansonnsten wird 'ungÃ¼ltig' zurÃ¼ckgegeben.
  ("FileLinux" natÃ¼rlich das gleiche)
- "File::Open(uint32 nAccess = 0)" zu "File::Open(uint32 nAccess)" gemacht da '0' eine ungÃ¼ltige Flag-Kombination ist
- Loader::OpenFile(): Muss Dateien auch korrekt erzeugen kÃ¶nnen beim Speichern, das mÃ¼sste so nun hoffentlich
  passen... nach den oberen Ãnderungen konnte ich keine Probleme mehr feststellen
- LoadableManagerLoaderPL: 'FileSystemSettings' entfernt und 'BaseDirectories' nach 'LoadableManagerSettings'
  verschoben
- "Loader::OpenFile()": Kennt nun 'nur' noch Basis Verzeichnisse, also kein '-1 = das aktuelle Verzeichniss'... dies
  war hÃ¶chst Problematisch da dies nicht mit den 'PrioritÃ¤ten' der Basis Verzeichnisse zusammen passte. War etwas im
  aktuellen Verzeichniss, also standardmÃ¤Ãig wo das Programm selbst liegt, wurde diese Datei 'immer' genommen, auch
  wenn man z.B. im Falle des Scene Viewers dem Verzeichniss in dem die aktuelle Szene liegt die hÃ¶chste PrioritÃ¤t geben
  wollte damit 'zuallererst' geschaut wird ob die gesuchte Datei dort liegt.
- LoadableManager: "", also ein leerer String ist nun ebenfalls ein gÃ¼ltiger Basis-Pfad und steht fÃ¼r das
  'aktuelle Verzeichniss'
- LoadableManager:SetBaseDirPriority(): Bei den URL-Umstellungen hatte sich hier ein kleiner Fehler eingeschlichen
  so das die PrioritÃ¤ten nicht korrekt geÃ¤ndert wurden



>> 14.01.2008
[SB]
- Beim Lesen aus Archiven mit dem Flag FileMemBuf gab es Probleme, weil die Zeilenenden auch dann konvertiert wurden,
  wenn die Datei als Binary geÃ¶ffnet wurde. Nachdem ich dieses Problem behoben hatte, scheinen auch wieder alle Daten
  richtig geladen zu werden :-)
- Habe das Flag FileBinary komplett gelÃ¶scht, da dieses nur Probleme machte. Generell werden Dateien im BinÃ¤rmodus geÃ¶ffnet,
  wenn dies nicht gewÃ¼nscht ist, muss FileText angegeben werden.
- Registry-Klasse in einen eigenen Ordner verschoben.
- Url::Collapse: Hier gab es einige Probleme, wenn ein ".." am Ende des Pfades stand. Diese sind nun hoffentlich behoben ...
- Ãnderungen aus dem Rewrite-Branch in den Trunk Ã¼bertragen. Gab so weit ich sehen kann keinerlei Probleme - die einzige
  Datei mit einem Conflict war "Diary.txt" :-))



>> 13.01.2008
[CO]
- Ein paar Mini-Ãnderungen an der "Registry"-Klasse



>> 12.01.2008
[SB]
- Wrapper fÃ¼r die Registry hinzugefÃ¼gt. Ich mÃ¶chte einfach *nirgendwo* mehr direkt auf die Windows-API zugreifen mÃ¼ssen,
  da das immer total nervt und meist extrem unÃ¼bersichtlich ist. Auch muÃ man dann ja meist wieder direkt mit irgendwelchen
  String-Buffern hantieren, Speicher allozieren etc. *brrr*. Die Klasse Registry bietet also Zugriff auf die Windows-Registry
  und wrappt einfach die API-Funktionen in eine hÃ¼bsche Klasse. SpÃ¤ter kÃ¶nnte man das evtl. noch erweitern, um auch auf andere
  Registry-Systeme zugreifen zu kÃ¶nnen (z.B. Gnome hat ja auch so etwas). Allerdings wÃ¼rden dann natÃ¼rlich auch die ganzen Pfade
  darin vollkommen anders aussehen, das muÃ man also mal sehen, ob das Ã¼berhaupt sinnvoll wÃ¤re. In jedem Fall kann man nun auch
  Ã¼ber die Registry-Klasse abfragen, ob Ã¼berhaupt eine Registry auf dem System vorhanden ist, falls nein kann man dann auf andere
  Methoden zurÃ¼ckgreifen und sich so ein #ifdef sparen :-)



>> 11.01.2008
[SB]
- Einige kleinere Fehler in RegEx behoben.



>> 10.01.2008
[SB]
- Neue Toolklasse Version eingebaut. Diese speichert die Versionsnummer eines Projektes und kann diese z.B. als
  String ausgeben. Auch kÃ¶nnen Versionsnummern miteinander verglichen werden. Dies soll spÃ¤ter verwendet werden,
  um die Versionen der einzelnen Komponenten zu verwalten.



>> 21.12.2007
[SB]
- Neue Klasse RegEx zum Parsen regulÃ¤rer AusdrÃ¼cke eingebaut. Diese sollten wir verwenden, um uns ansonsten schnell
  kompliziert werdende Parsing-Aufgaben zu erleichtern. Ich denke, dass wir damit an manchen Stellen das Parsen
  von Text deutlich vereinfachen kÃ¶nnen, z.B. fÃ¼r Vektoren, Listen usw. (a b c) . Der Tokenizer ist zwar recht leistungsfÃ¤hig,
  aber selbst damit ist es immer noch sehr aufwendig, so etwas zu parsen, und die entsprechenden Stellen werden meist
  sehr groÃ und sind schwer zu lesen. RegulÃ¤re AusdrÃ¼cke dÃ¼rften hier weiterhelfen und sind sowieso an vielen Stellen sehr
  nÃ¼tzlich :-) Das ganze benutzt den Perl-Syntax fÃ¼r regulÃ¤re AusdrÃ¼cke und darf noch krÃ¤ftig erweitert werden, im Moment
  kÃ¶nnen nur einfache Vergleiche ausgefÃ¼hrt werden. Die Klasse ist ein Wrapper fÃ¼r die PCRE Library (Perl Compatible
  Regular Expressions), die unter einer BSD-Lizenz steht.
- SearchFilterRegEx: Neuer Suchfilter zum Suchen mit regulÃ¤ren AusdrÃ¼cken.



>> 15.12.2007
[CO]
- Loadable System Ãnderung vom 08.12.2007 im Main-Branch wieder rÃ¼ckgÃ¤ngig gemacht da nicht alles wieder ging wie vorher
  und Stefan das im seperaten Branch komplett Ã¼berarbeitet. So haben wir zumindestens wieder eine voll lauffÃ¤hige Version.



>> 09.12.2007
[SB]
- Einige Unklarheiten beseitig, die beim Umstellen auf das neue FS deutlich wurden.
- Url: Die Methoden zum ZurÃ¼ckgeben der URL etwas umsortiert und umbenannt, damit deren Verwendung verstÃ¤ndlicher wird.
  Man sollte eigentlich immer Url::GetNative() verwenden, denn dies gibt den Pfad im nativen Format zurÃ¼ck, sofern dies
  ein lokaler Pfad ist, ansonsten als URL, wenn es sich z.B. um http:// handelt. Das scheint mir der natÃ¼rlichste Weg zu
  sein, weil der Pfad fÃ¼r den User "normal" angezeigt wird, und nur dann z.B. ein Protokoll hinzugefÃ¼gt wird, wenn das
  auch wirklich nÃ¶tig ist. GetUrl() dagegen gibt in jedem Fall file:// heraus, was man aber normaler Weise nicht haben
  mÃ¶chte und auch nicht braucht. Als Faustregel wÃ¼rde ich daher sagen:
  - Zur Ãbergabe von URLs (z.B. zum Laden/Speichern): GetUrl()
  - Zur Ausgabe von URLs an den Benutzer: GetNative()
- Url: Zugriff auf die einzelnen Teile einer Url etwas verÃ¤ndert und Funktionen fÃ¼r die hÃ¤ufigsten Zugriffsformen
  hinzugefÃ¼gt (z.B. nur Pfad oder Dateiname ohne Endung) 
- FileObject, File, Directory: GetUrl() gibt *immer* eine URL ohne "/" am Ende zurÃ¼ck. Dies ist wichtig zu wissen, denn
  dann kann man z.B. ohne Bedenken cDir.GetUrl() + "/filename.txt" schreiben, ohne noch selbst auf "/" testen zu mÃ¼ssen.
  Einzige Besonderheit: Beim Mounten von ZIP-Dateien muÃ das "/" angegeben werden, damit das FS Ã¼berhaupt weiÃ, dass diese
  ZIP-Datei als Verzeichnis angesprochen werden soll und nicht einfach die Datei geÃ¶ffnet werden soll. Das Ã¤ndert aber nichts
  an der Regel, dass GetUrl() auch in diesem Fall ohne "/" zurÃ¼ckgegeben wird!
- FileObject: Erweiterte die Funktionen zum Zugriff auf die URL, damit man die hÃ¤ufig benÃ¶tigten Funktionen direkt zur
  Hand hat und nicht stÃ¤ndig Url's dafÃ¼r erzeugen muss. Die Funktionen sind analog zur Url-Klasse und wrappen diese:
  GetUrl() gibt nun das Url-Objekt zurÃ¼ck, damit dieses nicht unnÃ¶tig neu erzeugt werden muÃ
  GetPathUrl() gibt die Url als String zurÃ¼ck
  GetPathNative() gibt den Native-Path als String zurÃ¼ck
  GetPathWindows() gibt den Windows-Path als String zurÃ¼ck
  GetPathUnix() gibt den Unix-Path als String zurÃ¼ck
  GetFilename() gibt nur den Dateinamen zurÃ¼ck
- Threads etwas umgebaut und GetMainThread() in System eingebaut.
- File: FileBinary und FileText vertauscht, damit ist FileBinary nun wieder der Standard.
- Die Engine auf das neue FS umgestellt. Dabei sind mir einige Stellen aufgefallen, die noch deutlich Ã¼berarbeitet werden
  sollten, z.B. werden noch viel zu Oft irgendwelche Dateipfade auseinandergebrÃ¶selt, hier sollte zumindest versucht werden,
  das mÃ¶glichst transparent nur an einer Stelle zu tun. Manche Dateitypen suchen dann wieder selbst die Basispfade durch
  oder geben einen festen Pfad vor (z.B. "data/sounds"), das sollte auf jeden Fall raus. Viele Dinge habe ich nur blind
  umstellen kÃ¶nnen und fÃ¼rchte, dass das nicht mehr richtig funktionieren wird. Dies war aber schlecht anders mÃ¶glich, da
  mir teilweise die Funktionsweise der entsprechenden Funktion nicht wirklich klar wurde und ein komplettes Neuschreiben
  on-the-fly zu aufwendig wÃ¤re.
- Es lÃ¤Ãt sich nun wieder alles compilieren, allerdings funktionieren die Loader noch nicht wieder richtig, weshalb viele
  Dateien noch nicht gefunden werden kÃ¶nnen. Als nÃ¤chstes werde ich daher die fÃ¼r spÃ¤ter geplanten Arbeiten vorziehen und
  das Config- und das Loader-System Ã¼berarbeiten. Es dÃ¼rfte sinnvoller sein, dies nun gleich neu zu machen, als erstmal
  das alte wieder mÃ¼hselig zum Laufen zu bringen um es dann hinterher doch noch neu zu schreiben.



>> 08.12.2007
[SB]
- PLGeneral/System Ã¼berarbeitet: Globale Manager entfernt, direkte Instanzen der Klassen sind jetzt mÃ¶glich und
  Impl-Klassen nach dem gleichen Pattern wie in File Ã¼berarbeitet.
- Folgendes Pattern fÃ¼r Implementationsklassen soll nun Ã¼berall mÃ¶glichst identisch verwendet werden:
  - Eine plattformunabhÃ¤ngige Klasse besitzt einen Zeiger auf eine (versteckte) Implementationsklasse
  - Diese wird im Konstruktor (oder evtl. erst spÃ¤ter, wie in FileObject) erzeugt, aber innerhalb dieser Klasse
  - Die Implementationsklasse besitzt keinen Zeiger zurÃ¼ck auf die plattformunabhÃ¤ngige Klasse!
  - Das gesamte Interface der Implementationsklasse sollte protected sein, auch die virtuellen Funktionen.
  - Mittels friend darf die plattformunabhÃ¤ngige Klasse darauf zugreifen.
  - Konkrete Implementation werden abgeleitet, auch diese mit protected-interface.



>> 08.12.2007
[CO]
- Base Path Dinge von FileSystem in LoadableManager verschoben. Ist noch nicht wirklich Prall realsiert, sollte so aber
  erstmal reichen. Nachdem das Ã¼berarbeitet FS drinnen ist sollte man sich das hier nochmal anschaun.



>> 05.12.2007
[SB]
- Map: Auf die Values einer Map kann nun auch nicht-const zugegriffen werden. Dies ist nÃ¼tzlich, wenn es sich um abstrakte
  Datentypen (z.B. Klassen) handelt, von denen man nur ein Attribut Ã¤ndern mÃ¶chte und nicht das gesamte Objekt per
  Replace austauschen mÃ¶chte. 
- SearchFilter implementiert. Beim Auflisten von Dateien wird Ã¼ber die Klasse SearchFilter getestet, ob der gefundene
  Dateiname dem Filter entspricht. Als Standard wird ein WildCard-Filter verwendet, es kÃ¶nnen aber auch individuelle
  Filter implementiert werden.
- GetCurrentDirectory und SetCurrentDirectory in PLGeneral::System implementiert.



>> 04.12.2007
[SB]
- HttpHandle und ZipHandle: Beide Klassen besitzen nun nur noch einen leeren Konstruktor und Ã¶ffnen zunÃ¤chst keine
  Datei bzw. Verbindung. DafÃ¼r gibt es nun jeweils eine Funktion Open(). 
- Habe mal etwas mit den Ideen herumgespielt, wie man beim FS den Zugriff auf z.B. passwortgeschÃ¼tzte Inhalte
  realisieren kÃ¶nnte. Die bisherige Methode, Open(Name, Passwort) gefÃ¤llt mir aus folgenden GrÃ¼nden nicht:
  - Die Signatur von Open wird um einen Parameter erweitert, den vermutlich die meisten User zunÃ¤chst nicht verstehen
  - Es wird nur von einem Passwort ausgegangen, in vielen FÃ¤llen kann es aber noch mehr Parameter geben
    (Username/Passwort, Crypto-Keys u.v.m.)
  - Wenn man z.B. eine Datei "http://www.pixellight.org/test.zip/dir/test.txt" laden mÃ¶chte, kann man an verschiedenen Stellen
    einen Zugriffsschutz haben, z.B. einmal fÃ¼r den http-server (username/passwort), und dann noch einmal fÃ¼r die Zip-Datei.
    Mit dieser LÃ¶sung ist es aber nicht mÃ¶glich, mehrere PasswÃ¶rter zu Ã¼bergeben, ausserdem vermittelt Open(Name, Passwort)
    in diesem Falle den Eindruck, dass das Passwort fÃ¼r test.txt benÃ¶tigt wird, was aber gar nicht der Fall ist.
  Es sollte also die MÃ¶glichkeit geben, mehrere Authentifizierungsdaten gleichzeitig anzugeben, falls die Dateisysteme wie
  im obigen Beispiel verschachtelt sind. Ausserdem wÃ¤re es nett, noch weitere Daten Ã¼bergeben zu kÃ¶nnen, z.B. dass bestimmte
  Zugriffsflags verwendet / nicht verwendet werden sollen (z.B.: Zip-File nicht memory-buffered Ã¶ffnen), oder weitere
  unbestimmte Informationen (annotation like).
- FileAccess implementiert, dies soll so funktionieren wie oben angegeben. Kleines Beispiel:
  FileAccess sAccess;
  sAccess["www.pixel-light.de"].SetAuth("username", "password");                // Username und Passwort fÃ¼r HTTP
  sAccess["http://www.pixellight.org/test.zip"].SetPassword("password");        // Passwort fÃ¼r die ZIP-Datei
  sAccess["http://www.pixellight.org/test.zip"].SetFlags(File_::FileMemBuf, 0); // ZIP-Datei ohne FileMemBuf Ã¶ffnen
  File cFile("http://www.pixellight.org/test.zip/dir/test.txt", sAccess);
  Etwas problematisch ist es zur Zeit noch die Frage, welcher Name fÃ¼r welche Zugriffsoptionen verwendet werden soll.
  FileZip sucht nach dem exakten Namen der Zip-Datei, also z.B. "http://www.pixellight.org/test.zip",
  FileHttp sucht dagegen nach der Domain, also z.B. "http://www.pixel-light.de". Gerade im Falle von HTTP ist das schwierig,
  da man ja nicht genau weiss, wo auf dem Server der Passwortschutz eingerichtet ist.
- FileAccess um bCaseSensitive erweitert. Dies wird von FileZip ausgelesen, somit kann man bestimmen, ob eine Zip-Datei
  case-sensitive behandelt werden soll oder nicht. Standardwert ist jetzt 'true', da wir dies anderswo auch meist so behandeln!
- Ebenfalls prÃ¼ft FileZip nun, ob ein Wert fÃ¼r FileMemBuf angegeben wurde. Ist dies der Fall, wird dieses Flag Ã¼bernommen,
  damit kann also das automatische Buffern von Zip-Dateien ausgeschaltet werden. Das Prinzip der Flags in FileAccess funktioniert
  so: Alle Flags, die in FlagsMask angegeben werden, gelten als "gesetzt" (egal ob 1 oder 0). Deren Wert wird dann in FlagsValue
  bestimmt. Beispiel: (Mask = Read | MemBuf, Value = Read) bedeutet, dass Read = 1 gewÃ¼nscht ist und MemBuf = 0. Alle anderen
  Werte sind nicht weiter bestimmt. Allerdings sind die ganzen Angaben in FileAccess nur "WÃ¼nsche", die berÃ¼cksichtigt werden
  kÃ¶nnen aber nicht mÃ¼ssen. Im Moment wird also nur bei Zip-Dateien auf MemBuf geachtet, alle anderen Flags werden ignoriert.
  Man kann dies also nciht nutzen, um z.B. eine Zip-Datei auch zum Schreiben zu Ã¶ffnen oder Ã¤hnliches.
- Mir ist aufgefallen, dass man auf die Values einer HashMaps nur noch als const zugreifen kann, man also die Werte spÃ¤ter
  nicht mehr Ã¤ndern kann. Gerade beim FileAccess brauche ich aber auch die MÃ¶glichkeit, die Objekte spÃ¤ter noch zu Ã¤ndern.
  Habe das daher erst einmal eingehackt, Christian sag bitte mal bescheid ob das so ok ist oder ob ich das anders lÃ¶sen
  sollte.



>> 03.12.2007
[SB]
- HttpHandle: Beim Lesen von Daten Ã¼ber das Netz kann es hÃ¤ufig vorkommen, dass noch nicht genÃ¼gend Daten im Stream
  vorhanden sind, in dem Fall gibt Socket.Read() einfach so viel zurÃ¼ck, wie bereits vorhanden ist, auch wenn dies
  weniger ist als angefordert. Dies ist so ok und sollte denke ich auch nicht geÃ¤ndert werden, wenn man mit Sockets
  arbeitet muss man dies einfach einplanen. Beim Arbeiten mit Dateien wird jedoch davon ausgegangen, dass Read() genau
  so viel liest wie angefordert, wenn weniger gelesen wird, ist dies ein Fehler. Daher habe ich dies in HttpHandle::Read()
  so geÃ¤ndert, dass so lange immer wieder vom Socket gelesen wird, bis die gewÃ¼nschte Datenmenge erreicht wurde, es
  kann also hier nicht mehr vorkommen, dass zu wenig gelesen wird. Bei grossen Dateien kÃ¶nnte dies also einen Moment
  lang dauern :-) 
- HttpHandle: Fehler behoben, es muss die gesamte URL Ã¼bermittelt werden, damit ein Webserver, der mehrere Domains hostet
  (wie bei uns) weiÃ, welche gemeint ist.
- HttpHandle: Es wird nun auch Http-Auth (Basic) unterstÃ¼tzt, damit kann also per Username und Passwort auf geschÃ¼tzte
  Webseiten zugegriffen werden.
- Memory buffered files implementiert: Wird eine Datei mit dem Flag FileMemBuf geÃ¶ffnet, so wird der gesamte Inhalt der
  Datei eingelesen und im Speicher behalten, alle weiteren Lesezugriffe finden dann nur noch auf diese Buffer statt.
  Ich habe mich fÃ¼r die Bezeichnung "Memory Buffered" entschieden, da "Memory Mapped" viele unterschiedliche Bedeutungen
  hat (z.B. auf OS-Ebene, um mittels gemappter Dateien IPC zu betreiben), da scheint mir "Memory Buffered" eindeutiger
  und daher leichter verstÃ¤ndlich. Der Buffer und der Zugriff darauf befindet sich in der Klasse File, und kann nur zum
  Lesen verwendet werden.
- ZipHandle: Das Zip-File wird nun mittel FileMemBuf geladen. Hier sollten wir uns noch Ã¼berlegen, ob man das evtl. von
  der DateigrÃ¶Ãe abhÃ¤ngig machen sollte, oder irgendwie eine MÃ¶glichkeit geben sollte, dies wenn gewÃ¼nscht zu deaktivieren.



>> 02.12.2007
[SB]
- Habe die Basisklassen von PLNetwork nach PLGeneral/Network verschoben, da Sockets und Netzwerkkommunikation eigentlich
  zu den System-Basisklassen gehÃ¶ren. Alles weitere, also die Struktur der Netzwerkkommunikation in PL, wird wie geplant
  in PLNetwork implementiert werden, die Basisklassen kÃ¶nnen jedoch auch an anderen Stellen nÃ¼tzlich sein. 
- Netzwerk-Basisklassen Ã¼berarbeitet und wo mÃ¶glich vereinfacht.
- HTTP-Client hinzugefÃ¼gt. Analog zu den ZIP-Dateien gibt es eine Klasse HttpHandle, die benutzt werden kann, um eine
  HTTP-Verbindung mit einem Server aufzumachen und Dateien zu Ã¼bertragen. Diese Klasse kann bislang nur das nÃ¶tigste, also
  nur das Ãbertragen einer Datei per HTTP/1.0 sowie das auslesen der wichtigsten Header-Informationen. Alles andere kann
  spÃ¤ter erweitert werden.
- HTTP-Implementation fÃ¼r das FS hinzugefÃ¼gt. Damit kann per HTTP auf Dateien aus dem Netzwerk zugegriffen werden, was ich mir
  sehr nÃ¼tzlich vorstelle, um z.B. News von der Webseite zu laden (oder auch Updates). Dank der Schachtelung ist natÃ¼rlich auch
  etwas wie "http://www.pixellight.org/test.zip/test.txt" mÃ¶glich, was auch gut funktioniert, allerdings nicht zu empfehlen ist :-)
- Linux-Implementation fÃ¼r das FS hinzugefÃ¼gt.
- Generische Funktionen fÃ¼r das Kopieren und Verschieben von Dateien hinzugefÃ¼gt. ZunÃ¤chst wird versucht, die systemspezifische
  Implementation fÃ¼r die entsprechende Funktion zu verwenden, wenn dies fehlschlÃ¤gt, wird es mit der generischen Variante
  versucht: Wenn man z.B. eine Datei aus einer Zip-Datei irgendwo hin kopieren mÃ¶chte, wird dies mit der Systemfunktion
  natÃ¼rlich nicht gehen. Das Herunterladen einer Datei aus dem Netz kann man nun also z.B. so erledigen:
    File("http://www.pixellight.org/test.zip").Copy("C:\\test.zip")



>> 01.12.2007
[SB]
- FunktionalitÃ¤t von ZipHandle vervollstÃ¤ndigt.
- FileZip und FileSearchZip unter Verwendung von ZipHandle wieder implementiert und getestet. Das Verhalten je nach
  Lesemodus (Binary oder Text) an die Systemfunktionen angepasst.
- Beim Ãffnen einer Datei wird die Implementationsklasse automatisch ermittelt: Entweder mittels des Protokolls,
  oder durch Suche nach ".zip/" oder ".pak/" im Dateinamen. Dadurch muÃ eine Zip-Datei als Verzeichnis so geÃ¶ffnet
  werden: Directory("test.zip/"), da "test.zip" an sich auch eine valide Datei wÃ¤re. Innerhalb der Zip-Datei sind aber
  z.B. "test.zip/test" und "test.zip/test/" identisch.
- Eine Problematik beim Verwenden von Zip-Dateien: Mir ist aufgefallen, dass in einer Zip-Datei nicht unbedingt alle
  Unterverzeichnisse auch aufgelistet werden. Wenn ich unter Windows direkt oder mit TugZip eine Zip-Datei packe, gibt es
  z.B. die EintrÃ¤ge "test/dir1/test1.txt" und "test/dir1/test2.txt", aber weder "test/dir1/" noch "test/". Je nachdem,
  welches Programm man verwendet, ist dies mal so und mal so, aber offensichtlich kann man sich nicht darauf verlassen,
  dass alle Verzeichnisse auch direkt aufgelistet werden. Dieses Problem in den Zip-Klassen zu lÃ¶sen wÃ¤re denke ich etwas
  aufwendig, da man die Pfade auseinandernehmen und eine eigene Liste erstellen mÃ¼Ãte, anstatt einfach nur alle EintrÃ¤ge
  in der Zip-Datei durchzugehen. SpÃ¤ter sollte man dies wohl tun, damit es keine Probleme mit "schlechten" Zip-Dateien gibt,
  im Moment wÃ¼rde ich aber einfach darauf achten, dass die Zip-Dateien vernÃ¼nftig sind - zip unter Linux trÃ¤gt beispielsweise
  alles korrekt ein :-)



>> 21.11.2007
[SB]
- Ãbertragen der Zip-Implementation begonnen.
- Neue Klasse ZipHandle erstellt, welche auf einer Zip-Datei arbeitet. Vereinigt die FunktionalitÃ¤t von StreamZip und IteratorZip,
  denn diese getrennten Klassen arbeiteten letztlich beide auf dem File-Handle von DirectoryZip, was ich sehr undurchschaubar
  finde. Weitere Zip-FunktionalitÃ¤t war auch noch innerhalb von DirectoryZip und FileZip verstreut, das wurde ebenfalls in diese
  Klasse Ã¼bertragen. ZipHandle besitzt nun selber den File-Handle fÃ¼r die Zip-Datei und soll als generelles Interface dienen, um
  den Inhalt der Zip-Datei aufzuzÃ¤hlen und anschliessend z.B. auf den Anfang einer Datei zu springen und diese auszulesen.
- Neue eingebettete Klasse ZipHandle::ZipEntry hinzugefÃ¼gt. Diese Klasse enthÃ¤lt die Informationen zu einem Eintrag
  innerhalb der Zip-Datei. Damit sind diese Informationen nicht mehr direkt in ZipHandle (Ã¼bersichtlicher), auÃerdem kann so
  leichter eine Liste von Zip-Entrys erstellt werden, was man z.B. innerhalb der FS-Abkapselung machen kÃ¶nnte, um den Zugriff
  auf das Directory schneller zu machen. 
- Da die verteilten Zip-Funktionen recht verwirrend waren, bin ich mir nicht 100% sicher, ob ich alles richtig Ã¼bertragen habe.
  Christian: Bitte schau nochmal genau drÃ¼ber und teste wenn mÃ¶glich ZipHandle etwas, ob noch alles richtig funktioniert.
- ZipHandle Ã¼berarbeitet und versucht, das Interface sowie die Variablennamen verstÃ¤ndlicher zu machen. Diese Klasse soll fÃ¼r
  sich alleine genommen schon leicht verwendet werden kÃ¶nnen, um auf eine Zip-Datei zuzugreifen und diese auszulesen. Die weitere
  Abstraktion Ã¼ber FileZip und FileSearchZip dient dann nur noch dazu, Zip-Files auch transparent Ã¼ber das FS-Interface nutzen
  zu kÃ¶nnen. Es soll aber auch ganz ohne gehen, die gesamte Zip-FunktionalitÃ¤t soll also in ZipHandle vorhanden sein.  
- Kleinen Test implementiert, der den Zugriff auf Zip-Dateien nur Ã¼ber ZipHandle demonstriert testet. Konnte bisher keine Fehler
  feststellen, das Verzeichnis eines Zip-Files sowie der Inhalt der enthaltenen Dateien werden mir korrekt angezeigt. 



>> 20.11.2007
[SB]
- Basisklassen und Win32-Implementation fÃ¼r das Dateisystem sind weitgehend vollstÃ¤ndig (bis auf Suchfilter).
  Das Klassenlayout wurde stark vereinfacht und gleichzeitig teilweise erweitert, so ist das Erstellen, LÃ¶schen,
  Umbenennen, Verschieben usw. nun direkt Ã¼ber ein File- oder Directory-Objekt mÃ¶glich. Dabei gibt es nun auch
  ein Muster, welches wir sonst selten haben: Gleichnamige Funktionen in abgeleiteten Klassen, die *nicht* virtuell
  sind. File::Create erstellt eine neue Datei, wÃ¤hrend Directory::Create ein Verzeichnis erstellt. In der Basisklasse
  gibt es diese Funktion nicht, daher dÃ¼rfte dies kein Problem darstellen, und Ã¼ber das verwendete Interface legt
  der Programmierer deutlich fest, was von beidem er tun mÃ¶chte, das ganze scheint mir so also auch am intuitivsten zu sein.
- Mittels Assign kann das Datei-Objekt auf einen neuen Dateinamen gelenkt werden. Dabei werden automatisch vorher
  geÃ¶ffnete Dateien geschlossen, das Objekt "zeigt" also dann auf eine andere Datei (diese muÃ nicht mal vorhanden sein).
  Beispielsweise kann so eine Datei oder ein Verzeichnis angelegt werden: Directory("test").Create();
- Dateiflags vervollstÃ¤ndigt und in hoffentlich Ã¼blicherer Weise verwendet (z.B. gibt es nun neben FileWrite auch FileRead,
  ebenso gibt es FileBinary und FileText).
- Die Url-Klasse wird nur noch intern eingesetzt, im Interface werden dagegen nur noch Strings Ã¼bergeben. Ansonsten mÃ¼Ãte
  man stÃ¤ndig Methoden doppelt machen, obwohl der User wohl meist sowieso Strings Ã¼bergeben wird. Ausserdem sollte Url
  sowieso so selten wie mÃ¶glich eingesetzt werden, um unnÃ¶tiges Parsen des Dateinamens zu verhindern.



>> 19.11.2007
[SB]
- Klasse Url Ã¼berarbeitet und vereinfacht. Ein Pfad wird nun *immer* intern in URL-Form gespeichert, d.h. mit Protokoll
  und mit '/' als Trennzeichen. Beim Umwandeln werden auch nicht mehr unterschiedliche Url-Instanzen kopiert, sondern
  direkt die Strings wie gewollt umgewandelt. Dies scheint mir am einfachsten und ist in der Benutzung konsistent, da
  es keine Unterschiede mehr geben kann, in welcher Form verschiedene Url-Instanzen ihre Werte vorliegen haben. Im allgemeinen
  mÃ¶chte man eine Url meist im einheitlichen Url-Format angeben, dieser Zugriff ist daher auch immer der schnellste, da nur
  ein String zurÃ¼ckgegeben werden muss. Will man dagegen in ein spezielles Format umwandeln, ist dies etwas aufwendiger, dafÃ¼r
  macht man dies meist nur einmal (z.B. beim Erzeugen einer FileWin32-Instanz). Da diese dann nur als String und nicht mehr
  als Url gespeichert wird, entfÃ¤llt dafÃ¼r aber auch der Overhead, noch einmal die umgewandelte Url in ihre Bestandteile
  zu zerlegen.
- FileObject: Die URL eines jeden Objektes wird jetzt immer ohne ein abschlieÃendes '/' gespeichert. Damit ist der Dateiname
  eines FileObject immer korrekt, und man kann sich sicher sein, wie dieser verwendet werden muÃ (z.B. kann der Suchpfad
  eines Verzeichnisses jetzt immer korrekt durch HinzufÃ¼gen von /*.* erzeugt werden). Eine URL kann aber weiterhin Pfade
  speichern, die mit / enden, da dies fÃ¼r eine URL von Bedeutung sein kann.



>> 13.11.2007
[SB]
- Rewrite des Dateisystems begonnen.
- Globale Klasse FileSystem entfernt.
- Die Klassen FileObject, File und Directory bleiben von der Funktionsweise sehr Ã¤hnlich, werden nun aber direkt verwendet,
  mÃ¼ssen also nicht mehr dynamisch erzeugt werden und beinhalten auch keine virtuellen Funktionen mehr.
- Die systemspezifischen Implementationen werden von der Klasse FileImpl abgeleitet und kapsel sowohl die Datei- also auch
  die Verzeichnisoperationen ab. Ein FileObject erzeugt eine Instanz einer von FileImpl abgeleiteten Klasse und verwendet
  diese.
- Das Auflisten/Suchen von Dateien wird wie bisher Ã¼ber eine eigene Klasse gehandhabt, wobei SearchHandle in FileSearch
  umbenannt wurde. Diese Klasse verwendet ebenfalls das Backend-Schema, zu einer Instanz von FileSearch gehÃ¶rt daher
  immer eine systemspezifische Implementation welche von FileSearchImpl abgeleitet ist.
- Alle Dateifunktionen sollen Ã¼ber die Klassen FileObject/File/Directory zu verwenden sein, z.B. auch das Erstellen
  neuer Dateien oder Verzeichnisse ebenso wie das LÃ¶schen. Dies sollte einfacher zu verwenden sein als vorher, wo manche
  Funktionen nur Ã¼ber das globale Filesystem-Interface ausgefÃ¼hrt werden konnten.



>> 12.11.2007
[SB]
- Rewrite begonnen. Ziel ist es, die Basisklassen deutlich zu vereinfachen und zu verschlanken, wobei folgende Ziele
  verfolgt werden:
  * Alle Klassen sollten mÃ¶glichst direkt instanziiert werden kÃ¶nnen, damit es dem Programmierer frei steht, ob er eine
    Klasse direkt verwendet oder dynamisch erzeugt, was auch eine effizientere Nutzung ermÃ¶glicht. Es sollte daher nicht mehr,
  wie bisher, eine dynamische Erzeugung von Objekten erzwungen werden, da dies auch die Problematik der spÃ¤teren
  Speicherfreigabe beinhaltet und generell komplizierter in der Verwendung ist.
  * MÃ¶glichst keine globalen Manager mehr, welche alle Instanzen einer oder mehrerer Klassen verwalten. Dies ist zwar manchmal
    sinnvoll (z.B. fÃ¼r Ressourcenmanager), aber oftmal auch komplett unnÃ¶tig (z.B. Dateisystem, Systemklassen allgemein).
  * Die Basisklassen sollten mÃ¶glichst schlank sein, also direkt mÃ¶glichst einfach zu verwenden sein und dabei mÃ¶glichst
    wenig Overhead erzeugen. Dies bedeutet vor allem, dass die Basisklassen vom RTTI unabhÃ¤ngig sein sollen und
    daher deutlich von den RTTI Klassen getrennt werden, diese arbeiten dann auf einer hÃ¶heren Ebene Ã¼ber den Basisklassen.     
- Ausserdem werde ich versuchen, folgende Konventionen einzuhalten:
  * Keine Verschachtelung mehr von Unterverzeichnissen, da dies eher wieder unÃ¼bersichtlicher wird als Ã¼bersichtlicher. Also
    wird es z.B. nur noch das Verzeichnis FileSystem geben, darin jedoch keine weiteren Unverzeichnisse fÃ¼r Zip, Win32, Linux etc.    
  * Das Backend-Prinzip wird konsequent umgesetzt, also Ã¼berall dort, wo es Systemspezifische Implementationen gibt, wird
    es nach aussen eine SystemunabhÃ¤ngige Klasse geben, welche die Details Ã¼ber eine systemspezifische Implementationsklasse
    abkapselt (1:1-Beziehung). Dieses Vorgehen bringt am wenigsten Probleme mit sich und ist sehr flexibel und ist daher besser,
  als z.B. direkt die Systemspezifischen Klassen abzuleiten (zumal dies nicht damit vereinbar ist, die Klasse direkt zu
  instanziieren).



>> 23.10.2007
[SB]
- Definition von _CRT_SECURE_NO_DEPRECATE in CMakeLists.txt hinzugefÃ¼gt. Dabei ist mir aufgefallen, dass im VC-Projekt
  diese Definition nicht auf die Ã¼bliche Weise unter "PrÃ¤prozessordefinitionen" hinzugefÃ¼gt wird, sondern per
  "zusÃ¤tzliche Optionen" der Kommandozeile. Habe das mal geÃ¤ndert, da ich keinen Grund sehe das hier anders zu machen
  als bei den sonstigen Definitionen und man so nur unnÃ¶tig suchen muss.



>> 20.10.2007
[SB]
- zlib.dll auch aus den Installationsanweisungen in der CMake-Datei entfernt.



>> 19.10.2007
[CO]
- zlib wird im VC8 Projekt nun genauso wie in der CMake-Datei statisch eingebunden. 'zlib.dll' aus dem Runtime-Ordner gelÃ¶scht.



>> 13.10.2007
[CO]
Alle Projekte:
- Einige 'const' eingefÃ¼gt
- Einige '#define' entfernt
- Ein paar AbsÃ¤tze eingefÃ¼gt



>> 07.10.2007
[CO]
Alle Projekte:
- Einige 'const' eingefÃ¼gt um dem Compiler das Leben etwas einfacher zu machen und mÃ¶glichen unerwÃ¼nschten Manipulationen
  vorzubeugen
- Dort wo es problemlos mÃ¶glich war machte ich beim Speichern das zu speichernde Objekt Konstant. Bei ein paar Loadern wie z.B.
  Mesh Loadern ist dies leider nicht mÃ¶glich da Index Buffer beim Lock verÃ¤ndert werden.
PLGeneral:
- String(const Variant &cVariant) entfernt da Ã¼berflÃ¼ssig, da nutzt man lieber Variant::GetString() :D
- Variant: Entfernte alle 'char*'-Funktionen da intern sowieso als 'String' gespeichert wird und man es daher gleich auch
  so Ã¼bergeben kann ohne das es einen wirklichen Unterschied macht. Die 'GetString()'-Funktion erzeugt nun auch gleich den
  String und gibt diesen zurÃ¼ck ohne das dieser eventuell in 'm_sString' gespeichert wird... das macht die Sache zwar langsamer
  wenn Ã¶fters diese Funktion hintereinander aufgerufen wird - allerdings hat diese Funktion wirklich konstant zu sein.
- Parameters::GetParams() entfernt da dies einen Iterator zurÃ¼ckgab Ã¼ber den man die Variablen hÃ¤tte verÃ¤ndern kÃ¶nnen +
  diese Funktion wurde nirgends verwendet.



>> 17.09.2007
[CO]
- Nahm das aktuelle Experimentelle Error System heraus da dies erstmal wohl nicht weiterverfolgt wird. Hab dafÃ¼r im
  lab-Repository ein entsprechendes Projekt mit diesem System angelegt.
- Entfernte nach RÃ¼cksprache mit Stefan 'PLBool'. Wir wollten zwar das noch solange drinnen lassen bis die Sache wie/ob
  wir ein 'Error System' implementieren geklÃ¤rt ist - allerdings ist es nicht abzusehen ob/wann das gemacht wird. Darum
  kommt das nun raus damit die Codes nicht mehr ganz so unfertig/hÃ¶chst Experimentell wirken. Sollte man dann irgendwann
  ein 'Error System' haben, mÃ¼sste man eh nochmal alles im Detail durchgehen.
  Das war nun zwar wieder einiges an FleiÃarbeit, aber so isses wieder viel besser da Ã¼bersichtlicher + weniger Overhead...
  die einzelnen dll's sind gleich um ein paar KB (eine davon sogar um 30! :) kleiner geworden. *g*



>> 15.09.2007
[CO]
- XML-Klassen: Die Konstruktoren noch etwas aufgerÃ¤umt - keine Ahnung wieso ich das damals so umstÃ¤ndlich machte. 'void *'
  hab ich allerdings als Parameter gelassen, man 'kÃ¶nnte' zwar eine direkte Referenz auf das TinyXml Objekt Ã¼bergeben, aber
  dann 'mÃ¼sste' diese TinyXml Klasse als 'Predefinition' in unseren XML-Headern stehen... und das will ich nicht. :D
  Nur die 'XmlDocument' Klassen Dokumentation weist darauf hin das intern TinyXml verwendet wird, ansonnsten sollte das wie
  gehabt absolut verborgen bleiben WIE das Implementiert ist.
- CmdLineParser nochmal etwas aufgerÃ¤umt



>> 14.09.2007
[CO]
- Element & Resource: 'Delete()'-Funktion liefert als RÃ¼ckgabewert nun ob alles gut ging oder ein Fehler auftrat



>> 13.09.2007
[CO]
- Da ich in Jens 'Kabiene'-Szene hin und wieder recht heftige stocker habe wenn ich einen neuen Raum betrete (wie es aussieht
  muss die GPU viele Textur Daten umschaufeln) das dazu fÃ¼hrt das alles kurz 'einfriert' und ich danach weit auÃerhalb der
  Szene bin, versuchte ich solche unregelmÃ¤Ãigkeiten im Timing etwas zu Kompensieren.
  In 'Timing::Update()' wird die Ãnderung des Zeit unterschiedes mit dem des letzten Frames verglichen und wenn diese Werte
  ZU stark voneinander abweichen wird hier 'geglÃ¤ttet'. Ãber die neue Funktion 'GetTimeDifferenceNoCompensating()' kann
  man sich den 'wirklichen' Zeit unterschied ohne 'Korrekturen' zurÃ¼ckgeben lassen um z.B. feststellen zu kÃ¶nnen ob
  unregelmÃ¤Ãigkeiten auftraten.



>> 08.09.2007
[CO]
- DirectoryZip::SearchCentralDir() vereinfacht, der Zwischenbuffer liegt nun direkt auf dem Runtime-Stack
- DirectoryZip::OpenObject(): Der verwendete ZIP-Iterator liegt nun direkt auf dem Runtime-Stack



>> 24.08.2007
[CO]
- SystemWin32::ErrorCodeToString() statisch gemacht da man wirklich keine Instanz der System Klasse dafÃ¼r braucht
- DynLibWin32::Load(): Gibt nun Ã¼ber 'SystemWin32::ErrorCodeToString()' eine Fehlerbeschreibung aus
- Localization::SetLanguage(): Nahm hier das [TODO] raus. Diese Funktion setzt wirklich nur einen String, fÃ¼r das Laden
  der konkreten Sprachen ist die jeweilige Implementation selbst verantwortlich. Generell wird die Sprache am besten NUR
  beim Programm-Start gesetzt und geladen, denn das jederzeit Ã¤ndern zu kÃ¶nnen wÃ¤re ziemlich Tricky... denn man mÃ¼sste dann
  irgendwie ALLES Informatieren das sich die Sprache geÃ¤ndert hat, alle Strings in allen Programmteilen mÃ¼ssten sich updaten
  etc. - sehr viel sehr unschÃ¶ne Arbeit fÃ¼r wenig Nutzen. Das sparen wir uns lieber und gehen den einfachen Weg. :D



>> 22.08.2007
[CO]
- Machte ein paar Ãnderungen an der Time-Klasse:
  - Ein paar statische Zeiten spendiert, 'Null' wird z.B. in PLNetworkIRC::IRCConnection::ProcessServerMessage()
    verwendet.
  - FÃ¼gte eine Funktion Namens 'ToString()' hinzu Ã¼ber die man sich eine String ReprÃ¤sentation der Zeit zurÃ¼ckgeben lassen kann.
  - m_nDay in m_nDayOfMonth + die entsprechenen Funktionen umbenannt damit eindeutig ist WAS das ist
  - 'EMonth' fÃ¤ngt nun wie EDay bei 0 (wie bei Linux und nicht wie bei Win32 SYSTEMTIME) an damit das einheitlich ist + man
    sich direkt die in ToString() verwendete String Representation des Monats/Tages Ã¼ber ShortMonthName[Month] bzw. ShortDayName[Day]
    zurÃ¼ckgeben lassen kann.
  - Einfache vergleichs-Operatoren hinzugefÃ¼gt.
  - Funktion IsLeapYear()' hinzugefÃ¼gt die ermittelt ob ein gegebenes Jahr ein Schaltjahr ist oder nicht.
  - Funktion 'SetUnixDate()' hinzugefÃ¼gt.
  - Funktion CalculateDayOfWeek()' hinzugefÃ¼gt die den Wochentag berechnent auf den ein Datum fÃ¤llt. SetDOSDate() nutzt
    diese Funktion.
  - 'Unkown' aus 'EDay' entfernt da man sich diese Information nun berechnen lassen kann wenn man diese nicht direkt hat.



>> 21.08.2007
[CO]
- "NoMemoryManager.h" entfernt da wir das derzeit so nicht brauchen da wir keine Memory-Makros nutzen
- Konnte in "Checksum::Get(const String &sClass, File &cFile, PLResult *pResult)" das [TODO] entfernen da es mittlerweile
  mÃ¶glich ist zu prÃ¼fen ob man aus einer Datei lesen kann.



>> 07.08.2007
[CO]
- FSTools: ValidatePath(): War leider etwas Problematisch da man nicht genau wusste ob nun am ende ein '/' eingefÃ¼gt werden
  sollte oder nicht. Darum zerlegte ich diese Funktion in zwei Funktionen:
  - Einmal ValidateFilePath() welche einen Dateinamen korrekt macht
  - Und ValidateDirectoryPath() welche auf ValidateFilePath() aufbaut + sicherstellt das am Ende ein '/' ist
  -> GefÃ¤llt mir zwar nicht wirklich gut, alledings wÃ¼sste ich nicht wie man das anderst handhaben sollte... der User MUSS
     wissen WAS dieser 'Pfad' Darstellt, darum muss er uns das auch mitteilen damit man nicht irgendetwas falsches annimmt.
     "C:/MyDirectory/Test" kÃ¶nnte ein Verzeichniss sein, aber auch eine Datei ohne Dateiendung, darum MÃSSEN Verzeichnisse
     bei uns ausdrÃ¼cklich mit '/' am Ende gekennzeichnet werden damit keine Mehrdeutigkeiten vorhanden sind. AllmÃ¤hlich fÃ¤nde
     ich es irgendwie erleichternd wenn wir Ã¼berall bei Datei/Verzeichniss Namen die 'Url'-Klasse nehmen wÃ¼rden - das wÃ¼rde an
     vielen  Stellen einiges einfacher machen da man nicht mehr irgendeinen Mehrdeutigen Schrott Ã¼bergeben bekommen kann.
     Derzeit sind an vielen Stellen immer Ã¤hnliche Abfragen, und an ein paar Stellen auch nicht wo es dann schnell mal zu
     Problemen kommen kann. :(
  -> Auf jedenfall sind sind nun keine FS Basis Pfade mehr 'doppelt' eingetragen (dort kam gerade durch eventuell fehlende
     '/' einiges durcheinander)



>> 03.08.2007
[CO]
Allgemein:
- Nahm Ã¼berall
    m_pImage->SetInteger(PLGraphics::Image::Mode_OriginSet,  true);
    m_pImage->SetInteger(PLGraphics::Image::Mode_OriginMode, PLGraphics::Image::Origin_UpperLeft);
  vor dem Laden von Bildern raus - diese Einstellungen sind/waren bei uns bereits Default, und innerhalb von PL sollte da
  auch nix umgestellt werden. (0, 0) ist bei uns also Ã¼berall 'links oben'. (u.a. DirectX nutzt diese Regel) Texturen die
  der GPU Ã¼bergeben werden nutzen bis jetzt "(0, 0) ist links unten". (wie in OpenGL) Bis jetzt war das 'nur' inkonsistent,
  aber da wir nun verstÃ¤rkt dds nutzen (um die Textur Massen halbwechs bewÃ¤ltigen zu kÃ¶nnen) zeigte sich das dies hier sehr
  unhandlich ist da dds von DirectX kommt. Zwar passt DevIL immer braf 'oben/unten' fÃ¼r uns an, aber bei den DXTC Daten die
  wir, wenn verfÃ¼gbar direkt zur GPU jagen, wird nix verÃ¤ndert. (war auch wenig Sinnvoll wÃ¤re da man sich dadurch wieder
  den Geschwindigkeitsvorteil kaputt machen wÃ¼rde :)
  Dadurch hatte man dann 'geflippte' Texturen. Darum nun dieses Ãnderung, damit das zum einen bei uns einheitlich wird +
  das man die Vorteile die dds bietet richtig nutzen kann.
  Musste nun zwar sorfÃ¤ltig prÃ¼fen wo z.B. Textur Koordinaten verwendet werden und dort Ã¼ber "1-y" vertauschen, oder "1-y"
  rausnehmen wo nun nicht mehr vertauscht wird - aber das lohnte defintiv. Endlich ist da Ordnung drinnen und in
  PLMesh::Texture::Load() konnte ich nun endlich einen doofen Hack rausnehmen der sowieso nicht zu 100% funktionierte.
  (Ã¼ber dieses 'flip'-Problemchen stolperte ich schon frÃ¼her im Zusammenspiel mit cube dds Texturen)
- Stellte Ã¼berall wo mÃ¶glich/sinnig Texturen auf das dds-Format um. (Texturen != OS Gui Bitmaps, da macht das natÃ¼rlich weniger
  Sinn da man dadurch keine Vorteile hat :)
-> Es wird sicherlich noch einige Tage dauern bis ich 'soweit alle' Stellen angepasst habe die von diesen Ãnderungen betroffen
   sind. Aber im groÃen und ganzen geht alles wieder wie vorher - nur halt flotter zu laden + Grafiker haben direkt selbst
   Kontrolle Ã¼ber die MipMaps und was genau fÃ¼r Kompression verwendet werden soll. :D
   (ohne dds geht das im Grunde nur automatisch -> man hat weniger Kontrolle)



>> 02.08.2007
[CO]
Allgemein:
- Alle Doxygen Konfigurations-Dateien Ã¼ber "doxygen -u" auf den neusten Stand gebracht
- Machte bei allen Loadern alle Funktionen const. Da es von diesen Loader Klassen jeweils nur eine globale Instanz gibt darf
  keine der Funktionen etwas an diesen Objekten Ã¤ndern oder man bekommt spÃ¤testens bei Multi-Threading probleme. Ein paar
  wenige Loader nutzen nun einfach 'pro Instanz'-Daten.



>> 01.08.2007
[CO]
- 'SearchHandleZip' hatte nicht das gleiche Verhalten wie die anderen Implementationen die zuerst '.', anschlieÃend '..' und
  erst dann die 'richtigen' Dateien auflistet... das viel in 'PLSceneViewer.exe' auf wenn man im Datei-Dialog in ein
  'zip-Verzeichniss' wechselte, aber keine '..' mehr da waren zum zurÃ¼ck gehen.



>> 30.07.2007
[CO]
- Loadable: Merkt sich nun auch den 'original' Dateinamen der zum Laden verwendet wurde
- LoadableType::AddLoader: Wenn ein Format bereits im Manager durch einen anderen Loader eingetragen wurde so ist das kein
  Fehler, sondern heist nur das man nicht eindeutig Ã¼ber die Dateiendung rausbekommen kann welcher Loader fÃ¼r dieses Format
  zustÃ¤ndig ist. Dies ist allerdings KEIN Problem da sowieso immer bekannt sein sollte WAS man denn eigentlich laden will,
  also obs ein Mesh, eine Scene etc. ist. Das DirectX Format kann z.B. als Mesh verwendet werden, aber da es sehr flexibel
  erweiterbar ist + Hierarische Strukturen hat kann es genauso auch als Scene genutzt werden.
  Was allerdings auch vorkommen kann ist, das z.B. zwei verschiedene Mesh Formate die gleiche Dateiendung haben, ja eventuell
  sogar im Grunde das gleiche Format sind, aber unterschiedliche Versionen davon. Derzeit wird soetwas noch nicht UnterstÃ¼tzt,
  mÃ¼sste sich spÃ¤ter aber erweitern lassen... macht die Sache allerdings bestimmt nicht einfacher oder Ã¼bersichtlicher. *g*
- Nahm die String Duplizierung aus Loadable::Reload() heraus, in Loadable::Load() ist nun ein universellerer 'Sicherheits'
  Test drinnen



>> 22.07.2007
[CO]
- 'Function': Machte den Konstruktor protected und Dokumentierte krÃ¤ftig da ich gerade ein paar Stunden damit verbrachte
  rauszubekommen was 'genau' (hatte vorher nur eine sehr grobe Vorstellung) das ist bzw. wie man es verwendet. In PLBaseTest
  gibts nun einige Tests fÃ¼r diese FunktionalitÃ¤t... anhand dieser Tests hab ich mich an die Sache rangetastet - Stefan,
  gib mir irgendwann bitte bescheit ob ich das soweit richtig verstanden habe und es auch wie vorgesehen nutze. :)
  Die Investierte Zeit hat sich auf jedenfall gelohnt, denn nun versteh ich was da ablÃ¤uft - wirklich eine sseeehr feine
  Sache. :)
- Container-Klassen abermals durchgeschaut und kleinigkeiten verbessert



>> 21.07.2007
[CO]
Alle Projekte:
- Die paar 'realloc' welche noch verwendet wurden durch 'MemoryManager::Reallocator()' ersetzt + stellen an denen noch z.B.
  'memcpy' verwendet wurde ebenfalls umgestellt damit wirklich alles Ã¼ber den Memory Manager lÃ¤uft. Das mag zwar auf den
  ersten (und eventuell zweiten und dritten und... *g*) Blick 'extrem' erscheinen, hat aber durchaus so seine Vortelle da
  alles eine 'Zentralverwaltung' passiert. (...big brother is watching you...)
PLGeneral:
- SystemWin32: Erste Ãffentliche Funktion eingebaut: ErrorCodeToString(): Wandelt einen Win32 Fehler Code den man Ã¼ber
  GetLastError() erhalten hat in einen PL-String den man dann z.B. direkt ins Log schreiben kann... das hatte ich vor einiger
  Zeit schonmal irgendwo lokal reingehackt als ich mir beim Debuggen Win32 Fehler als String zurÃ¼ckgeben lies.
  In SystemLinux hab ich soetwas nicht eingebaut da es unter Linux eine Funktion namens 'strerror' gibt die sich sehr leicht
  weiternutzen lÃ¤sst.
- System: Neue Funktion: IsLittleEndian(): Damit kann man feststellen welche Byte-Reihenfolge die aktuelle Maschine fÃ¼r
  grÃ¶Ãere primitive Datentypen verwendet. ZukÃ¼nftig kÃ¶nnen wir diese Funktion nutzen um zu entscheiden wie man z.B. ein
  'float' in eine BinÃ¤r Datei schreiben oder auslesen muss. Das bringt allerdings erst 'wirklich' etwas sobald wir nicht mehr
  wie momentan direkt Ã¼ber die Write/Read-Funktionen der File-Klasse diese Daten schreiben/lesen... da muss dann ein kleiner
  Wrapper her damit wir 'wirklich' Plattform unabhÃ¤ngig werden, also auch damit klarkommen wenn die Byte-Reihenfolge anderst
  herum ist. :)
  Ich habe die Funktion 'IsLittleEndian()' und nicht 'IsBigEndian()' genannt da wir derzeit eigentlich nur auf Little-Endian
  GerÃ¤ten arbeiten und ich denke auch diese Anordnung in unseren BinÃ¤r Formaten behalten werden - der Funktionsname deutet
  also so bereits an mit welcher Anordnung PL 'intern' arbeitet.
- Nahm die auskommentierten Memory-Makros aus 'MemoryManager.h' nun komplett raus da wir das denk ich mal so nicht nutzen
  werden da es einfach 'unschÃ¶n' und fehleranfÃ¤llig ist - es wÃ¤re einfach nur doof 'Ã¼berall' 'MemoryManager.h' einbinden zu
  mÃ¼ssen nur damit die Makros 'wirksam' werden. Wenn man brav mit new/delete arbeitet braucht man das auch nicht wirklich.



>> 19.07.2007
[CO]
Alle Projekte:
- Wenn Ã¼ber new Instanzen von Klassen erzeugt werden, aber dem Konstruktor nix Ã¼bergeben wird, war die Schreibweise nicht
  einheitlich. Ãberwiegend hatten wir z.B. "new MyClass()" -> also mit "()" am Ende. So sieht man im Grunde sehr hÃ¤ufig,
  und mittlerweile bin ich diese Schreibweise auch durch Jave gewohnt. Daher Ã¤nderte ich das entsprechend. (aber nicht
  wenn z.B. Primitive Datentypen oder Strukturen erzeugt werden... das kommt mir da etwas merkwÃ¼rdig vor und das sieht
  man auch praktisch nie so geschrieben :)
PLGeneral:
- Fand noch zwei Stellen wo ich sehr einfach malloc/free durch new/delete ersetzen konnte. Wo immer mÃ¶glich (also praktisch
  Ã¼berall :) sollte man lieber new statt malloc etc. nutzen - dadurch braucht man sich dann auch keine Sorgen zu machen 'wo'
  bzw. 'wer' den Speicher anlegt. 'new' lÃ¤sst sich ja sehr einfach Ã¼berladen was auch bereits gemacht wird... aber 'malloc' &
  CO kann man nicht wirklich Ã¼berladen. Zwar kÃ¶nnte man ein Makro schreiben, (was ich zum probieren auch machte :) das fÃ¼hrt
  allerdings dann zu mehr Problemen (teils sogar zu Compiler fehler in Third-Party libs) als es Nutzen bringt.
  An ein paar Stellen wird noch realloc genutzt, diese Stellen werde ich bei Zeiten noch Ã¤ndern damit wir in PL wirklich
  nur new/delete nutzen um mÃ¶glichen Problemen der Speicherverwaltung gleich von Anfang an aus dem Weg zu gehen.
  (man muss soetwas ja nicht provozieren :)



>> 08.07.2007
[CO]
Alle Projekte:
- Entfernte einige &<Name>[0] da & und [0] automatisch vom Compiler hinzugefÃ¼gt wird und das ohne besser Lesbar ist :)
PLGeneral:
- FÃ¼gte ein paar  #error "Unsupported platform"  ein (z.B. in SystemImpl.cpp)



>> 06.07.2007
[CO]
- Die Datei & Klassen Namen der FS Implementationen folgten nicht der Benennung der anderen PL Dateien



>> 24.06.2007
[CO]
Alle Projekte:
- Merkte gerade das in den meisten Dateien der inline Implementationen z.B.
    #ifndef __PLRENDERER_SHADERCGBACKEND_INL__
    #define __PLRENDERER_SHADERCGBACKEND_INL__
  etc. steht, also wie bei den Headern. Dies ist hier allerdings vÃ¶llig Ã¼berflÃ¼ssig da diese Dateien NUR von den jeweiligen
  Headern selbst eingebunden werden dÃ¼rfen und dort bereits im 'geschÃ¼tzten'-Teil liegen. (dem Compiler unnÃ¶tige Arbeit
  sparen iss immer ne gute Sache, auch wenn das absolut nicht ins Gewicht fÃ¤llt *g*)
PLGeneral:
- 'PL_F2DW()' und 'PL_DW2F()' aus 'PLRenderer/Types.h' entfernt und in 'PLGeneral/Tools/Tools.h' als FloatToUInt32() und
  UInt32FloatTo() eingefÃ¼gt. Zum einen fand ich es schon lange nicht mehr sonderlich prall das diese zwei Funktionen (frÃ¼her
  Makros :) so lieblos irgendwo in der Gegend herumstehen + die Namen selbst waren nicht mehr ganz korrekt und nicht
  sonderlich aussagekrÃ¤ftig.



>> 23.06.2007
[CO]
Alle Projekte:
- Verbesserte an einigen Stellen groÃ/kleinschreibung. Wenn z.B. mit 'windows' das Betriebssystem und nicht etwa 'GUI Fenster'
  gemeint sind sollte das 'Windows' geschrieben werden da Name. 'win32' konsequent zu 'Win32' gemacht. 'linux' ist ebenfalls
  ein Name, also 'Linux'.
- Bei 'AbkÃ¼rzungen' wurde so richtig wild gemischt und ich selbst war auch immer sehr unsicher 'wie' man das nun 'Ã¼berlicherweise'
  schreibt. Da wollte ich schon lange mal was machen damit das halbwechs konsequent ist. Daher googelte ich erstmal etwas +
  informierte mich auf Wikipedia wie man Ã¼blicherweise diverse Dinge schreibt. Danach Ã¤nderte ich u.a. 'url/Url' -> 'URL',
  'xml/Xml' -> 'XML', 'html/Html' -> 'HTML', 'zip/Zip' -> 'ZIP', 'gui/Gui' -> 'GUI' (bis auf die Dateiendung 'gui') - nur in den
  Dateinamen Ã¤nderte ich erstmal nix da dies die Lesbarkeit etwas verschlechtert - da kÃ¶nnen wir uns spÃ¤ter Ã¼berlegen ob wir das
  so lassen, oder ob wir das Ã¼berall durchwech konsequent schreiben wollen damit keine Unklarkeiten reinkommen. Das alles kÃ¶nnte man
  natÃ¼rlich als 'belanglose fusselei' abtun... allerdings empfinde ich soetwas als wichtig da es gerade in der Informatik mittlerweile
  sooo viele AbkÃ¼rzungen gibt und ich es auch in Mathematik hÃ¶chst verwirrend und stÃ¶rend empfinde wenn ein und dieselbse Sache
  immer wieder etwas anderst geschrieben wird - das hilft definitiv nicht AnfÃ¤ngern sich in die Materie einzuarbeiten! :(
  Zudem ist PixelLight generell 'case-sensitive' so das wir da (vorallem den Grafikern *g*) mit gutem Vorbild vorausgehen sollten.
PLGeneral:
- FileSystem vom Style und der Ordnung her aktualsiert. Also Dinge privat gemacht die privat zu sein haben, Konkrete
  Implementationen werden wo das nicht benÃ¶tigt wird oder wÃ¼nschenswert ist nicht Exportiert. Wo mÃ¶glich Zeiger zu Referenzen
  gemacht damit man den NULL-Fall nicht berÃ¼cksichten muss. Einige Kommentare verbessert oder genauer gemacht. Einige short
  zu int16 und long zu int32 (+ unsigned Variationen) gemacht damit das in PL Ã¼berall gleich ist + das ist deutlich besser
  lesbar + man weis wirklich ganz genau was das fÃ¼r grÃ¶Ãen zu sein haben.
- Bei der File-Klasse ein 'IsReadable()' hinzugefÃ¼gt. Dies wurde bereits im Loadable-System benÃ¶tigt + ist das passende
  GegenstÃ¼ck zu 'IsWritable()'
- LogFormater Implementationen umbenannt da diese nicht dem PL Namens Style folgten und es mich auch schon mehrmals stÃ¶rte
  das ich erstmal kurz die einzelnen Implementationen zusammensuchen musste - durch die Namens-Ãnderung sind diese Dateien
  wenn man Alphabetisch Ordnen lÃ¤sst immer nett beisammen was enorm Handlich ist.
- BufferedReader Implementationen umbenannt da diese nicht dem PL Namens Style folgten
- CMakeLists.txt: LogFormaterConsole.cpp fehlte
- 'PLEFileSeek' von FileSystem.h in die File-Klasse verschoben und in 'ESeek' umbenannt. 'PLEFileAccess' von FileSystem.h
  in die File-Klasse verschoben und in 'EAccess' umbenannt. Dadurch konnte man auch gleich wieder Header abhÃ¤nigkeiten
  reduzieren. :)
- FileSystem: GetRootDirectory() und GetCurrentDirectory() liefern nun Referencen statt Zeiger zurÃ¼ck denn diese Dinge
  MÃSSEN immer gÃ¼ltig sein... ansonnsten lÃ¤uft gerade etwas soetwas von total daneben. Durch diese Ãnderung wird an einigen
  Stellen der Code nun etwas Ãbersichtlicher da man keine NULL-Abfragen mehr machen muss/sollte.
- FileSystem: GetCurrentDirectory() fÃ¼gt nicht mehr automatisch eine Referenz zum aktuellen Verzeichniss hinzu



>> 22.06.2007
[CO]
- Entfernte aus Timing die Funktionen Start(), Stop() und GetEllapsedTime() und fÃ¼hrte eine neue Klasse Namens 'Stopwatch'
  ein welche diese FunktionalitÃ¤t bereitstellt. Stellte gleich eine Handvoll Stellen in verschiedenen Projekten auf diese
  neue Klasse um - das ist wirklich sehr Handlich. :)
- Time um SetDosDate()-Funktion aus ZipDate erweitert und ZipDate anschlieÃend entfernt da doppelte FunktionalitÃ¤t



>> 16.06.2007
[CO]
Alle Projekte:
- Entfernte bei allen virtuellen und nicht Implementierten Funktionen (=0) das Export Makro da in diesen FÃ¤llen nicht benÃ¶tigt
PLGeneral:
- 'PL_UNUSED'-Makro entfernt da dieses mittlerweile gerade im Zusammenhang mit ungenutzten Referenzen wo man dann zwanghaft
  Header einbinden muss obwohl nix benÃ¶tigt wird sehr unhandlich wird - zudem wollte Stefan das sowieso vor einigen Montaten
  raushaben. :)
  Das war eine Zeitlang recht nett dieses Makro um Ã¼berall zu checken ob Parameter Ã¼berhaupt benÃ¶tigt werden bzw. korrekt
  genutzt werden, mittlerweile ist das aber nicht mehr wirklich nÃ¶tig. Die 'nicht verwendet' Warnung erscheint Ã¼blicherweise
  nur in der allerhÃ¶chsten Warn-Stufe, wenn das jemand aktiv haben will, muss er es fÃ¼r sein Projekt wieder per Hand aktivieren.



>> 12.06.2007
[CO]
- Sleep() von der System Klasse in ThreadManager verschoben da dies dort Thematisch besser reinpasst (der aktuelle aktive
  Thread wird schlafen gelegt...)



>> 09.06.2007
[CO]
- MemoryCopy() & MemorySet() & MemoryCompare() aus Wrapper.h in MemoryManager.h verschoben, das ist dort denke ich recht
  gut aufgehoben
- MemoryManager.h: Defines auskommentiert: Diese Definitionen sind leider recht problematisch und verursachen recht schnell
  Fehler in 'Fremd-Header'.



>> 08.06.2007
[CO]
- BufferedFileReader: Laut Konstruktor Dokumentation wird die Ã¼bergebene Datei automatisch freigegeben, das war allerdings
  nicht der Fall wenn das Dateiende bereits erreicht war - vereinfachte/verallgemeinerte daher den Konstruktor etwas
- An einigen Stellen wo mÃ¶glich/sinnig Zeiger durch Referenzen ersetzt. Uh, verstehe gar nicht wieso ich das frÃ¼her noch
  nicht gesehen habe das es 'meistens' Ã¼ber Referenzen viel eleganter und sicherer geht da man den 'NULL'-Fall nicht
  berÃ¼cksichtigen muss wenn er eigentlich gar nicht erst vorkommen sollte. :)
  Ist zwar einiges an Arbeit nun alle Codes/Interfaces nochmal genau durchzuschaun, aber es lohnt definitiv + nebenbei
  fallen mir auch noch immer einige andere Dinge auf die nicht mehr ganz Up-To-Date sind... ganz nebenbei stehen in ein paar
  Wochen bei mir mal wieder PrÃ¼fungen im Studium an und da sind solche Arbeiten genau das richtige da man das nebenbei
  machen kann ohne sich Gedanklich voll reinhÃ¤ngen zu mÃ¼ssen was zur PrÃ¼fungszeit weniger optimal ist.



>> 07.06.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'childs' in 'children' geÃ¤ndert (das war an einigen Stellen noch falsch :)
PLGeneral:
- XmlAttribute: QueryIntValue() & QueryDoubleValue() Ã¤ndern den Wert der Ã¼bergebenen Variable im Fehlerfall nicht, damit
  ist das Verhalten vergleichbar zu den Ã¤hnlichen Funktionen in XmlElement
PLNetwork:
- Wo mÃ¶glich/sinnig Zeiger durch Referenzen ersetzt



>> 05.06.2007
[CO]
- Time fÃ¼r die Tage Enums spendiert
- Semaphore: m_nValue wurde nicht initialisiert (?)
- Thread::Thread(bool bMainThread): Hier wurden die Variablen nicht initialisiert



>> 29.05.2007
[CO]
- Erweiterte das Var-Interface etwas damit man besseren Zugriff auf die Enumeration-Daten hat



>> 26.05.2007
[CO]
- Das mischen von Debug/Release Builds gestern klappte nicht wirklich gut. Es gab merkwÃ¼rdige Crashs etc. da beide Builds
  intern unterschiedliche VC Memory Manager nutzen die nicht wirklich kompatibel zueinander sind. Da ich das aber wirklich
  wirklich endlich mal sauber am laufen haben wollte befasste ich mich heute etwas mit der Speicherverwaltung. Heraus kam
  ein eigener minimal Memory Manager der im 'PLGeneral/Core'-Ordner liegt und der die C++ new/delete Operatoren 'Ã¼berlÃ¤d'.
  Solche Operationen werden nun direkt in unseren eigenen Memory Manager 'umgeleitet' der fÃ¼rs erste nur malloc/free nutzt.
  Alles Speicher anlegen/freigeben findet nun also NUR noch innerhalb von PLGeneral statt und dadurch verschwinden diese
  merkwÃ¼rdigen Speicherproblemen + wir haben viele weitere mÃ¶glichkeiten wie Speicher-Statistiken, Sicherheits-Checks -
  oder das die Implementation einer komplett eigenen Speicher-Verwaltung!
  Der einzige Hacken bei der Sache ist, das jedes Projekt nun per Hand 'PLGeneral/Core/MemoryManager.inl' einmal irgendwo
  einbinden mÃ¼sste damit diese Operatoren sauber Ã¼berladen werden...
- FÃ¼gte einen Header Namens 'PLGeneral/ModuleMain.h' hinzu. Dieser ist das gegenstÃ¼ck von 'PLGeneral/Main.h' welches fÃ¼r
  Anwendungen verwendet wird. Verschob aus 'RTTIDefs.h' die paar Module-Makros in diese neue Datei - das sind Dinge die
  genauso wie in 'PLGeneral/Main.h' NUR einmal pro Projekt fÃ¼r den Einstiegspunkt benÃ¶tigt werden. 'PLGeneral/Main.h'
  baut somit auf 'PLGeneral/ModuleMain.h' auf, welches wiederum 'RTTIDefs.h' nutzt - so mÃ¼sste das recht Ãberschaubar sein.
  Ich muss allerdings zusgeben das 'Ãberschaubarkeit' nicht der eigentliche Grund fÃ¼r diese kleine Ãnderung war, sondern
  meine aktuellen arbeiten am Memory Manager. NUR einmal pro Projekt sollte 'PLGeneral/Core/MemoryManager.inl' eingebunden
  werden welches dann new/delete Operatoren mit PL eigenen Implementationen 'Ã¼berschreibt'. Allerdings wollte ich das nicht
  jedesmal an zig verschiedene Stellen schreiben mÃ¼ssen da man es mal schnell vergisst und dann der Memory Manager nicht
  korrekt in diesen Modulen arbeiten kann. Daher wird dieser eine Header gleich automatisch in 'ModuleMain.h' eingebunden das
  so oder so genutzt wird - wenn man sich an die PL Richtlinen hÃ¤lt und 'PLMain' etc. nutzt... wer das nicht tut und meint
  er mÃ¼sste selbst beim Einstiegspunkt herumwurschteln der muss sich halt auch selbst um andere Dinge kÃ¼mmern. *g*
  Somit muss sich der User also Ã¼berhaupt nicht um diese Speicher-Geschichte kÃ¼mmern.
-> Als Folge dieser Ãnderungen ist das mischen von Release/Debug Builds nun endlich mÃ¶glich. Da im Grunde im PL-SDK IMMER
   Release genutzt wird und mir die Plugin-Datei Ãnderungen von gestern nicht soo gut gefielen da es dadurch etwas
   unÃ¼bersichtlich und unnÃ¶tig aufwÃ¤ndig wird, machte ich diese Plugin-Datei Ãnderung wieder rÃ¼ckgÃ¤ngig... lies es aber
   hier im Diary stehen damit man nachlesen kann was wieso etc.
   Nutze ich die Release Versionen von PL kann ich aber immer noch mein eigenes Programm wie gehabt Debuggen - das klappt
   sogar mit Dll's. NatÃ¼rlich kann man mit dem Debugger nicht in die PL Funktionen 'einsteigen', aber das wÃ¼rde sowieso nicht
   wirklich gehen da im SDK die cpp-Dateien von PL nicht liegen. :)
   Leider ist derzeit ein zu 100% mischen nicht mÃ¶glich. Trage ich z.B. als Release Library eine Debug Version ein, wird
   die dll zwar ohne Crash etc. geladen, aber die RTTI Klassen werden nicht Regestriert... genau weis ich noch nicht was
   da im Detail ablÃ¤uft. Aber das was mir wichtig war, also z.B. Debuggen einer dll im zusammenspiel mit einer release exe
   klappt ganz wunderbar.



>> 25.05.2007
[CO]
Alle Projekte:
- In den letzten Tagen lies ich in allen Projekten nach 'DEFINE_VAR_LIST' suchen und stellte sicher das die am RTTI
  hÃ¤ngenden Variablen direkt in der Konstruktor Initialisierer-Liste initialisiert werden.
PLGeneral:
- Base: CreateInstance(): 'bSetVars'-Parameter entfernt. Das kann man als User selbst nachtrÃ¤glich machen wenn man will -
  zudem wÃ¼rde das nicht Initialisieren nicht wirklich Sinn machen bzw. wÃ¤re hÃ¶chst GefÃ¤hrlich da man undefinierte ZustÃ¤nde
  hÃ¤tte. (bzw. frÃ¼her hatte) Generell sollten IMMER alle Klassen ihre Variablen selbststÃ¤ndig auf korrekte Default Werte
  setzen (also unabhÃ¤ngig ob diese am 'RTTI' eingehÃ¤ngt sind oder nicht) die mit den in den RTTI Makros angegeben Werten
  Ã¼bereinstimmen. GefÃ¤llt mir zwar nicht wirklich dieses 'doppelte' reinschreiben von Default-Werten, wÃ¼sste aber momentan
  nicht wie man das anderst lÃ¶sen sollte. Auf diese weise kann man u.a. bereits in den Klassen Konstruktoren diese Variablen
  nutzen was voher nicht so ohne weiteres mÃ¶glich war da die Variablen erst 'nach' dem erzeugen auf die Default-Werte gesetzt
  wurden... das war eine sehr unglÃ¼ckliche Situation in die ich in den letzten Jahren natÃ¼rlich immer mal wieder reinstolperte.
  'DEFINE_VAR_RO' ging frÃ¼her nicht korrekt da SetVars() genutzt wurde was dann natÃ¼rlich das setzen der 'read-only'
  Variablen zu verhindern weis.
  Auch war das Initialisieren von am RTTI hÃ¤ngenden Variablen in der Initialisierer-Liste der Konstruktoren inkonsistent.
  Einmal wie z.B. in Vector3 wurde dort initialisiert da man diese auch ohne RTTI nutzen kann, und bei anderen Klassen wie
  z.B. SceneNode nicht da diese 'nur' Ã¼ber das RTTI Instanziert werden kÃ¶nnen.
  Zusammenfassend hat man mehr 'Sicherheit' da immer Variablen in bekannten InitialzustÃ¤nden - da muss wie Ã¼blich natÃ¼rlich
  JEDER Klassen-Schreiber dafÃ¼r sorgen! CreateInstance() ist schlanker + weniger 'Overhead' beim erzeugen von Instanzen -
  da das RTTI System mittlerweile sehr intensiv genutzt wird ein sicherlich nicht ganz unerheblicher Faktor... wird z.B.
  eine *wirklich* groÃe Szene mit mehreren tausend Nodes eingeladen spart man sich nicht gerade wenig Arbeit ein und auch
  wenn man mit dem Debugger Schrittweise den Code Analysiert ist das nun um einiges durchschaubarer.
  Hab mal noch kleine Performance Tests in 'PLSampleScene.exe' gemacht - grÃ¶Ãte Szene (F3) die 4098 Nodes hat, aber nur
  'sehr' wenig verschiedene Daten nutzt und daher optimal fÃ¼r diesen Test ist: (jeweils zwei anlÃ¤ufe)
  - Vorher: 6.483 sec & 6.191 sec 
  - Nacher: 5.571 sec & 5.232 sec
  -> Also in dieser Szene mit 'etwas mehr' Nodes 'minimal' schneller, jedes bischn bringt uns weiter. :)
- Plugin XML Dateien: Ich Ã¼berlegte mir bereits seit geraumer Zeit wie man das mit Debug/Release Builds 'mischen' am besten
  auf die Reihe bekommt - denn im Ã¶ffentlichen PL-SDK liegen NUR Release Builds (bzw. sollten!) und trotzdem soll man auch
  seine auf PL aufbauenden Projekte korrekt Debuggen kÃ¶nnen. Wenn man die Debug Builds hat sollen diese auch genutzt werden
  kÃ¶nnen. Von 3ds Max hab ich auch 'nur' die Release Version, und kann trotzdem meine Exporter Plugins dafÃ¼r korrekt Debuggen,
  also irgendwie ist das sauber realisierbar. :)
  SchlÃ¤gt das einladen einer 'Library' fehl, so kÃ¶nnen nun alternative 'Fallback Libraries' verwendet werden. Konkret ist
  das bei Debug-Libraries sinnvoll. Im Ã¶ffentlichen PL-SDK sind Ã¼blicherweise keine Debug Versionen von PixelLight dabei,
  folglich schlÃ¤gt der Versuch diese zu laden fehl - als Fallback wird nun versucht die entsprechende Release Library zu
  laden. Hat man also die Debug Version (warum auch immer *g*) wird diese korrekt genutzt, ansonnsten die Release Version.
  Als 'normaler PL-User' bin ich aber denk ich ganz froh die Release-Builds von PL beim Debuggen nutzen zu kÃ¶nnen, denn
  diese sind um einiges (!!) flotter und so kann man sich recht gut auf das Debuggen seines eigenen Projektes konzentrieren.
  Somit kann man problemlos und ich denke mal recht Intuitiv Release & Debug Builds mischen - das Plugin System Ã¼ber diese
  XML Dateien mÃ¼sste nun soweit alles kÃ¶nnen das wir derzeit brauchen.
  Nahm den Parameter der 'PLGetPluginInfo'-Funktion im 'DEFINE_MODULE_PLUGIN'-Makro heraus und fÃ¼gte dafÃ¼r eine weitere Funktion
  namens 'PLIsPluginDebugBuild' hinzu Ã¼ber die ermittelt werden kann ob das Plugin als Release oder Debug Ã¼bersetzt wurde.
  ClassManager::LoadPlugin() kann dann auf wunsch einen Build Type Test erzwingen so das NUR zusammen passende Builds verwendet
  werden kÃ¶nnen - als Default ist dies allerdings deaktiviert da dies normalerweise nicht nÃ¶tig/Ã¼blich ist bzw. sein sollte.



>> 22.05.2007
[CO]
- Bugfix: Class::GetVar(): Meine Ãnderung der Implementation vom 18.03.2007 war natÃ¼rlich nicht ganz korrekt da nicht
  berÃ¼cksichtigt wurde das es sehr wohl sein kann das die Variablen der Basis Klasse noch nicht Initialisiert sind - korrigiert.



>> 21.05.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'choosen' in 'chosen' geÃ¤ndert



>> 19.05.2007
[CO]
Alle Projekte:
- In Funktionen wo hÃ¤ufiger Instanzen von RTTI Klassen erzeugt werden und 'zur Sicherheit' geprÃ¼ft wird ob die Basis Klasse
  korrekt ist machte ich eine kleine rein Funktions interne Optimierung:
  Statt Class::HasBaseClass(String) wird nun Class::HasBaseClass(Class) genutzt wodurch man sich HashMap Operationen spart
  und sofort immer einen korrekten Zeiger auf die Basis Klasse hat. (der IMMER korrekt ist da Kern-Komponenten!) ZusÃ¤tzlich
  kann nun unsere String Klasse ihre Muskeln spielen lassen: Class::HasBaseClass(Class) nutzt intern String::Compare()...
  und hier muss dann am ende NUR noch ein einfacher Zeiger Test gemacht werden um festzustellen das die Basis Klasse gefunden
  wurde ohne die Strings selbst wirklich miteinander zu vergleichen - noch Effektiver gehts wohl kaum! *g*
  An Stellen wo teils nur ein einziges mal pro Programm start Class::HasBaseClass() verwendet wird lohnt soetwas natÃ¼rlich
  nicht - aber bei z.B. PLEngine::SceneContainer::Create() ist das durchaus eine feine Sache.
PLGeneral:
- Loader: RTTI Variablen sind nun endlich 'read only'. Dies erreichte ich dadurch das nicht das RTTI die Variablen anfangs
  Initialisiert, sondern das die Variablen sauber wie man es gewohnt ist in der Initialisierer Liste der Konstruktoren
  initialisiert werden. Von Loader abgeleitete Klassen 'Ã¼berschreiben' indem diese den jeweiligen Konstruktoren entsprechend
  neue Werte Ã¼bergeben - das ist so wirklich deutlich besser. :)
- HtmlLogFormater: Funktionen etwas umsortiert so das die Reihenfolge der Daten immer gleich ist
- Machte bei LogFormater Implementationen einiges 'private' da man nicht weiter davon ableiten kÃ¶nnen soll + ein paar
  Ã¶ffenliche Funktonen wurden nicht exportiert



>> 17.05.2007
[CO]
- Stack & Queue: Pop(): Kommentar erweitert (fÃ¼r eine Situation wo man aufpassen sollte)



>> 15.05.2007
[CO]
- System::DeleteEnvironmentVariable() Implementation fehlte
- Bei den System-Klassen einige Dinge 'private' gemacht wo entweder nix von auÃen drauf zugreifen soll oder wo man nicht
  weiter Ableiten kÃ¶nnen soll
- Ein paar 'const' hinzugefÃ¼gt
- Im Loadable System einige Zeiger zu Referenzen gemacht, so muss man bei den Kommentaren nicht mehr 'NEVER NULL!'
  dazuschreiben da es bereits von anfang an unmÃ¶glich ist NULL-Zeiger zu Ã¼bergeben.



>> 12.05.2007
[CO]
- Class::GetBaseClasses() entfernt da es hierfÃ¼r keine Implementation (mehr) gab (?)
- ClassManager::GetClasses() gibt keine Liste mehr zurÃ¼ck, sondern bekommt eine als Parameter Ã¼bergeben. Zum einen ist
  das so nun konsistent mit z.B. Class::GetVarList(), aber noch viel wichtiger ist, das so herum nun nicht mehr aufwÃ¤ndig
  viel herumkopiert werden muss. Das gleiche in der Module Klasse.
- Var: Machte ein paar grundliegende Funktionen protected. NUR Class darf hier direkt drauf zugreifen, so ist gewÃ¤hrleistet
  das z.B. wirklich IMMER eine Variable zu einer Klasse gehÃ¶rt.
- Machte an den RTTI Klassen einige 'Sicherungs'-MaÃnahmen indem ich einige Parameter & Funktionen const machte (an vielen
  Dingen hat der User einfach selbst nix zu Ã¤ndern :) und dort wo
  man nicht 'umbedingt' einen Zeiger als Parameter Ã¼bergeben muss wird nun stattdessen eine Referenz verwendet - denn die kann
  ja nie NULL werden und so kann der User schonmal weniger Schrott Ã¼bergeben + man spart sich Sicherheits-Abfragen. (die teils
  nicht vorhanden waren)
- Durch die Ãnderungen kann man sich nun sogar in 'RTTIDefs.h' das Einbinden von 'Var.h' sparen :)



>> 11.05.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'socked' in 'socket' geÃ¤ndert
- Rechtschreib-Korrektur: 'terminal NULL', ich glaub damit meinte ich 'terminating zero' (jeder lacht aber keiner sagts :)
PLGeneral:
- String: In der Funktions-Beschreibung von GetLength() fehlte eine ganz entscheidende Information, 'terminating zero'
  ist in der LÃ¤nge nicht enthalten. Ãberall anderst stand das bereits wenn ich nix Ã¼bersehen hab.
PLNetwork:
- Im Server-Destruktor muss man noch zur Sicherheit 'StopHost()' aufrufen da dieser Aufruf vom Host-Destruktor aus
  dummerweise in der Host Implementation von StopHost() landet und daher wenns mal mies lÃ¤uft nicht sauber aufgerÃ¤umt wird
- Im Destruktor von Socket() wird nun zur Sicherheit 'Close()' aufgerufen... etwas spÃ¤ter nach merkwÃ¼rdigen 'Problemen'
  merkte ich das ich nicht ganz verstanden hatte was bei Sockets abgeht. NatÃ¼rlich darf man das hier NICHT automatisch
  schlieÃen. Damit ich das nicht nochmal mache fÃ¼gte ich ein entsprechendes Kommentar in diesem Destruktor ein. *g*
  Das gleiche in der Create()-Funktion wo es ebenfalls nicht angebracht ist automatisch Close() aufzurufen.
- Socket::Close() liefert nun anstatt 'int' ein 'bool' zurÃ¼ck welches nur angibt ob alles gut ging oder nicht, denn mit der
  Implementations abhÃ¤ngigen Fehler ID sollte der User nicht in Kontakt kommen bzw. er kann damit im allgemeinen nix
  anfangen da er nix von der konkreten Implementation weis. (bzw. wissen sollte *g*)
  Das gleiche beim RÃ¼ckgabewert der Bind() und Listen() Funktionen.
- Socket::Create() gibt nun einen Fehler-Code zurÃ¼ck
- Socket::m_nSocket ist nun auf INVALID_SOCKET wenn 'ungÃ¼ltig'
- Connection::OnReceive(): Der Ã¼bergebene Buffer mit den erhaltenen Daten ist nun 'const' da dieser Buffer selbst nicht
  direkt manipuliert werden 'sollte' (kÃ¶nnte wenns dumm lÃ¤uft irgendwann mal unfeine Seiteneffekte erzeugen)
- Stellte auf PLBool um damit das erstmal Einheitlich ist
- Erweiterte die Kommentare so das mÃ¶glichst keine Fragen mehr offen bleiben was z.B. Parameter machen/was zurÃ¼ckgegeben
  wird etc. Einiges muss man aber bei Zeiten auf jeden Fall noch genauer Beschreiben, vorallem ein paar kleine hintergrund
  Informationen.



>> 10.05.2007
[CO]
- Sortierte ins Diary so richtig alte EintrÃ¤ge aus "PLSDK/internal/old_diaries.zip" ein



>> 09.05.2007
[CO]
- Sortierte ins Diary alte EintrÃ¤ge aus "PLSDK/internal/old_diaries.zip" von ab "02.04.04" ein
- Neue abstrakte Basis-Klasse eingefÃ¼hrt: 'Iterable': Alles was einen Iterator Implementiert sollte von dieser Klasse
  abgeleitet sein. 'Map', 'Heap' und 'Container' sind somit nun also von 'Iterable' abgeleitet - so bekommt man eine noch
  etwas schickere und stimmigere Klassen-Hierarchie. :)



>> 21.04.2007
[CO]
PLNetwork:
- Socket::Recv() in Socket::Receive() umbenannt (man spart nicht wirklich was und muss sich nen kÃ¼rzel merken)
- Klassen Beschreibungen anhand von Stefans Konzept vom 08.03.2007 hinzugefÃ¼gt/erweitert



>> 20.04.2007
[CO]
- Timing::Update(): Auf PLBool umgestellt



>> 18.04.2007
[CO]
Alle Projekte:
- Nach kurzer RÃ¼cksprache mit Stefan gestern Ã¤nderte ich (automatisch, also ') = NULL;' zu ') = 0;' gleiche mit const,
  ersetzen lassen, insgesammt an 688 Stellen + 1 wobei diese eine Stelle nur unglÃ¼cklich Formatiert war so das man per Hand
  ranmusste :) alle z.B. 'virtual void Test() = NULL' in 'virtual void Test() = 0' da 'NULL' in OS-Headern leider nicht immer
  zwanghaft als '0' oder '(void*)0' definiert ist - unter Linux ist das schonmal als '__null' definiert und dann gibts
  Compiler Fehler im Zusammenspiel mit z.B. 'virtual Test() = NULL' und man muss dann immer genau nachprÃ¼fen wo/wie NULL in
  Headern einfach umdefiniert wurde das nicht wirklich die Ãbersichtlichkeit fÃ¶rdert. :(
  Neben diesen Compiler-Problemen war dies Ã¼ber 'NULL' auch hin und wieder etwas unhandlich wenn man wie in
  'PLGeneral::Iterator.h' eigentlich Ã¼berhaupt kein Include benÃ¶tigt, aber durch 'NULL' dann eben doch den PLGeneral-Header
  einbinden musste. Ich googelte etwas und schaute mir verschiedene C++ Codes durch, fand aber irgendwie nichts wo bei
  virtuellen-Funktionen 'NULL' statt '0' verwendet wurde. Wenn ich mich recht erinnere sah man das 'frÃ¼her' hÃ¤ufiger,
  heute aber nicht mehr wirklich oft.
- Nahm '-U__GNUG__' Linux Compiler Definition aus allen CMake-Dateien heraus
PLNetwork:
- Sobald man in 'PLGeneralLinuxIncludes.h' das von z.B. 'gethostbyname' benÃ¶tigte '#include <netdb.h>' einband bekam man
  in '/usr/include/netdb.h:661' einen merkwÃ¼rdigen Compiler-Fehler.
  Stephan und ich fanden zusammen Ã¼ber herumstochern heraus das die Compiler Option '-U__GNUG__' dafÃ¼r verantwortlich ist,
  nahm man diese jedoch heraus wurde 'NULL' zu '__null' umdefiniert und man bekam bei virtuellen-Funktionen Probleme wenn
  '= NULL' verwendet wurde, daher die '= NULL zu = 0'-Ãnderungen von oben. :)
- PLNetwork & PLNetworkIRC lassen sich nun auch unter Linux Ã¼bersetzen



>> 14.04.2007
[CO]
- Base::SetVars() verbessert so das man z.B. auch 'Flags=""' in z.B. einer Szene-Datei schreiben kann ohne eine Fehlermeldung
  zu bekommen das ein abschlieÃendes '"' fehlen wÃ¼rde
- Thread::Join() Kommentar etwas erweitert... wie ich gerade in PLPhysicsNewton::WorldThread::~WorldThread() feststellen
  musste ist ein 'join' ohne Timeout mit Vorsicht zu geniesen...



>> 09.04.2007
[CO]
- Nahm weitere 'return' heraus
PLNetwork:
- Nahm weitere 'return' heraus



>> 08.04.2007
[CO]
- Formte einge Codes um so das man weniger 'return' benÃ¶tigt was die Sache etwas Ã¼bersichtlicher macht
- ClassManager.cpp: 'NO_GROUP'-Definition entfernt da dies mittlerweile nicht mehr verwendet wird
- ZipSearchHandle::CheckFileInDirectory(): Hier wird nun 'm_pZipDir->m_bCaseSensitive' berÃ¼cksichtigt
- ZipDirectory: Neue Funktion: IsCaseSensitive() wird von ZipSearchHandle::CheckFileInDirectory() benÃ¶tigt
- Base::IsVarDefault(): Arbeitet nun Case-Sensitive da PL generell Case-Sensitive ist
PLNetwork:
- Formte einge Codes um so das man weniger 'return' benÃ¶tigt was die Sache etwas Ã¼bersichtlicher macht



>> 07.04.2007
[CO]
- Dort wo in der String Klasse 'isdigit()' oder 'isalpha()' verwendet wird, wird zur Sicherheit auf 'unsigned char' gecasted
  da man sonst schnell ein Assert bekommen kann wenn man z.B. 'Ã' im String stehen hat. :(



>> 31.03.2007
[CO]
PLNetwork:
- Host::RemoveConnection(): Hm, hier fehlte das austragen der Connection aus der Liste (absicht?)
- OS/Standard-Header werden nun nur noch in den Implementationen eingebunden
- Ein paar Sicherheits-Tests in 'Socket'-Klasse eingebaut
- Globale 'Initialize()'-Funktion entfernt da es etwas unhandlich ist das Manuell aufzurufen. Das lÃ¤uft nun wie bei Image
  Ã¼ber einen globalen Guard.



>> 29.03.2007
[CO]
PLNetwork:
- Einige einfache Stellen auf unsere String-Klasse umgestellt
- Connection: SendMsg() ist durch unsere String Klasse nun Ã¼berflÃ¼ssig
- Connection: In Send() gabs wenn ich das richtig sah ein Speicherleck da der Daten-Speicher nicht wieder freigegeben wurde
  - durch die String Klasse natÃ¼rlich nun kein Thema mehr :)



>> 27.03.2007
[CO]
- Linux Port etwas aufgerÃ¤umt



>> 25.03.2007
[CO]
- Types.h entfernt. Ãberall wo X, Y, Z, W genutzt wurde durch entsprechende Vektor-Enums ersetzt damit man weiterhin sofort
  erkennen kann welche Komponente verÃ¤ndert wird. R, G, B wurde nur an einer einzigen Stelle verwendet. PL_UNUSED-Makro
  in die OS-Header verschoben.
- NULL-Definition in die OS-Header verschoben



>> 24.03.2007
[CO]
Alle Projekte: Alle CMake Dateien:
- Einige Leerzeichen/Tab Ãnderungen in den CMake Dateien
PLGeneral:
- System: Neue Funktion: GetPlatform(): Diese Funktion gibt im Gegensatz zu GetOS() nur einen Ã¼bergeordneten Plattform
  Namen wie z.B. 'Win32' fÃ¼r ein 32 Bit Windows System etc. zurÃ¼ck
- Xml Plugin Format nach Stefans VorschlÃ¤gen vom 25.02.2007 geÃ¤ndert. Es gibt nur noch eine Plugin Datei und keine fÃ¼r
  Release und Debug. In der Datei kann es beliebig viele 'Platform'-BlÃ¶cke geben, jedoch werden nur die berÃ¼cksichtigt
  welche mit System::GetPlatform() zusammenpassen. (daher diese neue Funktion :) Innerhalb eines 'Platform'-Blockes kann
  es verschiedene 'Library'-EintrÃ¤ge geben welche jeweils einen Release oder Debug Type haben kÃ¶nnen. Diese Dateien kÃ¶nnen
  absolute Pfade haben (nicht wirklich immer Sinnvoll *g*) oder relativ zur Plugin-Datei liegen.
  Passte alle Plugin-Dateien entsprechend an. Diese Ãnderungen machen wie Stefan schon sagte die Sache Ã¼bersichtlicher und
  ganz nebenbei mÃ¤chtiger da ein Plugin nun z.B. aus mehreren Bibliotheken bestehen kann und diese nicht mehr zwangslÃ¤ufig
  im gleichen Ordner liegen mÃ¼ssen wie die Plugin-Datei selbst. :D
  Dependencies werden in diesen Plugin-Dateien pro Library wie gehabt eingetragen. Das ist jedoch rein optional und soll
  wirklich nur dazu dienen das man immer den Ãberblick behÃ¤lt was von wem abhÃ¤ngt so das man nicht lange herumsuchen oder
  gar herumprobieren muss.



>> 23.03.2007
[CO]
Alle Projekte: Alle VC-Projekt Dateien:
- Deaktivierte die Linker Option '/INCREMENTAL' (nur geÃ¤nderte Methoden neu Ã¼bersetzen) da diese in Konflikt mit '/LTCG'
  (gesammte Projekt Optimierung) stand. Damit ist nun folgende Linker Warnung wech:
  "LINK : warning LNK4075: /INCREMENTAL wird aufgrund der Angabe von /LTCG ignoriert."
PLGeneral:
- Im Release Build wird die Bibliothek 'LIBCMT.lib' ignoriert da diese laut Linker Warnung in Konflikt mit einer anderen
  stand.



>> 18.03.2007
[CO]
Da wir mittlerweile sehr viele RTTI Klassen haben und spÃ¤ter gerade bei konkreten Projekten sicherlich nochmal einige
hinzukommen versuchte ich die vom RTTI verbrauchten Resourcen 'etwas' in den Griff zu bekommen OHNE das System komplett
umzubauen. Also minimalste Ãnderungen mit grÃ¶Ãt mÃ¶glicher Verbesserung damit das nicht mehr ganz so zÃ¤h lÃ¤uft was mich
ehrlich gesagt mittlerweile etwas stÃ¶rt.
Auf die Hash Map Optimierung vom 14.03.2007 kam ich erst als ich mir mal angeschaut hatte warum bereits einfachste
Programme vergleichsmÃ¤Ãig viel Speicher verbrauchten und beim starten auch viel zu lange brauchten. Es stellte sich heraus
das die Enum Dinge in der Vars Klasse sehr viel Overhead erzeugten. Es wurde gerade fÃ¼r die Enum Hash Map viel zu viel
Speicher verschwendet obwohl diese bei nicht Enum Variablen absolut nie benÃ¶tigt wurde. Ich Ã¼berlegte mir dort ob man
die Hash Map da nicht gleich ganz rausnehmen sollte, lies das aber erstmal da es nun nicht mehr so heftig ist und ich meine
Ãnderungen an diesen Komponenten so klein wie mÃ¶glich halten will.
Eine andere Sache ist die, das wir zwar viele RTTI Klassen haben, aber ebenfalls viele in den meisten Anwendungen Ã¼berhaupt
nicht nutzen. Daran DAS RTTI Klassen da sind, da kann man nix Ã¤ndern auÃer nicht benÃ¶tigte Plugins zu deaktiveren. Aber Ã¼ber
das bewÃ¤rte 'Lazy Evaluation'-Muster das schon so gut im Scene Graph klappt konnte man das ohne zu groÃe Eingriffe Resourcen
schonender machen:
- Class: In 'Init()' werden die Variablen der Basis Klasse NICHT mehr zu der aktuellen Klasse hinzugefÃ¼gt da dies einfach
  nur unnÃ¶tig ist. Stattdessen gehen die Funktionen 'GetVarList()' und 'GetVar()' einfach bei Bedarf Rekursiv zu der Basis-
  Klasse weiter - FunktionsmÃ¤Ãig also keine Ãnderung, aber Resourcen schonender und auch Ã¼bersichtlicher.
- Class::AddVar(): "Overwrite an already existing variable?"-Teil entfernt da dies nun durch die Ãnderung von oben
  Ã¼berflÃ¼ssig ist
- Die Klassen Variablen werden nun nach dem 'Lazy Evaluation'-Schema Initialisiert, sprich, erst wirklich dann wenn diese
  zum ersten mal wirklich benÃ¶tigt werden... was Ã¶fters NIE der Fall ist und dann mÃ¼ssen die Variablen auch NIE Initialisiert
  werden :D
-> Der Windows Task Manager zeigte mir bei 'PLSampleInitExit' vor dieser Ãnderung einen Speicherverbraucht von '31.368 K'
   an, danach '29.980 K' + es startet minimal flotter. (hab derzeit bei mir alle nicht umbedingt benÃ¶tigten Plugins wÃ¤hrend
   der Entwicklung deaktiviert, sonst wÃ¤ren das nochmal ca. 10 MB mehr Speicher)



>> 16.03.2007
[CO]
Alle Projekte: Einige Inkonsistensen behoben:
- In Headern wurde beim Einbinden von '*.inl' im Block einmal 'Implementation' oder 'Inline includes' geschrieben. Ãnderte
  das Ã¼berall in 'Implementation' da dies hÃ¤ufiger verwendet wurde... so braucht man nur nach '//[ Implementation' zu
  suchen um all diese Stellen angezeigt zu bekommen.
- 'filename' wurde nicht Ã¼berall gleich geschrieben, einmal 'FileName', oder 'file name'. Da 'filename' bei uns am meisten
  verwendet wird und das u.a. so auch auf Wikipedia geschrieben wird und mein Ãbersetzungs-Tool das so ebenfalls kannte
  machte ich das einheitlich da es mich nun schon ein paar mal verunsicherte wie man das schreiben soll - zudem ist das
  irgendwie doof wenn das innerhalb eines Projektes immer mal wieder anderst geschrieben wird, auch wenn beide schreibweisen
  'richtig' sind... so muss man nicht pro Funktion schaun wie es jeweils geschrieben wird. *g*
- Entfernte den Begriff 'dll' bei z.B. dem 'Import/Export'-Block oder Header Titeln damit das verallgemeinert und nicht
  Begrifflich Windows bezogen ist.
- Bei einigen Klassen sind die Methoden in einzelne 'BlÃ¶cke' unterteilt, versuchte den Block Titel soweit einheitlich einzurÃ¼cken



>> 14.03.2007
[CO]
- HashMap Speicher Optimierung: Die internen Slots werden NICHT mehr sofort angelegt, sondern erst dann wenn das erste Element
  eingefÃ¼gt wird... denn es kann durchaus vorkommen das eine HashMap warum auch immer mal Ã¼berhaupt nicht genutzt wird, und in
  dem Fall braucht diese intern keinen weiteren Speicher anzulegen. :)
  Der Windows Task Manager zeigte mir bei 'PLSampleInitExit' vor dieser Ãnderung einen Speicherverbraucht von '35.596 K' an,
  danach '31.368 K'.



>> 12.03.2007
[CO]
Alle Projekte: PLBase:
- Mit den Header Ãnderungen bin ich in PLBase nun erstmal soweit durch - mittlerweile wird von TortoiseSVN fast alles rot
  Dargestellt da geÃ¤ndert. Also nicht Ã¼ber die Masse an geÃ¤nderten Dateien wundern, das zieht sich wirklich durch alle Projekte
  durch. Ich finde das nun wirklich um 'einiges' besser als vorher - auch wenn es noch Details zu verbessern gibt.



>> 10.03.2007
[CO]
- Container + Implementationen: Add() & Remove() & Copy() & Compare(): 'nCount' ist nun uint32, wenn 0, so wird alles hinter
  Start kopiert. <0 war sehr ungeschickt und auch teils fehlerhaft Implementiert - zudem machte das wenig Sinn, wenn jemand
  nix machen will, so hat er erst gar nicht diese Funktionen aufzurufen! :)
- Machte die besprochenen Header Ãnderungen die auch in PLNetwork schon so gut klappten. In PL Headern sollten unter keinen
  umstÃ¤nden mehr direkt oder indirekt z.B. Standard-Header reinkommen, also u.a. kein direktes 'memcpy' mehr in Headern/Inline
  Implementationen. Da ich die Codes nochmal komplett durch schauen musste, Ã¤nderte ich dabei gleich Dinge die wir mittlerweile
  anderst schreiben. (u.a. 'strukturierter') Wo mÃ¶glich reduzierte ich die AbhÃ¤ngigkeiten von z.B. Headern durch Predefinitions
  oder verschieben von Inline in cpp noch weiter. Auch machte ich die besprochenen Ãnderungen bei der Verwendung von Namespaces,
  also Ã¼berall 'using namespace' in cpp sobald etwas einmal benÃ¶tigt wird.
- Kleine 'Wrapper'-Klasse im Tools-Ordner hinzugefÃ¼gt fÃ¼r Dinge wie z.B. 'memset' die wir in Headern oder Inline-Implementationen
  nutzen. (was nur sehr selten der Fall ist!)



>> 09.03.2007
[CO]
Neues Projekt: PLNetwork:
Stefan schickte mir gestern per E-Mail PLNetwork das er vor 3 Jahren oder so schon mal geschrieben und immer mal wieder kurz
aktualisiert hatte. Wie besprochen Integrierte ich dieses Projekt in PixelLight. Machte auch ein paar erste kleine Ãnderungen
die FunktionsmÃ¤Ãig aben nix Ã¤ndern sollten: (solche Ãnderungen sind ganz nebenbei optimal zum in etwas einarbeiten *g*)
- Host: Ersetzte die stl vector Klasse durch unsere List Klasse
- Socket::Close(): Hier stimmte glaube ich etwas nicht ganz, da z.B. gleich bei 'closesocket' die Funktion verlassen wurde, und
  etwas weiter unten dann (nicht wirklich *g*) die Variablen zurÃ¼ckgesetzt wurden
- Ãnderte ein paar Variablen wie z.B. 'Port' in uint32 damit man gleich von vorne an keine negativen Werte bekommen kann
- Passte hier und da minimal den Code Style an die anderen Projekte an
- Machte hier gleich die Ãnderungen die wir fÃ¼r alle Projekte machen wollen, also nur 'using namespace...' in cpp, ein Header
  hat selbst wirklich ALLES zu definieren/includieren was er selbst braucht - inklusive des Lib-Headers der eigenen Lib



>> 02.03.2007
[CO]
- FileSystem::SetBaseDirPriority() & LoadableType::SetSearchPathPriority() Implementiert
- Loader::OpenFile(): Da das File System bei absoluten Dateinamen nicht erst lange herumsuchen muss, versucht das Loadable System
  erstmal den wahrscheinlichsten absoluten Pfade zu nutzen - das klappt meistens und die Ladezeiten werden dadurch spÃ¼rbar kÃ¼rzer!
  Gerade in groÃen Szenen wie z.B. der aktuellen vom Dungeon Demo ist das Laden nun um einiges annehmbarer - zwar natÃ¼rlich noch
  nicht Optimal (Memory Mapped Files mÃ¼ssten hier nochmals einiges bringen) aber zumindestens nicht mehr Ã¤tzend. *g*



>> 02.03.2007
[SB]
- Da es keine Header geben sollte, die nur dann fehlerfrei benutzt werden kÃ¶nnen wenn vorher noch andere Header eingebunden werden
  (also AbhÃ¤ngigkeiten des Headers nicht im Header selbt eingebunden werden), habe ich PLGeneralWin32Header.h Ã¼berall dort, wo
  Win32-Datentypen in einer Klasse direkt verwendet werden, auch direkt in dem entsprechenden Header eingebunden. ZusÃ¤tzliche
  AbhÃ¤ngigkeiten werden dadurch nicht erzeugt, da diese System-Header sowieso nur in den eigenen .cpp Dateien eingebunden werden
  und in der Factory-Funktion, die das benÃ¶tigte System-Objekt erzeugt. An beiden Stellen muÃten vorher also auch die System-Header
  eingebunden werden, um die Header-Datei Ã¼berhaupt verwenden zu kÃ¶nnen, was wie gesagt niemals passieren sollte.   
- PLGeneralOSHeaders.h entfernt. Dieser Header wurde nur ein einziges Mal eingebunden, und sollte auch in Zukunft nur sehr selten
  gebraucht werden, da man meist gleich entweder eine Win32- oder Linux-spezifische Datei hat. Dieser Header ist daher unnÃ¶tig,
  und kann in diesen seltenen FÃ¤llen durch eine direkte Fallunterscheidung ersetzt werden



>> 28.02.2007
[CO]
- FileSystem::Mount(): Unterscheidet nun zwischen groÃ/kleinschreibung wie es Ã¼berall in PL der Fall ist
- ZipDirectory::GetName(): Gab etwas anderes zurÃ¼ck als ich erwartet hÃ¤tte und als es die Dokumentation zu FileObject::GetName()
  beschrieb. Daher Ã¤nderte ich es so das es passt und fÃ¼gte eine neue Funktion 'GetNameWithinZipFile()' hinzu welche den Namen
  innerhalb der Zip-Datei zurÃ¼ckgibt.



>> 26.02.2007
[CO]
Alle Projekte:
- Ging die Namensgebung der Funktionen nochmal durch welche im Grunde nur 'ja' oder 'nein' zurÃ¼ckgeben. GetEnabled, GetActive etc.
  zu IsEnabled, IsActive etc. Da wir momentan noch PLBool drinnen haben musste ich nur nach bool Suchen ("bool Get") lassen. :)
  Ein paar Funktions-Namen lies ich jedoch, an Stellen wo 'Is' irgendwie noch unpassender als 'Get' ist und ein 'Has' auch irgendwie
  fehl am Platz ist - da mÃ¼sste man eventuell nochmal schaun ob die Funktionnamen an sich Ã¼berhaupt Sinnvoll sind.
  (wenn man mal gerade nix besseres zu tun hat *g*)



>> 25.02.2007
[SB]
- Neue Klassen-Templates fÃ¼r Funktions-Objekte hinzugefÃ¼gt. Das sind recht praktische Zeitgenossen, mit denen Zeiger auf Funktionen
  als Objekte gespeichert werden kÃ¶nnen. Diese Objekte kÃ¶nnen dann genauso aufgerufen werden wie Funktionen. Im Gegensatz zu
  Funktions-Pointern kÃ¶nnen diese Objekte aber nicht nur Zeiger auf statische Funktionen sein, sondern auch Zeiger
  auf Member-Funktionen von Klassen, die zusammen mit einem Zeiger auf ein Objekt dieser Klasse gespeichert werden.
  Bitte beachten: FunctionTmpl.inl funktioniert etwas anders als unsere Ã¼blichen .inl Funktionen, daher auch der etwas andere Name,
  da es sich eben nicht nur um die Inline-Implementation von Function.h handelt. Das #ifdef in dieser Datei wurde NICHT vergessen
  sondern ist GEWOLLT weggelassen worden, da die Makros ansonsten nicht mehr richtig funktionieren wÃ¼rden! :-)   



>> 24.02.2007
[SB]
Alle Projekte:
- Alle Projekte so angepaÃt, daÃ sich wieder alles mit VC7 Ã¼bersetzen lÃ¤Ãt.
- Alle CMake Projektdateien angepaÃt: Es wird jetzt ein anderes Kommando fÃ¼r die Postbuild-Kommandos verwendet, da es bei der
  alten Variante u.U. zu Problemen mit den AbhÃ¤ngigkeiten und der Reihenfolge der Projekte kommen konnte. Auch wird so der
  Postbuild-Vorgang nicht mehr als eigenes Target angezeigt.  
PLGeneral:
- Undef einiger weiterer Definitionen aus den Window-Headern in PLGeneralWin32Includes.h hinzugefÃ¼gt, die benÃ¶tigt wurden da es
  sonst Namenskonflikte mit eigenen Methoden aus SystemImpl gibt.



>> 23.02.2007
[SB]
Alle Projekte:
- Alle Projekte so angepaÃt, daÃ sich alles auch wieder unter Linux Ã¼bersetzen lÃ¤Ãt



>> 23.02.2007
[CO]
Alle Projekte:
- Da ich gerade vom Compiler in den PL Beispielen mal wieder gesagt bekommen hatte das es einen Namespace Konflikt gibt und
  nicht entschieden werden kann ob 'Rectangle' denn nun ein "Win32 Rectangle" oder ein 'PLMath::Rectangle' sei hatte ich einfach
  absolut KEINE Lust mehr auf dieses total bescheuerte herumgehacke mit den Namespaces etc. nur weil irgendwo ein OS Header
  reinkommt den man eigentlich Ã¼berhaupt nicht braucht und dort halt Dinge definiert sind die man ebenfalls nicht braucht sondern
  wirklich nichts als Ãrger machen. Daher baute ich das endlich mal so um das OS Header NUR noch dann reinkommen wenn man diese
  WIRKLICH braucht, also in den konkreten OS Implementationen. Ãberall sonst darf von nun an absolut NICHTS OS AbhÃ¤ngiges mehr
  reinkommen - und falls das doch mal 'nÃ¶tig' sein sollte lÃ¤uft etwas falsch, denn es MUSS ohne gehen.
  Bei den erstaunlicherweise sehr kleinen Ãnderungen damit das ohne stÃ¤ndige OS Header klappt gab es ebenfalls erstaunlicherweise
  praktisch keine Probleme da wir im laufe der Jahre bereits alles 'virtualisiert' hatten. :)
  Beim Ã¼bersetzen unter Windows klappt das nun so ganz wunderbar, und man hat endlich in Projekten welche rein auf PL aufbauen
  praktisch (also bis auf das InputSystem, durch das leider noch derzeit OS Header reinkommen) keine Namespace Probleme mehr mit
  OS-Dingen. *freu*
  An ein paar Stellen bei denen Windows-Header genutzt werden, musste ich ein paar unschicke 'undefs' wie z.B. #undef MessageBox
  einfÃ¼gen, (gerade in PLGeneralWin32Includes.h ist das krass) ansonnsten bekam ich einmal Compiler Fehler da wir Funktionen haben
  die genauso heiÃen, und beim anderen mal Linker Fehler das etwas nicht gefunden wurde was wir gar nicht nutzen. Diese define
  Dinge der OS Header sind wirklich Ã¼belst und ich bin total froh das wir diese nun nur noch an 'sehr' wenig Stellen einbinden
  mÃ¼ssen.
  Bei den Linux Headern hab ich gekennzeichnet was umbedingt raus sollte.
PLGeneralLinux.h & PLGeneralWin32.h:
- Nahm THREAD_HANDLE heraus da es nirgends mehr verwendet wird
- NativeDirectory liegt nun direkt in FileSystem.cpp, der Benuter sollte davon nix sehen
- RTTI: Wie kurz besprochen PL_VAR_STRING & PL_VAR_FILENAME welche mit klassischen C-Strings arbeiteten entfernt und dafÃ¼r
  PL_VAR_PLSTRING & PL_VAR_PLFILENAME in PL_VAR_STRING & PL_VAR_FILENAME umbenannt. Alle Projekte daran angepasst.



>> 22.02.2007
[CO]
- ModuleID<T>::SetModuleName() & ModuleID<T>::SetModuleVendor() & ModuleID<T>::SetModuleDescription():
  Tests auf Buffer Ãberlauf eingebaut + statt strncpy wird nun memcpy genutzt damit einen VC 2005 nicht mit Warnungen
  in allen Projekten zumÃ¼llt.
- An Stellen wie z.B. SystemWin32::GetEnvironmentVariable() wird nun neben 'Unicode' auch 'UTF8' geprÃ¼ft, ist es ein UTF8 String
  mÃ¼ssen die Daten als Unicode zurÃ¼ckgegeben werden damit kein Informationsverlust stattfinden kann... da Windows nur wchar_t
  und kein direktes UTF8 kann muss leider immer Konvertiert werden, aber da kann man nix dran Ã¤ndern. (Ã¤hnliche Thematik dann
  unter Linux, nur umgekehrt *g*)
- Win32File::Rename() auf unsere String Klasse umgestellt. MÃ¼ssen wir bei Erfolgt ebenfalls auch den neuen Dateinamen speichern?



>> 21.02.2007
[CO]
Alle Projekte:
- Machte wie besprochen die Umstellungen auf die 'sicheren angeblichen Standard-Funktionen' vom 11.02.2007 wieder rÃ¼ckgÃ¤ngig,
  denn wie sich herausstellte sind diese leider nicht wirklich Standard - auf jedenfall wird das derzeit nicht von sonderlich
  vielen Compilern unterstÃ¼tzt und daher ist das leider unbrauchbar fÃ¼r uns. :(
  Schaute mir dabei gleich alle Stellen wo diese C-String Funktionen genutzt werden genau an damit es keine Buffer ÃberlÃ¤ufe
  geben kann. Ãberall auÃerhalb der String Klasse stellte ich soweit irgend mÃ¶glich/sinnig die letzten Stellen die ich finden
  konnte auf unsere String Klasse um damit man sich gar nicht erst mehr mit den C-String Funktionen herumÃ¤rgern muss. In den
  Projekten in denen VC 2005 trotzdem noch meckert das etwas 'potentiell unsicher' sein deakvierte ich diese Warnungen einfach,
  wir wissen (meistens :) schon ganz genau was wir tun und mÃ¼ssen uns da nicht von einem Compiler zujammern lassen. *g*
  -> *bin heute noch nicht ganz mit diesen Arbeiten fertig geworden*
PLGeneral:
- FSTools::ValidatePath(): Gleiche Ãnderung wie gestern in Win32FSTools::ConvertToWindowsPath()
- ZipDirectory::GetComment(): So geÃ¤ndert das kein 'strcpy' mehr verwendet wird, zudem Ã¼bernimmt die String Klasse direkt den
  Buffer (habs getestet, funkt noch korrekt :)
- Ein paar Kommentare von ZipDirectory & ZipStream korrigiert oder genauer gemacht
- ZipIterator::GetCurrentFileInfo(): Die String Klasse Ã¼bernimmt den Buffer mit dem Dateinamen und Kommentar direkt
- FÃ¼gte in diesem VC 2005 Projekt bei den Compiler Optionen "/D "_CRT_SECURE_NO_DEPRECATE"" ein damit keine unnÃ¶tigen
  Warnungen kommen
- Formte in der String Klasse ein paar AusdrÃ¼cke um so das es etwas besser Strukturiert rÃ¼berkommt



>> 20.02.2007
[CO]
Alle Projekte: Machte wie besprochen den ersten Schritt bei den Plugin-Ãnderungen:
- ClassManager::ScanPlugins(): Sucht wie vorher auch nach Plugins, kann dies jedoch nun auch Rekursiv machen
- ClassManager::LoadPlugin(): PrÃ¼ft ob es wirklich eine '.plugin'-Datei ist, lies die Meta-Informationen aus und prÃ¼ft dabei
  gleich den 'Typ' auf gÃ¼ltigkeit/Ã¼bereinstimmung oder ob ein Plugin aktiviert/deaktiviert ist. Danach wird der Name der
  Dynamischen Bibliothek ermittelt - derzeit wird der Plugin Name genommen und entsprechend geÃ¤ndert so das Plugin und
  Dynamischen Bibliothek also erstmal im gleichen Verzeichniss liegen mÃ¼ssen. AnschlieÃent wird wie gehabt (also 1 zu 1
  Ã¼bernommen :) die Dynamischen Bibliothek eingeladen.
- Verschob die Plugins der verschiedenen Projekte sammt benÃ¶tigter externer dlls in einen Plugin-Unterordner + dort wo sinnig
  in weitere Unterordner + schrieb entsprechende '.plugin' Dateien in denen ebenfalls vermerkt ist welche dll's diese benÃ¶tigen,
  was ich recht hilfreich finde. Hier mÃ¼ssen wir uns allerdings noch Ã¼berlegen ob wir das drinnen lassen da z.B. unter Linux die
  Dateiendung natÃ¼rlich anderst ist + auch teils die Namen der benÃ¶tigten Dynamischen Bibliothek, oder ob wir fÃ¼r jedes OS
  Seperate Dateien machen oder ob das innerhalb der Plugin-Dateien nach OS unterteilt ist.
- DynLibManager::LoadLibrary() & DynLib::Load(): Damit man Plugins + abhÃ¤ngige Dynamischen Bibliothek problemlos auch in
  Unterordnern halten kann was durchaus Sinnig ist Ã¤nderte ich das Verhalten dieser Funktionen minimal. Die Windows Funktion
  lÃ¤sst netterweise zu das die anderen nÃ¶tigen dll's zuerst im gleichen Verzeichniss wie die eingeladene dll zu suchen sind.
  Wenn es unter Linux soetwas nicht gibt muss man es so lÃ¶sen wie ich es zuerst unter Windows machen wollte: Einfach das
  aktuelle Verzeichniss kurzzeitig entsprechend Ã¤ndern. Dynamischen Bibliotheken sind also zuallererst im 'kleinsmÃ¶glichen Scope'
  zu suchen. *g*
- Passte die Post-Build Operationen aller VC & CMake Projekt entsprechend das herum kopieren)
PLGeneral:
- BufferedStringReader auf unsere String Klasse umgestellt. Diese Implementation ist sogar schlanker und Ã¼bersichtlicher bei
  gleicher EffektivitÃ¤t. :)
- Win32FSTools::ConvertToWindowsPath(): Das 'groÃmachen' des Laufwerksbuchstaben 'Unicode sicher' gemacht
- ClassManager::GetVarType(const String &sType) Case-Sensitive gemacht da PL generell Case-Sensitive ist
  (da diese Funktion bis jetzt nirgends genutzt wird, musste man auch nichts prÃ¼fen ob das korrekt verwendet wird :)
- Hack: Class::Init() Registriert sich in LoadableManager damit dieser von neuen Loadern Wind bekommen kann. Das war leider
  nÃ¶tig da ansonnsten u.a. in "PhysicsPlayground.scene" Sichtbar Dinge nicht korrekt Funktionierten. (was mich schon geraume
  Zeit stÃ¶rte, da die Ragdolls dort wirklich extrem cool rÃ¼berkommen *g*) In dem Falle bekam man die Meldung das die Ragdolls
  nicht eingeladen werden konnten da 'Radgoll' nichts sei was eingeladen werden kÃ¶nnte. Bei Config ist es im Prinzip genauso,
  aber da man da zum GlÃ¼ck derzeit nix von merkt war auch kein Hack dafÃ¼r nÃ¶tig. :)
  Klassen melden sich bei LoadableManager nicht ab, da dies derzeit nicht absolut nÃ¶tig ist - ich wollte einfach die Hacks
  so gering halten wie mÃ¶glich und fÃ¼gte auch ausreichene Dokumentation dazu damit man spÃ¤ter noch weis warum das drinnen ist.
- Loadable::Save(File *pFile, const Parameters *pParams) prÃ¼ft ob die Ã¼bergebene Datei beschreibbar ist
- SearchFilter::CheckMatch() auf unsere String Klasse umgestellt. Ich brauchte einige Zeit um in etwa nachvollziehen zu kÃ¶nnen
  was hier passiert. Ich hoffe das ich das FunktionsmÃ¤Ãig soweit verstanden und korrekt Ã¼ber unsere String Klasse realisiert
  habe so es FunktionsmÃ¤Ãig keinen Unterschied gibt.
  Stefan, wÃ¤re super wenn du das auch nochmal genau Durchdenken kÃ¶nntest ob ich da nicht doch nun eine Funktions Ãnderung
  drinnen habe... das war das komplizierteste was ich bis jetzt auf unsere String Klasse umgestellt habe und da kann schonmal
  was daneben gegangen sein. *bibber*
  (zumindestens einfache Dinge wie '*.pak' scheinen noch korrekt zu funktionieren, und das in '*' war der heftigste Teil :)



>> 16.02.2007
[CO]
- 'ConsoleLogFormater' hinzugefÃ¼gt - stand schon so lange auf dem Plan obwohl so wenig Arbeit *g*
- ClassManager::ScanPlugins(): Musste hier leider einen Hack einfÃ¼gen: "msvcr80.dll" und "msvcr80d.dll" sollte man nie per
  Hand einladen da ansonnsten eine dll Namens 'COREDLL.dll' verlangt wird (scheinbar WindowsC E) wovon ich nur eine nicht
  wirklich brauchbare Version im Netz nach langem suchen finden konnte. Hm, mit den Plugins mÃ¼ssen wir uns wirklich mal was
  Ã¼berlegen, denn irgendwie hÃ¤ufen sich Ã¤hnliche Probleme wenn man alle dlls einlÃ¤d und nach PL brachbaren Zeug durchforstet. :(



>> 12.02.2007
[CO]
- String: Neue Funktionen: IsValidInteger(), IsValidFloat(): PrÃ¼fen ob im String eine gÃ¼ltige Integer oder Float Zahl ist,
  solche Tests werden u.a. fÃ¼r die EditBox in PLGui benÃ¶tigt.



>> 11.02.2007
[CO]
Alle Projekte: Auf VC 2005 'umgestellt':
- Als ich zum ersten mal etwas unter VC 2005 Ã¼bersetze bekam ich natÃ¼rlich viele 'Depriciated Fehlermeldungen' wie z.B.:
    c:\programme\microsoft visual studio 8\vc\include\string.h(73): Siehe Deklaration von 'strcpy'
        Meldung: "This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use
        _CRT_SECURE_NO_DEPRECATE. See online help for details."
  Zum GlÃ¼ck nutzen wir mittlerweile 'fast' Ã¼berall (und wo das noch nicht der Fall ist und sinnig ist, wird das bald der
  Fall sein :) unsere eigene String Klasse so das sich dieses 'Warnungen' auf eine (groÃe) Handvoll Stellen beschrÃ¤nkten.
  Da die 'Sicherheits'-Warnungen + die neuen zusÃ¤tzlichen Warnungen durchaus Sinnvoll sind stellte ich u.a. auf 'sichere'
  Funktionen um dennen man die Buffer grÃ¶Ãe Ã¼bergeben muss damit sich Buffer ÃberlÃ¤ufe vermeiden lassen. (ich denke da spricht
  absolut nix dagegen :) Es gibt noch aufwÃ¤ndigere Stellen wo man umstellen mÃ¼sste oder wo wir sowieso bald unsere eigene
  String Klasse nutzen, das mache ich als zweiten Schritt - wÃ¼rde man das auf einmal machen kÃ¶nnten sich schneller Umstell-Bugs
  einschleichen... ich hoffe da sind bis jetzt keine reingekommen, denn bei dem +1 fÃ¼r mit/ohne \0 muss man immer verdammt
  aufpassen und sich genau Informieren wie die verschiedenen Funktionen das Ã¼bergeben haben wollen. (bitte die Ãnderungen
  nochmal kurz Ã¼berfliegen :)
- An Stellen wie z.B.
  .\src\Base\StringBufferASCII.cpp(285) : warning C4996: 'stricmp' wurde als veraltet deklariert
    C:\Programme\Microsoft Visual Studio 8\VC\include\string.h(213): Siehe Deklaration von 'stricmp'
    Meldung: "The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _stricmp. See online help for details."
  passte ich entsprechend an. ('Standardkonform' ist immer gut :) In 'PLGeneralLinux.h' kann man nun sicherlich einige 'stricmp' etc. entfernen.
- TinyXML: Mit VC 2005 neu Ã¼bersetzt damit der Linker nicht meckert



>> 10.02.2007
[CO]
- SystemWin32::GetOS(): Erweitert damit auch Windows Vista + Service Packs erkannt werden



>> 01.02.2007
[SB]
Alle Projekte:
- CMake build system ist komplett, alle Projekte lassen sich sowohl fÃ¼r Windows als auch fÃ¼r Linux Ã¼bersetzen
- Kleine Zusammenfassung, welche Probleme es mit CMake gab:
  - PROJECT_OUTPUT konnte nicht auf ein anderes als das Grundverzeichnis gesetzt werden (sollte eigentlich "bin" sein), da CMake
    ansonsten beim linux-build die AbhÃ¤ngigkeiten nicht mehr findet und sofort abbricht. Die Ausgabedateien werden also im
    Grundverzeichnis des Projektes erstellt, was aber nicht weiter schlimm ist, da es sich ja immer um max. 2 Dateien handelt
    und sich dort ansonsten nur die Projektdateien befinden.
  - Beim linux-build werden statische Bibliotheken, die eine AbhÃ¤ngigkeit von einer dynamischen Bibliothek darstellen, nicht nur
    zu dieser Bibliothek gelinkt sondern auch zu allen davon abhÃ¤ngigen Projekten (eine ErklÃ¤rung hierfÃ¼r findet sich in der CMake FAQ).
    Da die Pfade zu diesen Bibliotheken aber in den abhÃ¤ngigen Projekten nicht bekannt sind, werden diese nicht gefunden und das
    Ãbersetzen bricht ab. Um das zu vermeiden mÃ¼ssen die externen Bibliotheken immer mit absolutem Pfad angegeben werden, anstatt
  LINK_DIRECTORIES zu benutzen.
- Altes Linux-Buildsystem ausgebaut



>> 28.01.2007
[CO]
Alle Projekte:
- VC Projekt-Dateien wie besprochen in die jeweiligen Grundordner verschoben



>> 27.01.2007
[SB]
Alle Projekte:
- Neues Build-System fÃ¼r Linux auf Basis von CMake eingebaut. Die Projektdateien kÃ¶nnen dafÃ¼r benutzt werden,
  sowohl die Linux-Version zu erstellen als auch mittels Cross-Compiling mit VC7 die Windows-Version.
- PLBase Projektdateien sind komplett, jedoch lassen sich zur Zeit noch nicht alle Projekte auch fÃ¼r Linux Ã¼bersetzen.
  Das Cross-Compiling fÃ¼r Windows funktioniert aber schon perfekt :-)



>> 26.01.2007
[CO]
Kleinere AufrÃ¤umarbeiten in PLGeneral:
- "Friend declarations" in "Friends" geÃ¤ndert
- z.B. "Public interface" in "Public functions" geÃ¤ndert
- Namespace Style vereinheitlicht
- Ein paar Leerzeichen/Tabs korrigiert
- In ein paar Konstruktoren wurden nicht alle Variablen Initialisiert + an ein paar Stellen wurde noch nicht die
  Initialisierungs-Liste genutzt
- Ein paar const eingefÃ¼gt
- In ein paar Headern wo mÃ¶glich Includes durch Predefinitions ersetzt
- FÃ¼gte in einigen cpp-Dateien 'BlÃ¶cke' hinzu damit man sofort sehen kann welche Funktionen public, private etc. sind
- Ein paar Kommentare korrigiert/vervollstÃ¤ndigt (u.a. "@remarks:" zu "@note" gemacht, oder "@remarks" zu "@note")
- An ein paar Stellen Codes etwas vereinfacht/verschÃ¶nert, z.B. "for (;;)" in "do/while" geÃ¤ndert oder 'tote' Codes entfernt
  oder ein [TODO] davor gesetzt wenn nicht eindeutig klar war das es nicht mehr benÃ¶tigt wird
... An der FunktionalitÃ¤t sollte sich nichts geÃ¤ndert haben. Stellen wo man etwas Funktionell Ã¤ndern/prÃ¼fen
    muss hab ich mir erstmal nur notiert um diese in einem zweiten Schritt abzuarbeiten. (damit nix durcheinander kommt :)
    Gerade einige Umbenennungen waren mir sehr wichtig da diese das durchsuchen aller Projekte nach bestimmten Begriffen
    sehr erleichtern.
- BufferedStringReader::GetString(): Hier kann der String Buffer direkt Ã¼bernommen werden. Bringt jedoch nur 'im Augenblick'
  etwas, denn BufferedStringReader mÃ¼sste man komplett auf die String Klasse umstellen ohne 'char *' zu nutzen *Unicode Sicher*
- CmdLineParser Code Style angepasst und 'printf' fÃ¼r Debugging rausgenommen, soetwas sollte nie im Code bleiben und auch nie
  nÃ¶tig sein... man braucht hier *wirklich* einen brauchbaren Debugger damit man keine printf-KrÃ¼cken nutzen muss die den Code
  durcheinander werfen. Ich fand auch ein paar Stellen wo man die Implementation etwas vereinfachen konnte + Variablen die nix
  machten entfernen konnte. An der FunktionalitÃ¤t hab ich nichts geÃ¤ndert.
- Bugfix: SearchFilter::SearchFilter(): "m_sFilter.ToLower()" entfernt da PL generell case sensitive ist
- Tokenizer: 'm_sSingleChars' Default Einstellung ist nun eindeutig wie gehabt "{}()[]<*>/=,;\"", in den Codes war auch noch
  "{}()[]<>+-*/=,;\"" auskommentiert drinnen und in der Klassen Dokumentation stand "{}()[]=,;\"" als Default. + und - machen
  im Zusammenspiel mit Zahlen welche ein Vorzeichen haben schwere Probleme, darum sollten diese Zeichen als Default keine
  einzelnen Zeichen sein.



>> 18.01.2007
[CO]
- Bugfix: FSTools::ValidatePath(): ".." und "." wurden nicht korrekt aufgelÃ¶st da FSTools::GetFirstPath() ebenfalls '\' am
  Ende stehen hat. (war frÃ¼her mal anderst) Dies viel vorallem im Datei-Dialog auf. :)



>> 16.01.2007
[CO]
- Timer: SetTimeScaleFactor(), SetSlowMotionFactor() und SetCustomSlowMotionFactor(): Der Ã¼bergebene Faktor MUSS grÃ¶Ãer als
  0 sein, ist das nicht der Fall, liefern diese Funktionen nun einen Fehler zurÃ¼ck. Ein Faktor von 0 oder gar ein negativer
  Faktor macht an verschiedenen Stellen nur probleme und logisch Ã¼berhaupt seinen Sinn. 0 ist das gleiche wie Pause, also
  kann man gleich 'richtig' Pausieren wenn man das will, und negative Faktoren, hm, dann mÃ¼sste ja automatisch alles
  rÃ¼ckwÃ¤rts laufen... grrr... *g*



>> 23.12.2006
[CO]
- ChecksumCRC32 Checksum Implementation hinzugefÃ¼gt
- ChecksumSHA1 Checksum Implementation hinzugefÃ¼gt. Damit haben wir nun 3 Checksum Implementation (aller guten Dinge sind
  3... 3 Gui-Implementationen, 3 Renderer-Implementationen, 3 Sound-Implementationen... *g*)



>> 17.12.2006
[CO]
Alle Projekte:
- Bei den 'GetLoadableTypeName()'-Implementationen wird nun nicht mehr ein C-String zurÃ¼ckgeben, sondern diese Funktionen
  halten ihren RÃ¼ckgabe-String in einem statischen PL String der zurÃ¼ckgeben wird. Auf die weise muss nicht jedesmal
  der *wirklich* statische String in einen PL String umgewandelt werden nur um kurz darauf wieder zerstÃ¶rt zu werden.
  Statt z.B.
    String SceneContainer::GetLoadableTypeName() const
    {
      return "Scene";
    }
  wird nun
    String SceneContainer::GetLoadableTypeName() const
    {
      static String sString = "Scene"
      return sString;
    }
  geschrieben. Von auÃen merkt man also nix, und intern isses eine geschicktere Implementation. Das mag zwar die Performance
  nicht um das tausendfache steigern, aber wenn man soetwas machen kann ohne das es alles total durcheinander bringt sollte
  man das machen. An Ã¤hnlichen Stellen sollten wir das immer genauso machen, bin daher mal die Codes durchgegangen und Ã¤nderte
  es dort wo es sinnig ist. Wird nur "" zurÃ¼ckgeben, kÃ¶nnen wir das wie gehabt lassen da hier sowieso nix herum kopiert wird,
  oder wo der mehraufwand das Ã¼berhaupt nicht rechtfertigt und es dadurch nur unÃ¼bersichtlich wird sollten wir das ebenfalls
  wie gehabt lassen... z.B. bei pButton->SetText("Blah!").



>> 16.12.2006
[CO]
- Loadable: m_sAbsFilename muss leider protected sein da PLMesh::Texture und PLMesh::Material *sehr* spezielle Lade Funktionen
  komplett selbst Implementieren und entsprechend m_sAbsFilename in Eigenverantwortung setzen mÃ¼ssen.
- Loadable::Reload() darf der Lade-Funktion natÃ¼rlich keine direkte Referenz auf 'm_sAbsFilename' Ã¼bergeben da dieser String
  innerhalb der Lade-Funktion durch die Unload()-Funktion zurÃ¼ckgesetzt wird und dann natÃ¼rlich nicht bekannt ist was denn
  nun geladen werden soll. :)



>> 13.12.2006
[CO]
Alle Projekte:
- Schaute mir alle Stellen in den Codes an in denen 'using namespace' verwendet wird: Nahm unÃ¶tige 'using namespace'
  heraus, entfernte z.B. 'PLGeneral' vor 'PLGeneral::uint32' wenn gerade PLGeneral als Namespace verwendet wird, fand und
  entfernte dabei einige mittlerweile unnÃ¶tigen Header-Includes.



>> 03.12.2006
[CO]
- Ich schaute mir nochmal kurz die verschiedenen Implementation von Container::Remove() (+ Ã¼berall wo GetIndex() verwendet wird)
  an und merkte das diese bei weitem nicht Optimal war... denn da wurde ein int Wert von 'GetIndex()' ner Funktion Ã¼bergeben die
  ein uint32 erwartete und konnte ein Element nicht gefunden werden wurde -1 in uint32 umgewandelt... ging zwar meistens gut
  da wir nie Container mit SO vielen Elementen haben, war aber natÃ¼rlich nicht korrekt. Bei der Gelegenheit erweiterte ich die
  Container-Kommentare auch noch minimal so das mÃ¶glichst keine Fragen offen bleiben.



>> 02.12.2006
[CO]
- Der Loadable-Manager ist nun ebenfalls ein Loadable und kann sich somit selbst Laden und Speichern. File System Basis
  Pfade werden momentan ebenfalls speichern, wenn das unnÃ¶tig/ungeschickt sein sollte, kÃ¶nnen wir uns Ã¼berlegen wie wir
  das am besten anderst lÃ¶sen.
- Loadable um Reload()-Funktion erweitert, das ist zwar praktisch 'nur' ein pLoadable->Load(pLoadable->GetAbsFilename()),
  passt aber wunderbar rein und wird auch mehrmals genutzt. PLMesh::Material und PLMesh::Effect erweitern diese Reload()
  Funktion indem nach dem Neuladen zusÃ¤tzlich noch die verwendeten Texturen neu geladen werden.
- Bugfix: BufferedFileReader: Beim beenden wurde Release() von File aufgerufen, aber beim Datei Zeiger speichern wurde
  keine Referenz hinzugefÃ¼gt und so wurde in sehr unglÃ¼cklichen Situationen die Datei einfach gekillt obwohl diese noch
  Referenziert und auch verwendet wurde. FÃ¼gte nur ein 'm_pFile->AddReference();' ein anstatt auf Smart Pointer umzustellen.



>> 01.12.2006
[CO]
Alle Projekte:
- Auf Anregung von Stephan Ã¤nderte ich Ã¼berall
    XmlDocument *pDocument = new XmlDocument();
  in
    XmlDocument cDocument;
  wodurch auch kein delete mehr nÃ¶tig ist.
PLGeneral:
- Stack und Queue Kommentare minimal erweitert: Sucht man nun in PixelLight.chm z.B. nach 'FILO' wird man recht schnell
  das Stack Template finden. :)
- 'Timer' Klasse in 'Timing' umbenannt. Dieser Name ist passender - und ganz nebenbei kann's auch keinen Namenskonflikt mehr
  mit der neuen Timer Klasse in PLGui geben.
- Code im Destruktor von XmlNode entfernt da genau das gleiche in dessen Basis-Klasse XmlBase passiert (kein Fehler, nur unnÃ¶tig)
- FÃ¼gte bei den Xml-Klassen in denen es noch 'keinen' Destruktor gab einen leeren ein (wir hatten uns vor einiger Zeit geeinigt
  das wir das so machen wollen, also immer Destruktoren reinschreiben)



>> 30.11.2006
[CO]
- ClassManager::GetVarType(): PL_VAR_PLSTRING fehlte hier, merkwÃ¼rdig das dies bis jetzt noch nicht aufgefallen war :D
- XmlDocument::LoadFile() setzt nun ebenfalls den Dokument Wert auf den Dateinamen aus dem dieses Dokument geladen wurde
- Verschob FSTools::GetRelativePath() in den Loadable-Manager. Dieser schaut als allerersten Schritt nach ob's fÃ¼r diese Datei
  Endung Ã¼berhaupt einen eingetragenen Loadable Type gibt, wenn ja, so wird die Anfrage einen 'relativen Pfad' zu erzeugen
  an diesen Loadable Type weitergeleitet.
FileSystem:
- Nahm folgende Funktionen heraus da nun das Loadable-System fÃ¼r diese Jobs zustÃ¤ndig ist:
  GetNumOfSearchPaths(), GetSearchPath(), IsSearchPath(), AddSearchPath(), SetSearchPathPriority(), RemoveSearchPath(),
  ClearSearchPaths(), GetNumOfFileTypes(), GetFileType(), RemoveFileType().
- OpenInPaths() ist nun unnÃ¶tig und wurde daher entfernt
- Enfernte die Klasse FileType, Sie ruhe in Frieden *g*



>> 26.11.2006
[CO]
- Container Klassen etwas herausgeputzt: ein paar Klassen-BlÃ¶cke hinzugefÃ¼gt, Prefix bei Klassen-/Stuktur-Namen entfernt,
  ein paar kleinere Kommentare etwas geÃ¤ndert
- XML-Klassen etwas herausgeputzt: HauptsÃ¤chlich Kommentare komplettiert/verbessert
- ClassManager::LoadPlugin(): Eine Datei wurde geÃ¶ffnet, aber nicht wieder freigegeben -> Stefan schau bitte nochmal drÃ¼ber
  nicht das ich da nun etwas vermurkst habe. :)
- LoadableManager & Config: Ich wunderte mich gerade das Ragdolls im Scene Viewer nicht mehr geladen werden kÃ¶nnen da angeblich
  'Ragdoll' ein nicht bekannter Loadable Typ ist... als ich der Sache nachging stellte sich schnell heraus das der Loadable
  Manager bereits nach Loadable Typen sucht und diese Registriert (in dessen Konstruktor) bevor der Runtime-Ordner nach Plugins
  durchsucht wurde. Das lÃ¤sst sich momentan leider nicht 'beheben' da man sich nicht Informieren lassen kann wenn neue Plugins
  eingeladen wurden um anschlieÃend diese 'Neulinge' nach zu Registrierenden Komponenten zu durchsuchen. :(



>> 25.11.2006
[CO]
Alle Projekte:
- Schaute 'NULL' in allen Headern nochmal durch und ersetzte es im zusammenhang mit PL-Strings durch 'empty'
  (das waren noch Zeiten als wir 'char*' nutzten :)
PLGeneral:
- Loadable: Da es bei Mehrfachvererbungen (siehe PLEngine::SceneContainer oder PLPhysics::SNRagoll) leider schnell zu cast
  Problemen kommt baute ich bis eine bessere LÃ¶sung gefunden ist virtuelle 'LoadLoadable()' und 'SaveLoadable()' Funktionen
  ein mit denen sich das Problem 'umgehen' lÃ¤sst. Sehr schade, denn bis auf dieses Problem ist das Loadable-System mittlerweile
  recht nett, sehr einfach zu verwenden und zu erweitern.
- Localization Loader + Implementation fÃ¼r unser eigenes Format hinzugefÃ¼gt
- Config Loader + Implementation fÃ¼r unser eigenes Format hinzugefÃ¼gt



>> 24.11.2006
[CO]
- Vereinfachte das Loadable-System noch etwas und nahm einige Dinge aus 'Resource' heraus diese nun in dessen Basis-Klasse 'Loadable'
  liegen... Machte zuvor eine Kopie Namens 'ElementManager' etc. da sehr oft 'Resource' allein von Namen her in der Verwendung
  nicht korrekt war. (oder zumindestens nicht wirklich passend) Das ist zwar ingesammt immer noch nicht sonderlich prall, aber
  immerhin etwas besser als vorher. :)
  'Resourcen' sind 'Dinge' wie man Einladen & Speichern und von denen man Ã¼berlicherweise viele im Speicher hat und diese
  daher 'Verwaltet' haben mÃ¶chte. 'Elemente' sind Ã¤hnlich, aber einfacher und auch nicht lad oder speicherbar.
- Graph Loader + Implementation fÃ¼r unser eigenes Format hinzugefÃ¼gt
- Graph Path Loader + Implementation fÃ¼r unser eigenes Format hinzugefÃ¼gt



>> 11.11.2006
[SW]
- String: da die atof funktion unter linux auch locale abhÃ¤ngig ist, wird in den Funktionen GetFloat und GetDouble
      wie in den Format funktionen die locale auf "C" gesetzt.
- LinuxDirectory: ein Fehler bei der ÃberprÃ¼fung ob der Suchpfad mit einem "./" beginnt
  und dem lÃ¶schen dieser 2 zeichen behoben. In der ursprÃ¼nglichen Fassung wurde das LÃ¶schen durch die Stringfunktion Replace durchgefÃ¼hrt,
  was aber einen bÃ¶sen nebeneffekt hatte, wenn der pfad auch "../" enthielt.



>> 04.11.2006
[CO]
- Win32File & LinuxFile: Kann es wirklich sein das im Destruktor die Datei nicht geschlossen wurde falls diese noch offen
  war? (was bei Reference Counting schonmal passieren kann... der letzte hat die TÃ¼r zuzumachen... :)



>> 03.11.2006
[CO]
- Entfernte ein paar 'PLGENERAL_API' wo das nicht nÃ¶tig ist da es rein PLGeneral intern genutzt wird
- FÃ¼gte einige 'const' ein
- Virtual vor Destruktor entfernt da unnÃ¶tig: (verwenden nur eingebettete Implementationen) Semaphore, Mutex, DynLib
- In einigen cpp-Dateien Kommentar BlÃ¶cke hinzugefÃ¼gt damit man sofort sieht ob die Funktionen public etc. sind
- System: Neue Funktion GetLocaleLanguage(): Diese Funktion gibt den Namen der aktuell eingestellten Programm Sprache wie z.B.
  'English' zurÃ¼ck. Diesen String kann man dann nutzen um im Lokalisations-System eine korrekte Default-Sprache zu wÃ¤hlen.
- ~ThreadManager: Ãnderte das lÃ¶schen noch vorhandener Threads da Theads sich beim lÃ¶schen automatisch aus der Liste
  entfernen was beim Interator Probleme machen 'kÃ¶nnte'. In diesem speziellen Fall machte das zwar keine Probleme da der List
  Iterator intern direkt einen Zeiger auf das nÃ¤chste Element hÃ¤lt, aber beim z.B. Array-Iterator wÃ¼rde das schon nicht mehr
  gehen... lieber auf Nummer sicher gehen. :)
- SystemWin32: SetThreadAffinityMask() aus PLEngine::PL::InitEngine() hierher verschoben
- Thread um SetPriorityClass() und SetPriority() erweitert, PLEngine::PL::InitEngine() nutzt diese Funktionen um das Programm
  mit einer gewÃ¼nschten PrioritÃ¤t laufen zu lassen. (bis jetzt wurde dort mit einem ifdef gearbeitet)
  Stephan, bitte schau mal nach ob das mit der Thread PrioritÃ¤t unter Linux Ã¤hnlich ablÃ¤uft, wenn nicht, so mÃ¼ssten wir uns
  zusammen Ã¼berlegen wie wir das in PL handhaben wollen.



>> 28.10.2006
[CO]
- Loadable: Neue Funktion: GetAbsFilename() gibt den absoluten Dateinamen der Datei zurÃ¼ck aus dem dieses 'Ladbare Teil'
  geladen wurde. So einen absoluten Dateinamen braucht man Ã¶fters mal, z.B. in PLMesh::Texture::Load() um nach einer
  entsprechenden 'plt'-Datei zu suchen oder wenn eine Resource 'neu geladen' werden soll. Noch find ich die aktuelle
  LÃ¶sung noch nicht sooo prall, mal schaun ob wir das noch irgendwie besser & universeller hinbekommen kÃ¶nnen - aber fÃ¼r
  den Augeblick mÃ¼sste das reichen.
- FS: Directory::OpenCanonical(): Das Laden aus einer Zip-Datei anhand eines absoluten Namens klappte nicht (mehr) korrekt



>> 27.10.2006
[CO]
Alle Projekte:
- Nahm an ein paar Stellen <Extension>.ToLower() und CompareNoCase() heraus da wir generell zwischen groÃ/kleinschreibung
  unterscheiden wollen. In den Beispielen musste ich dadurch ein paar 3ds-Meshs per Hex-Editor korrigieren da Max irgendwie
  absolut keinen Wert auf groÃ/kleinschreibung legt und bei 3ds wie es momentan aussieht IMMER zwanghaft groÃschreibt.
  (da mÃ¼sste ich noch etwas Experimentieren ob dem wirklich so ist)
PLGeneral:
- 'Loader'-System eingebaut, dieses System lag bereits seit ein paar Monaten im Lab/PLResource-Ordner. Nahm 'File' aus
  den Klassen Namen heraus damit es etwas deutlicher wird das dies nicht 'direkt' etwas mit dem FS zu tun hat.
  Alles was irgendwie Lad- & Speicherbar ist sollte von nun an von 'Loadable' abgeleitet werden. Die konkreten Lade & Speicher
  Funktionen liegen in von 'Loader' abgeleiteten Klassen. Diese 'Loader' mÃ¼ssen sich wirklich NUR um das Laden & Speichern
  kÃ¼mmern, und nicht um das Ã¶ffnen/schlieÃen der Datei - das vereinfacht an vielen Stellen einiges. Abfragen welche Typen & Formate
  unterstÃ¼tzt werden kann man universell & bequem Ã¼ber den 'LoadableManager'. Das muss nun also nicht mehr x mal neu
  geschrieben werden, sondern 'Loader' werden zentral automatisch Registriert und verwaltet. Das System ist noch nicht final
  und wird an ein paar Stellen noch etwas vereinfacht werden. Aber es ist denk ich schonmal etwas besser als vorher... leider
  brachte dies keine groÃartige Ladezeit Verbesserung, trotzdem ist nun beim Laden einiges an Overhead weg. :)
- XmlDocument: Lade-Funktion hinzugefÃ¼gt der man dirkt eine Datei Ã¼bergeben kann



>> 18.10.2006
[CO]
Alle Projekte:
- FÃ¼gte "#pragma once" in alle Header ein damit das Ãbersetzen "minimal" schneller geht. Da dies sowohl unter VC als auch
  gcc bekannt ist, mÃ¼sste es damit keine 'KompatibilitÃ¤tsprobleme' geben.
- Mithilfe von "__pragma" kann man Pragmas auch in Makros nutzen. Ãnderte daher die PL_WARNING_PUSH & PL_WARNING_POP &
  PL_WARNING_DISABLE Makros entsprechend.



>> 17.10.2006
[CO]
Alle Projekte:
- Wie besprochen "PL_WARNING_POP", "PL_WARNING_PUSH", "PL_WARNING_DISABLE" Precompiler Makros eingebaut. Jedoch konnte man
  es leider nicht so realisieren das man direkt "PL_WARNING_DISABLE(4100)" schreiben kann... stattdessen muss man
  "#pragma PL_WARNING_DISABLE(4100)" schreiben. Nun mÃ¼ssten unter Linux die pragma-Warnungen weg sein. Wie genau man das lÃ¶st
  wenn man bestimmte Warnungen unter Linux deakivieren will mÃ¼ssten wir sehen wenn das ein Thema wird.



>> 16.10.2006
[SB]
Alle Projekte:
- Habe mal versucht die Export-Makros etwas zu entwirren. In PLGeneral ist jetzt jedes dieser Makros auch noch etwas genauer
  beschrieben, damit hoffentlich keiner mehr verwirrt ist welches Makro wozu gut ist.



>> 14.10.2006
[SW]
Alle Projekte:
- Finale version fÃ¼r das visibility attribute feature vom gcc.



>> 14.10.2006
[CO]
- Error System, zweiter Ansatz: (Namen & Implementation noch nicht final :)
  Hat eine Funktion einen 'boolschen' RÃ¼ckgabewert, so wird statt bool/PLBool 'PLReturn' genutzt welches ein Smart Pointer
  auf ein 'Result'-Objekt ist. (Experimentelle Implementation) Trat kein Fehler auf, so zeigt dieser auf 'Result::NoError',
  bei Fehler auf ein erzeugtes Result-Objekt. Dieses Result-Objekt kann man wie gehabt genauso wie einen einfachen boolschen
  RÃ¼ckgabewert verwenden falls man sich 'nur' dafÃ¼r Interessiert ob es einen Fehler gab. Interessiert einen selbst das nicht,
  wird dank dem Smart Pointer dieses Result-Objekt automatisch wieder 'freigegeben'. Gibt eine Funktion z.B. einen String
  zurÃ¼ck, so sollte es IMMER einen Optionalen PLResult-Zeiger geben der auf Wunsch das Ergebniss bekommt. Zwar bietet der
  Error-Manager die MÃ¶glichkeit sich den 'letzen' Fehler zurÃ¼ckgeben zu lassen, dies ist jedoch NICHT Multithreading-Safe...
  aber falls das einen nicht juckt, kann man diesen Optionalen Parameter auch ignorieren und z.B. Error::GetLast() nutzen was
  etwas 'bequemer' zu verwenden ist - das ist dem User Ã¼berlassen ob er dieses 'Risiko' eingehen will. Wir selbst sollten in
  der Engine aber NIE Error::GetLast() nutzen. :)
  Das System unterstÃ¼tzt auch 'Rekursion' so das man sich den vorherigen Fehler zurÃ¼ckgeben lassen kann um zu sehen wo der erste
  Fehler passierte. Anhand von Checksum::GetFile() kann man sehen wie das mit der Fehler-Rekursion derzeit ablÃ¤uft. Anhand von
  PLBaseTest::ChecksumTest() kann man sehen das dies bereits sehr gut klappt - wenn wir das so machen wollen, muss sich natÃ¼rlich
  dann jede Funktion daran halten damit das durchgehend klappt und man Fehler bis an den Ursprung zurÃ¼ckverfolgen kann.
  Die Ã¼bergebenen Funktions-Parameter sollten wenn mÃ¶glich IMMER mit einem PL_ASSERT() auf gÃ¼ltigkeit geprÃ¼ft werden und in der
  Funktions Dokumentation sollte genau beschrieben sein ob ein Parameter gÃ¼ltig sein MUSS oder nicht. Hier wird aber wirklich
  nur geprÃ¼ft und gewarnt wenn etwas nicht stimmt, danach gehts frÃ¶hlich weiter bis zum Crash.



>> 13.10.2006
[CO]
- PLMain Dokumentiert damit wirklich klar ist was die Parameter und vorallem der RÃ¼ckgabewert zu bedeuten haben
- UTF8Tools: Die 3 neuen Funktionen von Stephan vom Style & der Namensgebung her angepasst. Kommentar "One or both strings
  can be pure ASCII Strings" entfernt da dies eine allgemein gÃ¼ltige UTF8 Eigenschaft ist. 'FindSubString' kÃ¶nnten
  wir eventuell auch 'IsSubString' oder 'GetSubString' nennen... von der FunktionaliÃ¤t her hab ich nix verÃ¤ndert - konnte
  mit den erweiterten Unit-Tests auch keine Bugs oder so finden. :)



>> 11.10.2006
[SW]
Alle Projekte:
- Die projekte verwenden das neue visibility feature vom gcc, wenn vorhanden.
PLGeneral:
- Neues Makro PLTEMPLATE_EXPORT hinzugefÃ¼gt, mit denen unter Linux die Templates komplett exportiert werden kÃ¶nnen.
  Momentan betrifft das nur Array und Singleton



>> 06.10.2006
[CO]
Alle Projekte:
- Nachdem mich Stephan auf eine 'POD-Warnung' in "PLGui/Dialogs/ResourceManagerDialog.inl:288" aufmerksam machte,
  ging ich nochmals alle String::Format-Stellen durch und prÃ¼fte auf PLT()-Makro verwendung - denn dieses gibt mittlerweile
  einen PL String zurÃ¼ck. :)



>> 01.10.2006
[CO]
- Bugfix: XmlDocument::GetRootElement() -> Hier ging der Aufruf nicht Ã¼ber GetPLNode() und daher wurde keine korrekte eingebettete
  PL XML Node erzeugt. (gut das Stephan diese Funktion mal ausprobiert hatte *g*)



>> 28.09.2006
[SW]
Alle Projekte: PLBase:
- Die linux-projecte dateine an die Ãnderungen angepasst.



>> 27.09.2006
[CO]
- Auf PLBool umgestellt und wie Ã¼blich alle Projekte entsprechend angepasst. Stellte auch dort auf PLBool um wo das true/false
  bereits passte damit das 'Einheitlich' ist und das einbauen eines netten Fehler Systems leicher geht. (man muss fast nur noch
  nach PLBool suchen *g*)
  Beim Linux Teil *kÃ¶nnte* es noch Stellen geben wo man noch den Fehler Code anpassen muss.



>> 26.09.2006
[SW]
- In RTTIDefs.h an zwei stellen (void)0 anstelle von 0 geschrieben um eine gcc-4.x warnung zu beheben
- ClassManager::LoadPlugin da der DynLibManager momentan in der Hasmap von bereits geladenen Libs nur den Dateinamen speichert,
  wird nun der GetLibrary nur der Dateinamen Ã¼bergeben und nicht der komplette pfad.
  Wenn jemand was dagegen hat soll es entweder wieder zurÃ¼ckÃ¤ndern oder mir bescheid geben. (diese Ã¤nderung wieder auf wunsch von stefan revidiert)
- ein paar dumme printfs rausgeschmissen, die eigentlich nicht hochgeladen werden sollten



>> 26.09.2006
[CO]
- Machte ein paar kleinere erste Style anpassungen



>> 21.09.2006
[CO]
- Einfache Error-System Klasse hinzugefÃ¼gt + diverse Makros die einem das Leben mit Fehlern etwas einfacher machen
- Checksum & Config Klasse auf bessere Fehlerbehandlung umgestellt um zu sehen ob wir das so machen kÃ¶nnen/wollen



>> 21.09.2006
[SB]
- Neue Klasse Url hinzugefÃ¼gt. Diese Klasse verwaltet einen Pfad oder Dateinamen, kann zwischen den Unix/Windows Formaten sowie
  der URL Darstellung konvertieren und beinhaltet die Ã¼blichen Funktionen um einen Pfad in Verzeichnis, Dateiname, Extension aufzuspalten etc.
  Im Gegensatz zu den Funktionen aus FSTools ist die Klasse darauf ausgelegt, mÃ¶glichst flexibel zu sein, und mit so vielen Eingaben
  wie mÃ¶glich noch irgend etwas anfangen zu kÃ¶nnen. Kommt also z.B. ein Dateiname bunt gemischt mit \ und / herein stÃ¶rt das die
  Url Klasse nicht, der Pfad wird erstmal so gespeichert ohne gleich zwangslÃ¤ufig konvertiert zu werden. Sobald man dann einen fÃ¼r das
  System gÃ¼ltigen Pfad braucht lÃ¤Ãt man sich die Url umwandeln, damit sie korrekt wird.
  Im FS wird ab sofort nur noch diese Klasse verwendet und damit die alten FSTools Funktionen ersetzen. AuÃerhalb kann die Klasse natÃ¼rlich
  auch verwendet werden, um z.B. an einen Pfad/Dateiname/Extension o.Ã¤. heranzukommen, zum Speichern eines Dateinamens sollte sie allerdings
  nur sehr selten verwendet werden, da sie einiges an Speicherplatz braucht. Normalerweise sollte ein Pfad also weiterhin einfach als String
  gespeichert werden.
- FSRefCount entfernt. Die Basisklasse fÃ¼r alle FS Objekte (auch SearchHandle) ist nun FileObject, welches direkt von RefCount abgeleitet ist.
- FileObject: EType hinzugefÃ¼gt, welches angibt um was fÃ¼r ein Objekt es sich handelt. Dies wird nun nur noch in der FileObject Klasse behandelt,
  die virtuellen Funktionen zu diesem Zweck wurden daher entfernt.
- FileObject: Hat nun keinen Pointer mehr auf FileSystem, da es davon nur eine Singleton-Instanz gibt, auf die jetzt direkt zugegriffen wird.



>> 20.09.2006
[SB]
- Neue Hilfsklasse PLBool hinzugefÃ¼gt. Die macht nicht viel, auÃer einen bool zu speichern, und kann benutzt werden, um die
  true/false-Umstellung zu machen. Die Klasse ist so aufgebaut, daÃ sie *nicht* automatisch von/nach bool konvertiert,
  sondern bei jedem solchen Versuch einen Compilerfehler generiert. Das kann also so benutzt werden:
  - In der Funktion, die umgestellt werden soll, den RÃ¼ckgabetyp von bool in PL_BOOL umÃ¤ndern
  - return true -> return PL_FALSE
  - return false -> return PL_TRUE
  - Alle Projekte compilieren, dadurch gibt es Ã¼berall dort eine Fehlermeldung, wo die Funktion benutzt wird, z.B. bei
    if (TheFunction()), oder if (!TheFunction()) etc. Dort kann nun die Umstellung erfolgen:
  - if (theFunction()) -> if (PL_NOT theFunction())
  - if (!theFunction()) -> if (PL_IS theFunction())
  - Wenn sich wieder alles Ã¼bersetzen lÃ¤Ãt, kann man den Typus wieder auf bool setzen und per Suchen/Ersetzen alles zurÃ¼ck umwandeln
  - 'PL_FALSE' -> 'false'
  - 'PL_TRUE' -> 'true'
  - 'PL_NOT ' -> '!'
  - 'PL_IS ' -> ''
Auf diese Weise sollte die Umstellung wesentlich erleichtert werden, und dank der Compilerfehler mÃ¼Ãte man auch *alle* Stellen finden,
an denen die jeweilige Funktion verwendet wird, man kann also nichts mehr Ã¼bersehen. NatÃ¼rlich mÃ¼ssen immer alle Projekte compiliert werden,
denn nach dem Umwandeln sieht fÃ¼r die Compiler wieder alles richtig aus, auch wenn man ein Projekt noch nicht angepaÃt hat. Hoffe das macht
diese Umstellung etwas ertrÃ¤glicher ;-)



>> 19.09.2006
[CO]
- UTF8Tools: Neue Funktionen FromWideCharacterString() & FromWideCharacterString() + Ã¤nderte ein paar Namen so das klar ist
  das es sich z.B. um einen 'wide character' handelt. Ãnderte den Datentyp von 'wide character' von uint32 zu wchar_t - das
  ist zwar irgendwie total doof da wchar_t keine fest vorgegebene grÃ¶Ãe hat, allerdings kÃ¶nnen wir mit uint32 'wide character
  Dingen nix anfangen da die Windoof Unicode Funktionen nunmal leider wchar_t und kein UTF8 oder uint32 nutzen. :(
  Hatte mir zuerst Ã¼berlegt wchar_t UND uint32 Versionen der Funktionen anzubieten - aber das wÃ¤re dann doch etwas zuviel
  des guten geworden. Hat man mit wchar_t Problemen da es z.B. unter Windows zu klein ist, muss man ganz einfach NUR UTF8
  in seinem Projekt nutzen - es hindert einen ja bei unserer String Klasse bald (sobald fertig Implementiert) nix dran! *g*
- String Klasse: GetUTF8() mÃ¼sste mittlerweile Problemlos funktionieren -> Stephan, wenn du willst kannst du mal den Linux
  Port entsprechend anpassen bzw. mit GetUTF8() durchtesten ob das wirklich bereits brauchbar klappt. Der Rest muss noch
  ausgearbeitet werden.



>> 18.09.2006
[CO]
- Neue Tool-Klasse: UTF8Tools: Diverse UTF8 Funktionen die man immer mal wieder benÃ¶tigt. Hatte diese zuerst direkt als statische
  Hilfs-Funktionen in StringBufferUTF8 drinnen bis ich merkte das es immer mehr Funktionen wurden die man ebenfalls noch brÃ¤uchte...
  Daher entschloss ich mich diese Funktionen in einer seperaten Hilfs-Klasse abzulegen damit das nicht zuviel auf einmal wird.
- Fing damit an die String Klasse um UTF8-Support zu erweitern (noch nicht lauffÃ¤hig!)



>> 13.09.2006
[CO]
Alle Projekte:
- Schrieb bei jedem "#pragma warning(disable : <Number>)" dazu was genau dieses deaktiviert (... zumindestens bei VC...)



>> 12.09.2006
[SW]
- in Main.h das setlocale(LC_ALL, "") hinzugefÃ¼gt(unter Linux), da dadurch die systemlocale fÃ¼r den Prozess gesetzt werden, ist nÃ¶tig,
  da sonst im PLSampleGui die jpanischen schriftzeichen nicht angezeigt wurden.
- Durch die Ãnderung in der Main.h tauchten problem auf, wenn man floats in String und zurÃ¼ck umwandelt, da im Deutschen das Trennzeichen ein ',' ist und im Englischen ein '.'.
  Um das problem zu lÃ¶sen wurde in den Format-Funktionen des String-Klasse die locale auf "englisch" ("C") gesetzt und am ende der Funktion wieder auf die systemlocale zurÃ¼ckgesetzt.
  Das Problem und die LÃ¶sung(momentan nur fÃ¼r LINUX als test) habe ich zusammen mit Christian ausgearbeitet.



>> 11.09.2006
[CO]
- Beseitige Warnungen die erscheinen wenn der Compiler auf Warnungs-Level 4 gestellt wird:
 - Per Absicht nicht verwendete Variablen (da z.B. Virtuelle Funktionen) sollten mit PL_UNUSED() gekennzeichnet werden
   damit hier nicht angewarnt wird.
 - Beim Einbinden externer Header (z.B. tinyxml.h) deaktiviere ich diverse Warnungen da wir hier nix Ã¤ndern sollten.
 - Musste das PL_LOG-Makro minimal umschreiben damit nicht immer angewarnt wird das ein Ausdruck dort Konstant ist.
 - Deaktivierte die Warnung "warning C4201: Nicht dem Standard entsprechende Erweiterung: Struktur/Union ohne Namen" da
   ich nicht rausbekommen konnte wie man das besser machen kÃ¶nnte ohne das diese Warnung erscheint. :(
   (einfach keine Unions nutzen ist KEINE Option! ;-)
-> In den Projekten in denen ich die Warnungen beseitige hab ich im Debug-Modus erstmal Warn-Leven 4 aktiv gelassen. Solange
   es nicht stÃ¶rt kÃ¶nnen wir das so lassen und bekommen ein paar weitere nÃ¼tzliche Tips vom Compiler wo mÃ¶glicherweise
   etwas noch nicht ganz ok aussieht. Viele der 'zusÃ¤tzlichen' Warnungen sind durchaus hilfreich... um nur ein Beispiel fÃ¼r
   einen dadurch gefundenen Bug zu nennen:
      PLPhysicsNewton::WorldNewton::GenericContactBegin:: -> if (nCollisionGroup1 && Ignore)
    -> !! Ãbler Bug der nun zum GlÃ¼ck angewarnt wurde! ;-)
   Desweiteren werden auch Variablen angewarnt die zwar Initialisiert, aber nie verwendet wurden, ebenfalls recht nÃ¼tzlich,
   und wie schon oben erwÃ¤hnt sollte man PL_UNUSED() verwenden wenn das schon korrekt so ist.
-> Ich werde sicherlich noch ein paar Tage brauchen bis ich durch alle Projekte sauber durch bin. :)



>> 10.09.2006
[CO]
- Config: - GetVarBool() entfernt da man dafÃ¼r mittlerweile auch locker GetVar().GetBool() schreiben kann.
          - GetVarFloat() entfernt da man dafÃ¼r mittlerweile auch locker GetVar().GetFloat() schreiben kann.
- FSTools::ValidatePath(): Bei einem der Zahlreichen String-Anpassungen der letzten Zeit kam hier ein kleiner Bug rein so
  das es zu Problemen mit '/' oder '\' kommen konnte. Stefan, wÃ¤re nett wenn du irgendwann spÃ¤ter Ã¼ber diese Funktion
  nochmal drÃ¼ber schaun kÃ¶nntest - nicht das ich das Schrittweise kaputt oder zu umstÃ¤ndlich gemacht habe. :)
- Variant um GetString()-Funktion erweitert damit man sich ausdrÃ¼cklich die String-Version des Wertes zurÃ¼ckgeben lassen
  kann ohne vorher auf String casten zu mÃ¼ssen



>> 08.09.2006
[CO]
- Abstraktes Checksum-Interface + MD5 Implementation hinzugefÃ¼gt



>> 04.09.2006
[CO]
Alle Projekte:
- Fand einige Stellen an denen es z.B. netter ist vVector.x anstatt vVector[0] zu schreiben
PLGeneral:
- Types.h: FALSE, TRUE, und NULL flogen heraus bzw. verschob diese Definitionen in den Linux Teil da diese dort soweit ich
  weis benÃ¶tigt werden. (bei Windows werden diese Dinge in den Win32-Headern definiert)



>> 04.09.2006
[SW]
- Linux implementation des Unicode(wchar_t) supports, habe den aufruf der durch "int vswprintf( wchar_t *buffer,const wchar_t *format, va_list argptr )"
  durch die funtion "int vswprintf(wchar_t *buffer, size_t count, const wchar_t *format,va_list argptr)" ersetzt, da unter linux nur die mit dem count parameter gibt.



>> 01.09.2006
[CO]
Alle Projekte:
- Wie Stefan es wÃ¼nschte verwenden wir nun Ã¼berall 'd' als Prefix fÃ¼r 'double' anstatt ein universelles 'f' fÃ¼r 'floating point'.
PLGeneral:
- Lokalisierungs-System eingebaut. Das System an sich ist recht einfach aufgebaut und auch leicht zu bedienen. Texte sind
  in Gruppen aufgeteilt und jedes Projekt kann seine Texte in einer eigenen Gruppe anlegen damit es z.B. keinen Konflikt mit
  PL-Texten gibt. Wie Ã¼blich ist das 'Localization' Format in XML gehalten.
  Da wir bereits Ã¼berall wo SprachabhÃ¤ngige Texte verwendet werden das 'PLT'-Makro verwenden, waren die Code Umstellungen minimal.
  Nur den Header '#include <PLGeneral/Tools/Localization.h>' muss man nun einfÃ¼gen wo man SprachabhÃ¤nige Texte hat. Neben
  dem 'PLT'-Makro welches 'PixelLight' als Text-Gruppe nutzt gibt es noch ein 'PL_TEXT'-Makro bei dem als zweiter Parameter
  die Gruppe angegeben werden muss. Ob wir das 'PLT'-Makro drinnen lassen mÃ¼ssen wir noch sehen, auf jedenfall ist es im Augenblick
  noch nett da man die Codes dadurch nicht Ã¤ndern musste oder sich um die Gruppe innerhalb der PL-Codes kÃ¼mmern muss.
  Als 'native'-Sprache verwenden wir innerhalb von PL Englisch. FÃ¼r diese 'native'-Sprache ist keine Lokalisierungs-Datei
  nÃ¶tig da der Englische Text gleich als SchlÃ¼ssel fÃ¼r die Ãbersetung verwendet wird. Wird keine Ãbersetzung gefunden weil
  gerade z.B. Englisch als Sprache aktiv ist, so wird einfach dieser Text-SchlÃ¼ssel als Ergebniss verwendet. :)
  Was im Augenblick noch fehlt ist ein Tool welches Codes als Eingabe bekommt, nach unseren Lokalisierungs-Makros sucht
  und die Gefundenen Dinge in einer bzw. mehreren Lokalisierungs-Dateien auflistet so das man die Codes nicht per Hand nach
  zu Ã¼bersetzenden Texten durchwÃ¼hlen muss.
  Auch wÃ¤re es wohl sinnig wenn die Beispiele & Tools ihre Texte in eigenen Gruppen verwalten wÃ¼rden, das muss man aber
  noch ausjungeln wie was am besten ist. Hier ein Beispiel wie so eine Lokalisierungs-Datei aussieht:
    <?xml version="1.0" ?>
    <Localization From="English" To="Deutsch">
        <Text Name="Hello">Hallo</Text>
        <Text Name="This is a test">Dies ist ein Test</Text>
    </Localization>



>> 30.08.2006
[CO]
- Jede String Buffer Implementation speichert nun noch den String in einem jeweils anderen Format. Hab ich z.B. einen ASCII
  String, fordere aber einen Unicode-String an, so wird intern eine Unicode-String Variante erzeugt. Fordere ich nochmals
  Unicode an, so wird direkt dieser gepufferte Unicode-String zurÃ¼ckgegeben. Sobald der Orginal String verÃ¤ndert wird, wird
  dieser gepufferte String 'schmutzig' und muss sobald er wieder angefordert wird neu erzeugt werden. Arbeitete die internen
  String Konvertierungen aus, also wenn ich z.B. 'sMyString = sACII + sUnicode' schreibe.



>> 29.08.2006
[CO]
- String Klasse um wchar_t-Unicodes erweitert. In unseren Projekten sollte nun immer bei den Compiler-Einstellungen 'Unicode'
  anstatt 'Multi-Byte' verwendet werden was normalerweise die Standard-Einstellung ist. Da wchar_t von der grÃ¶Ãe her nicht
  fest Definiert ist, sollte man NIE davon ausgehen das ein Buchstabe 2 Byte oder so groÃ ist sondern IMMER sizeof(wchar_t)
  verwenden. Zudem sollte man aus diesem Grund wchar_t Strings auch nicht in Dateien speichern oder aus solchen Laden. Das
  sollte man dann Ã¼ber das 'sicherere' UTF-8 Format machen sobald dies Implementiert ist. Durch die Ã¤nderung der Compiler
  Einstellung wurden einige fehlerhafte String-Stellen gefunden wo z.B. !sMyString abgefragt wurde, 'true' zurÃ¼ckgegen wurde
  obwohl der RÃ¼ckgabewert ein String war etc. - also Stellen die man bei den krassen String Umstellungen von damals Ã¼bersehen
  hatte. :)
  An ein paar Stellen wie z.B. im Win32 PLGui Backend wird bereits das Format des PL Strings geprÃ¼ft und dann entsprechend
  die Unicode oder ASCII OS Funktions Variante verwendet... wie man anhand von PLSampleGui sehen kann geht nun auch Japanisch
  ganz wunderbar. *g*



>> 28.08.2006
[CO]
- Vorherige String Klasse durch die Ã¼berarbeite String-Klasse ersetzt. Das Interface ist noch kompatibel mit dem alten und
  wurde nur minimal erweitert. Die ASCII Implementation ist komplett Implementiert, wurde an einigen Stellen neu geschrieben
  und mit den erweiterten String-Tests geprÃ¼ft so das halbwechs sichergestellt ist das nicht wieder von neuem Ã¼ble Bugs
  reingekommen sind. ;-) (zudem lÃ¤uft alles auch im Release Modus noch stabil was auch schonmal ein gutes Zeichen ist *g*)
  Das sehr gut funktionierende String-Buffer Konzept wurde natÃ¼rlich beibehalten, jedoch haben String Buffer nun auch noch
  den Job die konkreten String Operationen auszufÃ¼hren - abhÃ¤ngig von deren internen String-Format. Die String Klasse selbst
  ist also sogesehen 'nur' noch ein String-Buffer-Container der bestimmte allgemeine Bedingungen prÃ¼ft so das diese nicht
  in jeder String Buffer Implementation erneut gemacht werden mÃ¼ssen.
  Es kamen noch ein paar zusÃ¤tzliche Hilfs-Funktionen hinzu damit man Strings auch mit Zahlen recht einfach zusammenbasteln
  kann. Beispiel: sString = 5 + sString + '_' + true + "HeHo" + 55.9; -> 5MyString_1HeHo55.9
  Damit kann man nun relativ einfach an vielen stellen String::Format() ersetzten was vorallem dann sehr sinnig ist wenn
  dort auch noch Strings miteingewoben werden sollen... man also GetString() nutzen muss. GetString() sollte man jedoch
  wo immer mÃ¶glich in den PL innereien vermeiden da man sich fÃ¼r auf ein String Format (sollte IMMER Unicode sein) festlegen
  muss. Zudem vergisst man bei String::Format auch mal schnell GetString() und dann bekommt man Schrott zurÃ¼ck - der VC Compiler
  meckert das ja leider nicht an. Am besten & flexibelsten & sichersten ist das String-System, wenn ALLE String Operationen
  KOMPLETT Ã¼ber die String Klasse gemacht werden und GetString() NUR genutzt wird um z.B. dem OS den String zu Ã¼bergeben.
  (sprich, um mit der Welt auÃerhalb von PL zu Kommunizieren *g*) HÃ¤lt man sich an diese Spielregel, so braucht man sich nicht
  darum zu kÃ¼mmern ob man gerade mit ASCII, Unicode, UTF-8 oder weis der Teufel was arbeitet - man verwendet einfach 'PL-Strings'
  und gut iss. ;-)
  Was noch fehlt sind Unicode-String Buffer die ich als nÃ¤chstes angehen werde.



>> 26.08.2006
[CO]
- System: GetProgramName() -> Gibt den Namen des laufenden Programms zurÃ¼ck. (z.B. 'c:\MyApplication\Test.exe')



>> 25.08.2006
[CO]
Alle Projekte:
- Nach dem Ã¶ffnen eines FS Verzeichnisses wurde meistens nicht geprÃ¼ft ob das gut ging - verbesserte dies um Crashs zu vermeiden
  falls das Ã¶ffnen eines Verzeichnisses mal nicht klappen sollte.



>> 24.08.2006
[CO]
Alle Projekte:
- Fand noch ein paar Stellen an denen anstatt stricmp/strcmp die String Funktionen verwendet werden kÃ¶nnen.
- Es gab noch ein paar Interface-Stellen wo 'const char*' anstatt 'String' verwendet wurde. Bei z.B. TestCase::GetName()
  ist dies aber durchaus Absicht da die Tests selbst nicht bereits von unserer String Klasse abhÃ¤ngig sein sollen.
- Entfernte extra 'const char*'-Funktionen in diversen Interfaces wie z.B. PLGeneral::Tokenizer so das 'nur' noch die eigene
  String Klasse verwendet wird. Da die String Klasse mittlerweile auch 'nur' einen Pointer auf einen 'char*' String halten
  kann 'ohne' dabei den gesammten String zu kopieren, ist dies ebenfalls kein 'Performance'-Problem. :)
- An ein paar Stellen wo String::CompareNoCase verwendet wurde wird nun == verwendet welches zwischen groÃ/kleinschreibung unterscheidet.
- Ersetzte wo mÃ¶glich String::Format durch String Addition. Zum einen ist das etwas kompakter & besser Lesbar, aber viel wichtiger:
  Das wird so mit z.B. Unicode Strings weniger Probleme bereiten da es nicht mehr Ã¼ber GetString() ablÃ¤uft.
- Entfernte einige <MyString.>GetString() wo das nicht wirklich nÃ¶tig ist.
PLGeneral:
- String: Nahm die Print()-Funktion heraus da diese in der Ã¼berarbeiteten String Klasse auch nicht mehr vorhanden ist. Ab
  jetzt muss man das immer Ã¼ber String::Format() machen, so gibt's nur noch eine einzige Funktion dafÃ¼r (kein doppelter Code)
  und die 'Performance' wird darunter wohl auch nicht wirklich leiden. ;-)
- String::String(const char *pszString, bool bCopy = true, uint32 nLength = 0) -> Am Ende kann man nun noch optional
  die LÃ¤nge Ã¼bergeben. Dies ist u.a. in PLMesh::EffectLoaderFX recht praktisch da man hier einen sehr langen String hat
  wo man aber bereits genau weis wie lange dieser ist.
- Tokenizer::Start(const char *pszBuffer, long nSize) entfernt und die Codes in den anderen Projekten entsprechend angepasst.
- BufferedStringReader::BufferedStringReader(const char *pszBuffer, uint32 nSize) entfernt.



>> 23.08.2006
[CO]
- Da ich momentan an einer neuen String Implementation mit Unicode Support Arbeite muss ich zwangslÃ¤ufig die String Dinge
  nochmal gaaaaaanz genau durchgehen. Dabei vielen mir gleich ein paar Dumme Dinge in der aktuellen Version auf - UND, wie es
  aussieht fand ich sogar unseren bÃ¶sen Release Crash Bug!!! String::Replace(char nOld, char nNew) -> 'Set pointers to new
  location' war NICHT in Ordnung, denn da bereits nIndex drauf addiert wurde durfte man nicht einfach nochmal zusÃ¤tzlich
  die String LÃ¤nge draufzÃ¤hlen um das Ende des Strings zu bekommen... denn nun schoss man Ã¼ber den Speicher heraus und es
  wurde irgendwo herumgeschrieben wo das nicht sein durfte - KEIN Wunder das dies Probleme machte! *g*



>> 22.08.2006
[CO]
Alle Projekte:
- Die Projekte verwenden nun die .lib's in PLSDK/Actual/libs anstatt die aus den build/win32 Verzeichnissen.
PLGeneral:
- Stellte TinyXML von 2.4.3 auf 2.5.0 (Beta) um. Da etwas an der Lib verÃ¤ndert wurde muss diese auf jedenfall noch
  gepackt vorliegen damit man selbst neu Ã¼bersetzen kann. (tinyxml_2_5_0_changed.zip)



>> 21.08.2006
[CO]
- XmlDocument: GetErrorDesc() so erweitert das standardmÃ¤Ãig auch in den String geschrieben wird 'wo genau' der Fehler
  auftrat - das will man in den meisten FÃ¤llen natÃ¼rlich auch direkt wissen. :)
  Mir viel dabei auf das die Xml-Datei Namen noch nicht den eigentlichen Klassen Namen entsprachen, Ã¤nderte dies.



>> 17.08.2006
[SB]
- Bei Log::Open() den Paramter fÃ¼r den LogFormater mit dem Standardwert "" versehen, falls man keine Parameter mit angeben mÃ¶chte
- Log::GetLogFormater() gibt nun kein const-Objekt mehr zurÃ¼ck, da man ansonsten auf die Optionen, die dieses Objekt zur VerfÃ¼gung stellt,
  gar nicht zugreifen kann. Das Objekt muÃ also auch verÃ¤nderlich sein, damit man sich den LogFormater zurÃ¼ckgeben und dann bequem
  dessen Optionen Ã¤ndern kann
- Einige Kommentare Ã¼berarbeitet



>> 16.08.2006
[SW]
- Log: XmlLogFormater hinzugefÃ¼gt.



>> 14.08.2006
[CO]
- String: Ãberarbeitete die Replace()-Funktion nochmal sorgfÃ¤ltig, z.B. war bereits der 'Count' am Anfang nicht ok. Die nochmals
  etwas erweiterten String Tests konnten nun keine Fehler mehr feststellen. (was allerdings leider nicht bedeutet das nix mehr
  drin wÃ¤re ;-)



>> 13.08.2006
[SW]
- HTML LogFormater hinzugefÃ¼gt: Und im zuge dieses LogFormaters die OpenFunktion des Logs um den Parameter sParameters erweitert.
  mit diesem Parameter ist es nun mÃ¶glich die LogFormater bezogenen Parameter zu Ã¤ndern, welche ans RTTI angebunden sind.
  beim HTML LogFormater sind das die Parameter Title(zum setzten des HTML-Titels), Header(dieser Text direkt nach dem <body>-tag geschrieben)
  Background(zum setzen einer Background farbe bzw. bild) und DefaultTextColor(zum setzten der default Farbe fÃ¼r den Text).
- Log::GetLogFormater hinzugefÃ¼gt. Hiermit ist es mÃ¶glich sich den aktuellen LogFormater zu hohlen um dann optionen des LogFormater zu Ã¤ndern.
  (z.b. beim HTML LogFormater kann man darÃ¼ber die Formatierung der Meldungen fÃ¼r jeden Loglevel seperat angeben).
- Log: die maximale anzahl der Loglevel von 2^32 auf 255 reduziert, da chris und ich glaube das kaum jemand mehr als 255 Loglevel brauchen wird.
- String::Replace: Hier wurden die restliche Zeichen des alten Textes nicht in den neuen String Ã¼bertragen, nachdem der eigentliche Replace beendet war.



>> 12.08.2006
[CO]
Log Ãnderungen:
- Bei LogLevel wieder meine Ãnderungen eingespielt, also wie besprochen das nur mit 'Debug'. Bei der Ausgabe steht dann auch
  nur 'Debug' - wie Stephan auch merkte wird das hier zuviel Text, das einzige was ich noch mehr hier habe ist das bei Debug
  wirklich 'nur' Debug und nicht Debug0 steht. Erst bei 'User Debug' Levels steht dann Debug1 etc. dabei.
- Verschob das Makro wieder nach oben wie Stephan es vorschlug, unterschied macht das keinen. Ich selbst geh die Codes nur
  immer von oben nach unten durch, und wenn dann oben etwas verwendet wird das aber 'rein Code liniear' gesehen erst 'unten'
  definiert wird sieht das fÃ¼r mich immer etwas merkwÃ¼rdig aus... aber bei Makros iss das ja FunktionsmÃ¤Ãig kein Unterschied...
  und wenn es euch oben besser gefÃ¤llt schreiben wir das mit den Makros *immer* oben.
- Wie Stefan vorschlug bei PL_LOG wird vor Level PLGeneral::Log:: eingefÃ¼gt -> passte alle Codes an, viel schlanker so das nun ist :)
- Nahm wie von Stephan vorgeschlagen die Update-Funktionen heraus, fÃ¼gte nun *aber* wie von mir geschrieben eine Flush Funktion
  hinzu damit ich von PLEngine::SNConsole aus einen Flush ERZWINGEN kann unabhÃ¤ngig vom Flush Log Level das die Konsole natÃ¼rlich
  *nicht* Ã¤ndern soll... zusÃ¤tzlich *MUSS* dort auch noch geprÃ¼ft werden ob sich die Datei seit dem letzten Check geÃ¤ndert hat,
  sei es durch ein frÃ¼heres Log Flush oder durch eine Datei Ã¤nderung des Users. (warum auch immer er eine machte)
  Derzeit ist das OS abhÃ¤ngig Implementierte, aber das Ã¼berarbeite FS wird dann ja solche Infos ebenfalls bereitstellen so das dies
  dann universell machbar ist.
- ... bei dieser neuen Flush Funktion merkte ich das Log::Write() noch nicht ganz ok war. Denn sobald m_qLastMessages einmal voll war,
  wurde nach jedem Output flush ausgefÃ¼hrt. Darum fÃ¼gte ich m_nFlushMessages hinzu. Bei jedem Eintrag wird das um eines erhÃ¶ht, und
  erst wenn m_nBufferedMessages erreicht ist wird dieser Counter zurÃ¼ckgesetzt und ein Flush ausgefÃ¼hrt.
- FÃ¼gte nach 'Quiet' noch ein Log Level namens 'Always' ein. In SNConsoleBase::ProcessCommand() *muss* der gerade eingebene
  Befehl *immer* unabhÃ¤ngig vom aktuell Eingestellten Log Level ausgegeben wird, auÃer natÃ¼rlich Log Ausgaben sind wieso auch
  immer mal komplett deaktiviert. Darum ist 'Info' hier nicht nutzbar. Wenn jemand da eine andere Idee hat wie man das lÃ¶sen kÃ¶nnte gebt
  bescheit... so wie das jetzt im Augenblick alles ist lÃ¤uft auch die PL Konsole wieder so sauber wie vor der Log Umstellung.



>> 08.08.2006
[SB]
- Kleinen Fehler im Log-Makro behoben: __LINE__ ist eine Zahl, daher muÃ es im printf-Style mit %d
  in den String eingefÃ¼gt werden, das %s fÃ¼hrte natÃ¼rlich zu einem Crash



>> 07.08.2006
[CO]
Alle Projekte:
- Stellte auf das neue Log System um



>> 06.08.2006
[CO]
- Timer um Funktion GetTimer() erweitert. Hierbei handelt es sich um einen allgemeinen Timer auf den einfach der aktuelle
  Zeitunterschied bei jedem Update addiert wird.



>> 31.07.2006
[CO]
- Array<AType>::Add(const AType Elements[], uint32 nCount): Hier habe ich Vorsichtshalber das memcpy durch Element weise
  Kopieren ersetzt, denn soetwas wie memcpy kann ja leider sehr schnell nach hinten Losgehen vorallem wenn man etwas komplexere
  Klassen direkt nutzt. Es ist zwar noch memset drinnen um auf *ausdrÃ¼cklichen* User Wunsch neue Elemente zu Initialisieren,
  da wÃ¼sste ich allerdings nicht wie man das anderst machen kÃ¶nnte, einfach jedem Element '0' oder so zuweisen geht ja nicht.



>> 28.07.2006
[CO]
- In SystemLinux/SystemWin32 wird im Konstruktur nun auch srand aufgerufen um den Zufallsgenerator zu Initialisieren. Bis
  jetzt stand in PLMath::Math ein Kommentar das man dies selbst Ã¼ber diese Funktion machen muss, und in PLEngine wurde dies
  dann auch gemacht... allerdings sollte man soweit irgend mÃ¶glich auf OS/Standardfunktionen verzichten um eventuellen
  InkompatibilÃ¤ts oder Makro Problemen gleich von anfang an die Luft anzuschnÃ¼rren.



>> 26.07.2006
[CO]
- Stellte alles auf die neue HashMap um und nahm die alte HashTable Klasse heraus. Beim Umstellen viel mir auf, das wenn
  etwas aus einer HashMap entfernt wurde das Objekt selbst Ã¼bergeben wurde, und nicht dessen Name. Wann immer mÃ¶glich sollte
  man Namen/Keys Ã¼bergeben da diese *sehr* viel schneller gefunden und entfernt werden kann - bei einem Objekt/Zeiger muss
  man erst die GESAMMTE HashMap durchlaufen um den entsprechenden Eintrag zu finden.
- Nahm an ein paar Stellen 'stdio.h' etc. heraus wo man dies nun nicht mehr benÃ¶tigt. (vor der String Umstellung brauchte man das
  dort wohl noch) Gerade in Headern sollte man es soweit mÃ¶glich vermeiden solche Header einzubinden um eventuellen Problemen
  die dadurch entstehen kÃ¶nnen zu vermeiden. (Makros etc.)
  Das ist momentan zwar noch nicht Optimal, zeigt aber wo es hingehen kÃ¶nnte/sollte. So bekommt man dann auch hoffentlich weniger
  Probleme wenn man mal einen Memory Manager/Tracker hinzufÃ¼gt, denn manche dieser Standard Header Ã¼berschreiben new etc. was
  dann ziemlich ungÃ¼nstig ist.



>> 23.07.2006
[CO]
- FÃ¼gte wie vor einigen Wochen mit Stefan bereits besprochen String::SetCharacter() hinzu.
  Ersetze in FSTools::ValidatePath() 'sValidPath.Delete(0, 1); sValidPath.Insert(&c, 0, 1);' durch 'sValidPath.SetCharacter(0, c)'.



>> 22.07.2006
[CO]
- FSTools::GetDirectory(): Hier habs noch einen Bug, wenn in einem gegebenen Pfad kein Verzeichniss vorhanden war, wurde der
  gesammte String als Verzeichniss zurÃ¼ckgegeben was aber sicherlich nicht gewollt war. Es wird in dem Fall nun ein leerer 
  String zurÃ¼ckgegeben. Das gleiche in FSTools::GetFirstPath(). Auch musste FSTools::ValidatePath() angepasst werden da GetFirstPath()
  es wie es bereits in der Funktions-Kommentierung stand am Ende ein '/' hat. Der File System Unit Test lÃ¤uft nun ohne das
  'Fehler' festgestellt werden. (vorher gabs Fehler bei den zip-Tests)
- Stephan fand gestern noch einen Fehler in XmlDocument::SaveFile(), hier wurde FSTools::GetPathPrefix() anstatt FSTools::GetDirectory()
  verwendet um das Verzeichniss herauszufinden in dem sich die Datei befindet. Solche Stellen gabs noch ein paar mal und ich korrigierte
  das Ã¼berall.
- Ãberall wo man eine Datei Ã¶ffnet um einen Tokenizer darauf arbeiten zu lassen wird eine Datei im Binary Modus geÃ¶ffnet, ansonnsten
  im Text Modus. Diese Stellen waren bereits mit einem [TEST] versehen und Stefan und ich hatten das auch bereits vor einer weile kurz
  besprochen. (Immer Text Modus kann Probleme machen, und hÃ¤uftig ist/war das leider auch der Fall :(
- Den Fehler in RefCount<AType>::Release() behoben den ich bereits am 16'ten gefunden hatte. FÃ¼gte desweiteren zur VollstÃ¤ndigkeit
  == und != fÃ¼r 'Direkte Zeiger' hinzu. Ebenfalls wird nun VOR einer Zeiger zuweisung geprÃ¼ft ob dies bereits der aktuell gesetzte
  Zeiger ist, machte man diesen Test nicht, konnte es zu einem Ã¼blen Crash kommen wenn man einen Reference Counted SmartPointer sich
  selbst zuwies. Die entsprechenden Bast Tests laufen nun sauber & stabil.



>> 21.07.2006
[SW]
- Linux port Ãnderungen von Christian teilweise angepasst/fehlendes hinzugefÃ¼gt.



>> 16.07.2006
[CO]
- Xml-Klassen: Diverse Definitionen nun mit groÃ/kleinschreibung geschrieben. Das ist zum einen Lesbarer, und manchmal sogar
  etwas kÃ¼rzer da man keine '_' mehr braucht.
- Types.h: Nahm einige mittlerweile total veraltete Definitionen heraus (das meiste wurde auch Ã¼berhaupt nicht mehr genutzt)



>> 16.06.2006
[SW]
- GetOpts in CmdLineParser umbennant
- CmdLineParser:
  eine Parse-funktion fÃ¼r PLGeneral::Array<PLGeneral::String> hinzugefÃ¼gt.
  und 2 statische funktionen ( String CmdArrayToString(int argc, char** argv) und
    Array<String> CmdStringToArry(String cmd_str) )
  hinzugefÃ¼gt.
  Die 1. Funktion Convertiert das char argumenten Array in ein String um
  Die 2. Funktion Convertiert ein String in ein Array<String> um.
- PLMain Ã¼bergibt nun ein PLGeneral::Array<PLGeneral::String> fÃ¼r die cmd-Parameter



>> 13.07.2006
[CO]
- HashString<AType>::~HashString(): Hier fehlte ein [], die Klasse ist zwar sowieso veraltet und mittlerweile durch HashMap
  ersetzt, aber solange das noch drinnen ist mÃ¼ssen eventuelle Bugs raus :)
- String::GetSubString(): Es wurde Speicher angelegt, korrekt gefÃ¼llt und einem String() Konstruktur Ã¼bergeben, da dieser jedoch
  selbst den String kopiert und nicht den Zeiger Ã¼bernimmt, hatten wir danach ein Speicherleck. Hab dem String(const char *pszString)
  Konstruktor erstmal einen Optionalen Parameter geben Ã¼ber den man dann festlegen kann das dieser Speicher Ã¼bernommen, und nicht
  kopiert werden soll... hat Vorteile wenn man das festlegen kann, ist aber auch etwas 'GefÃ¤hlich'. LÃ¤d man z.B. eine Datei ein,
  so kann man den 'Buffer' nun direkt an String Ã¼bergeben ohne das nochmal kopiert und danach der eingelesene Buffer wieder
  gerstÃ¶rt werden muss. StandardmÃ¤Ãig wird aber immer Kopiert.
- String: Dem StringBuffer muss man nun immer die LÃ¤nge des Strings Ã¼bergeben. Da diese IMMER bekannt ist, ist es einfach nicht
  so prall diese vom StringBuffer nochmals ermitteln zu lassen. Zudem ist der Zeiger auf den String innerhalb es StringBuffers
  NIE NULL, sobald es NULL wird, wird auch der StringBuffer nutzlos... Nahm daher auch den StringBuffer Konstruktor ohne
  Parameter heraus. Auf z.B. m_pStringBufffer->GetString() muss man daher NIE prÃ¼fen da es NIE NULL sein kann - bis auf eine Stelle
  in der String Klasse wurde das auch nie geprÃ¼ft. :)
  Machte die interne StringBuffer Implememtation inline und nahm 'Sicherheitsabfragen' wie z.B. pszString == NULL heraus da diese hier
  einfach nur Sinnlos sind, es ist schlichtweg ein ganz Ã¼bler Fehler der eigentlich NIE passieren dÃ¼rfte wenn hier mal NULL kommt,
  und wenn das mal der Fall ist, so ist das ein Bug in der eigentlichen String Implementation der behoben werden muss.
- DynLibManager::~DynLibManager(): Hier wurde der Iterator nicht wieder gelÃ¶scht
-> Die oberen Bugs fand ich als ich zum Testen mal den Memory Manager von http://www.fluidstudios.com/ im PLGeneral
   Header includierte, der merkte sofort das in der Hash Table der Speicher anderst wieder freigegeben wurde als er erzeugt wurde.
   Auch wurde ein Speicherleck in String::GetSubString() angemeckert - und tatsÃ¤chlich war was noch was... wir sollten uns
   wohl dranmachen unseren eigenen kleinen Memory Manager/Tracer zu schreiben, denn gerade bei solchen Speicherlecks hilft das
   enorm viel.



>> 29.06.2006
[CO]
- Bitset::Resize(): Das gleiche wie gestern in Array::Resize()



>> 28.06.2006
[CO]
- Array::Resize(): Hier konnte es zu Problemen kommen wenn ein Array intern bereits genug Elemente hatte und nach einem
  'GrÃ¶Ãe Ã¤ndern' bereits alle Elemente 'hinzugefÃ¼gt' sein sollten. Erstaunlich das dies bis jetzt noch nicht aufgefallen war.



>> 26.06.2006
[CO]
- CmdLineParser: 'DEBUG' zu '_DEBUG' gemacht damit das unter VC klappt



>> 17.06.2006
[CO]
- Container: Neue Funktion 'uint32 Add(const AType Elements[], uint32 nCount)'



>> 14.06.2006
[SB]
- Style-Anpassungen an GetOpts vorgenommen. Bitte mehr auf Spaces und Tabs achten
- PLMain arbeitet nun nur noch mit PLGeneral::String



>> 07.06.2006
[SW]
- Neu Klasse GetOpts hinzufgefÃ¼gt. Mit dieser Klasse lÃ¤Ãt sich Ã¤hnlich, wie die getopt funktion unter linux, Optionen parsen.
  Die Klasse wertet nur die Optionen aus welche ihr vorher bekannt gegeben worden sind.



>> 05.06.2006
[CO]
- ResourceManager: Neue Funktion: LoadResource(): Create() sollte jeweils NUR eine Resource erzeugen, aber diese nicht auch noch
  eventuell gleich einladen... dafÃ¼r ist nun die neue Funktion da. Siehe PLMesh Tagebucheintrag von heute fÃ¼r mehr Informationen.



>> 04.06.2006
[CO]
- String: Vor ein paar Tagen hatte ich in der String Klasse StringBuffer aus dem Interface in die Implementation verschoben
  damit das Interface mÃ¶glichst keine Implementations Details enthÃ¤lt und etwas Ã¼bersichtlicher ist. Allerdings konnte man nun
  nicht mehr beim Debuggen ohne weiteres 'in den String' schaun was oft sehr hilfreich ist. Machte daher diese Ãnderung wieder
  zu gunsten des Debugging rÃ¼ckgÃ¤ngig. FÃ¼gte auch gleich ein kleines Kommentar hinzu warum das public ist, nicht, das ich in
  ein paar Jahren wieder vergessen habe wieso das public ist und wieder auf die schlaue Idee komme das in die Implementation
  zu verschieben. ;-)
- Map: Neue Funktion: Replace() -> Stephan viel auf das diese Funktion welche recht nÃ¼tzlich ist noch fehlte



>> 30.05.2006
[CO]
- String: Mir viel gerade auf das wir zwar operator =(const char *pszString) hatten zum String kopieren, aber keine Funktion
  wo man nur eine bestimmte Anzahl von Zeichen kopieren konnte. Also fÃ¼gte ich eine Copy()-Funktion hinzu welche bereits
  im OpenGL Renderer verwendet wird. Ersetzte auÃerdem 'strcpy' durch 'strncpy' da das erstere mittlerweile 'deprecated' ist
  da keine Ã¼berprÃ¼fung auf SpeicherÃ¼berlauf. Nahm auch ein paar mehr oder weniger Ã¼berflÃ¼ssige 'strlen' heraus.
  Verschob die interne StringBuffer Klasse in die String.cpp Datei damit das Interface etwas aufgerÃ¤umter ist.



>> 25.05.2006
[CO]
- Module::GetClasses() die gleichen Parameter wie bei ClassManager::GetClasses() verpasst damit es einheitlich ist.
  Die Codes der Funktionen sind identisch, baute am Anfang noch eine Abfrage ein ob alle Regestrierten Klassen zurÃ¼ckgebenen
  werden sollen, in diesem Fall kann man sich extra Arbeit sparen und einfach die Klassen Liste zurÃ¼ckgeben. In
  PLEngine::GuiDebugScene::UpdateClassList() macht es die Sache mit dem einheitlichen GetClasses() auch etwas einfacher da
  ich mir dort gleich eine Liste mit in Frage kommenden Klassen zurÃ¼ckgeben lassen kann ohne per Hand aussortieren zu mÃ¼ssen.
  (der Grund fÃ¼r diese Ãnderung :)



>> 23.05.2006
[SW]
- Linux backend zum filesystem auf die Strings umgestellt



>> 22.05.2006
[CO]
Alle Projekte:
- Fand in diversen Projekten noch Stellen wo man z.B. Vector3::ZERO einsetzen konnte anstatt ein neues TemporÃ¤res Objekt zu erzeugen.
  Fand auch jede Menge stellen in denen man Werte direkt den Konstruktoren Ã¼bergeben konnte anstatt diese Werte intern erst
  initialisieren zu lassen um anschlieÃend einen Wert zuzuweisen.
- Ein paar Variablen Namen angepasst wo man z.B. einen Zeiger auf Zeiger hat (also z.B. **ppMyPointer)
PLGeneral:
- String::LastIndexOf(): An ein paar Stellen in den Codes wurde der RÃ¼ckgabewert in uint32 gespeichert was probleme gab wenn
  nichts gefunden wurde und '-1' daher als Ergebniss kam.
- FileSystem: IsBaseDir() hinzugefÃ¼gt. Da es bereits auch IsSearchPath() gibt und ich bereits an ein paar Stellen umstÃ¤ndlich
  per Hand prÃ¼fte ob ein gegebener Pfad ein Basis Verzeichniss ist oder nicht um z.B. diesen Pfad dann gegebenenfalls wÃ¤hrend
  dem einladen einer Szene TemporÃ¤r als Basispfad einzusetzen, denk ich diese Funktion hat im FS seine Existensberechtigung. :)
  Machte bei der Gelegenheit gleich ein paar int zu uint32, damit verschwinden ein paar Compiler cast Warnungen an diversen
  Stellen.
- String: + Operator hinzugefÃ¼gt damit man auch soetwas wie sResult = "A" + sString schreiben kann... wird bereits in
  PLSamplePhysics verwendet da hier recht praktisch.



>> 21.05.2006
[SB]
- BÃ¶sen Fehler im String behoben: Beim Duplizieren des StringBuffers hatte sich ein Fehler eingeschlichen, so daÃ nicht
  wirklich ein neuer Stringbuffer benutzt wurde. Daher wurde also im falschen Buffer geschrieben, so daÃ sich Strings verÃ¤nderten,
  die eigentlich vorher kopiert worden waren. Ein weiterer Fehler war auch noch in Replace(char, char), dort wurde der Index
  innerhalb des Strings erst nach dem Kopieren des Buffers berechnet, so daÃ man hinterher wieder im alten Buffer landete.
- FileSystem auf String umgestellt. Nach dem Beheben des String-Fehlers funktionierte das meiste wieder erstaunlich gut, nur ein
  paar kleine Fehler die bei der Umstellung des FS passiert waren. Da die FS Funktionen aber aus heftigen String-Manipulationen
  bestehen, die nun dank String-Klasse vÃ¶llig anders implementiert werden muÃten als vorher, kann es aber gut sein daÃ noch weitere
  Fehler auftauchen. Also bitte mal verstÃ¤rkt auf Probleme mit dem FS achten.
- Einige kleine Umstellungsfehler beseitigt
- String: Replace(char, char) vereinfacht, so daÃ nur noch eine Schleife benÃ¶tigt wird. Schleife in Schleife wobei die erste dann
  abgebrochen wird ist unschÃ¶n und sollte vermieden werden :-)



>> 18.05.2006
[CO]
- Nachdem Stephan beim Ã¼bersetzen mit gcc bei der Funktion PLPlugins -> PLSceneNodes1 -> SNLightning.cpp -> GenerateLightning()
  eine Warnung bekam da etwas nicht const war und 'pPoint[f]+vDest' einmal als Parameter verwendet wurde was eine Warnung
  verursachte, fÃ¼gte ich in GeneralWin32.h etwas hinzu so das auch bei uns bei Warnungs Level 3 bei soetwas eine Warnung kommt.
  (die Warnung empfinde ich als sinnig :)



>> 16.05.2006
[SB]
- Resourcen-Klassen auf Strings umgestellt
- Log-Klasse auf Strings umgestellt
- Profiling-Klasse auf ... Na ihr kÃ¶nnts euch wohl denken ;-)
- Einige Style-Anpassungen vorgenommen
- PLBase::FromString() und PLBase::VarChanged() auf String umgestellt und alle Projekte darauf angepaÃt



>> 15.05.2006
[SB]
- Nochmal die XML Klassen verÃ¤ndert. Die vorherige Ãnderung hatte zur Folge, daÃ in den Klassen mit einem public Konstruktor
  erstmal eine interne Node erzeugt wurde, und dann wieder Ã¼berschrieben wurde (Speicherleck). Leider fÃ¤llt mit keine sinnvolle
  LÃ¶sung ein, denn auch eine statische Methode mÃ¼Ãte ja intern einen Konstruktor aufrufen, gleiches Problem also.
  Habe daher den internen Konstruktor wie vorher wieder eingebaut, nur statt (void*) nimmt er nun (void*, int).
  Das ganze ist nur nÃ¶tig, weil ansonsten ein Aufruf von z.B. XmlText("Bla") einen Compilerfehler wegen Aufruf eines privaten
  Konstruktors auslÃ¶st (void* passt "besser" als String, daher wird das genommen). Darum also nun der zusÃ¤tzliche Parameter int,
  der wird zwar nicht verwendet, verhindert aber diesen Fehler.



>> 14.05.2006
[CO]
- Container/Functions.cpp hinzugefÃ¼gt in dem die Implementation fÃ¼r die String Funktionen liegen. Sobald man die String Klasse
  nutzt muss man PLGeneral einbinden, aber nutzt man 'nur' die Container Templates ohne String Klasse, so braucht man PLGeneral
  nicht einzubinden - praktisch fÃ¼r z.B. Max Exporter damit man nicht fÃ¼r alles diese grÃ¤sslichen stl Klassen nutzen muss. :)



>> 14.05.2006
[SW]
- POD-warnungen gefixed



>> 14.05.2006
[SB]
- RTTI Funktionen grÃ¶Ãtenteils auf Strings umgestellt. Dies bringt ein paar Probleme mit sich, denn da die RTTI Funktionen nun natÃ¼rlich
  auch Strings zurÃ¼ckgeben, ist es nicht mehr so einfach mÃ¶glich, festzustellen ob ein Fehler aufgetreten ist. Zumeist ist "" als
  RÃ¼ckgabe zwar ein Anzeichen fÃ¼r einen Fehler, jedoch kÃ¶nnte natÃ¼rlich auch der leere String eine gÃ¼ltige Variable sein.
  Anders herum ist es auch problematisch, denn wenn eine Variable auf "" gesetzt werden soll, wird jetzt vermutlich der Standardwert
  gesetzt - bei Strings kann jedoch wirklich "" gemeint gewesen sein. Dieses Problem bestand allerdings vorher auch schon, von daher
  sollte es erstmal keine grÃ¶Ãeren Probleme geben, nach den ganzen Umstellungen Ã¼berlege ich mir genau, wie wir das mit den Standardwerten
  kÃ¼nftig machen wollen.
- Base besitzt nun keine Funktionen mehr, um die Variablen aufzuzÃ¤hlen oder an ein Var* zu kommen. DafÃ¼r muÃ dann halt
  GetClass()->GetVar() geschrieben werden (intern passierte ja sowieso nichts anderes). 
- GetVarTypeAsString() in GetVarType() umbenannt - die Funktion heiÃt nun als in "beiden Richtungen" gleich
- Config: m_szVariableValue entfernt. Sollte einmal der Fall eintreten, daÃ aus zwei Threads auf das gleiche Config-Objekt zugegriffen wird,
  wÃ¼rde das bÃ¶se schiefgehen. Wir mÃ¼ssen daher in Zukunft darauf achten, daÃ alles Thread-Safe ist
- Tools: CombineStrings() entfernt. Diese Funktion ist Ã¤uÃerst unschÃ¶n und wurde sowieso nur an einer Stelle verwendet, wo sie Ã¼berhaupt
  nicht notwendig war. Die anderen String-Funktionen teilweise umbenannt, damit besser zu verstehen ist was die machen.
- Da die XML Klassen leider noch keine Strings verwenden, war es an einigen Stellen nÃ¶tig, so etwas wie String(pszString).GetBool() zu schreiben.
  Damit diese Stellen hoffentlich spÃ¤ter nicht vergessen werden, habe ich mich bemÃ¼ht diese immer mit einem [TODO] zu markieren. 
- Es sind immer noch an viel zu vielen Stellen Konvertierfunktionen fÃ¼r Strings vorhanden, teilweise in dreifacher AusfÃ¼hrung und jedesmal
  leicht anders implementiert :-( Habe daher angefangen die zu vereinheitlichen, das werde ich aber in den kommenden Tagen erst richtig angehen.
- XML Klassen auf Strings umgestellt  



>> 13.05.2006
[CO]
- Erweiterte HashMap & SimpleMap um eine Vergleichs-Funktion. Da die definierbaren Funktionen recht universell sind, packte ich
  diese in eine gemeinsame Datei Namens 'Functions.h' welche im Container Ordner liegt.



>> 12.05.2006
[CO]
- Fand einen Bug in HashMap::CSlotsList::Add() -> Falls dies nicht das erste Element dieses Slots ist, so wurde der Next 
  Zeiger nicht Initialiert.



>> 11.05.2006
[SB]
- Class Groups wurden entfernt, da diese kÃ¼nstliche Definition von Gruppen so keinen Sinn mehr ergab.
  Da die Gruppen sowieso mit den Ableitungen von einer Basisklasse Ã¼bereinstimmen, ist es sinnvoller gleich
  nach Basisklassen zu suchen. Nur das AufzÃ¤hlen von Gruppen ist jetzt nicht mehr mÃ¶glich, wird aber auch
  nicht wirklich gebraucht. Das Interface von ClassManager wurde daher so angepaÃt, daÃ man sich entweder alle
  abgeleiteten Klassen einer Basisklasse direkt zurÃ¼ckgeben lassen kann, oder nur die direkt abgeleiteten.
  Einige Klassen wurden auÃerdem auf Strings umgestellt.



>> 09.05.2006
[SB]
- Externe Libraries wurden nach "external" verschoben und dort entpackt, damit das Projekt direkt Ã¼bersetzt werden kann
  und keine Archive mehr entpackt werden mÃ¼ssen. Evtl. Sourcen kÃ¶nnen innerhalb der Lib-Verzeichnisse abgelegt werden,
  aber auch nur wenn diese wirklich benÃ¶tigt werden, weil z.B. fÃ¼r PL etwas verÃ¤ndert werden muÃte.
  Die Projekte wurden entsprechend angepaÃt.



>> 26.04.2006
[CO]
- XML Klassen: Ein paar Leerzeichen & Tabs verbessert
- FileSystem: RemoveBaseDir(): Der Ã¼bergebene Pfad muss zuerst 'korrigiert' werden so das dieser auf jedenfall mit dem
  intern gespeicherten Pfad Ã¼bereinstimmt.



>> 22.04.2006
[CO]
- Stefan und ich besprachen gestern das Iterator Problem und entschieden das es das beste ist, zusÃ¤tzlich in den Container
  Klassen neben GetIterator() noch GetEndIterator() anzubieten welches 'hinten' im Container startet. HasNext() gibt
  also 'false' zurÃ¼ck und HasPrevious() 'true'. Die Ãnderung in den Klassen war nicht wirklich aufwÃ¤ndig. Passte gleich die
  Stellen in allen Projekten an wo man einen Iterator fÃ¼r einen RÃ¼ckwÃ¤rtsdurchlauf verwendet.
- XmlDocument::LoadFile(): Hier gabs gleich zwei kleinere Problemchen. Man muss die Datei im BinÃ¤rmodus Ã¶ffnen damit TinyXML
  End Of Line (EOF) behandeln kann, und zum anderen fehlte ganz am Ende '\0'. Nun funktioniert im XML Test das Parsen von
  'demotest.xml' korrekt. In der neuen TinyXML Version wurde hier etwas geÃ¤ndert, darum konnte es nun Probleme geben.



>> 21.04.2006
[CO]
- HashMapIterator Konstruktor: Sind keine Elemente in der Map, so wird der Konstruktor nun sofort wieder verlassen da man
  ja bereits weis wie die Suche nach dem ersten Map Element ausgehen wird. Ist NUR ein Element drinnen ist es allerdings
  etwas Problematisch. Hab das nun erstmal so gemacht das man ein nÃ¤chstes aber kein Vorheriges Element zurÃ¼ckbekommt. Hier
  muss man sich wirklich Ã¼berlegen wie man diesen Sonderfall behandeln will, denn HasPrevious() gibt hier nun momentan immer
  false zurÃ¼ck. Dieses Problem gibts in jeder Iterator Implementation.
- Bei der Gelegenheit schaute ich gleich nochmal die Container Klassen durch und entfernte Ã¼berflÃ¼ssige Tabs & Leerzeichen



>> 20.04.2006
[CO]
- Container Klassen um Copy-Konstuktoren fÃ¼r den eigenen Typ erweitert



>> 17.04.2006
[CO]
- Stellte auf TinyXML 2.4.3 um. Anscheinend wurde intern etwas an den Strings geÃ¤ndert, wird hier nun NULL Ã¼bergeben gibts
  einfach einen Crash. Daher musste nun in
    XmlDeclaration::XmlDeclaration(const char *pszVersion, const char *pszEncoding, const char *pszStandalone)
  eine Sicherheitsabfrage rein.



>> 08.04.2006
[CO]
- Pool & FastPool: FreeElements(): Hatte vergessen den Fall zu berÃ¼cksichtigen wenn gerade Ã¼berhaupt keine Elemente vorhanden 
  sind...
- Bitset: Machte einige Funktionen inline



>> 05.04.2006
[CO]
- Pool & FastPool: FreeElements(): Die alte Implementation war viiieeel zu umstÃ¤ndlich. Man muss einfach nur die gesammte 
  Liste gerade verwendeter Elemente in die Liste der freien Liste 'anhÃ¤ngen'... das macht Pool & FastPool dort wo man sehr 
  hÃ¤ufig Elemente einfÃ¼gt, lÃ¶scht und alles komplett zurÃ¼cksetzt extrem Performant. :)



>> 28.03.2006
[SB]
- Base::GetClassName(): return false bei "const char *" ... ? in return NULL geÃ¤ndert :-)



>> 22.03.2006
[CO]
- Base::GetClassName(): Sicherheitsabfrage ob Klasse vorhanden ist eingebaut



>> 12.03.2006
[SW]
- Fehler in PLGeneral/Main.h behoben, explizites angeben des Namespaces fÃ¼r String da nicht immer
  sicher ist, das "using namespace PLGeneral;" vorher "verwendet" wurde wenn dieser Header includiert wird.
- Fehlerausgabe unter linux hinzugefÃ¼gt, wenn das laden einer LIB fehlschlug.



>> 27.02.2006
[SW]
- SemaphoreLinux.cpp: Der Check fÃ¼r den Maximalen wert des Semaphore eingebaut.
- TheadLinux.cpp: Der Execution Mutex (Er wird verwendet um Join(Timeout) zu implementieren ) wird
  in Terminate() und in Join(Timeout) explizit unlocked.
  In Terminate() wird er unlocked weil der Thread hier nichtmehr dazu kommt den Mutex selbst freizugeben.
  Wenn in Join(Timeout) der Mutex->Lock(Timeout) erfolgreich war, so muss der Mutex dort auch unlocked werden,
  da sonst beim nÃ¤chsten start des selben Thread-objectes der Thread nicht im versuch des "Locken" des Execution-Mutex
  blocked.



>> 27.02.2006
[SB]
- Ebenfalls noch einige kleine Style-Dinge hochgeladen. Das mit den Tabs und Freizeichen ist manchmal Geschmacksache,
  vor allem wenn man Variablen untereinander anordnen will etc. Am Anfang einer Zeile sollte jedoch immer Tab verwendet
  werden. Ebenfalls sollte darauf geachtet werden, daÃ Freizeilen auch wirklich frei sind, sprich keine Leerzeichen oder
  Tabs darin enthalten sind
- Einige kleine Ãnderungen im Linux Port:
  - MutexLinux: Habe den pthread mutex von einem Pointer in eine direkte Variable verwandelt, da bei allen Beispielen
    die ich gefunden habe keine Pointer verwendet wurden, sondern die Struktur direkt. Die Variable heiÃt nun entsprechend
    m_sMutex, da es sich um eine Struktur handelt. Das mit dem Pointer war natÃ¼rlich auch in Ordnung, allerdings scheint
    man sich das dynamische Erstellen hier sparen zu kÃ¶nnen, es ist also nicht notwendig (deswegen aber nicht falsch).
    In dem Falle hÃ¤tte allerdings nach pthread_mutex_destroy() noch das Objekt selber per delete gelÃ¶scht werden mÃ¼ssen,
    da die Funktion dies allem anschein nach nicht tut (wie sollte sie auch unterscheiden, ob das Objekt dynamisch erzeugt
    worden ist oder nicht). Und es ist nicht notwendig, beim Portieren die gleichen Namen zu verwenden wie im Win32 Port -
    dort handelt es sich ja um ein Mutex-Handle, welches man vom System zurÃ¼ckbekommt, daher m_hMutex, handelt es sich aber
    dann beim Linux Port um einen Pointer, so sollte auch der Name in m_pMutex oder wie jetzt fÃ¼r eine Struktur m_sMutex
    verÃ¤ndert werden.
  - Die System-Ports sollten mÃ¶glichst die Terminologie der entsprechenden System Ã¼bernehmen, damit sich ein Windowsprogrammierer
    z.B. im Windows-Port gleich zurechtfindet und ein Linux-Programmierer im Linux Port. Daher sollten die Datentypen entsprechend
    angepaÃt werden und nicht per Definitionen vereinheitlicht werden - dies ist ja auch nicht mehr nÃ¶tig, denn es handelt sich
    ja gerade um systemspezifische Klassen, welche nur im entsprechenden System funktionieren mÃ¼ssen. Das unabhÃ¤ngige Interface
    wird ja von den Klassen System, Thread, Mutex etc. bereitgestellt und benutzt die Impl-Klassen als Backend. Daher besteht
    also in den Backends selber keine Notwendigkeit mehr, irgendwelche Datentypen umzudefinieren oder zu vereinheitlichen :-)
  - DynLibLinux: Habe daher HANDLE m_hModule in void *m_pLib umbenannt
  - ThreadLinux: Variable in m_nThreadID umbenannt
  - ThreadLinux: In RunThread lpParameter in pParameter umbenannt. lp ist wieder nur fÃ¼r Windows und den dortigen Datentypen LPVOID Ã¼blich
  - ThreadLinux: In RunThread ppThread in pThread umbenannt. pp deutet auf einen zweifachen Pointer hin, es ist jedoch ein direkter Pointer
  - ThreadLinux: m_pMutex wurde nicht in jedem Fall initialisiert, jedoch spÃ¤ter benutzt. Nun wird es immer mit NULL initialisiert
  - Die neuen Member-Variablen wurden dokumentiert
  - Variablen sollten immer im kleinst mÃ¶glichen Kontext deklariert werden, also am besten beim ersten Benutzen und dann gleich
    initialisieren. Wenn es anders geht also mÃ¶glichst nicht am Anfang einer Methode die Variablen deklarieren und dann erst
    spÃ¤ter benutzen
  - Bitte Debug-Code immer mit [DEBUG] kennzeichnen
  - In den Kommentaren "Windows" durch "Linux" ersetzt :-)
- Der Linux Port ist wirklich schon sehr gelungen, ist einfach toll wie Ã¼bersichtlich das jetzt schon geworden ist :-)
  Hier noch ein Paar Anmerkungen bzw. Dinge die noch getan werden mÃ¼ssen:
  - ThreadLinux: Die Verwendung von m_pMutex muÃ noch etwas Ã¼berarbeitet werden. Beim Join beispielsweise muÃ wohl nicht mehr Unlock()
    aufgerufen werden, dann wenn der Mutex noch gelocked wÃ¤re dÃ¼rfte pthread_join gar nicht zurÃ¼ckgeben. AuÃerdem ist das LÃ¶schen
    des Mutexes an vielen Stellen nicht ok, denn dann geht der Aufruf beim nÃ¤chsten Starten des Threads schief, da der Mutex nicht
    mehr da ist. Eigentlich mÃ¼Ãte es reichen den Mutex nur im destruktor wieder zu lÃ¶schen, beim Abbrechen des Threads etc. muÃ nur
    darauf geachtet werden, daÃ korrekt Unlock() aufgerufen wird.
  - SemaphoreLinux: Hier fehlt noch die Behandlung des Max-Values. Bitte mal schauen ob Linux das bietet, wenn nicht ist die Frage
    ob wir das selber einbauen, oder ob dieses Feature unter Linux halt nicht zur VerfÃ¼gung steht. Falls wir das selber machen
    sollte dies vielleicht besser in Semaphore geschehen und damit einheitlich fÃ¼r alle Systeme. BlÃ¶d ist es natÃ¼rlich wenn eine
    Semaphore auch von anderen Prozessen verwendet wird, aber in dem Fall wÃ¼rde auch jetzt schon das MitzÃ¤hlen des aktuellen Wertes
    schiefgehen, und solange es dafÃ¼r keine Systemfunktionen gibt ist das Problem wohl auch nicht zu lÃ¶sen



>> 27.02.2006
[CO]
- Linux Dateien dem VC Projekt hinzugefÃ¼gt (werden jedoch vom Build ausgeschlossen)
- Machte beim Linux hier und da ein paar kleine Style Ãnderungen damit alles wie aus einem StÃ¼ck aussieht... die Linux 
  Implementation ist sehr viel Ã¼bersichtlicher als vor dem PLGeneral umbaun - gute Arbeit Stephan. :)
- Mir ist aufgefallen das an einigen Stellen wo z.B. als Abtrennung von Funktions Sammlungen bei z.B. 
    //[-------------------------------------------------------]
    //[ Public virtual ThreadFunction functions               ]
    //[-------------------------------------------------------]
  oft keine zwei Leerzeilen waren - bis jetzt hatten wir es hier immer so gemacht das wir hier zwei Leerzeilen hatten um 
  die Funktions BlÃ¶cke schÃ¶ner zu trennen so das man schon beim Ãberfliegen der Codes sehr schnell erkennt was zusammen 
  gehÃ¶rt. Ist natÃ¼rlich wieder so eine Geschmacksfrage - ich persÃ¶hnlich finds so aber einfach Ã¼bersichtlicher.
  Das ist natÃ¼rlich wieder so ein mehr oder weniger Sinnfreies 'kleinmist' Zeug... allerdings erleichtert ein durchgÃ¤ngig 
  Einheitlicher Code Style enorm die Arbeit wenn man sich dafÃ¼r Entscheidet eine Style Ãnderung vorzunehmen wie wir es in 
  der Vergangenheit ja schon recht oft gemacht hatten. :)
- An ein paar Stellen '/*<' durch '/**<' ersetzt... wenn ich solche Dinge per zufall finde, so Ã¤ndere ich diese immer 
  gleich so das es nicht noch mehr Stellen werden... man arbeitet ja oft mit Copy'n'Past oder schaut nach wie es woanderst 
  geschrieben wurde. ;-)



>> 26.02.2006
[SW]
- Linuxport auf die Klassen-Umstellung angepasst
- In der Thread-klasse die Funktion Stop in Terminate umbenannt, da die Bezeichnung Stop in meinen Augen nicht 
  "Kill den thread" sondern "Sende thread ein signal damit er sich beendet" bedeutet.



>> 25.02.2006
[SB]
- Haupt-Header von 'General.h' in 'PLGeneral.h' umbenannt
- Projekte an Ãnderungen angepaÃt



>> 23.02.2006
[SB]
- Habe mit der kompletten Umstrukturierung von PLGeneral begonnen. Das Projekt teilt sich ab jetzt in 3 Teile: Base, System und Core.
  In Base kommen alle Basisklassen und Datentypen, welche die Basis von PLGeneral bilden, also sprich Base, String, die Container, XML, Graphics etc.
  In System befinden sich die Klassen welche welche eine Abstraktion des Systems darstellen, also die frÃ¼here Platform Klasse, Filesystem, Threading, Libraries, Timing usw.
  In Core letztlich kommt dann das Application-Framework, welche PLGeneral zur VerfÃ¼gung stellt. Das ist insbesondere das RTTI mit allen dazugehÃ¶rigen Klassen, also
  Klassen, Module, Config etc. Das wird dann nach und nach ausgebaut, so daÃ ein richtig schÃ¶nes Framework entsteht. Die Trennung von System und Core ist wichtig,
  denn dies sind zwei vÃ¶llig unterschiedliche Dinge, es war daher nicht schÃ¶n daÃ diese vorher zusammen waren.
- Die Platform-Klasse wurde entfernt, da diese nicht gut gelungen war. DafÃ¼r befinden sich in System nun alle systemabhÃ¤ngigen Klassen, jeweils mit einer
  Implementierung fÃ¼r das jeweilige System. Die Win32 Implementierung ist jeweils schon dabei, die Linux-Implementierung kÃ¶nnte Stephan nachtragen :-)
  Das meiste kann aus der alten Platform-Klasse kopiert werden, es hat sich inhaltlich nicht viel verÃ¤ndert, nur das Interface ist schÃ¶ner geworden.
- Die System-Klassen benutzen nun ein Backend-System, es gibt also jeweils eine System-unabhÃ¤ngige Klasse als Interface, und eine Implementierungsklasse mit Ableitungen
  fÃ¼r jedes System. Das Interface besitzt dann einen Pointer auf die Implementierungsklasse. Das ist zunÃ¤chst komplizierter, hat jedoch den Vorteil daÃ das Interface
  und die Implementierung komplett voneinander getrennt sind, damit entsteht nicht wieder so ein Chaos wie in der alten Platform-Klasse.
- Habe den Threads und der Synchronisation ein vernÃ¼nftiges OOP System spendiert. Die Thread und Synchronisations Funktionen befinden sich in Threading, es gibt einen
  ThreadManager der die aktuellen Threads auflisten kann etc, fÃ¼r die Threads selber gibt es eine Klasse Thread, Mutex und Semaphore sind ebenfalls eigene Klassen.
  Damit ist dies nun endlich auch vernÃ¼nftig objektorientiert, wie es sich fÃ¼r C++ gehÃ¶rt.
  Das schreiben eines Threads geht nun auf verschiedene Arten, bevorzugt aber so: Eine Klasse MyThread wird von Thread abgeleitet und ihre Run() Methode Ã¼berschrieben.
  Mit new MyThread und pMyThread->Start() kann der Thread dann gestartet werden. Auf diese Weise hat der Thread ein Objekt zur VerfÃ¼gung und muÃ nicht mehr Ã¼ber void*
  Pointer umstÃ¤ndlich Daten Ã¼bergeben bekommen. Bitte in Zukunft darauf achten auch bei neuen Funktionen gleich vernÃ¼nftig objektorientiert zu arbeiten, und nicht plÃ¶tzlich
  in unserem kompletten OOP Framework altbackene prozedurale Methoden zu verwenden. Auch ist es nicht gut das Win32 Interface inklusive der gesamten Kommentierung
  einfach zu kopieren, denn erstens legt man sich damit auf das oftmals merkwÃ¼rdige Windows Interface fest, und zweitens hat Microsoft sicherlich ein Copyright auf seine
  Hilfetexte :-) Also wenn neue FunktionalitÃ¤t eingebaut wird bitte auch die MÃ¼he machen das vernÃ¼nftig zu designen, so daÃ es schÃ¶n ins System passt.
- Beim Umbauen der Threads bitte wenn mÃ¶glich von Thread ableiten, oder zumindest von ThreadFunction. Ich habe lange Ã¼berlegt, ob ich die MÃ¶glichkeit eines Function-Pointers
  Ã¼berhaupt noch anbieten will, habe mich dann dafÃ¼r entschieden. Das heiÃt jedoch nicht, daÃ das nun Ã¼berall einfach weiter verwendet werden sollte, da es am einfachsten
  ist das so umzubauen. Die OOP Methode ist viel flexibler und besser, der Funktionspointer sollte nur in AusnahmefÃ¤llen verwendet werden.
- Die System-Klasse wurde um ein paar nette Funktionen erweitert, so kann man nun z.B. den Computernamen und den Usernamen abfragen. Ebenfalls soll hierÃ¼ber eine
  Versionsverwaltung implementiert werden, so daÃ z.B. Plugin-DLLs schnell feststellen kÃ¶nnen, wenn sie mit einer inkompatiblen PLGeneral.dll arbeiten. Auch dient dies
  natÃ¼rlich den Log-Ausgaben. Das muÃ jedoch noch vernÃ¼nftig implementiert werden.
- Die Methode GetCPUMhz() aus der Tools-Klasse wurde ebenfalls nach System verschoben.



>> 20.02.2006
[CO]
- Array, Bitset: RemoveAtIndex(): Fand und behob einen bÃ¶Ã¶Ã¶sen uint32 Umstell-Bug... war ja klar das so eine Umstellung 
  diese Viecher anlockt ;-)
  Resize(): Auch hier gabs noch einen heftigen Bug - wow, das ich das bis jetzt Ã¼bersehen hatte, hm, die Container Tests 
  sind wohl noch nicht genau genug... :)



>> 12.02.2006
[SW]
Alle Projekte: Subversion:
- habe das property svn:eol-style fÃ¼r die neuen Dateien gesetzt.
    um dies automatisch zu machen sollten folgende optionen in der config-datei 
    von subversion vorgenommen werden:
    [miscellany]
    enable-auto-props = yes
    
    [auto-props]
    *.c = svn:eol-style=native
    *.cpp = svn:eol-style=native
    *.h = svn:eol-style=native
    *.inl = svn:eol-style=native
    *.dsp = svn:eol-style=CRLF
    *.dsw = svn:eol-style=CRLF
    *.sln = svn:eol-style=CRLF
    *.vcproj = svn:eol-style=CRLF
    *.sh = svn:eol-style=native;svn:executable
    *.py = svn:eol-style=native
    *.txt = svn:eol-style=native
    SCons* = svn:eol-style=native
    Makefile = svn:eol-style=native
    
    damit sollte jede datei die passende eol-kennung(bis auf die vc-projekt-dateien immer die kennung, welche vom OS verwendet wird)
    beim auschecken haben.
PLGeneral:
- Stellte die linux-thread-functionen auf pthread um.



>> 10.02.2006
[CO]
- Wie mit Stefan vorhin im Chat besprochen Ã¤nderte ich die Stack & Queue Klassen etwas so das Pop nun NICHT mehr das 
  entfernte Element zurÃ¼ckgibt da dies ziemlich Problematisch war. Stattdessen sollte man sich das Element nun Ã¼ber 
  GetTop()/GetBottom() zurÃ¼ckgeben lassen und danach Pop() aufrufen - oder Pop() einen Zeiger Ã¼bergeben der das Element 
  bekommen soll. (falls man nicht immer zwei Funktionen aufrufen mÃ¶chte :)



>> 09.02.2006
[CO]
- Binominal Heap Iterator implementiert, vorwÃ¤rts ging ja noch, aber rÃ¼ckwÃ¤rts war etwas fies zu Implementieren. Da in 
  diesem Heap nur der Nachfolger, aber nicht der VorgÃ¤nger bekannt ist, ist das rÃ¼ckwÃ¤rts durchlaufen auch nicht wirklich 
  gut von der Laufzeit her. Dort habe keinen VorgÃ¤nger Zeiger eingebaut da er hier unnÃ¶tig ist und 'nur' die Iterator 
  Implementation fÃ¼r rÃ¼ckwÃ¤rts durchlauf vereinfachen wÃ¼rde - da aber Iteratoren keine gÃ¤ngige Operation auf Heaps sind, 
  entschied ich mich dagegen hier im Binominal Heap pro Eintrag noch mehr Speicher zu verschwenden.
- Neue Heap Implementation: FibonacciHeap: Hat gewisse Ãhnlichkeiten zum Binominal Heap, jedoch geht u.a. das einfÃ¼gen 
  neuer Elemente superflott... dafÃ¼r ist das entfernen von Elementen etwas AufwÃ¤ndiger da hier dann auch gleich etwas 
  aufgerÃ¤umt werden muss. Ohne diese Funktion lÃ¤uft es zwar auch korrekt, aber dann hat man im Prinzip nur eine 
  doppelt verkettete List und diese Struktur wird Witzlos. :)
  Wir haben nun drei gÃ¤ngige Heap Implementationen - das sollte fÃ¼rs erste reichen.



>> 09.02.2006
[SB]
- Singleton hat nun wieder einen Destruction Guard, da die Benutzung des SmartPtr hier nicht mÃ¶glich war.
  Aufgrund des static initialization order problems kann es vorkommen, daÃ der statische SmartPtr spÃ¤ter initialisiert wird,
  als der Singleton. Beim Aufruf von GetInstance() wird also die Instanz erzeugt und im SmartPtr gespeichert, danach wird
  dann aber erst der SmartPtr initialisiert und somit der Zeiger wieder auf NULL zurÃ¼ckgesetzt, so daÃ beim nÃ¤chsten Aufruf
  von GetInstance() eine zweite Instanz erzeugt wird und die erste natÃ¼rlich auch niemals mehr gelÃ¶scht wird.
  Die statische Instanz welche das LÃ¶schen des Singletons Ã¼berwacht darf also keine Daten haben, die initialisiert werden
  mÃ¼ssen, daher muÃ hier doch wieder der speziell darauf abgestimmte Destruction Guard verwendet werden
- Der Destruction Guard besitzt nun eine leere inline Methode, welche innerhalb des Singleton einmal aufgerufen wird.
  Dies ist notwendig, damit der Compiler die statische Instanz erzeugt, ansonsten scheint diese in einer template-klasse
  wegoptimiert zu werden, wenn nicht einmal darauf zugegriffen wird. Die Methode macht also nichts ist aber notwendig,
  damit der Compiler richtig arbeitet. Interessant ist, daÃ dieses Problem nur bei Template Klassen auftrifft, bei Nicht-Templates
  funktioniert das mit der statischen Instanz auch ohne solche einen Trick
- Im Singleton werden nun auch die Zuweisung und der Copy-Constructor deklariert, um ein Kopieren des Objektes und damit
  die Umgehung des Singletons zu verhindern
- Die unschÃ¶ne Methode CheckInstance() wurde entfernt, statt dessen wird Ã¼ber ein Destroy-Flag Ã¼berprÃ¼ft, ob das Objekt
  bereits gelÃ¶scht wurde. Damit wird wÃ¤hrend der Deinitialisierung das Objekt nicht noch einmal neu erzeugt, nachdem es bereits
  gelÃ¶scht worden ist.
  Generell sollte man wÃ¤hrend der Deinitialisierung keine Singletons mehr verwenden, da diese schon gelÃ¶scht worden sein
  kÃ¶nnten - static DE-initialization order problem ;-) Also sollte z.B. in einem Destruktor eines Singletons nicht mehr auf andere
  Singletons zugegriffen werden. Sollte man es doch einmal tun muÃ auf jeden Fall der RÃ¼ckgabewert von GetInstance() auf NULL
  Ã¼berprÃ¼ft werden, da dies nun zurÃ¼ckgegeben wird, falls die Instanz bereits gelÃ¶scht wurde
- Singleton generell noch etwas Ã¼berarbeitet



>> 08.02.2006
[CO]
- Heap Interface um GetTop() und ExtractTop() erweitert um das 'oberste' Element anzufragen bzw. zu entfernen
- Neue Heap Implementation: BinominalHeap: Nachdem ich erstmal die Theorie soweit kapiert hatte war die Implementation 
  nicht soo schwer wie ich anfangs dachte, eigentlich sind nur CTree::Union() und ExtractTop() etwas kompliziert gewesen - 
  der Rest war 'trivial'. ;-)
  Die entsprechende Iterator Klasse muss ich noch Implementieren...



>> 07.02.2006
[CO]
- FÃ¼r Heaps (Priority Queue) gibts nun wieder wie frÃ¼her ein eigenes allgemeines Heap Interface da Heaps einfach etwas 
  anderes sind als Maps. (das erkannte ich erst wieder als ich mich wieder genauer mit den Datenstrukturen befasste :)
  Wie auch bei Container & Map hab ich Support fÃ¼r Iteratoren Implementiert. Dies ist zwar genauso wie bei Map eher 
  unÃ¼blich bei dieser Datenstruktur, jedoch ist das ein nettes Feature. In welcher Ordnung die Elemente beim Iterator 
  zurÃ¼ckgegeben werden kann man wie bei Map nicht wirklich vorausgesagen - man weis nur das das ERSTE Element jeweils das 
  grÃ¶Ãte/kleinste aller Elemente ist - je nach verwendeter Compare-Funktion.
- Binary Heap an neues Heap Interface angepasst
- Nam den Sicherheits-Test innerhalb einiger Container Iteratoren der prÃ¼fte ob der Container Zeiger gÃ¼ltig ist heraus 
  da total Ã¼berflÃ¼ssig - dieser Zeiger MUSS immer gÃ¼ltig sein, ansonnsten lÃ¤uft gerade etwas total schief... ;-)
- Einige Container Iterator Implementationen waren noch nicht ganz korrekt.



>> 06.02.2006
[SB]
- PLGeneral_Rewrite Branch entfernt. Die Ãnderungen wurden grÃ¶Ãtenteils in den main Branch Ã¼bertragen, der Rest muÃ sowieso
  noch einmal komplett Ã¼berarbeitet werden, was dann direkt in den aktuellen Sourcen geschieht.
- Kleine Fehler in RefCountPtr und SmartPtr entfernt. Diese Klassen werde ich wohl nochmal grÃ¼ndlich durchgehen mÃ¼ssen, da der
  Compiler ja leider nur die Teile compiliert die auch wirklich benÃ¶tigt werden. Und diese Klassen sind schon etwas kompliziert,
  da sie einige template Tricks verwenden :-)
- Singleton: DestructionGuard entfernt. Statt dessen wird der Zeiger nun in einem SmartPtr gespeichert, dieser lÃ¶scht genauso wie
  vorher der Guard das Objekt wenn er selbst gelÃ¶scht wird (also am Ende des Programmes, da es sich um eine statische Instanz handelt).
  Diese statische Instanz wird auch korrekt initialisiert, was wohl daran liegt daÃ sie nicht selbst zum Template gehÃ¶rt - dies ist wohl
  ein Fehler der Sprache, daÃ dies nicht korrekt funktioniert.
  Singleton ist nun von RefCount abgeleitet, damit der SmartPtr vernÃ¼nftig die Referenz halten und lÃ¶schen kann. Die Ableitung ist
  jedoch private, da ansonsten jeder den RefCount erhÃ¶hen oder verringern kÃ¶nnte, und somit das Singleton ad absurdum fÃ¼hren wÃ¼rde.
  Damit der SmartPointer dennoch den RefCount nutzen und die Instanz lÃ¶schen kann, muÃte er als friend deklariert werden.
  Falls es Probleme mit dieser LÃ¶sung gibt, bitte Bescheid sagen, denn dies ist schon einigermaÃen kompliziert - und bei den
  Templates noch durchzuschauen fÃ¤llt hier schon etwas schwer :-)



>> 06.02.2006
[CO]
- Bitset: Die Anzahl der benÃ¶tigten Integers wurde noch nicht immer korrekt berechnet + verbesserte das Initialisieren 
  der Bits. Container::GetSize() Kommentar etwas erweitert damit wirklich klar ist WAS hier zurÃ¼ckgebenen wird.
  (Kommentar also bitte nicht lÃ¶schen :)
- Tokenizer: Da momentan + und - als einzelnde Zeichen betrachtet werden funktioniert ParseNumber() nicht korrekt - 
  negative Zahlen werden nicht mehr korrekt gesetzt. Entweder mÃ¼sste man bei ParseNumber() nun nach Vorzeichen ausschau 
  halten oder wir behandeln diese Zeichen nicht als einzelnde Zeichen. (hab das erstmal auskommentiert damit alles sauber 
  lÃ¤uft)
- FastPool: FastPoolElement: Virtuellen Destruktor etc. hinzugefÃ¼gt damit alles sauber Ã¼ber die BÃ¼hne lÃ¤uft



>> 05.02.2006
[SB]
- String: Konstruktor mit Printf-FunktionalitÃ¤t wurde entfernt, da dies nicht bei jedem String erwÃ¼nscht ist.
  So war es unmÃ¶glich, einen normalen String der ein Prozentzeichen (%) enthÃ¤lt zu speichern. Statt dessen
  gibt es nun die statische Funktion Format, die einen formartierten String mit Printf syntax erstellt und einen
  String zurÃ¼ckgibt (named constructor).
- Tokenizer:
  - Fehler in ParseEquation(String, int&) entfernt - hier fehlte die Referenz, das Ergebnis wurde also nicht zurÃ¼ckgegeben
  - SingleChars zu {}()[]<>+.*/=,;" verÃ¤ndert. Damit dÃ¼rfte die Ã¼bliche Syntax von C Programmen besser abgedeckt werden
- Auf String::Format() umgestellt



>> 04.02.2006
[SB]
- String:
  - IsFixedNumeric() in IsNumeric() umbenannt. Man muÃ hier im Hinterkopf behalten, daÃ es um Eigenschaften der Zeichenkette geht (nicht um den Inhalt!),
     und das umfaÃt z.B., ob diese nur aus alphabetischen Zeichen besteht, nur aus numerischen oder aus alpha-numerischen Zeichen. Diese Begriffe sind
     allgemein bekannt und daher sollten diese Funktionen nun sehr verstÃ¤ndlich und eindeutig sein. An solchen Stellen sollte drauf geachtet werden, daÃ keine
     eigenen Begriffe erfunden werden, da dies auÃenstehende nicht verstehen wÃ¼rden, noch dazu wenn z.B. Fixed noch eine ganz andere Bedeutung hat
     (Fixkomma Zahl), das verwirrt die User dann noch einmal unnÃ¶tig, in diesem Fall also lieber gleich nach allgemein bekannten Begriffen suchen, wenn es
     einem einmal nicht einfÃ¤llt :-)
  - IsFloatingPointNumeric() entfernt. Diese Funktion gehÃ¶rt nicht in den String, da es sich nicht mehr um die Eigenschaft einer Zeichenkette handelt. Aus was
    fÃ¼r Zeichen eine Zeichenkette besteht kann direkt als Eigenschaft dieser Zeichenkette gesehen werden, dafÃ¼r die Funktionen IsAlphaNumeric() etc.
    Hier jedoch geht es eigentlich schon um den Inhalt, und dafÃ¼r sollte ein Parser zustÃ¤ndig sein. Abgesehen davon sollte so eine Funktion dann auch gleich
    ein anerkanntes Floating-Point Format erkennen, die sehen dann etwas komplizierter aus (123.4567E10 (f/d) o.Ã¤.) DafÃ¼r gibt es aber genug Definitionen, die
    man dann benutzen kann. Im Moment bleiben wir beim alten Verfahren, da wir nicht alles auf einmal machen kÃ¶nnen, spÃ¤ter werden dann solche Dinge gleich
    korrekt geparsed z.B. mittels regulÃ¤rer AusdrÃ¼cke.
  - Einige Kommentare angepaÃt
  - Bei einigen Funktionen const hinzugefÃ¼gt
- Profiling:
  - Kleine Ãnderungen im Coding Style



>> 04.02.2006
[CO]
- Profiling: SelectNextGroup() & SelectPreviousGroup() behob kleine uint32 umstell Fehler
- String:
  - Compare Funktionen wie besprochen um Start Position Parameter erweitert, in der Implementation werden ein paar 
    SonderfÃ¤lle berÃ¼cksichtigt in denen man auf einen Schlag weis ob die Strings gleich sind oder nicht - gerade beim 
    Vergleichen lÃ¤ngerer Strings wird das enorm Speed bringen.
  - IsSubString() wie besprochen geÃ¤ndert und neue Funktionen IndexOf() & LastIndexOf() hinzugefÃ¼gt.
  - IsCharacter() entfernt da mittlerweile Ã¼berflÃ¼ssig... IsCharacter() das kann man nun auch selbst per Hand in zwei 
    Schritten machen. (z.B. sToken.GetLength() == 1 && sExpected.IsSubString(sToken))
  - < und > Operatoren hinzugefÃ¼gt um Strings Lexikographisch vergleichen zu kÃ¶nnen (fÃ¼r sortieren wichtig)
  - Neue Funktionen: Replace() in 3 Varianten, einmal fÃ¼r const char *, String und fÃ¼r Buchstaben - Ich wÃ¼rde wirklich gerne 
    diese spezielle Replace Funktion fÃ¼r Buchstaben behalten da die Implementation deutlich einfacher ist. Zwar wird auch 
    in der String-Replace Implemenation getestet ob es sich nur um Buchstaben handelt und dann eine schnellere Implementation 
    gewÃ¤hlt, aber in der const char * mÃ¼sste ich dazu erst die LÃ¤ngen der Strings ermitteln lassen was hier ja nicht 
    'for free' ist... und will man wirklich nur Buchstaben austauschen ist diese extra Funktion handlich & Performant.



>> 03.02.2006
[SW]
- Linux buid: build is wieder fehlerlos unter linux
  habe in RTTIDefs.h den rÃ¼ckgabewert von CLASS_OFS von PLGeneral::uint64 auf size_t geÃ¤ndert.
  da size_t immer die passende lÃ¤nge auf dem entsprechenden sysstem hat.
  (32Bit-System -> 32 Bit, 64Bit-System -> 64Bit)



>> 03.02.2006
[CO]
- Container Klassen: Intern verwendete Klassen & Strukturen sind nun nicht mehr von auÃen 'sichtbar'... vorallem 'HashMap' 
  sieht nun in der Implementation ziemlich krank aus - dieses Template wirrwar ist kaum noch lesbar. ;-)
- String:
  - Compare Funktionen kann man nun noch optional die Anzahl der zu vergleichenden Zeichen Ã¼bergeben, so muss man nicht erst 
    umstÃ¤ndlich sich einen String & dann einen Substring davon erzeugen lassen damit man bestimmte Regionen von Strings 
    vergleichen kann.
  - Neue Funktion: IsSubString(): PrÃ¼ft ob ein gegebener String ein Unterstring ist
  - Delete() fÃ¤ngt nun auch den Fall ab wenn der String nun leer ist
  - Print() prÃ¼ft nun ob der Ã¼bergebene String NULL ist (ansonnsten gabs einen Crash in '_vscprintf')
  - GetSubString(): Position Parameter wird auf korrektheit Ã¼berprÃ¼ft
  - IsAlphabetic() & IsAlphaNumeric(): Kommentare um jeweils eine kleine Beispielzeile erweitert, denn ich hatte total 
    verpeilt fÃ¼r was diese eigentlich da sind und nahm an es wÃ¼rde sich um 'ist keine Zahl/ist eine Zahl' Funktionen handeln. 
    Stefan klÃ¤rte mich kurz im Chat auf und jetzt ist diese Sache natÃ¼rlich total logisch - aber da es sicherlich auch 
    andere nicht auf anhib peilen werden lieber kurz nen Beispiel dazu. :)
  - Neue Funktionen IsFixedNumeric() (hm, besserer Name??) prÃ¼ft ob der String eine Zahl ist, IsFloatingPointNumeric() prÃ¼ft 
    ob es eine FlieÃkommazahle ist



>> 31.01.2006
[CO]
- HashMap: HashSlot zu einfacher Stuktur gemacht, das spart Funktionsaufrufe und ist auch etwas kompakter. HashSlot speichert 
  nun auch den VorgÃ¤nger, dadurch war nun auch die Implementation der 'Previous' Iterator Funktionen mÃ¶glich - wobei diese 
  HashMap Iterator Implementation fÃ¼r 'vorwÃ¤rts' & 'rÃ¼ckwÃ¤rts' Support etwas Tricky ist... aber ich glaub das es kaum 
  einfacher gehen wird. :(
- SimpleMap Implementiert - diese Klasse verwendet intern 'Fast Pool' damit das hÃ¤uftige EinfÃ¼gen & LÃ¶schen etwas flotter 
  von dannen geht, aber zum auffinden der entsprechenden EintrÃ¤ge muss man natÃ¼rlich sequentiell die gesammte Liste 
  durchgehen... diese Klasse sollte daher mit bedacht eingesetzt werden. Andere Map Implementationen wie z.B. 'Binary Heap' 
  sind hier deutlich flotter und diese Implementation hat noch den netten Seiteneffekt das die Elemente vom Iterator gleich 
  'nach SchlÃ¼ssel geordnet' zurÃ¼ckgegeben werden was bei dieser Implementation 'for free' kommt. Bei SimpleMap und HashMap 
  ist dies nicht der Fall und ein geordnetes zurÃ¼ckgeben der Element zu 'erzwingen' wÃ¤re hier definitiv nicht gut da diese 
  Implementationen das einfach nicht 'unterstÃ¼tzen' und dies dann extra Implementiert werden mÃ¼sste was dann recht langsam 
  wÃ¤re. Jede Implementation hat hier genauso wie die Container-Klassen vor und Nachteile die man geschickt nutzen sollte. 
  Wenn wirklich benÃ¶tigt kÃ¶nnten wir spÃ¤ter noch extra Funktionen anbieden die Elemente 'IMMER' geordnet zurÃ¼ckgeben - ob 
  nun performant oder nicht... aber in den meisten FÃ¤llen ist es egal in weiler Reihenfolge die Elemente zurÃ¼ckgegeben 
  werden und da sollten wir defintiv die Sache nicht unnÃ¼tz kÃ¼nstlich ausbremsen.



>> 30.01.2006
[CO]
- Nahm wie mit Stefan besprochen die Funktion ExpectCharacter() wieder aus dem Tokenizer und implementierte eine vergleichbare 
  Funktion namens IsCharacter() in der String Klasse.
- Container, Map & Iterator Templates um virtuellen Destructor erweitert, auch bei Templates scheint dies Pflicht zu sein - 
  gut das genau zu wissen. :)



>> 29.01.2006
[CO]
- PrÃ¼fte Ã¼ber Doxygen ob die Kommentare soweit ok sind und verbesserte ein paar Stellen



>> 24.01.2006
[CO]
- Tokenizer: Neue Funktion: ExpectCharacter(): Ãhnlich wie ExpectToken(), aber erwartet das der nÃ¤chste Token ein einzelner
  Buchstabe ist welcher mit einem der Ã¼bergebenen Buchstaben Ã¼bereinstimmt. Wird bereits in Var::CheckMinMax() verwendet um 
  zu prÃ¼fen ob ein " oder ' vorhanden ist.
- Var::CheckMinMax() Funktionen an neuen Tokenizer angepasst
- Base::SetVars() an neuen Tokenizer angepasst



>> 23.01.2006
[SB]
- Tokenizer verÃ¤ndert, so daÃ bei Quotes erst die AnfÃ¼hrungszeichen ("), dann der Inhalt und dann noch einmal die AnfÃ¼hrungszeichen zurÃ¼ckgegeben werden.
  Ist das Wort leer, so wird es nicht zurÃ¼ckgegeben. Auf diese Weise kann der Tokenizer sowohl fÃ¼r strikte Syntax
  verwendet werden oder es kann wie bisher einfach der Inhalt der Quotes ausgelesen und weiterverarbeitet werden



>> 22.01.2006
[CO]
- Resource Manager & Profiling Klassen an uint32 angepasst damit die Warnungen verschwinden



>> 21.01.2006
[SB]
- Neue Tokenizer Klasse geschrieben. Intern benutzt diese nun eine vernÃ¼nftige State-Machine (TheoInf lÃ¤Ãt grÃ¼Ãen) ;-) Dies ist zwar u.U. etwas langsamer, sollte dafÃ¼r
  aber wesentlich stabiler sein und ist vor allem verstÃ¤ndlicher zu lesen
- Die Klasse arbeitet nun mit Strings anstatt mit char arrays
- Die Optionen werden nicht mehr beim Starten des Parsers festgelegt sondern Ã¼ber eigene Get/Set Methoden
- Die grundlegende FunktionalitÃ¤t des Tokenizers wurde besser von den erweiterten Parser-Funktionen getrennt. Diese sind zwar nach wie vor vorhanden, sollten aber nur
  eingesetzt werden, wenn keine strikte Syntax gebraucht wird. Im allgemeinen sollte der Tokenizer nur die Tokens liefern, danach muÃ der Output vernÃ¼nftigt
  geparsed werden
- Neue Klassen: BufferedReader, BufferedStreamReader und BufferedFileReader. Diese Klassen werden benutzt, um Schritt fÃ¼r Schritt aus einem Stream oder einem
  Buffer zu lesen. Dies wird im Tokenizer verwendet, so daÃ dieser jetzt auch direkt aus Dateien parsen kann. Leider ist die Implementierung nicht so performant wie sie
  sein kÃ¶nnte, dies sollte spÃ¤ter noch einmal Ã¼berarbeitet werden. AuÃerdem sollte es eine Stream-Klasse geben, die Byte fÃ¼r Byte zurÃ¼ckgibt, der BufferedStreamReader
  kÃ¶nnte dann auf beliebige Streams angewendet werden. Auf diese Weise kÃ¶nnte jeder Stream verwendet werden, nicht nur Dateien sondern auch z.B. Netzwerk-Streams o.Ã¤.
- Codes an neuen Tokenizer angepaÃt



>> 21.01.2006
[CO]
- Etwas an den Container Klassen gefeilt, u.a. wird nun dort so mÃ¶glich/sinnig uint32 anstatt int verwendet - dadurch kann 
  man gleich von vorne heraus Negative Werte ausschlieÃen so, das man sich intern extra Abfragen sparen kann. Bei 
  GetIterator() kann man nun optional einen Start Index setzen. Die Iterator Konstruktoren sind nun protected so das diese 
  NUR von dem jeweiligen Container Typ erzeugt werden kÃ¶nnen.
- Bitset: Damit wir endlich ein paar cpp-Dateien im Container Ordner haben machte ich das Bitset Template zur normalen 
  Klasse. Ein etwas weniger wichtiger Grund war, das man nicht jedesmal <bool> angeben muss - denn ein anderer Typ ist hier 
  sowieso nicht mÃ¶glich/gewÃ¼nscht... ein Bitset mit z.B. floats wÃ¤re total daneben. :)



>> 17.01.2006
[SB]
- Alle Klassen auf Namespaces umgestellt. Das RTTI machte dabei etwas Probleme, die Makros mÃ¼ssen hier nochmal Ã¼berarbeitet werden, es
  ist also mÃ¶glich daÃ externe Klassen im Moment nicht mehr richtig funktionieren.
- Alle Container-Klassen nach 'PLGeneral/Container' verschoben
- Quicksort nach 'PLGeneral/Tools' verschoben
- Verzeichnis 'FileSystem/Base' gelÃ¶scht und alle Dateien direkt nach 'FileSystem' verschoben
- Patch von Christian fÃ¼r einen Fehler in SearchMultiHandle eingearbeitet



>> 16.01.2006
[SB]
PLString:
- Die Operatoren gefielen mir noch nicht wirklich, da dies eine bunte Mischung aus der Verwendung von String und char* war.
  Habe nun bei den wichtigsten Operatoren jeweils beide Varianten eingebaut, wird dies mit char* aufgerufen ist es also minimal
  schneller, da nicht erst ein String-Objekt erzeugt werden muÃ
- StringModule wurde in StringBuffer umbenannt
- Der StringBuffer implementiert nun nicht mehr einen eigenen Reference Counter sondern benutzt PLTRefCount
- Hilfsfunktionen zur Verwendung von String-Buffern in der Klasse eingebaut. Dies erleichtert die Arbeit mit den Buffern, da ansonsten
  an vielen Stellen immer wieder das gleiche getan werden muÃte (Buffer kopieren wenn der String verÃ¤ndert wurde etc)
- Der String-Buffer Ã¼bernimmt nun immer einen neuen Zeiger auf einen Buffer, die MÃ¶glichkeit einen eigenen Buffer zu allokieren und
  den Ã¼bergebenen String zu kopieren fÃ¤llt weg. Dies macht die Verwendung des Buffers wesentlich verstÃ¤ndlicher, zumal das Kopieren
  des Strings nur an einer einzigen Stelle nÃ¶tig war
- Compare-Funktionen Ã¼berarbeitet
- Konstrukturen mit einem Char-Zeichen als Parameter aus StringBuffer entfernt. Im String selbst bleibt dieser Konstruktor erhalten,
  damit Operationen auf Strings auch mit Buchstaben funktionieren, ansonsten wÃ¤re das Umwandeln eines Buchstabens in einen String
  der LÃ¤nge 1 recht kompliziert
- IsAlpha: Wurde umbenannt in IsAlphabetic. AuÃerdem prÃ¼ft diese Funktion nun den gesamten String und nicht mehr nur ein Zeichen,
  fÃ¼r ein einzelnes Zeichen sollte entweder die System-Funktion direkt aufgerufen werden oder SubStrings verwendet werden
- IsAlphaNumeric: PrÃ¼ft nun ebenfalls den gesamten String, ob dieser nur aus alpha-numerischen Zeichen, sprich alphabetischen ODER
  numerischen Zeichen besteht. Vorher prÃ¼fte diese Funktion nur auf numerische Zeichen, der Name war also falsch
- PrintF in Print umbenannt. Naja typische SchÃ¶nheitsoperation, sollte dies auf heftigen Widerstand stoÃen kÃ¶nnen wir es auch wieder
  umbennen, aber ich finde so ein groÃes F am Ende irgendwie hÃ¤Ãlich ;-)
- Insert (char) entfernt. Wenn dies nicht dringend und an performance wichtigen Stellen gebraucht wird sollte dies lieber Ã¼ber einen String
  der LÃ¤nge 1 gemacht werden
- EatLeadingWhitespace und EatTrailingWhitespace umbenannt in TrimLeading und TrimTrailing. AuÃerdem noch Trim hinzugefÃ¼gt, welches
  beides macht. AuÃerdem geben diese Funktionen nun ebenfalls den String zurÃ¼ck
- Konvertierungsfunktionen aufgerÃ¤umt. Kleine Ãnderung: Beim =(char) wird nun der Buchstabe ausgegeben, nicht dessen Ascii-Wert.
  Dies war zuvor inkonsistent, bei =(char) wurde die Zahl genommen, bei += jedoch der Buchstabe
- Const bei entsprechenden Methoden hinzugefÃ¼gt
- String-Klasse liegt nun in Base
PLGeneral:
- PLTRefCount Template hinzugefÃ¼gt, Basisklasse fÃ¼r Reference Counting
- PLTRefCountPtr Template hinzugefÃ¼gt, diese Klasse ist ein spezieller Reference Counter fÃ¼r externe Objekte
- SmartPtr-Template hinzugefÃ¼gt. Diese Klasse arbeitet mit dem PLTRefCount Interface und Ã¼berprÃ¼ft dabei,
  ob das verwendete Objekt dieses Interface unterstÃ¼tzt oder nicht. Falls nicht wird mittel PLTRefCountPtr ein
  externer Reference-Counter fÃ¼r das Objekt erzeugt, es ist jedoch besser, wenn die Klasse auf die gezeigt
  wird von PLTRefCount abgeleitet wird, da dies Fehler z.B. durch doppeltes Zuweisen des gleichen Zeigers
  besser verhindern kann
- Alle Klassen auf die neue PLTRefCount-Klasse umgestellt



>> 07.01.2006
[CO]
- RTTIDefs.h: Da 'VAR_OFS' bei Stephan unter Linux Compiler Warnungen verursacht bastelte er ein Makro welches unter Linux 
  keine Warnungen produziert. Da VC aber anscheinend kein '__alignof__' kennt musste ich hier defines einsetzen, unter 
  Windows das eine Makro, unter Linux das andere... vielleicht bekommt man irgendwann spÃ¤ter etwas Universelles zusammen das 
  Ã¼berall sauber geht, aber ich denke wir kÃ¶nnen das erstmal so lassen.



>> 03.01.2006
[SW]
Alle Projekte:
- Habe das subversion property "svn:eol-style 'native' " fÃ¼r die source-files, text-files und project-files gesetzt.
  dieses property sorgt dafÃ¼r, das beim checkout,update die eol-kennung entsprechend des OSes ist
  d.h. unter linux ist die eol-kennung nur \n und unter windows \r\n und zwar egal vom welchem os aus diese
  Datei verÃ¤ndert oder erstellt worden ist



>> 02.01.2006
[SW]
- Memleak in der String-klasse unter linux behoben. Das Problem war das die _vscprintf-implementation
  fehlerhaft war(ein return hat gefehlt, *asche Ã¼ber mein haupt*).
  Da die vsnprintf-function unter linux das selbe macht, wurde die protabele_vsnprintf-fn aus GeneralLinux.cpp
  entfernt.



>> 01.01.2006
[SW]
- habe die kompabilitÃ¤t zu gcc 3.4 hergestellt bzw. zum c++-template standard
  zum einen musste ich den header string.h in HashTable.inl hinzufÃ¼gen, weil sonst der gcc mit folgender fehlermeldung 
  bezÃ¼glich strlen, strcpy,strcmp abbrach:
  "there are no arguments to `strcmp' that depend on a template parameter, so a declaration of `strcmp' must be available"
  Die Ã¤nderung von AType zu AType1 in der friend declaration in den Dateien ResourceManager.h, ResourceHandler.h und 
  Resource.h war nÃ¶tig weil sonst der gcc mit folgender Fehlermeldung abbrach:
  "include/PLGeneral/Base/ResourceManager.h:32: error: declaration of `class AType'
   include/PLGeneral/Base/ResourceManager.h:25: error:  shadows template parm `class AType'"
  es mÃ¼sste nur getestet werden ob diese Ãnderungen keine probleme verursachen
- tinyxml: habe eine statische lib fÃ¼r linux von tinyxml in den zips hinzugefÃ¼gt und tinyxml.h so abgeÃ¤ndert das sie auch 
  unter linux Ã¼bersetztbar ist
  
  
>> 01.01.2006
[CO]
- PLTString &PLTString::operator += (char nCharacter): Hier waren die Parameter vertauscht



>> 22.12.2005
[CO]
- Optimierte PLTHashTable da diese Klasse recht hÃ¤ufig verwendet wird und etwas lahm war... die alte Implementation war etwas 
  dÃ¼rftig. Bei 'Add()' wird nun nicht mehr geprÃ¼ft ob dieses Objekt bereits eingetragen ist - das muss der User schon selbst 
  machen wenn er hier unsicher ist und das jedesmal inter zu prÃ¼fen ist schlichweg zu AufwÃ¤ndig... Codes angepasst habe ich 
  keine da wir eh vorher immer im  Falle des Falles prÃ¼fen. Nahm diverse Ã¼berflÃ¼ssige 'Sicherheitsabfragen' raus - denn in 
  den Innereien kann man IMMER davon ausgehen das die gegebenen Dinge stimmen da diese bereits vorher mal geprÃ¼ft wurden. :)
  Desweiteren wird nun zwischen groÃ/kleinschreibung unterschieden. Die neue Implementation ist nun teils mehr als doppelt 
  so schnell wie die alte und die Namen kÃ¶nnen beliebig lang sein.
- PLTResource & PLTResourceHandler: Die alte Resource Handler Implementation war viel zu umstÃ¤ndlich - daher machte ich dies 
  'direkter', Resource kann also intern direkt auf Handler zugreifen und umgekehrt... da diese Dinge stark zusammenhÃ¤ngen 
  ist das denk ich ok und es vereinfacht die Sache enorm. Wenn ein Resource Manager automatisch nicht lÃ¤nger verwendete 
  Resourcen lÃ¶schen soll, lÃ¶schen nun die Resource Handler die alte Resource wenn diese nicht mehr verwendet wird.



>> 15.12.2005
[CO]
- Da PLTString nun stark an Bedeutung gewinnt, Ã¼berarbeite ich die String Klasse nochmal komplett - die alte Implementation 
  war leider teils heftig Buggy/Unbefriedigend. Das Ãberarbeiten war zwar einiges an Arbeit, aber ich denke es hat sich 
  definitiv gelohnt. :)
- Stellte intern die Speicherung von Namen im Resource Manager auf PLTString um - den Rest in PLGeneral wird Stefan 
  anpassen. Das verwenden von PLTString zur Speicherung von Namen bringt einige Vorteile, zum einen haben wir so keinen 
  Overflow mehr wenn man einen lÃ¤ngeren Namen hat als Speicher fÃ¼r einen Namen verfÃ¼gtbar ist... und zum anderen Spart man 
  einiges an Speicher da ein 'leerer' String gerade mal 4 Byte groÃ ist... und ansonnsten wird nur soviel Speicher fÃ¼r den 
  String verwendet wie wirklich nÃ¶tig ist. Also nicht mal fest char[256/1024 usw.] anlegen und hoffen das dies reichen 
  wird. ;-)
- In PLTParameters::AddParam() kam es nun nach 'PLTVariant *pVar = new PLTVariant(cParam);' zum Crash da in 
  'PLTVariant::m_sName' merkwÃ¼rdigerweise Schrott stand. Machte hier eine kleine Ãnderung, lies aber das vorherige als 
  Kommentar drinen. Stefan, schau bitte mal was hier schiefgeht und ob man es so wie es jetzt ist lassen kann.



>> 12.12.2005
[CO]
- PLTXmlElement::GetFirstAttribute(): An ein paar Stellen wo ich diese Funktion verwendete hatte ich vergessen vorher zu 
  PrÃ¼fen ob hier Ã¼berhaupt etwas zurÃ¼ckgegeben wird bevor ich es verwende - wieder soetwas wo man sich schwer wundert das 
  dies nicht schon vorher aufgefallen ist. ;-)
- Nahm wie besprochen die PrioritÃ¤ten aus dem Resource Manager da diese dort mehr Ãrger als nutzen bringen
- PLTSingleton: 'm_pInstance' bekommt nun im Constructor die Instance zugewiesen und nicht mehr in GetInstance(). Nach den 
  kleinen Ãnderungen im Resource Manager Template hatte ich hier in den konkreten Resource Managern nun das Problem das 
  in deren Constructoren teils GetInstance() verwendet wird - jedoch lieferte dies zu diesem Zeitpunkt NULL zurÃ¼ck da diese 
  Variable erst noch gesetzt werden musste. (endlos Rekursion :)
  Ich hoffe diese kleine Ãnderung geht ok...



>> 08.12.2005
[CO]
- PLTResourceManager: Die Funktion Get(<Name>) ist nun virtuell, in der Engine beim Scene System hat diese Funktion eine 
  erweiterte funktionalitÃ¤t da man Ã¼ber z.B. 'Root.Scene.Jeep' auch 'absolute Namen' angeben kann. Machte SetResourceName() 
  Protected da es reichen mÃ¼sste wenn man Ã¼ber PLTResource::SetName() den Namen einer Resource setzen kann. 
  PLTResource::SetName() ist nun ebenfalls virtuell da z.B. in der Engine bei PLTSceneContainer in Namen kein '.' vorkommen 
  darf und der Name 'Root' nicht verwendet werden darf. (NUR die Root Node selbst hat diesen Namen :)
  Dummerweise musste ich auch Get(<int>) virtuell machen und in PLTSceneContainer implementieren, ansonnsten bekam ich 
  folgende Fehlermeldung:
    "error C2664: 'PLTSceneContainer::Get': Konvertierung des Parameters 1 von 'int' in 'const char *' nicht mÃ¶glich"
  Was machen wir hier? Irgendwie ist das total dÃ¤mlich. :(



>> 02.12.2005
[CO]
- PLTHeap: Kann nun auf Wunsch auch den Key zurÃ¼ckgeben



>> 30.11.2005
[CO]
- PLTBase::SetVars(): Konnte kein '=' gelesen werden, wurde das nÃ¤chste gefundene Wort 'Ã¼bersprungen' was nicht korrekt war.



>> 20.11.2005
[SB]
- Habe das Interface von PLTContainer verÃ¤ndert: Die Funktion Add(const AType &Element) gibt nun ebenfalls einen AType* Zeiger zurÃ¼ck.
  Man braucht dies nicht, wenn man nur eine Liste von Zeigern hat, besteht die Liste jedoch aus direkten Objekten, welche kopiert werden,
  ist dieser Zeiger sehr nÃ¼tzlich, ansonsten wÃ¼rde es wesentlich umstÃ¤ndlicher.
- Habe in PLGeneral und PLMath alle Aufrufe von Add(const AType &Element) angepaÃt - da vorher true als Fehler zurÃ¼ckgegeben wurde, nun
  aber NULL fÃ¼r den Fehlerfall steht, muÃ leider jeder Aufruf angepaÃt werden. Habe dies auch in den anderen Projekten getan.



>> 18.11.2005
[SB]
- Include von PLTLog in PLTSingleton entfernt, dadurch muÃten an anderen Stellen die Include-Files geÃ¤ndert werden



>> 10.11.2005
[CO]
- PLTResourceManager<AType>::SetResourceName(): Ohman, wie konnte DIESER total dÃ¤mliche Bug nur soo lange unbemerkt 
  bleiben? (war natÃ¼rlich mein verschulden :) Hier wurde zuerst der neue Resourcen Name gesetzt, und dann wurde die 
  Resource mit hilfe diesen neuen Namens aus 'm_lstNameHashList' entfernt und dann mit dem neuen Namen wieder 
  hinzugefÃ¼gt... brrr, natÃ¼rlich muss die Resource mit dem alten Namen aus 'm_lstNameHashList' entfernt werden.



>> 09.11.2005
[CO]
- PLTTools: Neue Funktion: CombineStrings(): Kombiniert Strings miteinander. Diese Funktion wird u.a. im Renderer in den 
  Shader Backends benÃ¶tigt um den Shader korrekt zusammenzukopieren... denn hier mÃ¼ssen noch Renderer & Custom Definitionen 
  in den Shader eingefÃ¼gt werden.
- PLTList: Get() & ReplaceAtIndex() & AddAtIndex() & RemoveAtIndex() & Compare() etwas Optimiert: Ist der Index in der 
  'hinteren' hÃ¤lfte, so wird nun vom letzten Element rÃ¼ckwÃ¤rts durchlaufen wodurch man in diesen FÃ¤llen eine bessere 
  Suchzeit hat... wenn man schon ne doppelt Verkettete Liste hat, so kann man auch ruhig die Vorteile die diese bietet 
  nutzen. ;-)
  Passte ebenfalls PLTPool & PLTFastPool entsprechend an.



>> 07.11.2005
[SB]
Alle Projekte:
- Habe im Repository die Verzeichnisse _Branches und _Tags entfernt - ich fand die stÃ¶rend, und wir nutzen das bisher eh nur sehr selten.
  Der PLGeneral-Branch sitzt nun direkt im Hauptverzeichnis, was nicht weiter stÃ¶ren sollte, zumal Branches ja sowieso keine allzu lange Zeit
  am Leben sein sollen :-)



>> 02.11.2005
[CO]
- Reset-Funktion zu PLTArray hinzugefÃ¼gt mit der man den Array 'zurÃ¼cksetzen' kann - recht praktisch das
- PLTTools: Neue Funktionen: GetIntegersFromString(), GetFloatsFromString() und GetDoublesFromString()



>> 01.11.2005
[CO]
- PLTXmlDocument: LoadFile() und SaveFile() setzen nun den Dokument Wert auf den Dateiname + einen TinyXML Fehlercode
  wenn die Datei nicht geÃ¶ffnet werden konnte.



>> 29.10.2005
[CO]
- PLTSystem: VergrÃ¶Ãerte die Anzahl der Slots der Hash Tables von m_hashClasses & m_hashModules da ich derzeit 217 Klassen, 
  und 19 Module zÃ¤hle - so ist die Hash Table wieder Effektiver und da es nur eine Instance von PLTSystem gibt gibts auch 
  Speicher mÃ¤Ãig keine Probleme.
- Es kÃ¶nnen nun auch Passwort GeschÃ¼tze Zip-Dateien verwendet werden. DafÃ¼r musste ich PLTFile::Open() um einen weiteren 
  Optionalen Parameter erweitern. (das Passwort wenn benÃ¶tigt)



>> 25.10.2005
[CO]
- PLTTools: Neue Funktion GetBooleanFromString() welche einem den booleanischen Wert in einem String zurÃ¼ckgibt. Dies ist 
  z.B. beim Auslesen von XML Attribute Werten recht praktisch da der User dadurch '0' oder auch 'false' schreiben kann.
  PLTVar::Set() verwendet nun ebenfalls diese Funktion damit das Einheitlich gehandhabt wird.
- PLTXmlElement: SchlÃ¤gt das zurÃ¼ckgeben eines Attribute Wertes fehl, so Ã¤ndert TinyXML troztdem die Ã¼bergebene Variable - 
  das ist total unpraktisch und darum wird hier nun diese Variable nicht mehr geÃ¤ndert falls die Funktion fehlschlÃ¤gt. 
  Hatte mir schon Ã¼berlegt diese Ãnderung direkt in TinyXML zu machen, sah aber davon ab da dies eventuell Probleme 
  verursachen kÃ¶nnte.



>> 24.10.2005
[CO]
- PLTBase: Um Funktion AddVarsToXMLElement() erweitert welche die Variablen zu einem XML Element hinzufÃ¼gen. Dabei kann man 
  als Parameter Ã¼bergeben ob die Variablen als Attribute oder Elemente hinzugefÃ¼gt, und ob Variablen mit Default Werten 
  irgnoriert werden sollen. Da dieses 'Variablen zu XML Element hinzufÃ¼gen' Ã¶fters benÃ¶tigt wird, ist diese hilfs Funktion 
  ziemlich praktisch. Das 'GegenstÃ¼ck' zu dieser Funktion SetVarsFromXMLElement() ist ebenfalls vorhanden. Diese zweite 
  Funktion kann auf WÃ¼nsch selbstÃ¤ndig nach Variablen in den Attributen UND Child-Elementen suchen soll, Default Einstellung 
  ist jedoch Variablen nur in den Attributen suchen.
- PLTConfig lÃ¤d & speichert nun in einem XML Format, dabei werden die verschiedenen Variablen als Elemente hinzugefÃ¼gt 
  und auch Variablen mit Default Werten werden ebenfalls gespeichert - das ist hier irgendwie Ã¼bersichtlicher.
- PLTXmlDocument: LoadFile() verwendet nun eigene File System Funktionen um eine Datei einzuladen und zu Parsen



>> 21.10.2005
[CO]
- PLTConfig: Beim Laden & Speichern kann man nun Optional angeben ob die Config Datei NUR im aktuellen Verzeichniss gesucht
  werden soll. Damit kann man Konflikte zwischen verschiedenen Config Files verhindern - z.B. das plÃ¶ztlich in PLSamples 
  Configs aus PLTools genommen werden da die gewÃ¼nschten Configs in PLSamples nicht gefunden wurden und PLTools im FS als 
  Basis Pfad eingetragen ist... und somit wurden teils unerwÃ¼nschte Einstellungen verwendet. :)



>> 05.10.2005
[CO]
- Musste in TinyXML eine weitere kleine Ãnderung vornehmen: Hatte Probleme beim Scene Format da '[' und ']' nicht in Namen 
  vorkommen durften - aber somit konnte eine Scene nicht mehr geladen werden sobald eine RTTI Array Variable verwendet 
  wurde. Also erweiterte ich TiXmlBase::ReadName() so, das auch '[' und ']' in Namen akzeptiert werden... hoffentlich macht 
  das keine Probleme... hat jemand ne Ahnung ob das 'Absicht' ist das '[' und ']' bei XML nicht in Namen vorkommen darf, 
  sprich, es so in den 'Vorgaben' steht? Wenn ja, und wir uns daran halten wollen, mÃ¼ssten wir uns fÃ¼r RTTI Array Variablen 
  etwas anderes Ã¼berlegen was aber ziemlich unschÃ¶n werden wÃ¼rde.
- An ein paar Stellen wo das RTTI float Variablen in einen String schreiben soll %f durch %g ersetzt damit am Ende keine 
  ÃberflÃ¼ssigen Nullen stehen.



>> 29.09.2005
[CO]
- PLTString::Insert() um weiteren optionalen Parameter erweitert. Ist dieser nicht -1 so gibt dieser die Anzahl der 
  einzufÃ¼genden Zeichen an. Desweiteren noch ein paar Tool Funktionen hinzugefÃ¼gt.
- PLTSystem::ScanPlugins() um optionalen Parameter erweitert. Da wir mittlerweile ziemlich viele dll's haben kann 
  ScanPlugins() vorallem beim Programmstart im Debug Modus nervend viel Zeit in anspruch nehmen da zuerst einmal die dll 
  geladen werden muss und wenn nichts Interessantes drinen ist wird diese wieder entladen. Ist dieser neue Parameter auf 
  'true' (Default = 'true'), so wird anhand des Namens ein kleiner 'Vortest' gemacht so das man meist gut die hÃ¤lfte der 
  dll's erst gar nicht zu laden braucht was den Scan Vorgang beschleunigt. Dabei wird das 'D' am Ende des Namens geprÃ¼ft. 
  Ist man im Release Modus und ist dort ein 'D' wie z.B. bei PLSampleSceneNodesD.dll so wird dieses Module komplett 
  ignoriert. Da wir selbst uns an diese Namens Konvention halten klappt das hier, der User mÃ¼sste sich am Ende auch daran 
  halten, oder beim Scannen diesen Parameter auf 'false' setzen damit nicht eigentliche gÃ¼ltige Module ignoriert werden. 
  Ist natÃ¼rlich eine Sache die schnell daneben gehen kann wenn jemand nicht aufpasst - allerdings spart das Wertvolle 
  Ladezeit was ein deutlicher Pluspunkt ist... und eine andere LÃ¶sung um die ScanPlugins() Ladezeit zu verkÃ¼rzen hab ich 
  bis jetzt noch nicht gefunden. Ich machte das da diese Ladezeit gerade im Debug Modus mittlerweile deutlich auffÃ¤llig - 
  das iss schon fast so nervend wie bei 3D Studio Max wo am Anfang erstmal tausende von Plugins geladen werden welche man 
  teils gar nicht braucht was Debuggen zur Qualt macht. Das Scannen selbst kann man wohl nicht umgehen, aber halt wie 
  gesagt grob anhand des Names 'ausfiltern'. In meinem Debug Modus Test wurden frÃ¼her beim Programmstart gut 252 mal dll's 
  geladen und entladen. Jetzt nur noch 39 mal - frÃ¼her war das so hoch da wenn eine dll geladen wird ja auch gleich noch 
  alle damit Verbundenen dll's geladen werden, und beim endladen werden diese anderen dll's meist auch wieder entladen und 
  das gleiche Spielchen immer und immer wieder. Hoffentlich kommt Stefan mit dieser LÃ¶sung klar... oder findet etwas 
  besseres. ;-)
  Alternativ kÃ¶nnten wir vielleicht auch alle Plugin in extra Unterordner wie z.B. 'Plugins' und 'PluginsD' packen und dann 
  gezielt beim Initialisieren der Engine in diesen Ordnern Scannen lassen. Aber dann mÃ¼sste z.B. 'Newton.dll' auch im 
  entsprechendem Ordner liegen wenn man was 'rausgibt'... und im Grundordner mÃ¼sste dieses nochmal liegen falls die 
  Anwendung selbst Newton verwendet. (denn in diesem 'rausgeben' Fall wÃ¤re es nicht gut an den Environment Variablen zu 
  drehen)



>> 25.09.2005
[CO]
Alle Projekte:
  Ging alle PL Projekte durch und machte einige RTTI Variablen 'read only':
  PLTImageLoader, PLTTextureCreator, PLTMeshCreator, PLTSkeletonAniLoader, PLTMeshLoader
PLGeneral:
- PLTFileSystem: Neue Funktion: IsSearchPath() -> PrÃ¼ft ob ein gegebener Pfad ein Suchpfad eines gegebenen Types ist. Dies 
  brauchte ich in PLTMeshLoader wo ich prÃ¼fe ob ein Pfad bereits eingetragen ist. Wenn nicht, werden bei bedarf 
  wÃ¤hrend des Laden eines Meshs ein paar Suchpfade hinzugefÃ¼gt und nach dem Laden wieder entfernt. (siehe PLEngine Diary)
- PLTFileType::RemoveSearchPath() korrigiert nun den Ã¼bergebenen Pfad wenn nÃ¶tig (sicher ist sicher)



>> 22.09.2005
[CO]
- Neue Funktion: PLTPlatform::ShellOpen(): Das OS Ã¶ffnet eine Datei mit dem Programm welches mit diesem Datei Typ vernÃ¼pft 
  ist. Weis nicht ob diese Funktion wirklich in Platform passt oder nicht doch eher ins File System. Auf jedenfall ist diese 
  Funktion recht nÃ¼tzlich wenn man z.B. auf einen Link Klickt und sofort auf eine Internet Seite kommt - oder wenn man z.B. 
  im Mesh Editor ein Material Ã¶ffnen will. (in dem Fall wird nen Text Editor mit diesem Material geÃ¶ffnet)



>> 10.09.2005
[CO]
- Der einzige Unterschied zwischen PLTPool und PLTResourceManager bestand darin das PLTPool Element zusÃ¤tzlich noch 
  eine PrioritÃ¤t haben - wichtige Element liegen dann also immer am Anfang. Da PrioritÃ¤ten bei Resourcen sicherlich auch 
  nicht verkehrt sind erweiterte ich den Resource Manager um solche. Somit hat PLTPool nun keine Existensberechtigung mehr 
  und wurde gekillt. NÃ¶tige (meist kleinere) Anpassungen:
  - PLGeneral: PLTProfiling
  - PLModel: PLTAnchorPoint, PLTAnimationEvent, PLTAnimationInfo, PLTMesh, PLTMeshHandler, PLTMorphTargetAni
  - PLEngine: PLTSurfaceListener, PLTSky
  - MeshEditor: TGuiEditAnimationEdit
- Das mit PLTPool hatte ich mir nochmal angeschaut da ich den Namen PLTPool fÃ¼r etwas anderes brauchte - es gibt nun eine 
  Neue Container-Klasse mit diesem Namen. Im Prinzip handelt es sich hierbei um eine Verkettete Liste wie bei PLTList, 
  jedoch gibts Intern zwei Listen, eine mit den aktuell verwendeten Elementen und eine Liste mit derzeit nicht benÃ¶tigten 
  Elementen. Diese Klasse ist recht praktisch wenn man viele Dynamischen Elemente Managen will, also wenn hÃ¤ufig Element 
  gelÃ¶scht und wieder hinzugefÃ¼gt werden. Beim LÃ¶schen wird das eigentliche Element 'nur' zur Liste der freien Elemente 
  hinzugefÃ¼gt, und fÃ¼gt man wieder ein Element hinzu wird erst geschaut obs noch ein nicht verwendetes Element gibt - 
  ansonnsten muss wie bei der normalen Liste ein neues erzeugt werden.
- Neben PLTPool gibts noch eine schnellere Variante Namens 'PLTFastPool'. Bei diesem Container MÃSSEN die Elemente von 
  PLTFastPoolElement abgeleitet sein - damit kann man dann superschnell ein Element direkt vom Container entfernen ohne 
  voher wie bei PLTPool das reale Pool Element zu finden. Diese Klasse ist also Optimal wenn man sehr viele Elemente 
  regelmÃ¤Ãig lÃ¶scht und hinzufÃ¼gt. Ansonnsten verhÃ¤lt sich diese wie alle anderen Container Klassen auch. In der Engine 
  werde ich wohl PLTParticleGroup auf diese Klasse umgestellen und die neue Scene Hierarchy 'PLTSceneHierarchySphereTree' 
  verwendet diese Klasse ebenfalls da hier oft etwas gelÃ¶scht und wieder eingefÃ¼gt wird und dies daher so flott wie mÃ¶glich 
  gehen muss.
- In PLTList::RemoveAtIndex() war noch nen Bug, der Index wurde nicht erhÃ¶ht - das dies nicht schon vorher aufgefallen ist...
- PLTStack: PushBack() Privat gemacht da dies nicht in das 'Ã¼bliche' Stack Schema passt
- Neue Klasse: PLTQueue (FIFO) ist das GegenstÃ¼ck zu PLTStack (FILO)



>> 30.08.2005
[CO]
- PLTBitset::Resize(): Parameter waren vertauscht



>> 26.08.2005
[CO]
- Bei einigen XML Funktionen Funktionen ein Get davor gesetzt + ein paar interne Sicherheits Abfragen auf NULL Zeiger
- XML Interface Kommentare soweit vervollstÃ¤ndigt, sind aber noch hier und da nicht wirklich AussagekrÃ¤ftig da die TinyXML 
  Doku hier leider teils lÃ¼ckenhaft ist. Einiges undokumentiertes Verhalten hab ich bereits direkt in den Codes nachgeschaut 
  und bei uns Dokumentiert. Drehte auch ein paar boolische RÃ¼ckgabe Werte um so das diese zu unserem Style passen. 
  (bei Fehler 'true' statt 'false' - da wir fragen 'gabs nen Fehler?' und nicht 'ging alles glatt';-)
- PLTXmlDocument: Eigene Speicher Funktion eingebaut



>> 17.08.2005
[CO]
- XML Wrapper Versucht Nr. 2: Wie beim Treffen bei Jens Besprochen hat nun jede XML Klasse eine eigene Datei und alles 
  liegt in dem  Ordner. Zudem werden von diesen Klassen nun 'echte' Objekte erzeugt. Konkrete PL XML Objekte werden
  erst DANN erzeugt wenn diese benÃ¶tigt werden - z.B. wenn man sich ein Element zurÃ¼ckgeben lassen will wird intern falls
  zu dem TinyXML Element noch kein PL XML Element vorhanden ist eines erzeugt.
  Mit dieser LÃ¶sung kann es sein das bestimmte Elemente/Attribute NIEMALS 'angefasst' werden und man hier daher auch keine
  eigenen PL XML Objekte erzeugen muss. (wird wohl vorallem bei Attributen der Fall sein :)
  Bei der Implementation gabs nen paar Kleinigkeiten zu beachten:
  Da die User Data Variable von TinyXML verwendet wird, muss man beim Kopieren und beim EinfÃ¼gen der Objekte aufpassen da 
  sonst die PL XML Objekte Zeiger nicht mehr stimmen. Ãnderte in TinyXML TiXmlNode::CopyTo() es so das User Data NICHT
  mehr mitkopiert wird - denn das im Wrapper zu kompensieren war zuviel Aufwand. (rekursiv)
  Das LÃ¶schen der PL XML Objekte war etwas mehr Aufwand da man rausbekommen musste wann ein TinyXML Objekt zerstÃ¶rt wurde - 
  da TinyXML aber soetwas nicht anbietet erweiterte ich TinyXML um eine Destroy-Callback Funktion welche jedesmal aufgerufen 
  wird wenn ein Objekte zerstÃ¶rt wird. Durch diese Mini Erweiterung spart man sich dann in unseren Wrapper eine ganze Menge 
  an Arbeit. :)
  Alles in allem find ich diesen Wrapper recht brauchbar und der Aufwand/Nutzen Faktor stimmt. Mit einer komplett eigenen
  internen Hierarchy wÃ¤re alles mehr Arbeit als dies momentan der Fall ist. Zwar musste ich nun zwei mini Ãnderungen an 
  TinyXML selbst machen - aber ohne diese Ãnderungen hÃ¤tte man sich teils heftig im Wrapper verbiegen mÃ¼ssen um es sauber
  laufen zu lassen, ich finde das ist nen akzeptabler kompromiss zwischen 'TinyXML umschreiben und direkt in PLGeneral',
  'gesammte XML Hierachy selbst Managen' oder gar gleich 'komplett eigenen XML Parser schreiben'.



>> 16.08.2005
[CO]
- PLTTokenizer::GetNextToken(): Quote verhalten minimal geÃ¤ndert. Bis jetzt wurden = und ` gleich gehandelt. Man konnte also
  mit " starten und mit ` Enden. Nun wird es so gehandhabt das wenn mit " begonnen muss es mit " auch wieder enden muss. Hat
  den Vorteil das man nun Quotes 'Schachteln" kann was enorm Praktisch ist. z.B. kann man nun Problemlos eine Scene Node 
  erzeugen dessen Mesh automatisch erzeugt wird mit z.B. 
  pContainer->Create("PLTObject", "Sphere", "Pos=\"0.0 0.0 5.0\" MeshFilename=\"PLTMeshCreatorSphere 
  Name=`Sphere` Radius=`4.0` Detail=`20.0`\"");
- PLTArray: Ist nun wieder ein 'richtiger' Array, bei meinen Tests hatte ich keine Probleme und alles lÃ¤uft mit dieser 
  Ãnderung genau wie frÃ¼her. Ãnderungen in den anderen Codes sind nicht nÃ¶tig. Mit GetData() bekommt man den Zeiger auf 
  das erste Element des Arrays.
- Vertauschte bei PLTBitset & PLTArray Init & Add Parameter - denn Init sollte im Normalfall false sein und nicht geÃ¤ndert
  werden. (auÃer man weis genau was man tut :)
  Init ist praktisch wenn man GENAU weis das man einen Primitiven Variable Typ wie float hat oder einfache Klassen - aber 
  sobald z.B. virtuelle Funktionen ins Spiel kommen sollte man nie nie nie den Init Parameter auf True setzen da memset
  zum Initialisieren der Elemente verwendet wird!
  Keine Anpassungen in PLBase nÃ¶tig, ansonnsten nur eine Handvoll Parameter Anpassungen in allen Projekten zusammen.
- PLTBitset: SetResizeCount() hat nun den Default Wert 320 - denn da jedes Element hier nur 1 Bit ist und je 32 Bits in
  eine Integer Variable 'passen' ist es so wesentlich Effizienter.
- PLTBitset & PLTArray: RemoveAtIndex() verkleinert nun bei Bedarf den Array wieder. NUR diese Funktion lÃ¶scht die
  Elemente, alle anderen verwenden diese nur.
- PLTVar::SetEnumString(): Da m_lstEnum Array ist und jedesmal wenn ein neues Element hinzugefÃ¼gt wird sich die Adresse 
  im Speicher von anderen Elementen Ã¤ndern kann, darf man m_hashEnum erst nachdem alle Elemente eingetragen wurden
  erzeugen.



>> 10.08.2005
[CO]
- Wrapper fÃ¼r TinyXml geschrieben und im Tools Unterordner abgeladen. (+ Base Test um XML Test erweitert)
  Der Wrapper ist noch nicht 'perfekt' und es fehlen noch nen paar PL spezifische Funktionen fÃ¼r z.B. das eigene
  File System verwenden.



>> 06.08.2005
[SB]
- PLTWin32File::GetS() filtert nun nicht mehr das '\n' heraus sondern verhÃ¤lt sich jetzt genauso
  wie fgets(). Vermutlich werden wir jetzt aufgrund des neuen Verhaltens einige andere Stellen
  anpassen mÃ¼ssen, aber es ist ja immer besser sich an Standards zu halten :-)
- PLTWin32File::PutS() gibt jetzt die lÃ¤nge des Strings zurÃ¼ck, wenn es beim Schreiben keine
  Fehler gab, damit liefert PLTFile::Print() auch keine lÃ¤stigen Fehler mehr. Bin mit nicht 100%
  sicher, ob das auch beim Textmode immer funktioniert, sollte aber eigentlich :-)
- Habe einen neuen Branch fÃ¼r PLGeneral erstellt, an dem ich in nÃ¤chster Zeit arbeiten werde.
  Da ich noch einiges an PLGeneral Ã¤ndern mÃ¶chte und es unpraktisch wÃ¤re, dies im "laufenden Betrieb"
  zu tun, da dann stÃ¤ndig alles angepaÃt werden mÃ¼Ãte, ist dies eine gute Gelegenheit, mal Branches
  in Subversion auszuprobieren. Dies ist also eine Kopie des aktuellen PLGeneral, an der ich
  beliebig arbeiten kann, wenn die Arbeiten abgeschlossen sind werden die Ãnderungen wieder mit
  dem Hauptzweig gemerged - bei Bedarf kann man das auch zwischendurch schon machen, wenn ich z.B.
  nur einen kleinen Bugfix mache, der auch in der aktuellen Version ok ist, oder andersherum
  wenn jemand am Hauptzweig was Ã¤ndert was ich gleich Ã¼bernehmen kann. Also mal schauen wie gut
  das funktioniert :-)



>> 28.07.2005
[CO]
- Erweiterte das Resource Manager Template um die Virtuelle Funktion PLTResource::DestroyResource(), diese Funktion
  wird/sollte nun immer anstatt delete <Resource> verwendet werden. Als Standard ist ein einfaches 'delete' 
  Implementiert - in PLTSceneNode ist es aber nÃ¶tig VOR dem LÃ¶schen die Scene Node sauber aus dem Container zu 
  entfernen. Vorher wurde in PLTSceneNode erst direkt im Destruktor der Knoten aus dem Container entfernt - dies 
  machte aber casting-Probleme da anscheinend bereits Teile des Objektes gelÃ¶scht waren was dazu fÃ¼hrte das
  DeInitFunction() nicht mehr korrekt aufgerufen wurde.



>> 11.07.2005
[CO]
- PLTPlaneSet::IsBoxIn() kann nun Optional noch mit ausgeben welche Ebenen die Box schnitten.



>> 11.06.2005
[CO]
- Da ich merkte das man das Informer&Listener Prinzip immer wieder benÃ¶tigt und es mir einfach zu dumm wurde
  das immer wieder von neuem zu Implementieren erstellte ich Informer&Listener Templates an und legte diese im 
  Base-Unterordner ab. (PLTSceneQuery und PLTSceneQueryListener in der Engine verwenden diese Templates bereits)
- PLTString etwas erweitert



>> 17.05.2005
[CO]
PLTPlatform:
- FÃ¼gte Funktionen fÃ¼r Multi-Tasking hinzu da die Rechner (und vorallem neue Konsolen :) immer mehr CPU's
  haben, muss man zwangslÃ¤ufig versuchen wo immer mÃ¶glich bestimmte Aufgaben als eigene Tasks zu realisieren um 
  diese Systeme Effektiver nutzen zu kÃ¶nnen. PLPhysics z.B. werd ich dann gleich in einem eigenen Task laufen
  lassen da dies dort 'relativ' Problemlos mÃ¶glich ist - und der Trend bei Physik geht eindeutig zum eigenen
  Task dafÃ¼r. (Thema Physics CPU etc. :)
  Auch mÃ¼sste man nun so Ladebildschirme realisieren kÃ¶nnen welche lustige flÃ¼ssige Animationen zeigen wÃ¤hrend Parallel 
  dazu in einem Task die Daten geladen werden.
  Damit mÃ¼ssten wir auch das CPU/GPU Problem besser in den Griff bekommen... denn wenn die CPU im Hauptprogramm an einer 
  Stelle einmal dummerweise auf die GPU warten muss, wird die CPU im Hintergrund fÃ¼r z.B. die Physics weiter verwendet so 
  das keine/kaum Resourcen brach liegen.
  Hab mich beim Design an der SDL Implementierungen Orientiert da dies im Endeffekt recht Einfach zu verwenden 
  und Sinnig ist. (und es lÃ¤sst sich sicherlich kaum anderst machen da man ja nur die Grundfunktionen Wrapt :)
  Der User selbst kommt nur mit einer Handvoll Funktionen fÃ¼r Task & Mutex in Kontakt. Intern und vorallem
  bei den Linux Implementierungen ist das alles teils ziemlich umstÃ¤ndlich - da man dort anscheinend XXX
  verschiedene FÃ¤lle beachten muss. Hab dort die Funktionen aus SDL Ã¼bernommen, Stephan muss da aber nochmal drÃ¼ber schaun
  ob das so ok ist und natÃ¼rlich das mal ausprobieren - das wir endlich auch mal Multi-Tasking verwenden/unterstÃ¼zen sollen
  war ja schlieÃlich seine Idee. ;-)
  Ich bin mir seeehr sicher das es sich so wie es momentan ist noch nicht einmal Ãbersetzten lÃ¤sst. ;-)
  Erweiterte PLBaseTests gleich um einen einfachen Multi-Tasking Test.



>> 12.05.2005
[CO]
- PLTBase::SetVars(): Der Tokenzier behandelt hier '[' und ']' nun nicht mehr als einzelne Zeichnen da ansonnsten Variable
  Namen wie 'Test[3]' nur als 'Test' gelesen werden - sehr merkwÃ¼rdig das dies bis jetzt noch nicht Aufgefallen war. ;-)
- PLTConfig::GetVarInt() berÃ¼cksichtigt nun die FÃ¤lle wenn die Variable vom Typ Flag oder Enum ist
- PLTResourceManager<AType>: Add() & Remove() waren noch nicht ganz ok. Der Resource wird nun mitgeteilt das dies nun in 
  dem Manager ist und bei Remove() das diese nun in keinem Manager mehr ist. Den Bug merkte ich erst als ich eine Resource
  nachtrÃ¤glich einem Manager zuwies in es einen Crash gab als der Manager wieder gelÃ¶scht wurde... ohmanohman, wie konnte 
  ich das nur Ã¼bersehen. ;-)



>> 09.05.2005
[CO]
- In VC 7.1 spuckte der Compiler bei PLGeneral leider diverse Fehler aus. Diese liesen sich aber zum GlÃ¼ck recht leicht
  beheben:
- PLTSingleton
  template <class AType> PLTSingleton<AType>::__Destruction_Guard PLTSingleton<AType>::__Guard;
  Hier muss typename EingefÃ¼gt werden:
  template <class AType> typename PLTSingleton<AType>::__Destruction_Guard PLTSingleton<AType>::__Guard;
- PLRTTIDefs.h
  template <class T> typename PLTModuleID<T>::SelfInit__Class PLTModuleID<T>::__SelfInit;
  Hier muss ebenfalls typename EingefÃ¼gt werden:
  template <class T> typename PLTModuleID<T>::SelfInit__Class PLTModuleID<T>::__SelfInit;
- PLTParameters::AddParam(const char *pszName, const PLTVariant &cParam) -> cParam ist nun const -> Machte sonst Probleme
  unter VC 7.1. und noch krassere Probleme auf dem Linux Compiler :)
- Musste in PLGeneralWin32.h auf einmal das Makro 'min' selbst definieren da es ansonnsten nicht gefunden werden konnte
Beseitigte probleme welche bei Stephans Linux Compiler auftraten:
- PLTSystem: Friend Definitionen:
 'friend class PLTModuleID<int>;
' zu 'template<class T> friend class PLTModuleID;
' gemacht
- PLRTTIDefs.h: Ca Zeile 150: 'template PLTModuleID<int>;' wurde entfernt da es Compiler Probleme verursachte.
  (die Zeile wird anscheinend auch nicht benÃ¶tigt :)
  Desweiteren musste hier 'PLSystem.h' eingebunden werden und in PLBase.h wurde 'PLSystem.h' entfernt.
  (sollte keinen Unterschied machen - tut es aber ;-)



>> 07.05.2005
[CO]
- PLTBase::SetVars() minimal geÃ¤ndert so das auch 'PLTTextureCreatorASCII3D Name=ASCII3D' verstanden wird. In dem Fall wird
  wie Ã¼blich eine Fehlermeldung ausgegeben das bei 'PLTTextureCreatorASCII3D' ein '=' + Wert fehlt, der Rest wird nun aber 
  trotzdem weiterverarbeitet.
- PLTFileSystem::OpenInPaths() -> Hier wird nun zuerst in den Suchpfaden fÃ¼r den Typen (falls angegeben) gesucht, erst 
  wenn das nicht klappt wird versucht direkt zu Ã¶ffnen. (ansonnsten hatte pszType keine Auswirkung)



>> 27.04.2005
[CO]
PLTConfig:
- Implementiere die Funktionen Load() und Save(). Load() ist kein grÃ¶Ãeres Problem, Save() hingegen bietet die MÃ¶glichkeit
  entweder ALLE aktuellen Konfigurationen zu speichern oder nur diejenigen welche in einer bestimmten Konfigurations-Gruppe 
  sind. PLTConfig::GetInstance()->Save("All.cfg"); speichert allso ALLES in eine Datei namens 'All.cfg', wÃ¤hrend
  PLTConfig::GetInstance()->Save("Engine.cfg", "PLTEngineConfigGroup"); NUR diejenigen Konfigurations Klassen in eine Datei
  speichert welche von PLTEngineConfigGroup abgeleitet wurden. PLTEngineConfigGroup hingegen wurde von PLTConfigGroup 
  abgeleitet. Auf die Art ist das Config-System nun sehr flexibel und man kann beliebig neue Gruppen von Gruppen von Gruppen
  etc. Erzeugen. Die Engine selbst lÃ¤d/speichert also NUR 'PLTEngineConfigGroup'. :)
  Passte gleich PLRenderer (jedes Backend lÃ¤d/speichert sich selbst), PLEngine und PixelLab + Plugins an. (nur minimalste 
  Erweiterungen :) Bei der Gelegenheit vergab ich dort auch gleich entsprechende Variable Namen.
- PLTFileSystem::AddBaseDir() -> Baute Abfrage ein ob dieser Basis-Pfad bereits Regestriert ist.



>> 23.04.2005
[CO]
Alle Projekte:
- Stellte bei ALLEN Projekten die Release Einstellungen etwas Resourcen schonender ein. Im Netz gibts nen kleinen 
  Artikel Namens 'Compiler Optimization Of MechAssault 2' wo diese Einstell 'Tips/Tricks' beschrieben wurden.
  - Exception handling /EHsc) wird Deaktiviert - wir verwenden dad sowieso nicht
  - Whole program optimization (WPO) Aktiviert



>> 10.04.2005
[CO]
- PLSingleton.inl: Hm, irgendwie will das mit PLTLog dort nicht funktionieren. Sobald das Log hier verwendet wird beendet 
  sich jedes Programm welches PLGeneralD.dll mal kurz prÃ¼ft sofort ohne weitere Warnungen!??



>> 09.04.2005
[CO]
- Stellte PLGeneral auf neuen Kommentar Style um. PLSingleton.inl: Dort wo '[TODO] Add to log' stand stellte ich auf PLTLog
  um. PLTZipDate -> Packte die Inline Funktionen in PLZipDate.inl.



>> 20.03.2005
[SB]
- PLTZipStream::Read():
  Auch hier muÃ nun nSize und nCount angegeben werden, um Daten aus dem Stream auszulesen.
  Zwar wird intern wieder multipliziert und Byteweise gelesen, jedoch ist dies zur KompatibilitÃ¤t
  mit anderen Funktionen nÃ¶tig: Will eine Funktion einen Block von 18 Byte lesen, so ist der
  korrekte RÃ¼ckgabewert nach dem Lesen '1', und nicht '18', die Anzahl der gelesenen Bytes muÃ
  also noch einmal durch die BlockgrÃ¶Ãe geteilt werden. Genau dies fÃ¼hrte zum Fehler beim
  Lesen von "standardflare.tga", da der falsche RÃ¼ckgabewert '18' gefunden wurde, brach DevIL
  das Lesen der Datei ab


  
>> 20.03.2005
[CO]
- PLTZipFile::Seek() -> Wird der Offset auf 0 gesetzt, so wird nur zurÃ¼ckgesetzt, aber nicht 0 Bytes gelesen.
  (kÃ¶nnte probleme machen)



>> 02.02.2005
[CO]
- PLTVar::Set() -> FÃ¼gte optionalen Parameter hinzu mit dem man den Aufruf von VarChanged() unterdrÃ¼cken kann. Z.B. ist
  der Aufruf von VarChanged() in PLTBase::IsVarDefault() total ungÃ¼nstig da im schlimmsten Fall hierdurch etwas kaputt gehen
  kann - das hatte ich beim Klonen im WE. Danach waren die Orginal Entities plÃ¶tzlich in keiner Gruppe mehr da der Gruppen
  String leer war. Diese Gruppen wurden Dynamisch hinzugefÃ¼gt - dumme Sache das, derzeit hab ich noch keine Ahnung was man
  da machen kann auÃer auch die Dynamischen Gruppen einfach zu diesem String hinzuzufÃ¼gen.
  Zudem ist das hier in PLTBase::IsVarDefault() nen totaler Overhead. Mir gefÃ¤llt das zwar irgendwie nicht mit diesem Extra
  Parameter da priniziell IMMER Informiert werden sollte, aber bis uns fÃ¼r PLTBase::IsVarDefault() was besseres einfÃ¤llt ist
  das denk ich ok. Hauptsache es geht hier (vorallem im WE :) erstmal ohne oben Beschriebene Probleme beim einfachen
  Vergleichen zu erzeugen. Hatte mit VarChanged() auch bei PLTEntity Probleme wenn nen Entity noch nicht Initialiert war,
  aber bereits seine Variablen z.B. beim Initialisieren gesetzt wurden. Das umging ich dort Ã¼ber IsInitialized() Tests. 



>> 25.02.2005
[CO]
- PLTBase::GetVars() -> Intern auf PLTString umgestellt da ansonnsten der String aus PLTString wieder zerstÃ¶rt wurde und am 
  ende Schrott in pszBuffer Kopiert wurde.



>> 23.02.2005
[CO]
- PLTString um ein paar Sicherheits abfragen erweitert



>> 22.02.2005
[SB]
- Neue Klassen:
  - PLTVariant: Dies ist ein Variabler Datentyp, welcher verwendet werden kann wenn der Datentyp einer
    Variablen nicht feststeht. Dies wird bei dynamischen Parametern verwendet, auch kÃ¶nnte die Scriptsprache
    spÃ¤ter gebraucht davon machen. Ansonsten sollte es aber eigentlich kaum Verwendung dafÃ¼r geben :-)
  - PLTParameters: Dynamische Parameterliste, die bei Methodenaufrufen Ã¼bergeben werden kann. Im Moment ist
    dies nur fÃ¼r den Konstruktor da, wenn das RTTI eine Klasse mit Parametern kreieren will. Sollte das
    RTTI spÃ¤ter noch um dynamische Methodenaufrufe erweitert werden, wird diese Klasse auch dort Verwendung
    finden
- RTTI-Makros angepaÃt:
  - DEFINE_CLASS erstellt keine Ã¶ffentlichen Konstruktoren mehr, arbeitet also so wie vorher DEFINE_CLASS_PRIVATE
  - Zum Erstellen Ã¼ber CreateInstance() muÃ nun zusÃ¤tzlich das Makros DEFINE_CONSTRUCTION_PUBLIC hinzugefÃ¼gt werden
  - ZusÃ¤tzlich kann ein Konstruktor definiert werden, dem Parameter Ã¼bergeben werden kÃ¶nnen, dies geschieht mit
    DEFINE_CONSTRUCTION_PARAMS, der Konstruktor muÃ die form Class(PLTParams&) haben
  - Vor den Variablen muÃ die Liste mit DEFINE_VAR_LIST begonnen werden
  - Durch diese Ãnderungen war es nun mÃ¶glich, das Registrieren der Variablen wieder einfacher zu gestalten,
    es mÃ¼ssen also keine Variablen mehr rÃ¼ckwÃ¤rts und von vorne eingetragen werden. REDEFINE_VAR wurde
    ebenfalls entfernt, statt dessen werden bei DEFINE_VAR schon vorhandene Variablen mit dem gleichen
    Namen einfach Ã¼berschrieben
  - Neue PL_VAR-Variablentypen hinzugefÃ¼gt
  - Bei DEFINE_VAR muÃ nun immer auch der Enum-String als letzter Parameter angegeben werden, dafÃ¼r wurde
    DEFINE_ENUM entfernt
  - Bei DEFINE_VAR kann hinter der Variablen nun noch ein Variablen-Name angegeben werden. Ist dieser "",
    wird wie bisher der richtige Name der Variablen verwendet
- PLTBase: IsVarDefault() hinzugefÃ¼gt
- Klassen an neue RTTI-Definitionen angepaÃt



>> 11.02.2005
[CO]
- RTTI: REDEFINE_VAR() funktioniert durch die letzte Ãnderung nicht mehr da die Basis-Variablen nun erst bei Init()
        eingetragen werden. Zuerst wollte ich ne PLTClass Interne Liste anlegen wo die dann bei Init() zu 'Ã¼berschreibenden'
        Variablen eingetragen werden... Aber ich merkte schnell das dies etwas viel Aufwand ist - und wenn wir das so machen
        wollen wÃ¤re es das beste wenn Stefan, der sich ja deutlich besser mit dem RTTI auskennt das Ã¼bernimmt. Ich entschloss
        mich stattdessen erstmal in den MeshLoadern DEFINE_VAR() zu verwenden. Und will die Basis-Klasse dann ihre gleiche
        Variable eintragen geht das schief da diese Variable bereits vorhanden ist. War die einfachste LÃ¶sung - nur Typ
        Sicherheit hat man damit nun natÃ¼rlich nicht... da kÃ¶nnte man ne Warnung ins Log schreiben wenn wir das so lassen
        wollen...
        Macht REDEFINE_VAR() Ã¼berhaupt noch Sinn? Denn dann mÃ¼sste man auch DEFINE_ENUM() etc. Varianten anbieten.
- PLTLog::Open() -> Erzeugt nun ein neues Log wenn kein solches vorhanden ist.



>> 10.02.2005
[CO]
- PLTArray::AddAtIndex() und PLTList::AddAtIndex() waren noch nicht ganz ok. Wenn man ganz am ende ein neues Element einfÃ¼gen
  wollte ging das noch nicht wie erwartet. Dadurch funktionierte bei mir dann das Regestrieren der Klassen-Variablen nicht
  richtig.



>> 09.02.2005
[SB]
- PLTConfig: Die Methoden GetVarb() etc. umbenannt in GetVarBool(), GetVarInt(), etc. Wie haben bisher immer aussagekrÃ¤ftige Namen
  verwendet, daher sollten wir dies auch hier tun. Es wÃ¤re zu Ã¼berlegen, ob Methoden dieser Art nicht gleich in PLTBase
  eingebaut werden sollten, um es dem Programmierer zu erleichten, auf Variablen zuzugreifen (ist natÃ¼rlich dann
  schlecht, wenn der Programmierer den falschen Typ verwendet).
- PLTConfig: Habe AddClass() wieder entfernt und durch eine simple "Create-On-Demand" LÃ¶sung ersetzt, da mir kein Grund einfiel,
  der dagegen sprach :-) Wenn jemand versucht, auf eine Konfiguration eines bestimmten Typs zuzugreifen, wird erst
  einmal geschaut, ob es diese schon gibt. Wenn nicht, wird das Objekt in dem Moment erzeugt und zurÃ¼ckgegeben.
  Sollte wÃ¤hrend das Programm lÃ¤uft niemand versuchen, auf eine Config-Klasse zuzugreifen, wird diese auch niemals
  erzeugt, was ich auch fÃ¼r genau richtig halte, warum sollte man erst einmal alle mÃ¶glichen Objekte erzeugen,
  wenn diese dann gar nicht gebraucht werden? Wir mÃ¼ssen da nur evtl. beim Speichern darauf achten, aber es stellt
  sich mir sowieso die Frage, ob das Speichern der gesamten Konfiguration sinnvoll ist, da ja z.B. Game-Config und
  Engine-Config nicht zusammen in eine Datei kommen sollten.
- PLTSystem: Eintragen der Config-Klassen wieder ausgebaut (s.o.). LÃ¶sungen dieser Art sollten grundsÃ¤tzlich vermieden werden,
  da sie die Hierarchie eines Systems durcheinander bringen. PLTSystem steht ganz oben in der Hierarchie, d.h. alle
  anderen Teile der Engine verwenden PLTSystem, aber PLTSystem weiÃ nichts von diesen anderen Teilen. Wenn wir nun
  anfangen, das zu Ã¤ndern (PLTSystem weiÃ plÃ¶tzlich von PLTConfig und trÃ¤gt dort Klassen ein), wird das ganz schnell
  unÃ¼berschaubar, da in beide Richtungen aufeinander zugegriffen wird - wozu das fÃ¼hren kann, sah man sehr deutlich
  beim alten FS, wo GetValidFileName() zu abwechselnden Aufrufen im Manager und im FS fÃ¼hrte, dadurch konnte Ã¼berhaupt
  nicht nachvollzogen werden, was wo getan wird und welches System wofÃ¼r verantwortlich ist. Das gleich kÃ¶nnte leicht
  bei PLTConfig und PLTSystem passieren, wenn nun PLTConfig im Gegenzug anfÃ¤ngt, neue Klassen einzutragen, und schon
  pendeln die Aufrufe wieder hin und her. Darum also: Aufrufe immer nur in eine Richtung, so daÃ die Hierarchie erhalten
  bleibt, niemals wieder zurÃ¼ck vom oberen Teil der Hierarchie in untergeordnete Teile.
- PLTSystem: Beim Eintragen der Klassen wird nun geschaut, ob die Basisklasse bereits registriert wurde, ist dies nicht der Fall
  wird so lange gewartet, bis die Basisklasse da ist und erst dann die Registrierung der Variablen aus dieser
  Basisklasse vorgenommen. Damit die Variablen in der richtigen Reihenfolge bleiben, muÃte ich bei den Schleifen und beim
  Eintragen der Variablen etwas tricksen, schÃ¶nere LÃ¶sungen wÃ¤ren hier sehr willkommen. Bitte mal schauen ob die Probleme
  damit gelÃ¶st sind, in meinen Tests hat's jedenfalls funktioniert :-)
- PLTSystem: Mir ist aufgefallen, daÃ immer wieder PLGENERAL_API zu allen Funktionen hinzugefÃ¼gt wird. Dies ist ok, wenn es wirklich
  benÃ¶tigt wird, also die Funktion soll von auÃen verwendet werden und es gibt unaufgelÃ¶ste externe Symbole aufgrund des
  fehlenden Exports. Ist dies aber nicht der Fall, bitte nicht einfach so hinzufÃ¼gen, denn die Entscheidung, welche
  Methoden exportiert werden sollen und welche nicht, ist an den meisten Stellen schon mit Bedacht gewÃ¤hlt worden!
  Dies ist z.B. eine gute MÃ¶glichkeit, um noch etwas mehr Sicherheit zu gewÃ¤hrleisten, indem Methoden, die nur intern
  verwendet werden sollen, auch nur intern aufgerufen werden kÃ¶nnen (im System ist dies z.B. bei kritischen Methoden
  wie dem HinzufÃ¼gen von Modulen der Fall). Dies kann dann auch nicht durchs VerÃ¤ndern eines Headers (protected in
  public Ã¤ndern) umgangen werden, und ist daher fÃ¼r solche kritischen Methoden nÃ¼tzlich.
  Also bitte immer Ã¼berlegen, ob das Exportieren einer Methode wirklich gewÃ¼nscht ist, und nicht einfach alle Methoden
  exportieren.



>> 08.02.2005
[CO]
- PLTResourceHandler: Machte SetResource() virtuell da es man z.B. in PLTSkeletonHandler sobald eine Resource gesetzt wurde
  diverse Aufgaben erledigen muss.




>> 05.02.2005
[CO]
- PLTConfig: Neue Funktion: AddClass() -> Da jederzeit neue Module mit eventuell neuen Konfigurations-Klassen darin
  eingeladen werden kÃ¶nnen war es nÃ¶tig eine Funktion anzubieten um neue Config-Klassen zu regestrieren.
  In PLTSystem::RegisterClass() wird nun versucht die neue Klasse in PLTConfig einzutragen - mir viel da 
  keine bessere MÃ¶glichkeit ein... vielleicht wÃ¤re da ne art von System-Listener angebracht, falls man noch
  an anderen Stellen mitbekommen mÃ¶chte wenn z.B. neue Klassen regestriert/entladen werden.
- PLTFile: Die Read&Write Funktion wurde so erweitert das man auch Count angeben kann -
  das war leider nÃ¶tig da DevIL nicht korrekt laden konnte wenn man nSize*nCount direkt berechnete und als zu
  lesende Bytes Ã¼bergab - da gibts anscheinend intern irgendwo doch nen Unterschied. 
  Auch bei ZLib ists nen Unterschied wenn man die Parameter size und count bei fread vertauscht.
  Stefan, wenn du weiÃt wieso dad so iss klÃ¤re mich bitte auf - ich kanns mir momentan noch nicht ErklÃ¤ren. ;-)



>> 04.02.2005
[CO]
- PLTResourceManager: In Create() wird nun die interne Funktion CreateResource() verwendet welche man in einem konkreten
  Manager Ã¼berschreiben MUSS. Da das mit der automatischen Erzeugung im Template nicht klappt falls
  der Resource-Typ abstrakt ist, wie dies beim Sound-Manager der Fall ist, musste das geÃ¤ndert werden.



>> 02.02.2005
[CO]
- Ein paar kleinigkeiten an den Resource-Templates geÃ¤ndert



>> 01.02.2005
[CO]
- Neue Funktion: PLTFSTools::GetRelativePath() -> Macht aus einem Absoluten Pfad wenn mÃ¶glich einen Relativen 
- PLTWin32FSTools::ConvertToWindowsPath() & PLTFSTools::ValidatePath() -> Kleine Laufwerksbuchstaben werden zu
  GroÃbuchstaben gemacht da es sonst Probleme geben kann. (ich hatte da eines in AddBaseDir() :)



>> 01.02.2005
[SB]
- PLFSTools, PLPlatform: Nannte FileNameEnding in FileExtension um.
  Dieser Begriff sollte wohl allgemein bekannt sein, und wir sollten es dem User nicht unnÃ¶tig schwer machen :-)
- PLSearchHandle: Nahm die Ãnderung, daÃ '.' und '..' grundsÃ¤tzlich aufgelistet werden, wieder heraus (und wenn ich
  es richtig sah, wurden inzwischen sogar alle Verzeichnisse aufgelistet). Dies mag an einigen Stellen nÃ¼tzlich sein,
  doch es gibt genÃ¼gend Situationen, in denen das ausdrÃ¼cklich nicht gewÃ¼nscht ist, doch die kÃ¶nnen dann nichts
  mehr daran Ã¤ndern (z.B. versucht unser PluginSystem "." und ".." als DLL zu laden, was sicher nicht gut ist).
  Wenn also alle Verzeichnisse sowie bestimmte Dateien gefunden werden sollen, sollte dies ist zwei
  Schritten erfolgen, worin ich kein Problem sehe (der FileDialog macht dieses ja auch genau so), denn diese LÃ¶sung
  behindert im Gegensatz zur anderen nicht die entsprechend andere Situation.



>> 31.01.2005
[CO]
- Machte PLTProfiling zum Singleton und passte Engine etc. an.



>> 29.01.2005
[CO]
- Nahm die Module-Templates aus der Engine, benannte diese in ResourceManager etc. um, Ã¼berarbeitete diese etwas - diese
  Resource-Templates liegen im Base-Unterordner da es universelle Grundklassen sind die man Ã¼berall gut brauchen kann.
  Dabei implementierte ich es so das man auch Resourcen & Resource Handler OHNE Resource Manager verwenden kann. Ist jedoch
  ein solcher Resource Manager vorhanden so MUSS jede Resource einen einmaligen Namen bestitzen - und das wird intern 
  auch sichergestellt. :)
  Somit kÃ¶nnen diese Resource & Resource Handler Templates auch in PLRenderer, PLSound etc. verwendet werden, denn dort gibt
  es auch Resourcen, allerdings ohne konkreten Manager dahinter da dies dort unnÃ¶tig ist - das wÃ¼rde sonst dort zuviel des
  guten sein.
- Die konkreten Template Implementationen von PLTStack, PLTHashTable, PLTHeapBinary, PLTSingleton liegen nun in seperaten
  'inl'-Dateien. Ich finde es einfach Ã¼bersichtlicher wenn im Header NUR das Interface liegt. :)


>> 26.01.2005
[CO]
- PLTConfig: Funktionen wie GetVarb() hinzugefÃ¼gt mit dem man komfortabel gleich den Boolean Wert abfragen kann etc.
- PLTFileType::AddSearchPath(): Pfad wird nun intern bei Bedarf 'korrigiert'



>> 21.01.2005
[CO]
- PLTPlatform: GetTickFrequency() entfernt und PLTTimer entsprechend angepasst. Dies war nÃ¶tig da es erstens so nicht
  unter Linux ging (dort hab es schwere Probleme mit dem richtigen Timing...) und zweitens war das mit der extra Frequenz
  sowieso nicht so brall. ;-) Da der Name 'TickCount' nicht wirklich aussagekrÃ¤ftig war, benannte ich ihn in
  GetMilliseconds() und GetMicroseconds() um, damit weiÃ man auch sofort in welcher Einheit man die vergangene Zeit
  zurÃ¼ckbekommt. Ein paar Dateien mussten in diversen Teilprojekten angepasst werden, aber nun mÃ¼sste das etwas Sauberer
  sein.



>> 17.01.2005
[CO]
- Kleinen Fehler in PLTFile::Seek() behoben - das viel mir erst auf als bei FMod das Streaming aus PLTFile einfach
  nicht funktionieren wollte - nun gehts. ;-)



>> 10.01.2005
[CO]
- PLTPlatform: Neue Funktion: GetModuleFileNameEnding() -> Gibt die Dateiendung von Modulen, also unter Windows 
  'dll' und unter Linux 'so' zurÃ¼ck. PLTSystem::ScanPlugins() verwendet nun diese Funktion. Das IMMER Ã¼ber #ifdef
   zu machen wÃ¤re keine so dolle LÃ¶sung gewesen. :)
- PLRTTIDefs.h: Foreward declaration von PLTSystem eingefÃ¼gt da es ansonnsten unter Linux einen Compiler
  fehler gibt.
- PLGeneralWin32.h/PLGeneralLinux.h: Dort wird nun PLEXPORT/PLIMPORT definiert da man dies ja seehr oft benÃ¶tigt.
  PLRTTIDefs.h -> DEFINE_MODULE_PLUGIN verwendet nun PLEXPORT. (ging ja sonst so nicht unter Linux :)
-> Das waren noch die paar Dinge wie Port-mÃ¤Ãig gemacht werden mussten. Damit es unter Linux problemlos Ã¼bersetzen geht.
- PLStack.h: Nahm PLGeneral.h include raus da ich dann z.B. beim Max Exporter nun durch die weiter intern
  eingebundenen Dinge dazu gezwungen bin PLGeneral dort miteinzubinden was ich aber nicht will. :)
- PLTPlatformWin32::LoadModule() -> Der Dateiname wird nun zuerst in einen Win32-Pfad umgewandelt bevor die Lib
  geladen wird.



>> 10.01.2005
[SB]
- Die Ãnderung vom 29.12. geht leider so nicht, weil sie dazu fÃ¼hrt, daÃ der DestructionManager
  nicht mehr korrekt gelÃ¶scht wird und somit ein Speicherleck entsteht:
  DestructionGuard wird beim beenden deinitialisiert und lÃ¶scht den DestructionManager
  -> dieser lÃ¶scht alle Singletons
  -> Singleton ruft PLTDestructionManager::GetInstance()->RemoveObject(this) auf
  -> Dadurch wird der DestructionManager neu erzeugt und nie wieder gelÃ¶scht.
  Dies habe ich nur deswegen so ausfÃ¼hrlich aufgeschrieben um klarzumachen, daÃ kleine und vÃ¶llig
  harmlos aussehende Ãnderungen beim RTTI sehr bÃ¶sartig sein kÃ¶nnen, da das RTTI leider auf vielen
  Tricks basiert, aber genau dies ermÃ¶glicht erst, daÃ es so gut und einfach zu bedienen ist :-)
- Habe nun DestructionManager und DestructionObj gelÃ¶scht, statt dessen hat jede Singleton-Klasse
  ab jetzt einen eigenen DestructionGuard, welcher das Singleton beim Beenden wieder lÃ¶scht
  (damit ist die AbhÃ¤ngigkeit der Singletons von einem weiteren Singleton nicht mehr gegegeben).
- Die Klassen eines Moduls melden sich beim Beenden nicht mehr vom System ab, weil dies ein
  Ã¤hnliches Problem wie oben ergab: Die Reihenfolge der Deinitialisierung statischer Variablen
  wird vom Compiler vorgegeben und kann nicht beeinfluÃt werden, es passiert also, daÃ zuerst
  das PLTSystem-Singleton gelÃ¶scht wird und dann die Klassen eines Modules deinitialisiert werden,
  wenn diese dann PLTSystem::GetInstance()->Remove() aufrufen, wird PLTSystem neu erstellt und
  wir haben wieder ein Speicherleck.
  Um die AbhÃ¤ngigkeiten mÃ¶glichst gerin zu halten, melden sich also die Klassen nicht mehr ab,
  sondern nur noch das Modul, wodurch automatisch alle Klassen entfernt werden. Um das Problem
  hier zu beheben, gibt es in PLTSingleton nun noch eine Methode CheckInstance(), welche nur die
  Instanz zurÃ¼ckgibt aber keine erstellt. Im oben genannten Fall meldet sich ein Modul also
  nicht mehr ab, wenn das System bereits deinitialisiert worden ist, denn in diesem Fall
  wurden ja sowieso schon alle Klassen beim Beenden gelÃ¶scht.



>> 09.01.2005
[CO]
- PLTPool: GetElements() in GetNumOfElements() umbenannt, PLTProfiling musste entsprechend angepasst werden.
- PLTArray & PLTBitset & PLTList: Compare() so umgeschrieben das der Operator != nun nicht mehr zwangslÃ¤ufig vorhanden
  sein muss



>> 03.01.2005
[CO]
- PLTSearchFilter::CheckMatch() -> '.' und '..' kommen nun immer durch den Test, ansonnsten gibts probleme beim Auflisten
  des Inhaltes eines Verzeichnisses.
- PLTFSTools::GetFileNameEnding() -> BerÃ¼cksichtigt nun auch nicht vorhandene Dateinamen Endungen
- PLTFSTools::ValidatePath() -> FÃ¼gt nun am Ende des Pfades noch ein / an falls dort keines ist damit Pfade immer mit /
  Enden.



>> 29.12.2004
[SW] + [CO]
- Die Linux Tests Crashten immer nachdem das Programm bendet wurden - nach Stundenlanger Such und dem durchgehen aller
  mÃ¶glichkeiten waren wir schon nahe am Verzweifeln da man sich den Crash einfach nicht erklÃ¤ren konnte. Tja, und irgendwie
  landeten wir dann eher per Zufall im Destruktor von PLTDestructionManager und dort Crashte es beim LÃ¶schen eines Objektes.
  Es stellte sich raus das Zeiger ungÃ¼ltig waren - ein Blick auf den Destruktor von PLTDestructionObj zeigte das sich Objekte
  nicht wieder bei Tot abmeldeten sondern sich einfach ins Nirvana schlichen. ;-)
  Kleines Problem, merkwÃ¼rdige PhÃ¤nomene - viele Stunden suchen. ;-)
- PLGeneral und PLMathLib auf Linux portiert:
  -> Nun laufen PLBaseTest, PLFileTest und PLMathTest auch problemlos und sauber unter Linux - wir haben Teils auch alles Ã¼ber
     Eclipse Debugt etc. Jetzt da diese Dinge auf zwei Platformen laufen kann man annehmen das es so nun schon recht ordentlich
     ist.  :):)



>> 27.12.2004
[CO]
- Passte PLTTimer an die aktuellen Ãnderungen an. Die Timer Klasse verwendet nun PLTPlatform und ist dadurch Platform unabhÃ¤ngig
  und die ganzen Timer Platform-Dinge konnten entfernt werden - erleichtert das Portieren. :)
- Erweiterte PLTPlatform um GetTickFrequency() - wird fÃ¼r PLTTimer benÃ¶tigt
- Dort wo in PLGeneral noch PLTDynamicList verwendet wurde stellte ich auch PLTArray um. Hab nun die alten Listen Klassen +
  PLTDataSet was wir ja mittlerweile nicht mehr brauchen gelÃ¶scht. Desweiteren alte Stack-Klasse herausgenommen.
  -> Endlich wieder Ordnung in PLGeneral - da Stephan und ich uns die nÃ¤chsten Tage intensiv mit der Linux Portierung beschÃ¤ftigen,
     wollte ich dieses alte Zeug drauÃen haben so das wir nicht mit unnÃ¶tig vielen Dateien jonglieren mÃ¼ssen.



>> 26.12.2004
[CO]
- PLTArray: Musste internes Speicher Management etwas umstellen da es Probleme mit Klassen welche Klassen etc. beinhalten gab
  ... diese wurden dann nicht korrekt Initialisiert wenn alle Element in einem groÃen Buffer lagen. Nun hat PLTArray einen Buffer
  aus Zeigern auf die Elemente welche Ã¼ber new erzeugt und Ã¼ber delete wieder gelÃ¶scht werden... hat den kleinen Vorteil das nun
  auch die Konstruktoren & Destruktoren verwendung finden. :)
  -> Mittlerweile ist auch das merkwÃ¼rdige Static Initialization Problem in der Engine verschwunden und alles lÃ¤uft wieder
     einigermaÃen - so langsam mÃ¼ssten die Container Klassen aber so passen. :):)



>> 25.12.2004
[CO]
- PLTFileSystem: Um GetNumOfFileTypes() & GetFileType() & RemoveFileType() erweitert damit ich in 
                 GuiFileSystemDialog die Search Path Ansicht fÃ¼llen konnte
- In PLTFileSystem::AddSearchPath() wurde der File Type Name nicht korrekt gesetzt
-> Diese Ãnderungen wurden nur gemacht um GuiFileSystemDialog implementieren zu kÃ¶nnen - es zeigte sich ja schon bei
   GuiSystemView das es ganz Praktisch ist diese Dinge Ã¼ber einen Dialog 'anfassbar' zu machen... zudem wird dieser Dialog
   auch in PixelLab verwendung finden damit man Einstellen kann von wo die Daten kommen sollen.
- PLTBitset & PLTArray: Resize() kann nun optional mitgeteilt werden das ALLE SpeicherplÃ¤tze fÃ¼r Elemente automatisch
  zugreifbar sind... ist dann so als hÃ¤tte man alle Elemente einzelnd hinzugefÃ¼gt. Dies ist immer wieder nÃ¼tzlich wenn man
  einfach ein Feld haben will bei dem man frei auf die Elemente zugreifen kann ohne vorher alle Ã¼ber Add hinzugefÃ¼gt zu haben
  wie dies bei 'normalen Listen' der Fall ist.
  Wenn man Resize() per Hand aufruft sind immer standardmÃ¤Ãig ALLE Elemente gleich verfÃ¼gbar, so, als hÃ¤tte man alle Ã¼ber Add()
  hinzugefÃ¼gt - denn wenn man schon selbst Resize() aufruft erwartet man normalerweise das alles gleich zugreifbar ist, xxx
  mal beim Array Add() aufzurufen wÃ¤re schlichtweg zu umstÃ¤ndlich. :)



>> 24.12.2004
[CO]
- PLContainer: AddAtIndex(int nIndex) hinzugefÃ¼gt um ein neues Element an einer bestimmten Stelle zu erzeugen
- In PLTConfig() korrekten Config Klassen Name gesetzt



>> 22.12.2004
[CO]
- PLTFSTools: Neue Funktionen: - GetFileNameEnding() -> Liefert die Datei-Endung zurÃ¼ck
                               - CutFileNameEnding() -> Liefert Dateinamen ohne Endung
                               - GetDirectory() -> Liefert das Verzeichniss eines Dateinamens zurÃ¼ck
- PLContainer Klassen minimal erweitert



>> 21.12.2004
[SB]
- PLTBase.h: Die virtuelle Funktionen stehen nun in einem eigenen Bereich, wie wir es sonst auch meistens haben. Ich finde
  das zwar an dieser Stelle etwas unschÃ¶n, da z.B. die beiden ToString() Methoden damit auseinandergerissen werden, es
  dient jedoch der Ãbersicht des Programmierers. Die Dokumentation der Methoden habe ich auch noch etwas erweitert.
- PLGeneral: Die Definition von systemabhÃ¤ngigen Klassen wird nun einheitlich in den Include-Dateien fÃ¼r das jeweilige
  System vorgenommen. Dies fÃ¼hrt zwar dazu, daÃ einige Header immer eingebunden sind, scheint mir jedoch besser zu sein,
  da dann alle Plattformdefinitionen an einem Ort sind und somit schnell wiedergefunden werden kÃ¶nnen.
- FileSystem: PLNativeDirectory.h gelÃ¶scht und die Definition entsprechend nach PLGeneralWin32/Linux.h verschoben
- PLTTimer: Anpassung an unseren Ã¼blichen Stil, die Basisklasse ist nun abstrakt, da es kaum sinnvoll ist, diese direkt
  zu instanziieren (es gibt ja auf jeder Plattform eine systemspezifische Implementierung). Die Konstrukturen/Destruktoren
  sind nun protected (nicht unbeding nÃ¶tig, aber einheitlich), und auch die Basisklasse besitzt Konstruktur/Destruktor
  wobei der letztere virtuell ist, da die Klasse virtuelle Methoden besitzt. Auch hier wurde die Definition von PLTTimer
  verschoben
- PLTPlatform: Neue Klasse, welche plattformabhÃ¤ngige Systemfunktionen enthÃ¤lt. Der Einfachheit halber, und weil man es
  vom Namen her sowieso so erwarten kÃ¶nnte, habe ich PLTSystem einfach von dieser Klasse abgeleitet - damit braucht man
  sich nicht mehr Ã¼berlegen, wer wo eine Instanz davon erzeugen kÃ¶nnte sondern bekommt diese bei PLTSystem::GetInstance()
  ja gleich mit (nur fÃ¼r die Doku ist es nicht so schÃ¶n, weil die Systemfunktionen nicht direkt in PLTSystem dokumentiert
  sind, allerdings sollten diese Funktionen sowieso nicht von einer Applikation verwendet werden, da wir ja alles schÃ¶n
  mit unserem eigenen System abgekapselt haben). Auch die Timerfunktionen sind jetzt in PLTPlatform zu finden - fragt
  sich ob das so gut ist, wenn ja mÃ¼Ãten wir eigentlich auf die Unterteilung der Timerklassen verzichten kÃ¶nnen, oder?
- PLTSystem: Zum Zugriff auf dynamische Bibliotheken wird jetzt PLTPlatform verwendet, womit PLTSystem jetzt hoffentlich
  plattformunabhÃ¤ngig ist



>> 21.12.2004
[CO]
- Behob kleines Problem in PLTBase::GetVars() mit dem vergleichen von Default-Werten - denn z.B. bei float-Werten kÃ¶nnen
  u.a. am ende noch diverse Nullen sein - um solche Probleme zu verhindern wird zuerst der aktuelle Wert der Variable gespeichert,
  dann wird der Default Wert gesetzt welcher dann wieder als String ausgelesen wird, anschlieÃend wird der Variable Wert wieder
  auf seinen aktuellen Wert gesetzt - und nun hat man zwei vergleichbare Strings welche bei float Zahlen am Ende gleich viele  
  Nullen haben wodurch korrekt geprÃ¼ft werden kann ob dies wirklich der Default Wert ist.
  -> bei pVar->Set() ist es an dieser Stelle unnÃ¶tig und vielleicht auch etwas Riskant das in Set() pObject->VarChanged(m_szName);
     aufgerufen wird, vielleicht kÃ¶nnte man es hier noch etwas schÃ¶ner machen - hab aber die Finger davon gelassen da es ansonnsten
     zu viele Ãnderungen geworden wÃ¤ren... Stefan, wenn du Zeit und Lust hast kannst du ja mal schaun wie man das besser LÃ¶sen
     kÃ¶nnte. :)
- Bei PLTBase::ToString() -> pszBuffer[nCopy+1] zu pszBuffer[nCopy] gemacht da das letzte Zeichen ansonnsten Schrott war :(
- PLTIterator um Funktionen erweitert um zum vorherigen Element zu springen, dies ist hin und wieder nÃ¶tig wenn z.B. wÃ¤hrend
  der Iterator verwendet wird ein Element aus der Liste gelÃ¶scht wird, in dem Fall muss man den Iterator um ein Element 
  zurÃ¼cksetzen und ganz nebenbei wird nun endlich auch pPreviousElement in PLTList verwendet.
  (Previous() brauchte ich zum ersten mal in GuiSys::Update())
- PLContainer: AddAtIndex() ist Index = -1 wird nun am Ende eingefÃ¼gt (wie frÃ¼her)



>> 19.12.2004
[SB]
- Containerklassen in PLGeneral eingebaut, dabei die alten Klassen umbenannt, damit diese noch verwendet werden kÃ¶nnen
  und schrittweise umgestellt werden kann
- Iteratoren: Remove() entfernt, ein Iterator dient nun nur noch zum Anschauen der Container, nicht zum Ãndern. Dadurch
  ist es auch mÃ¶glich, Iteratoren von const-Listen zu erhalten, dies ging vorher leider gar nicht
- Container: Jeweils einen operator= hinzugefÃ¼gt, welcher die selbe Klasse als Parameter erwartet. Dies scheint leider
  nÃ¶tig, da der Compiler diese Methode anscheinend implizit verwendet und nicht die vorhandene Methode mit PLTContainer
  als Parameter verwendet, wenn beide Operanden vom selben Typ sind (bei z.B. *pList = *pArray geht es dagegen!)
- PLGeneral: Auf neue Containerklassen umgestellt. ZunÃ¤chst ist dies nur eine 1:1 Umstellung, also noch keine Verbesserung
  der Interfaces was Listen/Container angeht, dies wird im nÃ¤chsten Schritt passieren (erstmal sehen, ob alles noch
  funktioniert)
- RTTI: Kleinen Fehler bei der Registration von Modulen behoben. Wenn ein Module zuerst registriert wird, bevor Klassen
  aus diesem Modul registriert worden sind, war die ModuleID noch nicht gesetzt worden, was dazu fÃ¼hrte daÃ die Klassen
  nicht dem Modul zugeordnet werden konnten. Da man auf die Reihenfolge der Initialisierungen keinen EinfluÃ hat (das
  macht der Compiler), kann dies mal so und mal so passieren, es muÃ also in beiden FÃ¤llen funktionieren - und ich hatte
  es auf den worst-case ausgelegt, so daÃ der best-case fehlerhaft war ;-))



>> 19.12.2004
[CO]
- PLTFSTools: Um GetPathInfix() erweitert damit es vollstÃ¤ndig ist. (prefix, infix & postfix :)
  Wollte das zuerst in GuiSys::SaveWindows() verwenden, dort reicht aber schon GetPathPrefix().



>> 18.12.2004
[CO]
- PLTVar::SetFlagsString(): Kleine zusÃ¤tliche Abfrage eingebaut damit bei Flags am anfang kein '|' steht.
- PLTVar: Musste m_szEnum vergrÃ¶Ãern da z.B. bei GuiSlider mehr Zeichen benÃ¶tigt werden (hab lustige fehler am ende :)
- PLTFile::PrintLn() musste Buffer etwas vergrÃ¶Ãern da es oft nicht reichte - vielleicht finden wir da bei Zeiten ne bessere
  LÃ¶sung fÃ¼r die Dynamische Ãbergabe von Strings - f(char *text, ...)



>> 18.12.2004
[SB]
- PLTClass:  Constructor und Destructor sind jetzt protected, da ja nur die Klassen selber eine Instanz von sich erzeugen
             sollen und diese dann selbstÃ¤ndig am System anmelden
- PLTModule: Die Informationen Ã¼ber das Modul wurden in zwei Teile aufgeteilt, einmal dem Info-Teil bestehend aus
             Name/Vendor/Description, und dem Handle-Teil, bestehend aus ModuleID, Instance-Handle und Dateinamen
- PLTSystem: Neue Funktion zum Registrieren von Modulen eingebaut. Ein Modul wird erzeugt, sobald die erste Klasse aus
             diesem Modul registriert wird, dann wird auch die Module-ID zugeordnet, danach kann dann diese Funktion
             verwendet werden, um die Informationen Ã¼ber dieses Modul zu setzen
- PLTSystem: Einige Umstrukturierungen sowie NamensÃ¤nderungen der Funktionen, die Funktionen zum Registrieren sind nun
             protected, womit das ganze wenigstens halbwegs sauber ist ;-)
- RTTI:      Makros zum Registrieren von Modulen so angepaÃt, daÃ diese sich per Selbstinitialisierung nun ebenfalls beim
             System anmelden, um ihre Informationen zu Ã¼bertragen. Dadurch kÃ¶nnen nun sowohl interne als auch plugin-module
             registriert werden, die Makros wurden dafÃ¼r entsprechend angepaÃt und erweitert
- PLGeneral: Hauptdatei PLGeneral.cpp hinzugefÃ¼gt, in welcher das PLGeneral-Modul registriert wird



>> 15.12.2004
[CO]
- Neue Listen-Klassen geschrieben welche die alten ersetzen werden. Es gibt nun eine universelle abstrakte Klasse namens
  PLTContainer. PLTList, PLTArray und PLTBitset werden davon abgeleitet. Desweiteren gibt es eine universelle Iterator
  Klasse fÃ¼r die es jeweils pro Listen-Art eine spezielle Variante gibt. Die Codes hab ich noch nicht in PLGeneral 
  geladen da Stefan die Anpassungen in PLGeneral & PLGui vornehmen wird.



>> 13.12.2004
[CO]
- PLConfig.h: PLTConfigGroup eingefÃ¼hrt, alle Configurations Gruppen sollten davon abgeleitet werden.



>> 13.12.2004
[SB]
- Module:    Es gibt nun fÃ¼r jedes Module eine eindeutige ModuleID, welche von PLGeneral und nicht vom System vergeben wird.
             Ãber diese ID sollten die einzelnen Module angesprochen werden, da dies auf jeder Plattform funktioniert,
             die System-Handles sollten nur noch dann verwendet werden, wenn z.B. ein Modul wieder entladen werden soll,
             was jedoch innerhalb von PLTSystem passiert (es dÃ¼rfte also eigentlich gar keinen Grund geben, das System-Handle
             anstatt der ModuleID zu verwenden).
- Module:    Klasse Ã¼berarbeitet, so daÃ nur PLTSystem die wichtigen Daten der Klassen Ã¤ndern kann sowie Zugriff auf die
             darin enthaltenen Klassen hat. Ebenso einige Ãnderungen bezÃ¼glich der Daten, da bei neuen Module zunÃ¤chst
             nur die ModuleID bekannt ist, wÃ¤hrend die anderen Daten (Dateiname, Name, Vendor) erst spÃ¤ter bekannt
             werden. Btw: Es hat seinen Grund, daÃ der Name nur Module und nicht PLTModule ist :-)
- PLTClass:  Anstatt des Module-Handles besitzt die Klasse nun nur noch die ModuleID ihres Modules
- PLTSystem: Auch hier wurden die Module-Handles durch Module-IDs ausgetauscht. AuÃerdem besitzt diese Klasse nun eine
             Methode, um die eindeutigen IDs zu erzeugen, dies wird von den RTTI-Makros benutzt um fÃ¼r jedes Modul
             eine eigene ID zu erhalten
- RTTI:      Die Makros wurden so geÃ¤ndert, daÃ sie pro Modul eine eindeutige ID erhalten und diese in ihren Klassen
             vermerken. Damit ist das System in der Lage, jede Klasse einem eindeutigen Modul zuzuordnen, auch wenn
             das System-Handle dieses Modules zur Zeit der Registrierung noch nicht bekannt ist (was leider immer
             der Fall ist, deswegen kann nicht einfach die HINSTANCE durchgereicht werden). Um dies zu erreichen,
             speichert eine Template-Klasse die ModuleID, welche sie vom System bekommen hat, und gibt diese an
             die Klassen weiter. SpÃ¤ter setzt das System die zugehÃ¶rigen Daten wie System-Handle, Dateinamen etc.
             im Modul, so daÃ diese Daten angezeigt werden kÃ¶nnen. Anmerkung: Dieses Vorgehen fÃ¼hrt dazu, wirklich
             jedes Modul seine eigene ID bekommt, auch alle nicht dynamisch geladenen, dadurch sind also
             PLGeneral/PLEngine/PLGui/etc. unterschiedliche Module, welche allerdings erstmal alle den Namen
             "Internal" bekommen (wie kann man von loadtime-gelinkten DLLs den Namen herausbekommen?). Ob das ein
             Vor- oder Nachteil ist, kann unterschiedlich sein, wenn jemandem einfÃ¤llt, wie man anders die Module
             und Klassen zuordnen kann, bitte sagen :-)
- PLTClass:  Der Gruppenname wurde entfernt, dafÃ¼r kann jede Klasse als Basisklasse einer Gruppe definiert werden, welche
             dann alle abgeleiteten Klassen enthÃ¤lt
- RTTI:      Das Makro DEFINE_GROUP() angepaÃt
- PLTSystem: Gruppen wurden entfernt, dafÃ¼r kann bei GetClassList() die Basisklasse angegeben werden. ZusÃ¤tzlich kÃ¶nnen
             alle als Gruppen definieren Klassen zurÃ¼ckgegeben werden



>> 12.12.2004
[CO]
- Bei der Klasse Module fehlten noch ein paar PLGENERAL_API - vielleicht sollte man diese Klasse bei Zeiten in 
  PLTModule umbenennen damit es einheitlich ist.
- PLTSystem::UnloadPlugin() -> Nur Dynamische Module kÃ¶nnen entladen werden
- PLTSystem::ScanPlugins() -> verwendet nun LoadPlugin() um die Module einzuladen
- PLTSystem::LoadPlugin() -> Module werden nun korrekt regestriert
- IsClass(), IsClassGroup() und IsModule() - hm, vielleicht wÃ¤re ne art von Iterator Klasse nicht schlecht damit das 
  Ã¼berall einfach Einheitlich ist :)



>> 30.11.2004
[SW]
- PLGeneral: linux port + project archiv upgedated



>> 29.11.2004
[SB]
- PLTBase: Der Destruktor ist nun wieder protected, da dies unbedingt nÃ¶tig ist, wenn das ganze RTTI System Ã¼berhaupt
           einen Sinn machen soll. Das Problem ist, wenn der Destruktor in PLTBase Ã¶ffentlich ist, kann jede Klasse
           damit gelÃ¶scht werden, es besteht fÃ¼r die Klasse also keinerlei MÃ¶glichkeit mehr, dies zu verhindern. Damit
           wird die Verwendung von DEFINE_CLASS_PRIVATE() nutzlos, und alle Sicherheitsvorkehrungen von abgeleiteten
           Klassen kÃ¶nnen damit umgangen werden: z.B. PLTRefCount ist so angelegt, daÃ es sich nur selber lÃ¶schen
           kann, wenn der RefCount auf 0 sinkt, dies stellt sicher daÃ das Objekt niemals gelÃ¶scht werden kann, wenn
           es noch irgendwo gebraucht wird. Wenn nun aber PLTBase einen Ã¶ffentlichen Destruktor hat, wird es
           mÃ¶glich, dieses Verhalten von PLTRefCount zu umgehen und das Objekt von auÃen ungeachtet des RefCounts
           zu lÃ¶schen, was natÃ¼rlich gravierende Fehler zu Folge haben kÃ¶nnte. In PLTBase ist dies nun auÃerdem
           nÃ¤her erleutert, warum Constructor und Destructor von PLTBase protected sind :-)
- RTTI:    Habe das RTTI nun so erweitert, daÃ ein Objekt mit PLTBase::Destroy() gelÃ¶scht werden kann, FALLS dessen
           Klasse mit DEFINE_CLASS() und nicht mit DEFINE_CLASS_PRIVATE() definiert wurde. Auf diese Weise kann
           man ein Objekt nur mit Hilfe eines PLTBase-Pointers lÃ¶schen, aber nur wenn die Klasse dies explizit
           erlaubt, denn dies ist wichtig um die Wahl bei den Klassen zu belassen (s.o.).
           Hierzu waren einige Ãnderungen in PLTBase, PLTClass und PLRTTIDefs notwendig



>> 26.11.2004
[CO]
- PLTBase: Musste Destruktor public machen damit ich Klassen Instanzen von denen ich nur einen Zeiger auf 
  PLTBase habe auch wieder zerstÃ¶ren kann. Ich hoffe das ist ok so - ich fand keine andere mÃ¶glichkeit...
  (siehe PLTConfig::~PLTConfig())
- Neues Configuration-System PLTConfig als Singleton implementiert. Dieses Config-System verwendet das RTTI
  und lÃ¤sst sich daher sehr einfach bedienen und erweitern. Load() & Save() ist noch nicht implementiert,
  ansonnsten funktioniert alles.
          


>> 24.11.2004
[CO]
- Neue Datenstruktur: PLTHeap welche als PrioritÃ¤tswarteschlange verwendet werden kann. Bereits implementierter
  konkreter Heap: PLTHeapBinary. Ich entschloss mich zu dieser abstrakten Template realisierung damit der SchlÃ¼ssel
  und der damit verbundene Wert sowie die konkrete Implementation mÃ¶glichst universell sind.



>> 21.11.2004
[CO]
- PLTQuickSort: QuickSort Algorithmus der spÃ¤ter u.a. zum sortieren der Partikel verwendet wird. Ich hab versucht
  die Klasse so allgemein wie mÃ¶glich zu halten, die Compare Funktion wird Ã¤hnlich wie in Java Ã¼ber eine abgeleitete
  Klasse implementiert. LÃ¤sst sich im Prinzip also genauso verwenden wie das bereits in VC vorhandene qsort - aber
  ich denke es ist das beste wenn man da was eigenes hat, man weis ja nie... ;-)



>> 21.11.2004
[SB]
- PLMain.h: Diese Datei beinhaltet nun einen plattformunabhÃ¤ngigen Einstiegspunkt fÃ¼r die Programme. Die LÃ¶sung per Makro
  war zwar eine gute Idee, jedoch nicht wirklich praktikabel, da ein Zugriff auf Programmparameter und Optionen damit 
  faktisch unmÃ¶glich gemacht worden wÃ¤re, denn diese Parameter wÃ¤ren nach wie vor je nach System unterschiedlich gewesen.
  Auch fand ich die Verwendung dieser Makros nicht sonderlich schÃ¶n, da innerhalb eines Makros-Blocks dann der
  Funktions-Quellcode gestanden hÃ¤tte, man aber gar nicht gewuÃt hÃ¤tte, wie diese Funktion nun wirklich aussieht.
  Ein Programm, welches die plattformunabhÃ¤ngige Einstiegsfunktion verwenden will, muÃ nun einfach PLMain.h einbinden
  und die Funktion PLMain deklarieren, die Parameter dieser Funktion sind dabei nun wirklich auf jedem System gleich,
  da sie je nach OS unterschiedlich implementiert wird.
  Es muÃ natÃ¼rlich darauf geachtet werden, daÃ PLMain.h nur ein einziges Mal in eine .cpp Datei eingebunden wird, da
  ansonsten die Einstiegsfunktion fÃ¼r das System mehrfach im Programm vorhanden wÃ¤re und es dann beim Linken natÃ¼rlich
  einen Fehler gÃ¤be. Dies sollte aber kein Problem darstellen, wenn dies einfach in der main.cpp verwendet wird, wie
  es wohl natÃ¼rlicher Weise der Fall sein sollte.
- PLRTTIDefs.h: Makros fÃ¼r den Programm Einstiegspunkt entfernt



>> 20.11.2004
[CO]
- PLRTTIDefs.h: Makros fÃ¼r den Programm Einstiegspunkt hinzugefÃ¼gt. (DEFINE_MAIN/END_MAIN) Diese sind zwar Optional, sollten aber
  IMMER verwendet werden damit man Plattform unabhÃ¤ngig bleibt ohne sich immer selbst drum kÃ¼mmern zu mÃ¼ssen.



>> 19.11.2004
[CO]
- PLTTimer zum Singleton gemacht, PLTTimer in PLTTimerBase umbenannt und PLTTimer definiert das wie beim Gui automatisch jeweils korrekt
  je nach Plattform definiert wird so das man sich nicht mehr drum kÃ¼mmern muss. Hab auch gleich die Linux Variante mit angepasst,
  Stephan - bitte gleich mal prÃ¼fen ob ich nicht fehler reingemacht hab. :)
  Passte gleich alle Codes an so das der Renderer nun endlich von der Engine selbst unabhÃ¤ngig sein kann.
- PLTLog: Ein paar kleine Ãnderungen gemacht, z.B. wird nun bei PLTLog::OutputString(const char *pszText) direkt in die Datei geschrieben
  damit man keinen Crash bekommt wenn der String lÃ¤nger als 1024 ist. Bei den mit ,... gehen wir einfach momentan noch aus das diese Strings
  nicht ZU lang werden. ;)
- PLTFile: PutC() -> Parameter mit const versehen



>> 18.11.04
[SW]
- Bis auf das FS auf linux portiert und ein paar kleine include fehler behoben (pfadangaben)



>> 15.11.2004
[SB]
- PLTPluginManager wurde wieder ausgebaut, und dessen FunktionalitÃ¤t nach PLTSystem verschoben. Dies ist sinnvoller
  und vor allem fÃ¼r den Programmierer einfacher, da PLTSystem besser zwischen den Klassen und den Modulen verknÃ¼pfen
  kann - das wÃ¤re mit einer getrennten LÃ¶sung kaum mÃ¶glich gewesen, da die Libraries und die Klassen damit scheinbar
  voneinander getrennt gewesen wÃ¤ren. Da PLTSystem nun aber beides managed, kann es die Klassen gleich den entsprechenden
  Modulen zuordnen und bietet so auch fÃ¼r den Programmierer einen flexibleren Zugriff auf diese Informationen.
  PLTSystem ist jetzt also eine Ã¼bergeordnete Klasse, die der Programmierer nutzen kann um auf Klassen und Bibliotheken
  zuzugreifen sowie alle Plugins zu managen, ohne dabei die Struktur der Applikation oder der Plugins festzulegen.
- PLTSystem wurde noch einmal in groÃen Teilen umgebaut, und ist nun sowohl einheitlicher als auch komfortabler.
  Dabei gibt es fÃ¼r Klassen, Gruppen und Module jeweils eine Methode GetXXXList(), um alle Objekte des Typs aufzulisten,
  sowie eine Methode GetXXX(), um einzelne Objekte per Name bzw. ID anzusprechen. Es ist jetzt also mÃ¶glich, alle
  Klassen, Gruppen oder Module aufzulisten sowie deren ZugehÃ¶rigkeiten untereinander zu erkennen. Die Methode
  GetClassList() wurde dabei so erweitert, daÃ entweder alle Klassen, oder alle Klassen einer Gruppe und/oder eines
  Moduls aufgelistet werden kÃ¶nnen, was die Einordnung der Klassen wiederum vereinfacht. Intern wurden die Methoden
  vereinheitlicht, auÃerdem sind die Add/Remove Methoden nun protected und kÃ¶nnen also nicht mehr wie vorher von
  auÃen aufgerufen werden, was hÃ¤tte miÃbraucht werden kÃ¶nnen.
- Die wahnwitzigen RTTI-Makros wurden noch einmal umgebaut, indem die Register-Funktionen nun nicht mehr Teil der
  zu registrierenden Klasse sind, sondern Teil der geschachtelten Info-Klasse. Durch Ableitung von der Basisklasse
  PLTClass und Aufruf der darin deklarierten Basisfunktionen _Register und _Unregister kann die Klasse dann bei PLTSystem
  angemeldet werden. Dieser weitere Trick dient nur dazu, die Add/Remove-Methoden von PLTSystem nach auÃen abzuschotten
  und als protected zu deklarieren, damit diese nicht beliebig aufgerufen werden kÃ¶nnen.
- Da sich die RTTI-Makros verÃ¤ndert haben, mÃ¼ssen sÃ¤mtliche Projekte, welche diese verwenden, neu Ã¼bersetzt werden, damit
  die Klassen vom aktuellen System korrekt registriert werden kÃ¶nnen. Dies sollte jedoch in der Zukunft nicht mehr so
  oft vorkommen :-)



>> 06.11.04
[SB]
- PLGeneral: Das Template PLTShared wurde gelÃ¶scht, die Idee war zwar nicht schlecht, hÃ¤tte aber zu mehr Verwirrung gefÃ¼hrt
  als daÃ es Nutzen gebracht hÃ¤tte. Es gibt nun also nur noch Singletons, welche nur eine globale Instanz der Klasse
  erlauben, dies gilt z.B. fÃ¼r Syste, FileSystem, Log, etc. Die Klassen sollten also so strukturiert werden. daÃ entweder
  beliebig viele Instanzen mÃ¶glich sind (wie z.B. bei der Gui), oder nur eine globale Klasse, um eine saubere Struktur
  zu bewahren.
- PLGeneral: Neue Klasse PLTPluginManager eingebaut, welche das Laden und Verwalten von Plugin-DLLs Ã¼bernimmt. Dabei wird
  Ã¼berprÃ¼ft, ob eine DLL bereits geladen wurde und ob debug/release Modus Ã¼bereinstimmen. Das Scannen einen Verzeichnisses
  nach Plugins wird zunÃ¤chst von der Engine aufgerufen, jedoch kann ein Programm auch weitere Verzeichnisse Scannen.
  Zur Definition von Plugin-DLLs wurde PLRTTIDefs.h um entsprechende Makros erweitert.



>> 05.11.04
[SB]
- PLTRefCount: Abfrage des counts ist nun eine const-Funktion
- PLTFileSystem: Ist nun wieder ein singleton, es kann also nur eine einzige Instanz davon geben, die von allen
  Programmteilen verwendet werden muÃ. Dies ist aber kein Problem, da die Verwaltung von Suchpfaden nun doch
  nicht zentral im FS stattfinden wird, da dies einfach zu komplex geworden wÃ¤re (vor allem auch die Verwaltung
  durch den Programmierer, denn die Implementierung war ja bereits komplett).
- PLTFileSystem: Beim erstellen des FS wird nun das aktuelle Verzeichnis vom OS Ã¼bernommen
- PLTFSTools: GetFileName() gibt den Dateinamen aus einem kompletten Pfad zurÃ¼ck (splitpath() Ã¤quivalent)
- PLTWin32Directory: Bei Angabe von "." wird das aktuelle Verzeichnis vom OS genommen
- PLTLog: Ist ebenfalls wieder ein Singleton, zur Unterscheidung verschiedener Logs wird diese Klasse entsprechend erweitert



>> 27.10.04
[CO]
- Behob kleinen 'Fehler' in den Vektor und Farb Klassen welche Offset Probleme im zusammenspiel mit dem RTTI erzeugten.
  Heute dazugelernt: "Vorsicht beim umgang mit this Zeigern!" ;-)
  Desweiteren ist es beim RTTI erfordlich das ALLE von PLTBase abgeleiteten Klassen virtuelle Destruktoren haben da es 
  ansonnsten bei delete [] zu einem Crash kommt - ebenfalls in PLTBase Notiert.



>> 15.10.04
[SB]
- PLTStack2: Da leider jedes Mal, wenn ich die Stack-Klasse benutzen will, irgend etwas nicht funktioniert, habe ich
  eine neue, sehr einfache Stack-Klasse geschrieben, welche auch wirklich nur das tut, was von einem Stack erwartet
  wird und dafÃ¼r hoffentlich stabiler ist als die bisherige Klasse. Implementiert sind die Standardmethoden eines
  Stacks, Push()/Top()/Pop(), sowie noch eine Extramethode PushBack(), um ein Element an das andere Ende des Stacks
  anzufÃ¼gen (dies ist vor allem beim Kopieren eines Stacks sehr wichtig). Ansonsten ist der Stack als einfache
  verkettete Liste implementiert, was vollkommen ausreicht da ja nur auf das Top-Element des Stacks zugegriffen werden
  kann, worauf immer ein direkter Zeiger existiert. Ein beliebiger Zugriff auf alle Elemente des Stacks ist also nicht
  implementiert und sollte auch nicht gebraucht werden, fÃ¼r einen solchen Fall sollte entweder eine Liste oder eine
  Array-Klasse verwendet werden. Dann ist auch endlich gegeben, daÃ sich die Containerklassen wirklich voneinander
  unterscheiden und somit je nach Situation optimal eingesetzt werden kÃ¶nnen.
  Die alte Klasse PLTStack sollte nun Ã¼berall durch PLTStack2 ersetzt werden, oder durch eine andere Containerklasse,
  falls die Stackoperationen nicht ausreichend sind fÃ¼r einen bestimmten Fall, danach sollte die alte Klasse gelÃ¶scht
  werden und die neue Klasse in PLTStack umbenannt werden. Die zwei Klassen sollen also nur vorÃ¼bergehend nebeneinander
  existieren, um die Anpassung zu erleichtern
- PLTTokenizer: Auch hier habe ich zunÃ¤chst Ãnderungen vorgenommen, ohne die alte Version davon zu entfernen, damit die
  entsprechenden Stellen problemlos angepaÃt werden kÃ¶nnen. Die Methoden Push()/Pop() implizieren schon vom Namen her
  eine Stack-FunktionalitÃ¤t, die sie dann jedoch nicht bieten, da nur ein einziger State gespeichert werden kann. Solche
  Dinge sind es aber, die spÃ¤ter andere Programmierer, die mit PL arbeiten wollen, in den Wahnsinn treiben werden, denn
  ein Programmierer weiÃ, was er von einer Push()/Pop() Methode erwarten kann und wird nicht auf den Gedanken kommen, 
  daÃ der Name vielleicht zu viel verspricht. Ich habe daher einen echten Stack in den Tokenizer eingebaut sowie
  Funktionen, um auf diesen zuzugreifen. Mit PushState() kann der aktuelle Status des Tokenizers auf dem Stack gespeichert
  werden, mit PopState() wird dieser wiederhergestellt oder mit DropState() vom Stack verworfen. Damit ist ein einfacher
  recursive-descent parser, der natÃ¼rlicher Weise mehr als einmal den Status speichern muÃ, also sehr leicht zu schreiben.
  Auch hier sollten die alten Methoden entfernt werden und durch die neuen ersetzt werden, sobald alle Stellen angepaÃt
  sind, wo dies verwendet wird. Sollten die alten Methoden aus irgend einem Grund erhalten bleiben, kÃ¶nnten sie z.B. in
  SaveState()/RestoreState() umbenannt werden, was auch ihrer FunktionalitÃ¤t entsprÃ¤che.



>> 08.09.2004
[CO]
- PLTArray um const [] erweitert



>> 05.09.2004
[CO]
- PLVar.h: Zwei Includes hinzugefÃ¼gt



>> 29.08.2004
[SB]
- PLTRefCount: GetRefCount() ist nun const
- PLTVar besitzt nun eine Funktion, um eine Zeiger auf die Variable selbst zu erhalten. Da der Variablentyp natÃ¼rlich nicht
  bekannt ist, ist der RÃ¼ckgabewert ein void* Zeiger. Diese Funktion sollte natÃ¼rlich nur mit grÃ¶Ãter Vorsicht verwendet
  werden, da man hiermit quer im Speicher rumschreiben kann. Auch alle Sicherheitsmechanismen wie readonly-variablen kÃ¶nnen
  mit dieser Funktion natÃ¼rlich umgangen werden. Dennoch war eine solche Funktion nÃ¶tig, um z.B. bei Variablen von Typ
  PL_VAR_CLASS an den Klassennamen heranzukommen (hierzu muÃ man sich den Zeiger auf das Objekt zurÃ¼ckgeben lassen und dann
  mit PLTBase::GetClassName() den Klassennamen ermitteln). Hierzu viel mir leider bisher kein besserer Weg ein...



>> 28.08.2004
[CO]
- FÃ¼gte PLTList<AType>::Add() noch einen Parameter hinzu mit dem man bei bedarf verhindern kann das geprÃ¼ft wird ob etwas bereits
  in der Liste ist. Bei GuiListBox war es tÃ¶tlich wenn extrem viele Elemente eingefÃ¼gt wurden - da war der Aufwand ganz enorm so das 
  es teils viele Sekunden dauerte bis alles eingefÃ¼gt war. :(
  Durch das deaktivieren des Tests geht es zwar nur etwas flotter, aber immerhin.
  


>> 26.08.2004
[SB]
PLGeneral:
- Habe PLGeneral.h umgebaut: Hier werden nun die OS-Spezifischen include-files eingebunden, so daÃ die Verwendung mÃ¶glichst
  auf allen Betriebssystem identisch ist. Bei einer Portierung wird also einfach eine neue .h-Datei hinzugefÃ¼gt und
  in PLGeneral.h mit den entsprechenden #ifdef's eingebaut. In PLGeneralWin32.h und PLGeneralLinux.h sind nun fÃ¼r das
  jeweilige Betriebssystem die import/export Makros sowie  die Datentypen definiert.
  Die Unterscheidung zwischen Import und Export geschieht nun nicht mehr Ã¼ber unterschiedliche .h Dateien sondern
  Ã¼ber eine Compilerdefinition (welche von VC++ automatisch gesetzt wird, diese mÃ¼Ãte dann nur fÃ¼r Linux in die
  Makefiles eingebaut werden)
- Datentypen angepaÃt, es werden nun nur noch die nÃ¶tigsten definiert: int32, uint32, etc. Diese sollten nur da verwendet
  werden, wo es auf die BitgrÃ¶Ãe des Datentyps explizit ankommt, also meist bei Dateizugriffen. Ansonsten sollten nur
  noch die primitiven Datentypen, also z.B. int, long, ... verwendet werden (fÃ¼r Flags z.B. unsigned long). Da DWORD/WORD
  von vielen als Windows-Datentypen verstanden werden, die man nicht braucht, habe ich mich fÃ¼r die Bezeichnung
  int16/int32/int64 entschieden, um klarzumachen daÃ es nur um die BitgrÃ¶Ãe der Datentypen geht.
- PLTypes.h: Alle immer wieder verwendeten Datentypen/Definitionen der Engine befinden sich nun in dieser Datei,
  statt wie vorher noch in PLEngine. Da PLGeneral von den anderen Teilprojekten eingebunden wird ist dies besser,
  so muÃ PLEngine nicht mehr eingebunden werden, um z.B. die Definitionen fÃ¼r X/Y/Z verwenden zu kÃ¶nnen, wie dies
  bisher der Fall war
- Dummerweise vergessene PLGENERAL_API in PLTVar eingefÃ¼gt :-)
RTTI:
- PLTSystem: Fehler bei den ClassGroups behoben: Da "" nicht als gÃ¼ltiger Hash-String gilt, wird nun ein Dummy-GroupName
  verwendet, um Klassen ohne Gruppe zu bezeichnen
- SelfInit-Class so erweitert, daÃ Klassen auch wieder automatisch ausgetragen werden, wenn das entsprechende Modul
  entladen wurde. Wenn kein SelfInit verwendet wird, muÃ der Programmierer stattdessen das Makro UNREGISTER_CLASS verwenden.
  Wie er mitbekommt, daÃ seine DLL entladen wurde, ist dann allerdings sein eigenes Problem ;-)



>> 18.08.2004
[CO]
- PLTBase::ToString: Behob String Problem, der Zeiger auf den Speicher wurde ungÃ¼ltig da das String Objekt nach ToString() wieder
  zerstÃ¶rt wurde und auch den String-Speicher selbst dabei killte.
- PLTSystem: Zwei neue Funktionen: GetVarType() & GetVarTypeAsString()



>> 10.08.2004
[SB]
- Neuer Variablentyp PL_VAR_PLSTRING zum Zugriff auf Variablen vom Typ PLTString eingebaut
- PL_ENUM Makros verÃ¤ndert: Der enum-string steht nun doch am Ende des Makros, da dies die Variablendefinition Ã¼bersichtlicher gestaltet



>> 08.08.2004
[SB]
- PLTClass: Der Methode CreateInstance kann nun angegeben werden, ob die Variablen des erzeugten Objektes automatisch auf
  ihre Default-Werte gesetzt werden wollen, dies ist nun auch das Standardverhalten von CreateInstance().
- PLTBase: Neue virtuelle Methode VarChanged() eingebaut, diese wird aufgerufen wenn der Wert einer Variablen durch das
  RTTI verÃ¤ndert worden ist, um ggf. nÃ¶tige Aktionen nach dem VerÃ¤ndern einer Variable durchzufÃ¼hren



>> 07.08.2004
[SB]
- PLTBase, PLTClass: GetVarList(List, true) gibt nur die Variablen der eigenen Klasse zurÃ¼ck, ohne die von Basisklassen
  vererbten
- PLTVar::GetClass() gibt zurÃ¼ck, in welcher Klasse die Variable deklariert wurde
- Mittels DEFINE_ENUM kÃ¶nnen AufzÃ¤hlungs-Variablen registriert werden. Als Typ kann hier entweder PL_VAR_ENUM oder
  PL_VAR_FLAGS angegeben werden. Das Setzen der Variablen kann entweder Ã¼ber die numerischen Werte oder Ã¼ber die
  enum-Namen erfolgen: z.B. Set("2|4"); Set("beta"); Set("Read|Write");



>> 06.08.2004
[SB]
- PLTypes.h erweitert, so daÃ die Definitionen an anderer Stelle komplett entfallen kÃ¶nnen. Die verwendeten Datentypen
  sollten jedoch noch einmal komplett Ã¼berarbeitet werden
- Log-Ausgaben wieder eingebaut, dazu wird nun das "shared"-Log verwendet. Zur Zeit wird dieses jedoch nirgendwie aktiviert,
  deshalb verschwinden die Logausgaben im Nirvana :-)
- RTTI System erweitert:
  - Klassen beinhalten nun auch die Variablen ihrer Basisklassen
  - Es wird nun mit m_nBaseOfs auch der Offset zu PLTBase gespeichert, damit die Variablen auch dann noch korrekt gesetzt
    werden kÃ¶nnen, wenn eine Klasse nicht als erstes PLTBase in der Ableitungsliste stehen hat
  - DEFINE_VAR_READONLY erlaubt das Definieren von Variablen, die nur gelesen aber nicht verÃ¤ndert werden kÃ¶nnen
  - REDEFINE_VAR erlaubt das "Ãberschreiben" von Variablen in abgeleiteten Klassen, dabei kÃ¶nnen DefaultValue,
    Description und Annotation verÃ¤ndert werden



>> 05.08.2004
[CO]
- Den Ordner Tools in PLTools umbenannt. Beim Includieren wÃ¤re es am ende unschÃ¶n wenn man #include <Tools/...> schreiben
  wÃ¼rde, da vermiss ich irgendwie das PL davor... und so musste ich die anderen Codes nicht an die verschiebung von PLTools
  in PLGeneral anpassen. ;-)
  Vielleicht sollten wir auch die anderen Ordner entsprechend anpassen damit es einheitlich ist. 
  (wieder so ne dumme Namensgeschichte ;-)
- Bei ein paar Headern in PLTools noch PLGeneral.h eingebunden - bei der Gelegenheit ging ich gleich alle Includes unserer
  Projekte durch und passte alles an. (waren ja in letzter Zeit einige Ãnderungen)
  Nun sieht man z.B. schÃ¶n wie die Libs aufeinander aufbauen da alles geordnet ist.
- PLTimerWin32.inl & PLTimer.inl gelÃ¶scht da die inlines dort nicht so doll sind (was dachte ich mir frÃ¼her dabei? :-)
- PLTypes.h von der Engine in PLGeneral verschoben, musste PLTypes in z.B. PLList.h einbinden da in der Engine teils
  NULL unbekannt war da windows.h dort nicht eingebunden werden musste



>> 04.08.2004
[SB]
- PLTDestructionManager eingebaut. Diese Klassen sorgen dafÃ¼r, daÃ Instanzen von Singleton- oder Shared-Klassen am
  Ende der ProgrammausfÃ¼hrung auch wieder gelÃ¶scht werden. Die Implementierung ist relativ kompliziert, da man
  hierbei wieder sehr mit der Compiler- und Exportproblematik herumschlagen muÃte. Die Funktionsweise des Systems:
  - Statische Initialisierung wird durch Singleton::GetInstance() vermieden, dies ist nÃ¶tig damit die Klassen sich
    Ã¼ber Selbstinitialisierung beim Programmstart bei PLTSystem anmelden kÃ¶nnen. WÃ¤re PLTSystem eine statische
    Variable, kÃ¶nnte dies zu Problemen fÃ¼hren, wenn PLTSystem noch nicht initialisiert wurde
  - Jede Instanz von PLTSingleton und PLTShared meldet sich beim PLTDestructionManager an. Dies ist mÃ¶glich, da
    PLTDestructionManager selbst ein Singleton ist und daher bei der ersten Verwendung erzeugt wird
  - Am Ende mÃ¼ssen alle Instanzen wieder gelÃ¶scht werden. Dazu dient die einzige statisch Variable
    PLTDestructionGuard::Instance, deren Destructor am Ende des Programmes automatisch aufgerufen wird. Diese lÃ¶scht
    die Instanz von PLTDestructionManager, welche wiederum alle bei ihr angemeldeten Objekte lÃ¶scht. Auf diese
    Weise werden alle erzeugten Instanzen auch wieder automatisch gelÃ¶scht :-)



>> 03.08.2004
[SB]
- Neues Verzeichnis PLTools, hier befinden sich nun allgemeine Tool-Klassen
- PLTTokenizer nach Tools verschoben
- Klassen aus PLEngine nach PLGeneral verschoben, welche allgemein verwendet werden kÃ¶nnen. Die Klassen sind nun
  allgemein und kÃ¶nnen auch auÃerhalb der Engine verwendet werden, PLEngine-spezifischer Code wurde dabei entfernt
  und muÃ weitern in der Engine selbst ausgefÃ¼hrt werden (z.B. Anzeige von Informationen etc).
  Verschobene Klassen: PLTLog, PLTProfiling, PLTTimer, PLTTools



>> 02.08.2004
[SB]
- PLTRefCount nach Base verschoben und von PLTBase abgeleitet
- PLTFile: Neue Methode PrintLn eingebaut
- PLTFile: Neue Methode Flush eingebaut
- PLTWin32File und PLTZipFile angepaÃt



>> 01.08.2004
[CO]
- PLTDynamicList: In der Engine hab es nun mit den const/nicht const etwas probleme. Hab die Warnung
  "PLTDynamicList<AType>' : multiple assignment operators specified" fÃ¼rs erste Deaktiviert da diese ansonnsten tausende male
  kam. ;-)
  Bei Zeiten mÃ¼ssten wir nochmal schaun wie wir das besser machen kÃ¶nnen...
- PLTPool: Um Copy Operator erweitert



>> 01.08.2004
[SB]
- Neue Basisklassen PLTShared und PLTSingleton eingebaut. Dies sind Template-Klassen, welche verwendet werden kÃ¶nnen,
  um Klassen mit nur einer Instanz (PLTSingleton) oder mit einer gemeinsamen Instanz fÃ¼r alle Programmteile (PLTShared)
  zu definieren.
- PLTFileSystem benutzt nun die neuen Basisklassen PLTSingleton und PLTRefCount
- PLTSystem: Anpassung an neue Basisklassen sowie kleinere Korrekturen
- Neue Definition PLGENERAL_TEMPLATE zum Exportieren von template-Klassen, dies muÃ bei allen zu exportierenden
  Template-Instanzen verwendet werden
- Verzeichnisse umbenannt



>> 30.07.2004
[SB]
- Habe das RTTI System in PLGeneral eingebaut und dafÃ¼r die vorlÃ¤ufigen Plugin-Klassen wieder entfernt, da diese
  damit Ã¼berflÃ¼ssig geworden sind :-)



>> 29.07.2004
[SB]
- Die Gruppe einer Klasse wird nun mittels eines eigenen Makros gesetzt, wird dieses nicht verwendet gehÃ¶rt die Klasse
  keiner Gruppe an
- Die Basisklassen einer Klasse werden nun in PLTClass gespeichert und kÃ¶nnen dort abgefragt werden. Ebenso kann
  PLTBase::IsInstanceOf() als Shortcut zur Abfrage einer Basisklasse verwendet werden
- PLTBase selbst wird jetzt als Klasse registriert
- Beim Definieren einer Klasse wird nun eine interne von PLTClass abgeleitete Klasse erzeugt, welche dann in PLTSystem
  gespeichert wird. Dadurch ist es mÃ¶glich, private Methoden von PLTClass zu verwenden sowie virtuelle Methoden
  zu Ã¼berschreiben
- PLTClass::CreateInstance() kann benutzt werden, um eine neue Instanz einer Klasse zu erzeugen. Es muÃ allerdings noch
  ein Weg gefunden werden, daÃ Klassen dieses Verhalten unterbinden kÃ¶nnen, wenn eine direkte Erzeugung von Instanzen
  nicht erwÃ¼nscht ist
- PLTClass: Methoden zum Ãndern einer Klasse sind nun protected, kÃ¶nnen von AuÃen also nicht mehr aufgerufen werden,
  damit sind auch die konstanten Zeiger nicht mehr von NÃ¶ten und wurden durch normale Zeiger (PLTClass*) ersetzt
- Pointer-Truncation Warnungen wurden beseitigt, indem zur Speicherung des Offsets nun der 64Bit-Datentyp int__64
  verwendet wird
- Neues Makro: Wird DEFINE_CLASS_PRIVATE anstelle von DEFINE_CLASS verwendet, so kann die Klasse nicht Ã¼ber
  CreateInstance() instanziiert werden. Dies ist nÃ¼tzlich fÃ¼r Klassen, die nicht beliebig instanziiert werden
  sollen und daher meits auch keinen Ã¶ffentlichen Standardkonstruktor besitzen
- Mittels der Compiler-Definition USE_SELFINIT kann bestimmt werden, ob die Selbstinitialisierung verwendet werden soll
- In PLTClass wird nun ein Module-Handle gespeichert, zu dem die Klasse gehÃ¶rt



>> 28.07.2004
[SB]
- Zugriff auf Variablen vollstÃ¤ndig implementiert und getestet
- Klassen kÃ¶nnen nun in Gruppen eingeteilt werden, um einfach die Klassen eines bestimmten Typs auflisten zu kÃ¶nnen. Dies
  dient nur dem Entwickler zur Einfacheren Verwaltung seiner Klassen, z.B. sollten alle Plugins eines Typs den gleichen
  Gruppennamen bekommen (z.B. PLEntities), dann kann der Plugin-Manager sich eine Liste aller Klassen dieses Typs herausgeben
  lassen um die Plugins dann zu verwenden
- PLTVar wurde doch noch einmal umgeschrieben, es ist nun nicht mehr mÃ¶glich, mit hilfe eines PLTVar-Objekts direkt auf
  eine Instanz einer Variablen zu zeigen, da dies zu Inkonsistenzen fÃ¼hrte (PLTClass::GetVar() gab einen konstanten Zeiger
  auf PLTVar zurÃ¼ck, der nicht gelÃ¶scht werden durfte, wÃ¤hren PLTBase::GetVar() ein neues PLTVar Objekt erzeugte, welches
  dann wieder gelÃ¶scht werden muÃte!). Die jetzt zurÃ¼ckgegebenen Objekte mÃ¼ssen grundsÃ¤tzlich nicht mehr gelÃ¶scht werden,
  da sie Zeiger auf feste Instanzen darstellen und nicht neu erzeugt werden. DafÃ¼r gibt es nun Methoden in PLTVar,
  um den Wert der Variablen bezogen auf eine Instanz zu setzen: SetVar(PLTObject*, const char *pszValue)
- RTTI Interface ist nun komplett



>> 27.07.2004
[SB]
- Neue Funktionen in PLTBase: ToString() und FromString(). Mit diesen Methoden wird der Inhalt eines
  Objektes in einem String Ã¼bergeben. Dies entspricht in wesentlichen dem VarString, jedoch kann das
  Aussehen dieses Strings von der Klasse bestimmt werden, es mÃ¼ssen also nicht die Variablennamen
  angegeben werden (die ReprÃ¤sentation eines 3D-Vectors kÃ¶nnte z.B. "10 20 30" sein, anstatt "X=10 Y=20 Z=30")
- Mittels PLTVar kÃ¶nnen nun Werte von Variablen gesetzt und abgefragt werden
- Klassen werden in PLTClassRegistry gespeichert und kÃ¶nnen dort abgefragt werden
- PLTClassRegistry wurde in PLTSystem umbenannt, da diese Klasse die allgemeine Verwaltung des Systems Ã¼bernehmen
  wird (neben Registrierung der Klassen werden auch Plugins, Dynamic Libraries etc. in ihren Aufgabenbereich fallen,
  evtl. kann man spÃ¤ter auf Log etc. in PLTSystem einbetten)
- Die Klassen wurden Ã¼berarbeitet und vereinheitlicht, z.B. wurden Unterschiede beim Zugriff auf Listen und Daten
  der Klassen beseitigt
- SelfInit-Part eingebaut, welcher die Klasse automatisch registriert
 


>> 25.07.2004
[SB]
- PLTVar Ã¼berarbeitet, die Instanz des Objektes kann nun nur noch im Konstruktor Ã¼bergeben werden
- Zugriff auf Variablen Ã¼ber PLTClass implementiert



>> 24.07.2004
[SB]
- PLTVar fertiggestellt, diese Klasse beinhaltet Informationen Ã¼ber eine Variable innerhalb einer Klasse. In PLTClass
  kann man eine Liste der registrierten Variablen abfragen, und in PLTObject kÃ¶nnen die Werte der Variablen gesetzt
  oder abgefragt werden. ZusÃ¤tzlich kann auch PLTVar die Instance einer Variablen darstellen, dann kann auch Ã¼ber
  PLTVar auf die Werte der Variablen zugegriffen werden



>> 22.07.2004
[SB]
- Habe endlich einen generellen Weg gefunden, daÃ die Variablen einer Klasse nicht mehr pro Objekt gespeichert werden
  mÃ¼ssen sondern nur noch einmal fÃ¼r jede Klasse. Bisher besaÃ jede Instanz einer Klasse eine eigene Variablenliste,
  in der die Zeiger auf die Variablen gespeichert wurden (die Informationen Ã¼ber die Variablen wurden nur einmal
  gespeichert, dies fÃ¼hrte jedoch dazu, daÃ es zwei unterschiedliche Klassen fÃ¼r Variablen geben muÃte, was auch
  nicht schÃ¶n war). Dies ist nun nicht mehr nÃ¶tig :-)



>> 21.07.2004
[SB]
- PLGeneral: PLTDynamicList und PLTList so erweitert, daÃ diese nun auch mit konstanten Daten umgehen kÃ¶nnen.
  Dies ist z.B. dann nÃ¼tzlich, wenn der Zugriff auf eine const PLTList/PLTDynamicList erfolgt
- RTTI System begonnen. Mit Hilfe dieses Systems wird es mÃ¶glich sein, zur Laufzeit auf Klasseninformationen zuzugreifen,
  damit kÃ¶nnen z.B. die vorhanden Variablen oder Methoden eines Objektes abgefragt und verÃ¤ndert werden, sowie
  natÃ¼rlich generelle Informationen Ã¼ber den Typ eines Objektes abgefragt werden.
  Das System entspricht in seiner Funktionsweise dem EntityPluginSystem, ist jedoch allgemeiner und soll um einiges
  flexibler werden. Wenn alles klappt, wird durch dieses Klassensystem auch gleich ein sehr einfach zu verwendendes
  Pluginsystem zur VerfÃ¼gung stehen, wobei die bisherigen Fallunterscheidungen nicht mehr benÃ¶tigt werden sollten
  (bisher muÃte unterschieden werden, ob eine Klasse im Hauptprojekt, in der Engine-DLL oder in einer Plugin-DLL
  deklariert wurde, dies ist nicht sehr schÃ¶n und kann hoffentlich vermieden werden). Auch das Scriptsystem wird
  nach der Implementierung der RTTI leicht zu entwickeln sein, da der Zugriff auf Klassen und Variablen/Methoden
  zur Laufzeit damit bereits implementiert ist :-)
  Das RTTI wird also eine Reihe von Basisklassen zur VerfÃ¼gung stellen, die in der gesamten Engine verwendet werden,
  zusÃ¤tzlich wird es noch einige abgeleitete Klassen geben, welche fÃ¼r bestimmte Klassentypen zum Einsatz kommen
  kÃ¶nnen (RefCount, Singleton, etc)



>> 30.06.2004
[SB]
PLFileSystem:
- Fehler in PLTSearchMultiHandle behoben: HasNextFile() gab false zurÃ¼ck, sobald der erste SearchHandle komplett durchlaufen
  war, dadurch wurden die anderen SearchHandles ignoriert
- Das Interface von PLTFileSystem wurde noch einmal leicht verÃ¤ndert. GetRootDirectory() gibt nun das System-Root-Verzeichnis
  zurÃ¼ck, dieses kann jedoch nicht selbst gesetzt werden. SetCurrentDirectory()/GetCurrentDirectory() ermÃ¶glichen das Setzen
  eines aktuellen Verzeichnisses, sowie AddBaseDir() etc., welche im Prinzip weitere aktuelle Verzeichnisse hinzufÃ¼gen lassen
  (falls mehrere benÃ¶tigt werden). Hierdurch bleibt das System kompatibel zu den Ã¼blichen Dateisysteme, erlaubt jedoch zusÃ¤tzlich
  mehr Kontrolle
- Zugriff auf Suchpfade und Rootverzeichnisse ist vollstÃ¤ndig, es funktioniert nun also alles was fÃ¼r die Engine benÃ¶tigt
  wird. Es kÃ¶nnen Dateitypen (z.B. "Textures", "Sounds", etc.) festgelegt werden und Suchpfade dafÃ¼r angelegt werden.
  Das FS durchsucht dann beim Ãffnen einer Datei automatisch diese Pfade, so daÃ sich die Anwendung nicht mehr darum
  kÃ¼mmern muÃ, was wo liegt
- Suchpfade/Rootverzeichnisse ausgetestet und den PL-Realfall simuliert (separate Verzeichnisse fÃ¼r Textures/Models/etc)



>> 29.06.2004
[SB]
PLFileSystem:
- Geschwindigkeitstests durchgefÃ¼hrt. Leider ist das FS vor allem beim Zugriff auf viele kleine Dateien deutlich langsamer
  als die Standardfunktionen, beim Zugriff auf groÃe Dateien fÃ¤llt der Unterschied allerdings kaum mehr ins Gewicht.
  Dies dÃ¼rfte hauptsÃ¤chlich an den vielen String-Operationen liegen, wie mÃ¼ssen also einfach austesten, ob dies im reellen
  Gebrauch negativ auffÃ¤llt und ggf. versuchen, diese Funktionen zu optimieren
- Neue Funktion PLTSearchHandle::GetNextFileAbs(), diese Funktion liefert den absoluten Pfad zurÃ¼ck. Funktion wurde in
  allen abgeleiteten Klassen implementiert
- Neue Funktion PLTZipDirectory::GetZipFile(), liefert ein Handle auf die Zip-Datei zurÃ¼ck, die das Verzeichnis beinhaltet.
  Der RÃ¼ckgabewert ist const, damit zwar Dateiattribute (Namen etc.) abgefragt werden kÃ¶nnen, die Datei aber nicht
  verÃ¤ndert werden kann
- Fehler in PLTZipSearchHandle behoben: Das zugrunde liegende Verzeichnis wurde nicht gesichert (refcount)



>> 28.06.2004
[SB]
PLFileSystem:
- Dateien aus Zip komplett Ã¼berarbeitet und an den PL-Style angepaÃt
- Alle Dateien Ã¼berarbeitet und die Ã¼blichen "VerschÃ¶nerungen" vorgenommen :-)



>> 25.06.2004
[SB]
PLFileSystem:
- Beim Suchen mit Filter entspricht der Filter "" nun der Suche nach allen Dateien
- Beim Suchen mit Filter ist es nun auch mÃ¶glich, noch Unterverzeichnisse mit anzugeben (z.B. Suche nach "subdir/*.txt")
- Mounten von Root-Verzeichnissen implementiert
- Dateitypen und Suchpfade wurden implementiert
- PLTSearchMultiHandle eingebaut: Dies ist ein Search-Handle, welches intern wiederum aus mehreren Search-Handles besteht
  und diese nacheinander abarbeitet
- PLTFileSystem interface wurde komplett implementiert
- Dateien aus Base und Win32 Ã¼berarbeitet und komplett kommentiert



>> 23.06.2004
[SB]
PLFileSystem:
- PLEFileType und entsprechende Zugriffsmethoden in PLTFileObject wurden entfernt, IsDirectory() und IsFile() werden
  nun von abgeleiteten Klassen implementiert
- Neue Methoden GetName() und GetAbsName() in der Basisklasse PLTFileObject eingebaut, diese dienen dem Abfragen von
  relativen und absoluten Namen aller Dateiobjekte
- Interface von PLTFileObject wurde Ã¼berarbeitet (const-Methoden)
- GetName() und GetAbsName() in allen abgeleiteten Klassen implementiert und getestet, es kann nun immer der relative
  sowie der absolute Pfad angefragt werden
- PLTSearchFilter implementiert, dieser filtert Suchergebnisse nach Wildcards
- Beim Erzeugen des Dateisystems wird das aktuelle Verzeichnis '/' automatisch als system-root gemountet
- Setzen des aktuellen Verzeichnisses implementiert
- Design von PLTFileSystem wurde festgelegt. Diese Klasse stellt das Hauptinterface zum FS dar, dient also dem Benutzer
  zum Ãffnen von Dateien und Verzeichnissen sowie zum Suchen von Dateien



>> 22.06.2004
[SB]
PLFileSystem:
- FSTools: Neue Funktion IsAbsolutePath() eingebaut
- PLTWin32Directory: Es kÃ¶nnen nun auch absolute Pfade angegeben werden (z.B. D:\test.txt), welche unabhÃ¤ngig vom aktuellen
  Verzeichnis gefunden werden. AuÃerdem kleine Anpassungen an IsValid() vorgenommen



>> 20.06.2004
[SB]
PLGeneral:
- Neue Basisklasse PLTRefCount in PLGeneral eingebaut, da dies nun bereits in mehreren Klassen verwendet wird.
  Davon abgeleitet gibt es speziell fÃ¼r das FS die Klasse PLTFSRefCount, welche zusÃ¤tzlich die Anmeldung erzeugter Objekte
  beim FileSystem Ã¼bernimmt



>> 19.06.2004
[SB]
PLFileSystem:
- Fehler behoben: Das MountParent-Attribut eines Verzeichnisses wird nun weitergegeben, wenn ein Unterverzeichnis geÃ¶ffnet
  wird. Dadurch bezeichnet MountParent jedoch nicht mehr unbedingt das direkte Superdirectory, wenn es gesetzt ist, sondern
  das Basisverzeichnis des gesamten Unterbaumes. Dies wurde ebenfalls in PLTZipFile implementiert
- Die einzelnen Implementierungen von PLTDirectory::Open() rufen nun intern OpenCanonical auf, wenn sie die Datei auf
  direktem Wege nicht Ã¶ffnen kÃ¶nnen
- PLTWin32Directory und PLTZipDirectory: EnthÃ¤lt der zu Ã¶ffnende Dateiname ein / (bzw. \) am Ende, so wird nur ein
  PLTDirectory* zurÃ¼ckgegeben. Wird nur eine Datei gefunden, beendet die Funktion mit einem Fehler und gibt NULL zurÃ¼ck
- PLTFileSystem: Mount ist nun protected, darf also nur vom FileSystem selbst (und PLTDirectory) aufgerufen werden
- Weitere kleine Fehler in Mount() und PLTWin32Directory/PLTZipDirectory behoben. Der Zugriff auf Dateien und Verzeichnisse
  scheint nun komplett zu funktionieren
- ReferenceCounting und garbage collection wurden nun auch in PLTSearchHandle implementiert, damit dies einheitlich fÃ¼r das
  gesamte FS ist
- Kleinere Fehler im ReferenceCounting und beim ObjectManagement behoben, dies scheint nun fehlerfrei zu funktionieren
  (nicht mehr benÃ¶tigte Objekte werden selbstÃ¤ndig gelÃ¶scht)
- Umstrukturierung der Open/OpenCanonical Funktionen. Dadurch konnten redundante ÃberprÃ¼fungen entfernt werden (Ãffnen von
  Verzeichnissen oder Dateien), und eine endlose Rekursion zwischen den Funktionen Open und OpenCanonical ausgeschlossen werden
- PLTDirectory::FindFirst() gibt nun einen SearchHandle zurÃ¼ck, der immer alle Dateien im Verzeichnis auflistet. Daher muÃ
  PLTSearchHandle also keine Suchmaske mehr implementieren, dies wird spÃ¤ter durch eine ContainerKlasse implementiert
- Hilfsfunktion FindFirst(pszFilter) und neue Klasse PLTSearchFilter erstellt, worÃ¼ber das Suchen von Dateien mit einem
  Filter mÃ¶glich ist. PLTSearchFilter ist jedoch noch nicht implementiert
- Die Grundfunktionen des FS sind nun *endlich* komplett implementiert, d.h. es kann auf alle Dateien und Verzeichnisse
  zugegriffen werden, wobei ZIP-Dateien bei Bedarf automatisch gemountet werden. Auch der Zugriff auf Dateien und
  Verzeichnisse Ã¼ber Dateisystemgrenzen hinweg ist mÃ¶glich. Es fehlt nun noch das Mounten von root-Verzeichnissen
  sowie die Verwaltung von Dateitypen und Suchpfaden



>> 18.06.2004
[SB]
PLFileSystem:
- Beim Ãffnen des Verzeichnisses '..' wird nun immer das korrekte Verzeichnis zurÃ¼ckgegeben, auch wenn dazu auf ein frÃ¼her
  gemountetes Verzeichnis zurÃ¼ckgegriffen werden muÃ
- OpenCanonical wurde implementiert. Diese Funktion Ã¶ffnet einen Pfad Schritt fÃ¼r Schritt, wobei wenn nÃ¶tig auch Dateisystem
  gemountet werden (z.B. ZIP-Dateien)
- On-The-Fly-Mounten implementiert (z.B. beim Ãffnen von "C:\test.zip\test.txt")



>> 16.06.2004
[SB]
PLFileSystem:
- PLTZipDirectory wurde so erweitert, daÃ nun auf ein bestimmtes Verzeichnis im ZIP-File zugegriffen werden kann.
  Mittels Open() kÃ¶nnen jetzt auch Unterverzeichnisse geÃ¶ffnet werden
- Fehler in PLTZipFile behoben: Das PLTZipFile erhÃ¶ht nun den Reference-Counter seines Zip-Verzeichnisses, damit
  dieses nicht gelÃ¶scht werden kann, solange das PLTZipFile existiert
- Zip-Implementierung wurde komplett implementiert. Der Code basiert auf unzip.c, wurde jedoch objektorientiert umgesetzt



>> 14.06.2004
[SB]
PLFileSystem:
- IsValid() wurde als Basisfunktion in PLTFileObject fertiggestellt
- PLTFSTools::ValidatePath() wurde implementiert. Diese Funktion validiert einen Verzeichnisnamen, indem z.B. '..'
  und '.' soweit mÃ¶glich entfernt werden, / und \ vereinheitlicht werden und sonstige Fehler mÃ¶glichst korrigiert werden



>> 11.06.2004
[SB]
PLFileSystem:
- Das Interface von PLTFileSystem wurde noch einmal komplett Ã¼berarbeitet
- Dateisysteme kÃ¶nnen nun gemountet werden, wobei der Typ des Dateisystems automatisch festgestellt wird
  (z.B. zum Mounten von ZIP-Dateien). Damit der Kontext erhalten bleibt, kann ein Basisdirectory Ã¼bergeben werden,
  welches die zu mountende Datei enthÃ¤lt



>> 05.06.2004
[SB]
PLFileSystem:
- Win32-Implementierung wurde komplett fertiggestellt



>> 04.06.2004
[SB]
PLFileSystem:
- Die Interfaces wurden noch einmal komplett umgestellt und vereinheitlicht
- Das Erzeugen und LÃ¶schen von Instanzen ist nun nur noch Ã¼ber spezielle Methoden und Klassen mÃ¶glich
- Reference-Counting fÃ¼r PLTFileObject (und abgeleitete Klassen) implementiert
- Alle erzeugten PLTFileObject-Instanzen werden nun beim PLTFileSystem gespeichert und spÃ¤testens dann gelÃ¶scht,
  wenn auch das PLTFileSystem selbst gelÃ¶scht wird
- Auch PLTFileSystem selbst besitzt nun einen Reference counter



>> 26.05.2004
[SB]
PLFileSystem:
- Die erste Version vom PLFileSystem wurde fertiggestellt



>> 11.05.2004
[CO]
- PLGeneral: PLError wurde entfernt. GelÃ¶schte Dateien: PLBuffer.h, PLError.cpp, PLError.h. Nahm desweiteren PL_ASSERT
  aus diversen Codes heraus da WENN da mÃ¼sste man dies konsequent in ALLEN Codes machen. :)



>> 30.03.04
[SB]
- Plugin-Basisklassen in PLGeneral eingebaut. Diese ist noch nicht ganz fertig, funktioniert
  aber schon ganz gut. Es fehlen noch einige Optimierungen sowie die VerknÃ¼pfung mit dem
  FileSystem, damit die Plugins leicht gefunden werden kÃ¶nnen. Auch mÃ¼Ãten die Klassen noch
  auf Linux Systeme angepaÃt werden. Wenn dies fertig ist kann ein PluginManager in der Engine
  erzeugt werden, der alle Arten von Plugins einlÃ¤dt und zur fÃ¼r VerfÃ¼gung stellt, die
  einzelnen Programmteile benutzen dann den Manager um ihre Plugins zu erzeugen



>> 25.03.04
[CO]
- Wie ich sehe hat Michael nochmals PLTBuffer verbessert... ich selbst hatte gestern in PLBuffer in PLArray
  umbenannt und mehr oder weniger komplett umgeschrieben da ich diese Klasse mittlerweile im neuen Renderer beim
  Wrappen von Render States etc verwende und die alte Klasse nicht stabil genug war. Hatte die Codes aber noch
  nicht hochgeladen - PLArray.h ist nun auf dem Server, PLBuffer.h lass ich auch erstmal noch oben nicht das da
  etwas durcheinander kommt. :)



>> 23.02.04
[CO]
- PLTStack leicht modifiziert



>> 19.02.04
[CO]
- PLTString um Funktionen zum setzen und auslesen von Zahlen hinzugefÃ¼gt.



>> 15.02.04
[CO]
- Plugin Systeme wie Entity und Sound: Dadurch das nun wÃ¤hrend der Entwicklung zwei Versionen eines jeden Plugins vorhanden
  sind (Debug und Release) gab es teils crashs da dann doppelt noch das andere z.B: Release Plugin eingeladen wurde was
  aufgrund inkompatiblem Compiler Modus einen crash verursachte. Diese Plugins haben nun intern einen vermerk ob diese im
  Release oder Debug Modus sind - Plugins in einem falschen Compiler Modus werden nun nicht mehr geladen. Nun mÃ¼sste das mit
  dem Release/Debug Problemen entgÃ¼ltig der Vergangenheit angehÃ¶ren! Wenn nun was nicht geht dann liegts nur an nichtzusammen
  passenden Release Versionen. (da z.b. eine dll veraltet ist :)
- PLTList und PLTDynamicList -> Add Funktion so erweitert das optional ein Index mitgegeben werden kann um 
  festzulegen WO in der Liste das neue Element eingefÃ¼gt wird



>> 11.02.04
[CO]
- PLTLanguageManager::GenerateLanguageList() -> Kann nun auch aus einer Preload Datei im Languages Block die verfÃ¼gbaren
  sprachen auslesen falls mal ALLE Daten in einer pak Datei sind und daher die Sprachverzeichnisse nicht direkt abgelesen
  werden kÃ¶nnen.
- PLTList + PLTDynamicList: -> Da man beim Kopieren oft Start+Anzahl trifft (siehe read etc) haben wir nun beide
  Kopier Funktionen drin, also Start+Anzahl und Start-End. (heist CopyFromTo())
  Da die Listen sehr hÃ¤ufig Verwendung finden mÃ¼sste es ok sein wenn man da etwas mehr komfort bietet.
  Die Kopier Funktionen mÃ¼ssten so nun wirklich passen. (getestet)



>> 07.02.04
[CO]
- Ein paar kleinigkeiten am alten FS geÃ¤ndert so das man nun im HDRI Viewer auch direkt pak/zip files einladen kann



>> 05.02.04
[CO]
- PLTTimer: Delay() in Sleep() umbenannt damit es identisch mit dem PLGui Sleep() ist. Ist zwar nun im GuiNative und Timer
  doppelt, aber so hat man alles Timer Relevante in der Engine sauber in einer Klasse beisammen. :)



>> 04.02.04
[CO]
- PLTDynamicList: Copy() kopierte durch <= ein Element mehr als man angab
- PLTList: Neue Funktion. Copy
- PLTBitset: Neue Funktionen: GetSize() -> Liefert die Bitset grÃ¶Ãe zurÃ¼ck
                              Copy() -> Copiert Bits in ein anderes Bitset



>> 01.02.04
[CO]
- PLTTokenizer: GetDataBlock() Funktionen erweitert. Es gibt nun neben der Block Schreibweise [X Y Z ...] auch alternativ
  {X, Y, Z ...} da man beide Schreibweisen hÃ¤ufig antrifft. wird z.B. im Ã¼berarbeiteten Material Format bei den Parametern
  verwendet um dort ein fx-Ã¤hnliches Aussehen beizubehalten damit die Grafiker nicht zu 100% umdenken mÃ¼ssen und es leicht
  ist ein fx File in unser eignes Material Format umzuschreiben.



>> 29.01.04
[CO]
- PLTList: neuer operator: Concat. Zur Verkettung zweier Listen.
  Desweiteren wurden in einem Kunstruktor noch nicht die Variablen Initialisiert. (siehe MH oben)



>> 22.01.04
[CO]
- PLTOutputDevice in PLTErrorOutputDevice und PLTError in PLError (da gleich statische instanz) umbenannt.
- Erweiterte PLGeneral Headers um jeweils ein kleines Beispiel wie man die verschiedenen Klassen einsetzt



>> 21.01.04
[CO]
- Nahm aus PLList, PLHashTable und PLStack wieder die Assertion Funktionen heraus da man durch diese selbst bei
  einfachen Templates GEZWUNGEN wurde PLGeneral ins Projekt mit einzubinden auch wenn man eigentlich 'nur' Templates
  aus PLGeneral verwendete. PLMath ist somit wie PLGeneral komplett eigenstÃ¤ndig - verwendet zwar z.B. Listen aus PLGeneral
  aber dies erfordert keine Einbindung von PLGeneral in das PLMath Projekt.
  In Klassen welche sowieso die Einbingung von PLGeneral erfordern kann man ja sorgenlos die Assert Funktionen verwenden. :)
- Einige von Michals Ã¤nderungen an String und Error wieder angepasst - ich hoffe da kam nun nichts durcheinander da unsere
  Codes diesmal stark voneinander abwichen - Michael, passe bitte auf das du nicht auf dem Server
  bereits geÃ¤nderte Dateien Ã¼berschreibst. (wie dieses Tagebuch oder Codes)
  Am besten bevor du etwas hochlÃ¤ds zur Sicherheit prÃ¼fen ob jemand was dran geÃ¤ndert hat. Am FileSystem Ã¤ndern wir erstmal
  nichts bis du nicht das ok gibst - sonst kommt das durcheinander. :)
  Sobald wir auf CVS umstellen wird das sicherlich besser da diese Programm dann heftig warnt wenn man Datein die man
  hochladen will auf dem Server geÃ¤ndert wurden.
  Ps. Es ist wirklich, wirklich wichtig das die Codes so sauber sind wie mÃ¶glich und mÃ¶glichst kein Buchstabe vom Style
  abweicht. Wir haben mittlerweile insgesammt weit mehr als 2 MB an Quellcodes und wenn man da anfÃ¤ngt mit soetwas nachlÃ¤ssig
  zu werden wird man sich ganz bestimmt spÃ¤ter mal drÃ¼ber Ã¤rgern. Von daher kommts schonmal vor das wir mehr Zeit in die Code
  pflege stecken als in das schreiben des Codes selbst... aber es lohnt sich da man sich dadurch spÃ¤ter Zeit spart!



>> 20.01.04
[CO]
- PLTTokenizer::GetDataBlockInt() und PLTTokenizer::GetDataBlockFloat() -> Brechen nun ab wenn beendende Klammer ]
  gefunden wurde und fÃ¼llen den Rest mit 0. Geben die Anzahl der gelesenen Elemente zurÃ¼ck.
  (PLModelLoad.cpp und PLTextureHandler.cpp mussten aktualisiert werden)



>> 12.01.04
[CO]
- PLTFile::GetS() -> Fehler korrigiert (sonst gibts probleme beim HDRI maps im Viewer einladen)



>> 09.01.04
[CO]
- PLGeneral.h muss nun nicht mehr inkludiert werden bevor man z.B. PLTBitset verwenden will
  (dies geschieht nun in den PLGeneral Headern automatisch)



>> 03.01.04
[CO]
- PLTDynamicList: Neue Funktion: Add() -> FÃ¼gt ein neues Element in die Liste ein und gibt einen Zeiger darauf zurÃ¼ck
- PLTBitset erweitert -> PrÃ¼ft nun auch ob ein gegebener Bit Index korrekt ist
- PLTTokenizer: Neue Funktionen: GetNextTokenBool() und GetTokenBool() -> Machen das gleiche wie die Funktionen ohne Bool
  am Ende auÃer das diese den gefundenen Token als boolean Wert zurÃ¼ckgeben (erkennt auch 'false' und 'true')
- Ãberall in Formaten wo man statt einer 1 auch 'true' schreiben kÃ¶nnte ist dies nun dank umstellung auf GetNextTokenBool()
  auch mÃ¶glich



>> 30.12.03
[CO]
- PLTString: Michales neue Ãnderungen wieder angepasst (bitte noch mehr drauf achten wie wir was schreiben Michael :)



>> 27.12.03
[CO]
- Passte noch ein paar kleinigkeiten von Michaels Ã¤nderungen an PLTString an. Find() gibt nun direkt den Index zurÃ¼ck.



>> 20.12.03
[CO]
- PLTFileSystem::GetFilenameEnding() -> Wenn Datei keine Datei endung hat so wird pszFilenameEnding nun auf "" gesetzt



>> 13.12.03
[CO]
- PLTTimer: Neue Funktion: GetTickCountLow() -> Macht das gleiche wie GetTickCount() nur mit weniger genauigkeit
- PLTDataSet.Get() -> Gibt nun NULL zurÃ¼ck wenn ungÃ¼ltiger Index -> ein paar stellen in der Engine an denen Zeiger
  verglichen werden mussten angepasst werden



>> 27.11.03
[CO]
- PLString: Neue Funktion: - TStringModule::GetUsage() -> Gibt zurÃ¼ck wie oft ein String Module verwendet wird
  Neue Operatoren: += -> HÃ¤ngt einen String an einen String an +  -> Verbindet zwei Strings zu einem neuen



>> 25.11.03
[CO]
- Mir war ein paar Minuten langweilig und da warf ich nochmal einen kurzen Blick auf PLGeneral und behob
  ein paar kleine SchÃ¶nheits fehler - also absolut unnÃ¶tige Ãnderungen. (sieht nun aber etwas universeller aus ;-)



/*********************************************************\
 *  EintrÃ¤ge aus altem Diary, damals noch ohne genaue Datum angaben. (oben -> unten = neuer -> Ã¤lter)
\*********************************************************/



[SB] Neues Projekt PLGeneral erstellt, welches alle allgemeinen Toolklassen enthÃ¤lt (Listen, Strings, ...). Die
     entsprechenden Toolklassen wurden aus PLEngine entfernt, alle Projekte wuredn umgestellt (betrifft nahezu alle
     Projekte)
[CO] In PLTypes.h stehen nun auch Daten-Typ definationen wie z.B. WORD oder DWORD
[CO] PLTTimer: Portabel gemacht -> System abhÃ¤ngige Funktionen abgekapselt
[CO] PLTFileSystem::GetValidFilename() -> PrÃ¼ft ZUERST ob eine Datei in einem Sprach Unterornder ist und somit fÃ¼r eine
     Sprache quasi 'Ã¼berladen' wird (wichtig fÃ¼r Lokalisierungen :)
[CO] PLTFileSystem: Neue Funktionen: ConvertBackslashsToSlashs() und ConvertSlashsToBackslashs()
[CO] Kleinen fehler in PLTList::Remove(int nIndex) behoben
[CO] PLTModule::IsHandler() war mittlerweile veraltet und musste daher aktualisiert werden
[CO] PLTList & PLTDynamicList um ein paar hilfreiche weitere Funktionen erweitert - auch in PLGui2
[CO] PLTLog: GetSystemMetrics herausgenommen, somit ist diese Klasse Windows unabhÃ¤ngig :)
[CO] PLTLanguageHandler: Strings werden nun anstatt mit Get() mit [] angefordert, etwas kÃ¼rzere und angenehmere
     Schreibweise :) CustomUpdate-Funktionen entfernt da wechseln der Sprache wÃ¤hrend das Programm lÃ¤uft nicht mehr
     mÃ¶glich ist. *nur probleme mach* -> API Doku um Language System erweitert
[CO] Ordnungs-Wahn: Alle Dateien nochmal durchgegangen um sicherzustellen das alle das gleiche Layout haben... also die
     Beschreibung der Dateien, #idndef usw.   Den Code durchgegangen um sicherzustellen das immer zuerst Get und danach
     erst Set funktionen kommen. (damit alles einem einheitlichen Schema folgt ;-)
[CO] File System um Ordner fÃ¼r 2D Guis erweitert, der Gui2D Loaded setzt nun wie alle anderen Loader den Dateinamen
     selbststÃ¤ndig dynamisch zusammen
[CO] PLTPluginManager: Alle Entity Plugins befinden sich in einem Module (internal, dll, entities) dessen name nun im
     Plugin selbst gespeichert wird. Mit GetModulePluginList() kann man eine Liste aller Plugins in einem Module
     anfordern. GetNumberOfModules() und GetModuleName() um Module Namen zu erhalten.
[CO] PLTTimer: Neue Funktion: Delay() -> HÃ¤lt die ausfÃ¼hrung des Programms fÃ¼r eine gewisse zeit an
[CO] PLTDataSet: Neue Funktionen: GetTotalSize() of den gesammten speicherbedarf in Bytes abzufragen GetElementSize() ->
     Liefert die grÃ¶Ãe eines grund Elements in Bytes zurÃ¼ck GetAllocated() -> Liefert die Anzahl der belegten grund
     Elements zurÃ¼ck. Desweiteren oben eine kurze Beschreibung des Data-Sets hinzugefÃ¼gt.
[CO] PLTModuleManager: Behob einen (mehr oder weniger) kleinen fehler beim Laden von Modulen... bei SetName() wird das
     Module in den Module Handler eingetragen, kann das Module nicht geladen werden so wird es nun wieder korrekt vom
     Manager entfernt (ansonnsten crash beim Laden von nicht vorhandenen Resourcen :)
[CO] PLTTools: Neue Funktionen: FlipRB3() & FlipRB4() -> Optimierte Assembler Funktionen welche die RB komponenten in
     einem RGB bzw. RGBA Buffer vertauschen... ist bei diversen Bild Formaten notwendig... und so kann man die
     Ladezeiten etwas verkÃ¼rzen :)
[CO] PLTLog: Neue Funktion: GetActive()
[CO] PLTFile um Funktionen zum Schreiben in Dateien erweitert
[CO] PLTModuleHandler: Neue Lade Funktion welche den Handler direkt mit einem Objekt lÃ¤d
[CO] Stil der Friend deklarationen in den Klassen vereinheitlicht (Ã¼ber all nun friend class, so machts auch weniger
     probleme mit den Predefinationen :)
[CO] PLTTimer: mit GetFPSLimit() & SetFPSLimit() kann man nun eine FPS limitierung einbauen, diese FPS wird dann nicht
     Ã¼berschritten... die Engine wird entsprechend aktualisiert, dadurch bleiben dem System mehr Resourcen fÃ¼r andere
     Dinge -> in fertigen Anwendungen sollte es keine FPS limitierung geben, zum Debuggen usw. kÃ¶nnte es aber nÃ¼tlich
     sein :)
[CO] PLTModelHandler: GetStaticBoundingBox() & GetCollisionBoundingBox() entfernt. Wird ein Modell geladen so Ã¼bergibt
     dieses all seine Bounding Boxes an sein Entity. Wird ein Modell entladen so verliert auch das Entity automatisch
     ALLE Bounding Boxes. Im Modell Handler selbst ist nun nur noch eine Bounding Box welche fÃ¼r die Sichtbarkeits
     bestimmung verwendet wird! (diese wird beim Modell Laden automatisch erzeugt)
[CO] PLTTools: Neue Funktionen: GetVarType() & GetVarTypeString() -> Tool-Funktionen welche einen Variable Typen in
     einen String konvertieren oder umgekehrt
[CO] Ãnderte bei den Pfadangaben die Backslashs zu Slashs damit alles einheitlich ist (es sind ja zwei verschiedene
     Schreibweisen im Umlauf :)
[CO] Alle PL-Tools in PLTools verschoben (ME, WE & Max plugin)
[CO] Die PLEBitField Flags waren falsch... das fÃ¼hrte zu einem ganz erheblichen Performance verlust (da die Clear flags
     somit schrott waren :)
[CO] PLTTools: Neue Funktionen: SetFlagsString() und GetFlagsFromString() zum setzen und auslesen eines Flag-Strings
[CO] Ist der Timer 'eingefrohren' so werden nun auch keine Eingaben usw. akzeptiert, alles steht still ;-)
[CO] PLTModuleManager & PLTModule geÃ¤ndert. Nun hat PLTModule einen zeiger zurÃ¼ck auf PLTModuleManager denn wenn der
     Name von PLTModule geÃ¤ndert wird, so muss der Module Manager aktualisiert werden! Wichtig da die Module meist mit
     ihrem Namen angesprochen werden, daher darf es keine doppelten Module Namen geben! :)  ('Hey DU!... wer ich? NEIN
     du!' ;-)
[CO] PLTTokenizer: Einige Funktionen wie z.B. FindToken() und GetDataBlockInt() setzten am Ende automatisch auf den
     nÃ¤chsten Token, dies erwies sich als ziemlich unpraktisch, daher ist dies nun geÃ¤ndert. (Funktionen welche den
     Parser verwenden wurden angepasst)
[CO] PLTModuleManager: Instance Check vorherst herausgestrichen da es ansonnsten unmÃ¶glich ist den Module Manager von
     einer Anwendung aus zu verwenden (da durch Template Problem Instance dort immer NULL), desweiteren nahm ich
     m_lstIDHashList heraus womit die Get(ID) funktion nun besser zum durchlaufen einer Module Schleife geeignet ist
[CO] Neue Funktion: PLTModuleManager::Create() -> Erzeugt ein neues Modul und liefert den Zeiger darauf zurÃ¼ck
[CO] Ãber PLTConfig kann man nun einstellen ob die 3 Ebenen visualisiert werden sollen oder nicht
[CO] PLTFileSystem::SetApplicationPath() fÃ¼gt nun am Ende automatisch ein '\' ein wenn dieses nicht vorhanden ist
[CO] Neue Window-Klasse: PLTWindowOpenDialog -> Ein Dialog zum auswÃ¤hlen von Dateien -> Nam
     PLTFileSystem::GetFilenameDialog() heraus da nun Ã¼berflÃ¼ssig
[CO] PLTList ist nun nur noch ein 'Hilfmittel', sprich, es kann keine Zeiger mehr LÃ¶schen!
[SB] Makros geringfÃ¼gig verÃ¤ndert und die Namen vereinheitlicht, Ã¼ber PL_IMPLEMENT_BASECLASS kÃ¶nnen nun auch mehrere
     Basisklassen implementiert werden
[SB] Die Makros wurden so erweitert, daÃ nun auch die Variablen der Entity-Klassen exportiert werden kÃ¶nnen. In einer
     VarTable werden diese Variablen dann mit ihren Namen gespeichert
[CO] PLTFileSystem: Neue Funktion: SetApplicationPath() -> Damit lÃ¤sst sich der Pfad der Anwendung einstellen, im Fall
     des Modell Editos kann man diesen Pfad nun einstellen
[CO] Diverse Tool-Klassen erweitert
[CO] PLTModuleManager hatte teils gleiches problem wie das PLTGui... in den Listen wurden gelÃ¶schte EintrÃ¤ge nochmals
     gelÃ¶scht...
[CO] PLTTime -> Mit m_fTimeScaleFactor lÃ¤sst sich nun ein universeller Zeit Faktor einstellen welcher IMMER angewannt
     wird. In der Konsole kann man diesen mit 'timescale 'f'' einstellen... beim Debuggen hilfreich :)
[CO] PLTPool -> Die PrioritÃ¤t eines Pool-Elements lÃ¤sst sich nun verÃ¤ndern... praktisch wenn man ein Element vor einem
     anderen haben will (z.B. Sky layer verÃ¤ndern) :)
[CO] Baute eine Profiling Tool Klasse ein welche Hilfreich bei der Ãberwachung der verschiedenen Engine Teile sein wird,
     grob gesehen ist es nur eine Klasse welche verschiedene Gruppen von Texten verwaltet... aber mit diversen
     Hilfs-Funktionen :)
[CO] Neue Tool-Klasse: PLTPool -> Verwaltet eine Gruppe von Elementen wie z.B. Animations Informationen, Anker Punkten,
     Animation Events usw.
[CO] Copy funktionen eingebaut in: PLTMesh, PLTDataSet, PLTList, PLTDynamicList, PLTStack, PLTBitset
[CO] Neue Tool-Klasse PLTBitset zum verwalten beliebiger bits (z.B. um zu vermerken ob eine Geometry schon gerendert
     wurde oder nicht)
[CO] PLTFileSystem -> Neue Funktionen -> GetOnlyFilename() und GetDirectory()
[CO] Neue Funktion: PLTTimer::GetTickCount()
[CO] PLTTokenizer: GetNextToken() liefert nun einen Zeiger auf den gefundenen Token zurÃ¼ck damit man diesen z.B. sofort
     via atoi() in eine zahl umwandeln kann
[CO] PLTList & PLTDynamicList & PLTStack: Nahm Funktionen FindFirst(), FindNext() und GetCurrent() heraus da diese
     potentielle Fehlerquellen sind und der Operator [] durch die intere Zeiger optimierung mittlerweile genauso wenig
     Performance benÃ¶tigt
[CO] Behob einen Fehler in der Listen-Klasse (beim LÃ¶schen... man, wie viele Fehler sind denn noch im Code!?? ;-)
[CO] Code sinnloserweise 'verschÃ¶nert' ;-)
[SB] PLTTokenizer: Habe einen kleinen Fehler in den Abbruchbedingungen der Parserschleife behoben: Es ist auch mÃ¶glich,
     daÃ sich z.B. Kommentare und ungÃ¼ltige Zeichen mehrfach abwechseln, diese mÃ¼ssen alle ignoriert werden und dÃ¼rfen
     nicht als korrekte Zeichen angesehen werden
[CO] Behob einen kleinen Fehler im ModuleManager (zuerst Remove() und dann Objekt selbst entladen)
[CO] Erstellte eine einheitliche Tokenizer Klasse... benannte meine Klasse um und fÃ¼gte Funktionen deiner hinzu... nun
     haben wir ein Monster Tokenizer ;-)
[SB] PLTTokenizer: Delimiters kÃ¶nnen nun auch wÃ¤hrend des Parsens ausgewechselt werden
[SB] PLTTokenizer Klasse hinzugefÃ¼gt, welche zum direkten Auslesen von Tokens aus einer Textdatei dient.
[CO] PLTParser: Neue Funktionen: CompareTokens(), FindTokens(), GetTokensValueInt(), GetTokensValueStr(),
     GetDataBlockInt(), GetDataBlockFloat(), Push(), Pop()
[CO] Das Laden aus Archiven funktioniert nun endlich!! :)
[CO] Arbeitete etwas am FileSystem weiter. U.a. kann man nun auch Ã¼ber die Klasse PLTFile aus zip Archiven laden.
[CO] FileSystem: Dateien kÃ¶nnen nun auch auÃerhalb des Spieleordners liegen
     (dies sollte man aber trotzdem vermeiden :)
[CO] Baute eine Hash-Klasse ein (PLTHash) welche z.B. im Entity Manager verwendet wird
[CO] Baute PLTString Klasse ein
[SB] Module System eingebaut
[CO] PLTDataSet wurde erweitert und kann nun auch die Daten anderer Daten sets verwenden. Dies wird z.B. in PLTMesh
     verwendet um einzelne Daten mit anderen Meshs zu teilen. Ein Vorteil dieser Technik: Kommen die geteilten Daten
     'abhanden', so werden die anderen Daten Sets darÃ¼ber informiert.
[CO] Erweiterte PLTDataSet um einzelene Elemente um alles noch dynamischer zu machen. Um z.B. Textur Koordinaten zu
     speichern kann man entweder PLTDataSet<PLFLOAT2> fTexCoord (1 element) oder PLTDataSet<float> fTexCoord (mit 2
     elementen) verwenden... wobei die letztere Technik mehr freiheiten lÃ¤sst. ;-)
[CO] umbekannt: PLTDynamicLinkedList in PLTDynamicList
[CO] umbekannt: PLTLinkedList in PLTList
[CO] beseitigte den hÃ¤sslichen Zeiger auf die delete-Funktion...  (Projekt-Einstellungen auf SE werte eingestellt :)
[CO] einen dummen Rechtschreibfehler behoben
[CO] baute dein Data Set Template ein (und erweiterte es etwas :)
[CO] viele kleine Stil anpassungen :)
[CO] Ordner strukturierung & docs
[CO] Namens Ãndung
[CO] Intel-Jpg-Lib durch Independent JPEG Group's ersetzt
