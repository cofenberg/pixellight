>> 21.02.2012
[CO]
- Added "Renderer::SetDepthRenderTarget()"



>> 16.02.2012
[CO]
PLRendererOpenGL:
- "TextureBuffer3D::InitialUploadVolumeData()": We really have to disable the automatic mipmap generation for the split, else mipmaps are generated
  for every single uploaded depth layer... which may take ages on large volume data...
PLRendererOpenGLCg:
- "CgContext::AddCgContextReference()": Our renderer is not multithreaded, so, avoid lock overhead by setting "cgSetLockingPolicy(CG_NO_LOCKS_POLICY);"



>> 13.02.2012
[CO]
PLRendererOpenGL:
- More massive volume data upload fun within "TextureBuffer3D::InitialUploadVolumeData()" (08.12.2011): When the "GL_NV_texture_compression_vtc"-extension is there
  and there's enough GPU memory available, I "hope" it's save to upload the data in one single "glTexImage3DEXT()" call instead of splitting it into multiple calls in
  order to avoid a GPU driver crash. When asking the GPU to compress the data as well as to generate mipmaps, this split will slow down the process horribly. But still
  better as a crash. Wow, getting a >500 MiB big 3D texture onto the GPU can be a lot of fun, especially when it has to work on GPUs from different vendors.
- "TextureBuffer3D::BackupDeviceData()" & "TextureBuffer3D::RestoreDeviceData()": In here we can ignore "GL_NV_texture_compression_vtc" because we're just caching the
  data for the GPU, so, the internal block order is not interesting
- Another "GL_NV_texture_compression_vtc"-extension thingy, I hope that was the last thing we have to take into account when this extension is there. Such a different
  behaviour is just evil. Added "TextureBuffer3D::GetCompressedTexImage()" used within "TextureBuffer3D::Download()". When the user requests the compressed data from the
  GPU and the "GL_NV_texture_compression_vtc"-extension is there, we also have to reorder the data blocks in order to hide this NVIDIA extension behaviour - if we don't
  do this, it would e.g. be impossible to directly save the requested data within a dds file.



>> 10.02.2012
[CO]
- Bugfix: "TextureBuffer::DownloadAsImage()" (added "09.12.2011"): The mipmap size was wrong
  -> Just noticed that one of my favourite texture tools "The Compressonator Version 1.50.1731" (64 bit, http://developer.amd.com/tools/compressonator/Pages/default.aspx )
     crashes when I try to create mipmaps for a 3D texture (used LATC1 compressed volume data). Also, when trying to load in a LATC1 compressed 3D texture containing mipmaps,
     nothing happens, no crash, no error message, just nothing. This tool is also really useful to inspect the slices of 3D textures, but unusable when using 3D textures
     with mipmaps. :/



>> 09.02.2012
[CO]
PLRendererOpenGL:
- Bugfix: "ContextWindows" when multisample antialiasing was disabled, the extensions were not initialized. I assume that I introduced this bug
  either on "07.12.2011" or "22.11.2011" when trying to simplify this overcomplicated OpenGL context creation without much success.
- Implemented 3D texture data reordering as described yesterday (08.02.2012)



>> 08.02.2012
[CO]
PLRendererOpenGL:
- Added support for "NV_texture_compression_vtc"... or to be more correct: We need test for this extension to do some special nasty stuff.
  When uploading LATC1 compressed 3D textures on AMD/ATI GPU's, there are no issues. When doing the same on NVIDIA GPU's the rendered
  volume looks pretty odd. The issue 13 in the "EXT_texture_compression_latc"-specification explains this weired behaviour:
  "
    13) Should these formats be allowed to specify 3D texture images
        when NV_texture_compression_vtc is supported?

        RESOLVED: The NV_texture_compression_vtc stacks 4x4 blocks into
        4x4x4 bricks.  It may be more desirable to represent compressed
        3D textures as simply slices of 4x4 blocks.

        However the NV_texture_compression_vtc extension expects
        data passed to the glCompressedTexImage commands to be "bricked"
        rather than blocked slices.
  "
  So, we need to check for this extension, if it's there, we need to reorder the texture data before uploading it to the GPU. I'am sure
  this will accelerate the loading times and make this easier. :/



>> 29.01.2012
[CO]
- "SetSourceCode()"-method within "Shader"/"GeometryShader": Added optional shader compiler arguments parameter
PLRendererOpenGLCg:
- Beside the namespace "CG_PROGRAM", we also have to search the namespace "CG_GLOBAL" for parameters
- When searching for parameters, ignore unused ones (the compiler may have optimized them out) because we're only interested in used stuff
-  When using Cg on a modern AMD/ATI graphics card, we only have a choice between the profiles
  "arbvp1", "arbfp1", "glslv", "glslf", "glslg" - meaning we don't have a choice and have to stick
  to GLSL because "arbvp1" & "arbfp1" are heavily out-dated.
  Sadly, there are several issues when using Cg with GLSL profiles. When using no GLSL version hint,
  old school GLSL is used which is related to fixed function stuff. This is causing heavy issues when
  using VBO because the Cg compiler is now throwing e.g. glMultiTexCoord0 into the resulting GLSL code
  as source of vertex data, but not using VBO is not an option. So, we need to provide the Cg compiler with a
  GLSL version like 150... then the next thing happens: Cg just tells us "The parameter used is invalid." when
  using "cgGLSetParameterPointer()"/"cgGLEnableClientState()". So, we have to figure out the OpenGL attribute
  location and then falling back to "glVertexAttribPointerARB()"/"glEnableVertexAttribArrayARB()" instead
  of using buggy Cg OpenGL functions. Long story, short conclusion: Using the combination
  Cg & OpenGL & GLSL & AMD-hardware is painful, but sadly NVIDIA appears to be not interested to changing anything
  on this situation... this issue is not new and nearly as old as Cg itself and I'am already fighting with this topic
  for years. Still, Cg is worth all this efforts... a shader cross-compiler is a fantastic thing...



>> 24.01.2012
[CO]
- Added "TextureBuffer::IsPowerOfTwo()"-method
PLRendererOpenGL:
- Do also use polygon offset for line and point, even when this is not supported by some other renderer API's
PLRendererOpenGLES2:
- When using "glGenerateMipmap()" to let OpenGL ES create the mipmap chain for us...
  -> Lookout! "OpenGL ES Common Profile Specification Version 2.0.25 (Full Specification) (November 2, 2010)" ->
      "3.7.11 Mipmap Generation" states:
     "If either the width or height of the level zero array are not a power or two, the error INVALID_OPERATION is generated."
  -> On "LG P990 Optimus Speed" (Tegra 2, Android 2.3.4) there was no crash
  -> "Asus Eee Pad Transformer" (Tegra 2, Android 3.2.1) crashed instead of returning an error
  -> So we really have to check for this situation by using, right, the new "TextureBuffer::IsPowerOfTwo()"-method



>> 20.01.2012
[CO]
- Bugfix: "Animation" was not initializing "m_fFrame" within "Reset()" -> "SetCurrentFrame()". To avoid such issues in the future I now copied
  all "Reset()" variable resetting into the constructor initializer list as usually done. This way we *really* know that there are known initial
  values set because it can be seen by just looking at it without the need to follow the program logic to see were it's been initialized.
  Found this bug when playing the work-in-progress Sci-Fi "realtime movie" under Linux... and suddenly noticed that some shots were not played
  correctly... at least not always, sometimes it worked... the typical indicator for "A. Memory leak" or "B. Not initialized variable". Reviewing
  the involved classes with A or B in mind revealed the issue at once. One of those horror bugs because not recognizable or exploding at once,
  not on all platforms/combinations - but when it's jumping onto you it's always fun to narrow down the issue.



>> 08.01.2012
[CO]
PLRendererOpenGLES2:
- "PLRendererOpenGLES2::TextureBuffer3D::TextureBuffer3D()": "glGenerateMipmap(GL_TEXTURE_2D)" -> "glGenerateMipmap(GL_TEXTURE_3D_OES)"



>> 02.01.2012
[CO]
- Added "DrawHelpers::DrawGradientQuad()" which is similar to "DrawQuad()", but with a nice gradient color
  (it's actually an implementation which had been removed together with "PLGui 2" on 02.07.2010)



>> 28.12.2011
[CO]
- "VertexBuffer": Added support for the "half" data type (16 bit floating point)
- "VertexBuffer": Added generic comfort methods "GetFloat()" and "SetFloat()"
- "PLRendererOpenGL": Added support for "GL_NV_half_float" and "GL_ARB_half_float_vertex"
- "PLRendererOpenGLES2": Added support for "GL_OES_vertex_half_float"
- "PLRendererOpenGL" & "PLRendererOpenGLES2": This is not performance critical, so, I use the comfort method "VertexBuffer::SetFloat()" instead of
  "VertexBuffer::GetFloat()" to fill the vertex buffer. Interesting: In a test situation the FPS was around 90 when using "Float3", and around 74 FPS
  when using "Half3". Used system: "ATI Mobility Radeon HD 4850" (512 MiB) using Catalyst 12.1 and Windows 7 64 bit. I still have to do some more
  testing to see whether or not it's the same on mobile devices, or for bigger vertex data sets.
- Bugfix: "VertexBuffer::ClearVertexAttributes()" was not resetting the size of the vertex buffer
- "VertexBuffer::AddVertexAttribute()": Reviewed "Float3" (or now also "Half3") restriction of "Normal", "Tangent" and "Binormal". At first this restriction
  looked artificially because in modern OpenGL a vertex attribute is a vertex attribute, but the "PLRenderer"-API has still support for a legacy fixed
  functions API and here normal vectors must have exactly three components.
- Current progress on testing whether or not the "half" data type within vertex buffers can be used to increase the performance beside reducing the memory
  requirements: The font rendering on a Tegra 2 smartphone was slightly better *tiny vertex buffer*. Converted on-the-fly a scene to "half"-usage to test the
  behaviour on larger vertex data... this resulted in a horrible performance on my "ATI Mobility Radeon HD 4850". Slide show, while totally fluidly when using
  float, similiar to what I noticed in the simple font rendering test, only worse. If this horrible performance is not limited to my mobile GPU, I ask myself why
  "GL_ARB_half_float_vertex" is provided in the first place when it's practically useless on ATI/AMD drivers. I wonder if it's the same on NVIDIA GPUs, have to
  check this out when I'am back at the university. At least on a Tegra 2 GL_OES_vertex_half_float is working quite fine, the performance is slightly better instead
  of incredible worse as noticed on my desktop GPU. I was unable to find visible precision errors, but still, the half data type has to be used carefully - but
  when it can be used we can half the memory consumtion of vertex data which is really useful on mobile devices with a limited amout of available memory compared
  to a desktop PC... even when the first mobile devices with 1 GiB ram are now out, 512 MiB is more common which is usually already full of up and running apps.



>> 27.12.2011
[CO]
PLRendererOpenGLES2:
- "FontTexture::CreateGlyphTextureAtlas()": When calling "glGenerateMipmap(GL_TEXTURE_2D);" before allocating the texture data by using "glTexImage2D"
  there were no issues on the smartphone "LG P990 Optimus Speed" (Tegra 2, Android 2.3.4) or on "Asus Eee Pad Transformer" (Tegra 2, Android 3.2.1).
  On "LG P920 Optimus 3D" (PowerVR SGX 540, Android 2.3.5) the App directly closed without any further information within the Android logcat.
  When calling "glGenerateMipmap(GL_TEXTURE_2D);" after allocating the texture data by using "glTexImage2D" this issue was gone. When looking into
  "OpenGL ES Common Profile Specification Version 2.0.25 (Full Specification) (November 2, 2010)" I found no information which order is the correct
  one. When thinking about this order it makes sense, but this is still just a guess how it's implemented in the graphics driver...
  Within e.g. "TextureBuffer2D" the order was already "correct".
- "DrawHelpersBackendShaders::GetAndSetGeneratedProgram()": On "LG P920 Optimus 3D" (PowerVR SGX 540, Android 2.3.5) the shader compiler gave me the detailed
  error description: "Compile failed." -> "Link Error: Fragment shader was not successfully compiled."
  There's no such error when using Tegra 2 or an OpenGL ES 2.0 emulator or a PC driver supporting native OpenGL ES 2.0. I had to play with various shader
  combinations to narror down the issue:
    if (gl_FragColor.a < AlphaReference)
      discard;
  works but
    gl_FragColor *= Color;
  or
    gl_FragColor = gl_FragColor*Color;
  or
    lowp vec4 fragmentColor = gl_FragColor;
    gl_FragColor = fragmentColor*Color;
  does not and the shader compiler gives me the mentioned error. When only writing out into gl_FragColor there are no issues.
  -> "OpenGL ES Common Profile Specification Version 2.0.25 (Full Specification) (November 2, 2010)" - "7.2 Fragment Shader Special Variables" states:
     "These variables may be written to more than once within a fragment shader. If so, the last value assigned
      is the one used in the subsequent fixed function pipeline. The values written to these variables may be
      read back after writing them. Reading from these variables before writing to them results in an undefined
      value."
  -> This appears to be a shader compiler bug - I have no other explaination for this. This means that we have to only write out into gl_FragColor
     to be on the safe side even when the official GLSL specification defines another behaviour. :/
- "Renderer::SetRenderTarget()": Added a check whether or not the surface to set is already the current surface



>> 22.12.2011
[CO]
- Bugfix within the CMake file of "PLRendererOpenGLCg": For example "cg.dll" was still copied into "<Runtime Directory>/PLRenderer/cg.dll" instead of
  "<Runtime Directory>/cg.dll"



>> 14.12.2011
[CO]
- "UniformBuffer": Added ease of use methods "CopyFrom()" and "CopyTo()"
- "ProgramUniform": Added more comments on how to use this interface
- "ProgramUniformBlock": Added more comments on how to use this interface



>> 13.12.2011
[CO]
- Added comfort renderer program wrapper "ProgramWrapper". The "Program.h"-header is slim and the program interface is designed to be universal and efficient.
  While this is fine in general, it may feel to complicated in simple daily use. For example, in order to set a program attribute one has to write for instance
    ProgramAttribute *pProgramAttribute = pProgram->GetAttribute("VertexPosition");
    if (pProgramAttribute)
        pProgramAttribute->Set(pVertexBuffer, VertexBuffer::Position);
  The purpose of this "ProgramWrapper"-interface is to make simple usage as shown in the example above more compact and direct by allowing to write
    m_pProgram->Set("VertexPosition", m_pVertexBuffer, VertexBuffer::Position)
  instead.
  Please note that "ProgramWrapper" is just an interface and no real class which can be instanced. All methods are inlined and simple. In order to use this
  interface write e.g.
    ProgramWrapper *pProgram = static_cast<ProgramWrapper*>(pShaderLanguage->CreateProgram(pVertexShader, pFragmentShader));
  This means that it is actually a hack because one has to cast an class instance to a certain class, altought the class
  instance is in fact not an instance of it. Due to the simplicity of "ProgramWrapper" and the fact that it doesn't introduce
  e.g. new variables, this is working.



>> 09.12.2011
[CO]
- Added method "TextureBuffer::GetFormatForImage()" (similar name as "TextureBuffer::GetFormatFromImage()") which returns the image (PLGraphics::Image)
  settings required to be able to store the texture buffer data within an image
- Added comfort method "TextureBuffer::DownloadAsImage()" downloading the texture buffer data into an image instance which then can for example be saved
  as dds-file. First I thought about something like "pTextureBuffer->DownloadAsImage().SaveByFilename("MyTexture.dds");", but this would have required
  to add more includes into the basic texture buffer header increasing the overall header complexity just for one tiny comfort method. :/
- Inline within PLRenderer: "Animation", "AnimationBase", "AnimationEvent", "AnimationFrameInfo", "AnimationInfo", "RendererApplication", "Effect",
  "EffectManager", "EffectPass", "EffectPassLayer", "EffectTechnique", "SPEffectPreview", "Material", "MaterialManager", "Parameter", "ParameterManager",
  "SPMaterialPreview", "RendererContext", "SPPreview", "Buffer", "Font", "FontGlyph", "FontManager", "IndexBuffer", "ProgramGenerator", "RenderStates",
  "Resource", "ResourceHandler", "SamplerStates", "Surface", "SurfaceHandler", "SurfacePainter", "SurfaceTextureBuffer", "SurfaceWindow", "SurfaceWindowHandler",
  "TextureBuffer", "TextureBufferRectangle", "VertexBuffer", "RendererBackend", "SPTexturePreview", "Texture", "TextureAni", "TextureHandler", "TextureManager"



>> 08.12.2011
[CO]
- When trying to upload a 512x512x1743 8 bit (435,75 MiB) uncompressed volume to the GPU using one "glTexImage3DEXT"-call and asking for LATC1 as
  internal format (resulting in 217,875 MiB), the result was a crash inside the graphics driver.
  -> Used system: "ATI Mobility Radeon HD 4850" (512 MiB) using Catalyst 11.11 and Windows 7 64 bit
  -> Using 512x512x128 voxel (32,00 MiB) was working
  -> Using 512x512x255 voxel (63,75 MiB) was working as well
  -> Using 512x512x256 voxel (64,00 MiB) or more -> Crash inside the graphics driver
  -> So, to be on the safe side, do not upload big volume textures using one "glTexImage3DEXT"-call,
     split the upload into multiple "glTexSubImage3DEXT"-calls
  -> Hopefully 32,00 MiB per "glTexSubImage3DEXT"-call is fine across various graphics cards
  -> The ugly stuff is handled within the new "TextureBuffer3D::InitialUploadVolumeData()"-method. I'am sure more similar handling is required
     within "TextureBuffer3D" and "TextureBuffer2DArray" but for now I'am totally happy to be able to upload a 512x512x1743 8 bit volume and
     compressing it by using LATC1 in order to enable my "ATI Mobility Radeon HD 4850" (512 MiB) to handle this volume wihout been forced to
     scale it down to be able to at least use it (performance is another topic :).
  -> Creating a 3D texture is still easy, just use e.g. "cRenderer.CreateTextureBuffer3D(cImage, TextureBuffer::LATC1, 0)", the renderer hides the
     internal complexity
- Bugfix: "PLRendererOpenGL::Renderer::ChooseFormats()" was also returning compression formats even when the data type of the given image was not "byte"



>> 07.12.2011
[CO]
- Within my master thesis I have to deal with quite big texture data... so, I need a way to figure out how much graphics memory is available
  in order to make the correct decisions what to do with the data.
  While this task sounds simple, it isn't, at least when using OpenGL. Nowadays there are extensions like GL_NVX_gpu_memory_info (NVIDIA),
  WGL_AMD_gpu_association (AMD Windows) and GLX_AMD_gpu_association (AMD Linux) as well as GL_ATI_meminfo (AMD).
  I tried over an hour to get WGL_AMD_gpu_association up and running on my "ATI Mobility Radeon HD 4850" using Catalyst 11.11, without much
  success. While "wglGetContextGPUIDAMD()" gave me "1" which looks correct, everything else totally failed. I really tried all combinations
  I was able to think of, read the AMD whitepaper http://developer.amd.com/sdks/wgsdk/Documents/GPU_Association_WhitePaper.pdf - nothing worked.
  So, it apperars that on my system GL_ATI_meminfo is the only way which doesn't end up in a pure hacking around with versions for x-platforms.
  It's no option to just e.g. create a D3D context and ask it for the available graphics memory. "GL_ATI_meminfo" only returns the still free
  memory, divided into texture, VBO and renderbuffer memory. All three sections gave me "480" for my 512 MiB graphics card. This is close enough
  and has to do the job. On Linux it gives me 287 MiB, not really close to 512 MiB. At least the solution is simple and cross-plattform, more or less.
  On NVIDIA systems I'am using of course "GL_NVX_gpu_memory_info" which gave me the expected value (2048 MiB) on the available system.
  -> Within PLRenderer, this information is available via "PLRenderer::Capabilities::nTotalAvailableGPUMemory"



>> 29.11.2011
[CO]
- "ShaderLanguage": Added comfort methods "CreateVertexShader()", "CreateGeometryShader()" and "CreateFragmentShader()" creating a shader instance and
  setting the shader source code at once
- "ShaderLanguage": Added comfort methods "CreateProgram()" creating a GPU program and assigning shaders at once



>> 28.11.2011
[CO]
PLRendererOpenGL:
- Another Mac OS X related refactoring... after Mac OS 10.7 was installed on the available Apple system, new header chaos came up. We really, really
  have to keep X11 headers away from the Apple headers, those two constantly fighting each other. :/
  -> I'am afraid, that in the end, we also have to add Cocoa Support within PLFrontendOS.



>> 23.11.2011
[CO]
- "TextureBuffer::GetFormatFromImage()": Added support for the "DataWord" (16 bit) data type of "PLGraphics::Image"



>> 22.11.2011
[CO]
PLRendererOpenGL:
- "Renderer::RestoreDeviceStates()": Moved fixed functions stuff like "glDisable(GL_TEXTURE_1D)" into the fixed functions class
- "TextureBuffer1D::BackupDeviceData()" etc. : There's no need for "glEnable(GL_TEXTURE_1D)" (this just enables texture mapping for fixed
  functions... we can also use "glGetTexImage()" with disabled fixed functions texture mapping *g*)
- The extensions are now directly initialized from within the context implementation



>> 20.11.2011
[CO]
- "PLRenderer::DrawHelpersBackendShaders::GetProgramGenerator()": When generating a GLSL shader for OpenGL ES 2.0, my graphics driver no longer accepts
  "#extension GL_ARB_texture_rectangle : enable" within a GLSL shader targeting OpenGL ES 2.0... the driver then just hangs. So, in order to make it easier
  for the driver, "#extension GL_ARB_texture_rectangle : enable" is now added to the shader string dynamically, but only when not targeting OpenGL ES 2.0.
  This is correct, but interesting that the graphics driver suddenly no longer ignores unknown extensions.
- Added support for 2D array textures (kind of 3D texture, but without filtering between the depth layers)
PLRendererOpenGL:
- Added support for 2D array textures ("GL_EXT_texture_array"-extension)
PLRendererOpenGLES2:
- 3D textures using the "GL_OES_texture_3D"-extension are now working (at least using the desktop native OpenGL ES 2.0 support)
- Added support for 2D array textures ("GL_EXT_texture_array"-extension)
  -> A funny thing: Tegra 2 has support for the extension "GL_EXT_texture_array", but has no support
     for the "GL_OES_texture_3D"-extension. At least it's not listed in the extension string.
     "GL_EXT_texture_array" is reusing functions defined by "GL_OES_texture_3D"... and therefore we're
     now getting the function pointers of "GL_OES_texture_3D" to be able to use "GL_EXT_texture_array".
     Works even when "GL_OES_texture_3D" is not listed. Nice.



>> 13.11.2011
[SW]
- "PLRendererOpenGLES2" Extended under linux the check for the right lib to load for EGL/GLES. Because the opensource drivers provides the libEGL.so and libGLESv2.so libs for EGL/GLES. But the closed source drivers doesn't.
  On the systen the opensource version might be present so first check libGL.so if it contains the eglGetProcAddress if not the try the separate EGL/GLES libs.



>> 13.11.2011
[CO]
- "PLRendererOpenGL": The header refactoring within this project a few days ago was really worth the effort, there are now fewer header-order issues. Still,
  there are some places were I have to include Apple headers in the end, else there are tons of compiler issues introduced by those Apple headers. Header inclusion
  order should never ever matter, but when it comes to OS headers it usually does. OS headers are usually written in C with a lot of definitions - and the names
  used within the OS definitions then can't be used e.g. within classes, within totally different namespaces. C-definitions don't care about namespaces. This means
  to analyze cryptic compiler errors in order to figure out that e.g. I have to define "Never" right after including OS headers. Each platform has it's own, other
  definitions - when you got it working on one platform it doesn't mean that your free to use e.g. "GetCurrentDirectory" as method name on another platform. Would
  be boring otherwise. Especially Apple is really port-hell, the language mixup required in order to access the Cocoa-API, which can only be accessed by using Obj-C,
  isn't that much fun. I'am glad that using Objective-C++ is working now - wasn't working with my own build GCC 4.6 because support for this language has to be activated
  manually. Which I of course hadn't. I wasn't able to compile GCC a second time, just got tons of errors during build and after a few hours I gave it up. That's the
  reason why I spend time in making PixelLight compile by using GCC 4.2 shipped with Mac OS X. This compiler has build in Objective-C++ support. By using Objective-C++
  it's possible to reuse and access existing C++ interfaces, while being able to include Cocoa Obj-C headers and e.g. using Obj-C style object construction while been
  able to use C++ style method calls. Finally, after weeks of struggling with all those issues I was now able to mix C++ and Obj-C code which is required within the
  OpenGL renderer in order to connect the OpenGL-context created by using C with the window, created in C, by using an Obj-C API just to be able to render into a window.
  My brain hurts.
  I hope the rest of the OpenGL renderer port isn't that painful as well. Why I wrote all that in here? It's a reminder why you really don't want to include OS
  headers and using OS features directly. I'am really glad that we decided directly in the beginning of the development that OS headers shouldn't be included into
  headers used by a programmer using the PixelLight API.
- "PLRendererOpenGLES2" is now also compiling under Mac OS X, just had to add the definition "__unix__". We could move this definition into "LinuxGCC.cmake", but
  I'am not sure about possible negative side effects across all projects - so, for now, I keep it local.
- "PLRendererOpenGLES2" on Mac OS X now gives me the expected "Failed to find the entry point "eglGetProcAddress" within the EGL dynamic library"



>> 12.11.2011
[CO]
- "PLRendererD3D9" & "PLRendererD3D11": Updated x64 Visual Studio project settings



>> 11.11.2011
[CO]
- "PLRendererNull" & "PLRendererOpenGLES2" & "PLRendererOpenGLCg": Updated x64 Visual Studio project settings



>> 08.11.2011
[CO]
PLRendererOpenGL:
- "Renderer" is no longer derived from "Extensions"
- "Context": Added method "GetExtensions()"



>> 27.10.2011
[CO]
PLRendererOpenGL:
- Refactoring: "SurfaceWindow" has now derived classes like "SurfaceWindowLinux"



>> 26.10.2011
[CO]
PLRendererOpenGL:
- "SurfaceWindow": Added Mac OS X implementation of the methods "GetGamma()", "SetGamma()" and "GetSize()". Except for some names, they are identical
  to the Linux implementation.



>> 25.10.2011
[CO]
PLRendererOpenGL:
- Removed non public "OpenGL.tar.gz" package within "Windows_x86_32" and "Linux_x86_32" (other targets had no such package).
- "gl.h", "glu.h" and "glx.h" are from MesaLib 7.10
    - License: MIT License (http://mesa3d.org/license.html)
    - Downloaded from: ftp://ftp.freedesktop.org/pub/mesa/7.10/MesaLib-7.10.zip
-> PLRendererOpenGL can now be used without the need to worry about proprietary stuff
PLRendererOpenGLES2:
- Added a CMake option in order to make the non public "OpenGLES2.tar.gz" package only optional... it's only required in case you want to use
  the emulator instead of the native OpenGL ES 2.0 support of your graphics driver



>> 21.10.2011
[CO]
PLRendererOpenGL:
- "ContextMacOSX": Implemented CGL context creation. Not yet tested, don't know whether or not this will work at all, but I have to start somewhere
 (never developed on or used Apple stuff before).
- "Extensions": Implemented Mac OS X part (not yet tested)



>> 20.10.2011
[CO]
PLRendererOpenGL:
- Removed "ExtensionConfig" -> To complicated, to error prone, long winded to maintain, not really useful -> goodbye
  (had been deactivated for several month)
- Extension cleanup: "GL_POINT_SPRITE_ARB" & "GL_COORD_REPLACE_ARB" are within the official "glext.h" from Khronos (years ago, this was not the case,
  there wasn't even such a cool common header :)
- Extension cleanup: Removed "GL_TEXTURE_RECTANGLE_EXT" definition. "GL_TEXTURE_RECTANGLE_EXT" & "GL_TEXTURE_RECTANGLE_NV" and the resulting
  "GL_TEXTURE_RECTANGLE_ARB" have the same value. When I implemented it many years ago, there was no "GL_ARB_texture_rectangle".
- Extension cleanup: Removed "ExtensionDefinitions.h" and added an extension helper macro to make the extension handling easier to maintain
- Extension cleanup: Added "OpenGLExtensions::InitUniversal()" which is called after "OpenGLExtensions::Init()" has done it's job. While "Init()"
  has a platform dependent implementation, "InitUniversal()" has a platform independent implementation. This reduces code which is nearly
  identical across multiple platforms and should make it easier to add support for new platforms. Within "InitUniversal()", I used macros similar
  to the one I used within PLRendererOpenGLES2, this makes the implementation more compact and reusable across multiple platforms.
- Extension cleanup: Renamed the "OpenGLExtensions"-class into "Extensions" (the file itself had already this name)



>> 19.10.2011
[CO]
PLRendererOpenGL:
- All OS dependent implementations are now in subdirectories ("Windows", "Linux" and so on)
- Added empty Mac OS X classes to have something to start with (intentionally no extensions file right now)



>> 17.10.2011
[CO]
- Renamed "VertexBuffer::PSize" into "VertexBuffer::PointSize". There's a Linux definition named "PSize" causing nasty naming conflicts, but here it was
  possible to just "undefine" this namespace wasting definition. On Mac OS X this doesn't seem to work... I didn't research how it's defined because it's
  getting time consuming and stupied with this namespace wasting OS stuff. So, I now just renamed it within PixelLight (but such an action should not be
  enforced by OS headers...).
- PLRendererOpenGL: Kicked the legacy pbuffer implementation. Frame buffers are now commonly supported, even by OpenGL ES 2.0 on mobile devices. There's no
  longer a reason to keep this ugly, frequently breaking and hard to port pbuffer stuff.



>> 28.09.2011
[CO]
PLRendererOpenGLES2:
- Added support for "GL_EXT_Cg_shader" (ftp://download.nvidia.com/developer/GLSL/GLSL%20Release%20Notes%20for%20Release%2060.pdf - page 13)... a REALLY
  cool extension: If this extension is available (on Tegra 2, it is) one can directly feed OpenGL ES 2.0 with Cg shaders!
  This means that in this case, there's no need for the Cg runtime (> 6 MB) - altought there's no Cg runtime for Android anyway. Adding support within
  "PLRendererOpenGL" for this extension would be easy - but there's always the high possibility that this extension is not available (like on AMD GPUs
  as my own :). I'am sure that it's no good idea to use Cg shaders for official released Android apps because one has to assume that this extension is
  not available - but during development I'am also sure that this will become usefull, e.g. for "quick'n'dirty" rapid prototyping using already written
  Cg shaders.
  I noticed two issues with the Cg shaders:
    - When using semantics within Cg attributes, "glGetActiveAttrib()" returns the semantic (e.g. "POSITION") instead of the real attribute name
    - Inverse for matrices required
  ... so, still some minor usage details to figure out for an easy and generic usage... but hey, Cg shaders on a mobile device! :D
- Added support for "GL_OES_texture_3D"
- Added support for "GL_NV_get_tex_image"
- Added support for "GL_OES_mapbuffer"
- Added support for "GL_ARB_draw_buffers", "GL_NV_fbo_color_attachments", "GL_NV_read_buffer", "GL_ANGLE_framebuffer_blit", "GL_ANGLE_framebuffer_multisample",
  "GL_OES_packed_depth_stencil", "GL_OES_depth24" and "GL_OES_depth32"
  -> "FrameBufferObject" has now the same feature set as the OpenGL renderer (and there's still a render to texture refactoring on my list :)
  -> Multi render targets (MRT) is now working on my Tegra 2 smartphone, tested it with 4 render targets, there are up to 8 render targets supported... WOW! :D
    (meaning it's technically possible to also use deferred rendering on Tegra 2 smartphones)



>> 27.09.2011
[CO]
PLRendererOpenGLES2:
- The OpenGL ES 2.0 emulator from ARM can now be used under Linux as well (although it's horrible slow compared to MS Windows, at least on my system)
- Using native OpenGL ES 2.0 on a desktop PC under Linux is now working as well, at least the initalization... right now, when running something there's just a black
  flickering something visible (all EGL and OpenGL ES 2.0 entry points were found, no errors within the log etc.)...
- Linux: "ContextRuntimeLinking::LoadGLESEntryPoints()": When "eglGetProcAddress()" is used to get the OpenGL ES 2.0 function entry points, I see at least something
  (although there's some window flickering from time to time)
- Linux: Ok, it looks like that the "flickering" has something to do with the colormap and that EGL creates an own colormap. When moving around the window, one can clearly
  see that the rendering area stays at the previous position and the window content is black - after stopping the window move around, the render area snaps to the new window
  position. I tried to fix that, but without any luck... maybe someone else can figure out how to solve this?
- Added support for "GL_OES_element_index_uint"
- Added support for "GL_EXT_texture_filter_anisotropic"
- Implemented "Renderer::SetupCapabilities()"
- Added support for "GL_EXT_texture_compression_dxt1" (just a subset of "GL_EXT_texture_compression_s3tc")



>> 25.09.2011
[CO]
- "PLRendererOpenGLES2": Added support for "GL_EXT_texture_compression_s3tc", "GL_EXT_texture_compression_latc" and "GL_AMD_compressed_3DC_texture"



>> 13.09.2011
[CO]
- "PLCore::FrontendConfig" and "PLRenderer::Config" have now the same default size (800x600 still feels quite fine during development)
- "PLRendererOpenGLES2": Implemented render to texture using "PLRendererOpenGL" as base. Please note that this is definitly not optimal and not final... but
  right now I don't want to do the required render to texture refactoring within PLRenderer... the current render to texture design is from the time were one had
  to use e.g. "pbuffer" and the "framebuffer"-extension of OpenGL was not yet existing. So, the current PLRenderer render to texture interface is somewhat out-of-date
  (but for now, it is still usable).



>> 06.09.2011
[CO]
- "PLRendererOpenGLES2": Added Android part to the EGL headers



>> 04.09.2011
[CO]
- Moved the null font manager implementation from "PLRendererNull" into "PLRenderer" backend tools
- "PLRendererOpenGL" & "PLRendererOpenGLES2": It's now possible to disable the font support and by doing so removing the freetype external dependency. Usually
  font support is a nice thing to have - except when you start porting to a new platform and want to see first "proof of concept" results as fast as possible
  before you start to hammer out the details.



>> 01.09.2011
[CO]
- "PLRendererOpenGLES2": The runtime linking approach used in "ContextDesktop" is working really well... time to realize a single source solution working for
  desktop, emulator and mobile device without reconfigurating the CMake file or the source code. This makes it really easier to use the OpenGL GL 2.0 renderer
  and it's now also possible to switch between desktop or emulator by just adding the emulator dlls into the same directory as the renderer dll or removing them
  from this directory. No need to recompile.
  -> Renamed "ContextDesktop" into "ContextRuntimeLinking" and removed "ContextEmulator" and "ContextNative"
- "Renderer": Added "IsInitialized()"-method returning whether or not the renderer instance was initialized successfully within it's constructor
- "RendererContext::CreateInstance()": In case the renderer instance was not initialized successfully within it's constructor, the created instance is destroyed
  and a null pointer will be returned (would be be to dangerous to use a not correctly initialized renderer instance)



>> 31.08.2011
[CO]
- Android port related: "PLRendererOpenGLES2": No X11 when using Android
- Android port related: "PLRendererOpenGLES2" is now compiling as well (when configuring "CMakeFile.txt", this will be changed soon, but one step after another :)



>> 27.08.2011
[CO]
- D'OH! After one hour of experiments it appears that the native OpenGL ES 2.0 support of my ATI desktop driver ("AMD Catalyst 11.8", Windows 7 64 bit,
  "ATI Mobility Radeon HD 4850" with Windows Aero deactivated) can't deal with multiple windows. Until now, the OpenGL renderer implementations
  always created an internal dummy window because OpenGL just needs an OS window to work in the first place... even if your application doesn't
  have a window at all because you're only rendering into background buffers.
  The renderer context is by design window independent, it doesn't even know anything about one or multiple windows (renderer targets). The renderer
  instance is connected with the renderer context. So, the renderer doesn't depend on an OS window as well, but the internal renderer implementation
  may need an OS window. If you have an OS main window which is valid as long as the renderer context instance exists, it's highly recommended to tell
  the renderer context of this main window during creation, else the internal renderer may create it's own invisible dummy window. Most times, there's
  no problem with an invisible dummy window holding a renderer implementation together. Sadly, there are e.g. some OpenGL ES 2.0 implementations which
  just fail when using multiple windows (the internal invisible dummy window and the real visible one => two windows).
  In a nutshell:
  - If you've already got an OS main window which is valid as long as the renderer context instance exists, just tell the renderer
    context about it
  - If you don't have such an OS main window, don't create one just for the renderer context and pass in "NULL_HANDLE", the renderer
    implementation must be able to deal with this situation on it's own
- Bugfix: PLRendererOpenGL & PLRendererOpenGLES2: Automatic texture uncompression was broken ("Passing "empty" images to the GPU no longer creates internal
  image data"-change in PixelLight 0.9.6-R1)
  Bug birth "22.03.2011", but death "27.08.2011": PLRendererOpenGL & PLRendererOpenGLES2: When there's an image without data, e.g. "glTexImage2D()" is
  called with nullptr instead of "ImageBuffer::GetData()" which creates internal image data although it's not required... but only if there's also no
  compressed data available as well! In here, the new "PLGraphics::ImageBuffer::HasAnyData()"-method is now used instead of the
  "PLGraphics::ImageBuffer::HasData()"-method just looking for uncompressed data.
- "PLRendererOpenGLES2" -> "FontManager_GLSL.h": The native OpenGL ES 2.0 support of my ATI desktop driver now eats this shader as well



>> 26.08.2011
[CO]
- PLRendererOpenGLES: Current AMD GPU drivers are (at least in theory) able to provide native OpenGL ES 2.0 support. So, this renderer implementation now
  has three supported use cases:
  - Emulator (for development)
  - Desktop using GPU drivers supporting this (primarily for development)
  - Native (for the mobile devices)
  First, I just saw nothing at all when using the desktop version. No errors, no crashes, but also no graphics. Tested it with "AMD Catalyst 11.8" and Windows
  7 64 bit on a "ATI Mobility Radeon HD 4850" with Windows Aero active. As soon as I disabled Windows Aero all went fine. Good that I tried that after over two
  hours of research and experiments... "(?!$$(!"=$/()=!"$
  Ok, looks like a driver bug or so, but it's really cool that I can now use OpenGL ES 2.0 on my desktop without an emulator! :D
- Renamed PLRendererOpenGLES into PLRendererOpenGLES2 to avoid any future name conflicts



>> 20.08.2011
[CO]
- "FontManager::GetFontTexture()": Font filename comparison should only be done on the absolute paths to be on the safe side



>> 19.08.2011
[CO]
- "RendererApplication" is using the display mode settings from the configuration again



>> 16.08.2011
[CO]
- "RendererContext" destructor was virtual, but it shouldn't be
- Renamed "PLRendererOpenGLCg::ShaderToolsCg" into "PLRendererOpenGLCg::CgContext"



>> 13.08.2011
[CO]
- Removed default font options within the renderer configuration. The font manager itself has now a build in default texture font. In order to remove the default
  texture font or to set another default texture font, just set it during the application initialization.
- Renamed "RendererBackend::GetStatisticsT()" into "RendererBackend::GetWritableStatistics()"



>> 07.08.2011
[CO]
- Renamed "Surface::Update()" into "Surface::Draw()" to make clear that this method is considered to only draw and not e.g. update the complete game logic
- "RendererApplication": Removed "IsFullscreen()" and "SetFullscreen()", this stuff is now part of the frontend-side



>> 06.08.2011
[CO]
- Removed "RendererApplication::Update()"
- "RendererApplication::OnUpdate()" is now an overridden method of "PLCore::AbstractFrontend"
- "RendererBackend::Update()" no longer updates (= redraws) the renderer surfaces
- "RendererApplication::OnDraw()" now only updates the primary frontend renderer surface, while "update" only means "draw"



>> 04.08.2011
[CO]
- Moved "RenderApplication" from "PLEngine" into "PLRenderer". It's now finally possible to use RenderApplication for applications just using PLRenderer... until now
  one had to also include a bunch of other high level components like PLMesh, PLScene, PLEngine... and of course also the big project PLGui...
  It should be possible to write bare minimum applications just using PLRenderer for basic rendering without the need to use any high level components like meshes or
  the scene graph. This should also make it easier to port PixelLight to new platforms - in order to use e.g. the sample application 50RendererTriangle to test
  PLRenderer, one doesn't need to port/compile everything up to PLEngine to do so.
- Renamed "RenderApplication" into "RendererApplication" so that one can guess the name of this class by just knowing the component name it's in



>> 24.05.2011
[CO]
PLRendererOpenGLEs:
- Bugfix: "ShaderLanguageGLSL": "pl_class" and "pl_implement_class(ShaderLanguageGLSL)" was missing
PLRendererOpenGLCg:
- Bugfix: "ShaderLanguageCg": "pl_implement_class(ShaderLanguageCg)" was missing



>> 09.05.2011
[CO]
- Bugfix: "TextureManager::CreateTexture()" set a new instance of "ResourceHandler" which was totally wrong because there were already an instance.
  Thank you "jacky" for pointing this out within the PixelLight forum at http://dev.pixellight.org/forum/viewtopic.php?f=6&t=47
  This whole "m_bShareTextureBuffer" looks somewhat messy, but right now I don't dare to refactor something in here because I'am currently working on totally different
  stuff.



>> 08.05.2011
[CO]
- Added "Capabilities::bTextureBufferNonPowerOfTwo", if it's "true" there are no power of two restrictions for all texture buffer types (yeah! :)
- "Renderer": Added "IsValidTextureBuffer1DSize()" & "IsValidTextureBuffer2DSize()" & "IsValidTextureBufferRectangleSize()" & "IsValidTextureBuffer3DSize()" &
  "IsValidTextureBufferCubeSize()" to make validating a texture buffer size more comfortable. Modern graphics APIs/extensions and GPUs have finally removed nearly all
  limitations from the texture buffers, except for maximum size of course. The renderer interface and PixelLight in general must stay compatible with legacy stuff so
  there are multiple test methods instead of just one for all texture buffer types.
PLRendererOpenGL:
- If "GL_ARB_texture_non_power_of_two" is available "Capabilities::bTextureBufferNonPowerOfTwo" is set to "true"



>> 22.04.2011
[CO]
- Added a version of "DrawHelpers::DrawImage()" with an 3D image position and an object space to clip space matrix as parameters
PLRendererOpenGL:
- "gl_PointSize" in GLSL and "PSIZE" in Cg had no effect because "GL_VERTEX_PROGRAM_POINT_SIZE_ARB" was not enabled
  (see from http://www.opengl.org/registry/specs/ARB/vertex_program.txt -> "(42) How does PointSize work with vertex programs?" for more information)



>> 16.04.2011
[CO]
PLRendererOpenGL:
- Added support for the OpenGL extension "GL_EXT_transform_feedback", currently only used for the binding point of "GL_ARB_uniform_buffer_object"
  (but transform feedback support is planned!)



>> 15.04.2011
[CO]
- "PLRendererOpenGLCg::ProgramCg" was emitting the "EventDirty"-event when the program destructor was called while "PLRendererOpenGL::ProgramGLSL" was not,
  "PLRendererOpenGL::ProgramGLSL" is now emitting this event within the destructor as well
- Added "uniform buffer" (UBO, aka "constant buffer") support



>> 10.04.2011
[CO]
- Added "TextureBuffer::IsDepthFormat()" which returns whether or not a texture buffer format is a depth buffer format
PLRendererOpenGL:
- Ouch! When using a depth buffer texture format (D16, D24, D32) "FrameBufferObject::Initialize()" was also adding a color buffer, fixed that. The interesting
  thing is that my ATI driver never told me "Incomplete attachment frame buffer object" while the NVIDIA sytem, I'am using for testing, told me at once that
  there's something wrong...



>> 08.04.2011
[CO]
- "Parameter::Parameter()" sets the value by default to zero
- Added "ParameterManager::OnParameterChange()" which is called when a parameter has been changed (created, destroyed, value changed)
- Added "ParameterManager::EventParameterChanged"-event which is called when a parameter has been changed (created, destroyed, value changed)
- Added "Material::EventParameterChanged"-event which is called when a parameter has been changed (created, destroyed, value changed)



>> 01.04.2011
[CO]
- Ok, I have enough of this GLSL precision qualifiers issues on NVIDIA systems... now I've receive a "error C1101: ambiguous overloaded function reference
  "clamp(lowp float, float, float)"" while everything works on my AMD/ATI system. I removed the precision qualifiers from all none OpenGL ES 2.0
  runnable shaders, and for those GLSL shaders targeting OpenGL as well as OpenGL ES 2.0, I will remove precision qualifiers from the shader source
  code before passing it to OpenGL. It's just not worth all this issues and it's really sad that there are that many issues with the different
  GPU driver implementations of precision qualifiers (which, as mentioned, on OpenGL have no real effect anyway... at least according to the
  specification... but who cares about specifications anyway, beside me?!).
- Finally removed "PLRenderer::ProgramGenerator::ApplyGLSLHacks()"... again... see diary entries from "07.07.2010", "26.11.2010" and "01.12.2010" for
  more detail (written in German at this time)
- Added "Shader::RemovePrecisionQualifiersFromGLSL()" which is in fact the "PLRenderer::ProgramGenerator::ApplyGLSLHacks()", but this is no longer a
  hack - it's a feature *g*
-> ... cool, it finally looks like that the GLSL shaders are now working properly on my AMD/ATI system as well as the NVIDIA system at my university.
   While the NVIDIA driver is totally fixed on the given GLSL version and blames each and every single wrong set point (this is a good thing!!!),
   the AMD/ATI driver isn't really that interested in the given GLSL version. Sadly, this means when I'am working with GLSL shaders, I can never be sure
   whether or not I missed a GLSL version issue because the AMD/ATI driver probablity won't tell me what I've done wrong according to the selected
   GLSL version. :/



>> 31.03.2011
[CO]
- I was wondering for some time now why on NVIDIA systems there were some issues when using GLSL. Finally I had the possibility and time to check this
  issue in detail using the NVIDIA system at my university. It took me just a few minutes to figure it out that the issue had to do with the "#version"
  directive of GLSL. I was aware that there's such a precompiler definition, and I already put it as comment into the GLSL shader codes as a reminder...
  the reason to don't add a version information was to create one GLSL shader that can be used on e.g. OpenGL and OpenGL ES 2.0 at the same time. On my
  ATI system this approach worked really well, but as mentioned this way was not working the same on NVIDIA systems... and after having a look into the
  OpenGL specification I just noticed that the ATI driver handles this thing "wrong", meaning not according to the specification:
    "The OpenGLÂ® Shading Language - Language Version: 3.30 - Document Revision: 6 - 11-Mar-2010" Page 14: "Version 1.10 of the language does not require
     shaders to include this directive, and shaders that do not include a #version directive will be treated as targeting version 1.10."
  Ok, this means that one REALLY has to put the GLSL version into the shader source code... but I still try to keep some shaders OpenGL ES 2.0 usable by
  adding the version definition at runtime. I think for the deferred renderer shaders I can but the version directly into the shaders and use more modern
  GLSL language constructs because it will not really run on OpenGL ES 2.0 anyway.
  In GLSL, "#version" must occur before any other statement in the program as stated within:
    "The OpenGLÂ® Shading Language - Language Version: 3.30 - Document Revision: 6 - 11-Mar-2010" Page 15: "The #version directive must occur in a shader
     before anything else, except for comments and white space."
  ... sadly, this time NVIDIA (driver: "266.58 WHQL") is not implementing the specification in detail and while on AMD/ATI drivers ("AMD Catalystâ¢ 11.3")
  you get the error message "error(#105) #version must occur before any other statement in the program" when breaking specification, NVIDIA (driver: "266.58 WHQL")
  just accepts it without any error.
  ... and another one... "Order of Qualification" ...
    "The OpenGLÂ® Shading Language - Language Version: 3.30 - Document Revision: 6 - 11-Mar-2010" Page 52:
    "4.7 Order of Qualification
     When multiple qualifications are present, they must follow a strict order. This order is as follows.
     invariant-qualifier interpolation-qualifier storage-qualifier precision-qualifier
     storage-qualifier parameter-qualifier precision-qualifier"
  NVIDIA (driver: "266.58 WHQL") did not yell at me when I wrote "in highp vec4 VertexPosition" while the AMD/ATI driver ("AMD Catalystâ¢ 11.3") throw a
  "error(#132) Syntax error: 'in' parse error" at me which, according to the specification, was the right action... I changed it yesterday from
  "highp in vec4 VertexPosition" (correct) into "in highp vec4 VertexPosition" (wrong) because the NVIDIA driver gave me a "error C7538: OpenGL does not
  allow 'highp' after 'inout'" (I was not able to find this statement in the GLSL specification!). After looking into the GLSL specification again after all
  this confusion, it looks like that the NVIDIA driver does it "wrong". I know that the precision qualifiers are for OpenGL ES 2.0 compatibilty
  and (currently) have no effect when using OpenGL, but I wanted to use them anyway. Ok, in this situation (in/out/inout) I have no chance to make it working
  using precision qualifiers on both, NVIDIA and AMD/ATI... so I just removed the precision qualifiers for this use cases... :/
  ... such things REALLY make it hard to write shaders running on a broad range of GPU's! As for me, as mentioned, I "just" have an AMD/ATI graphics card and
  no NVIDIA graphics card. At the moment, when I want to test everything on a NVIDIA system, I have to use the NVIDIA system at my university - either directly
  within the university laboratory or via horrible slow remote control. So, I can't test each and every time when making a change within the PixelLight
  codes. If any of you have a NVIDIA system and notice any strange behaviour, please tell me at once so that I can test and fix it!
- Because "PLRenderer::ProgramGenerator" adds "#define" dynamically at runtime at the top of the shader, this is a break of the GLSL specification because
  "#version" needs to be on the very top (see comments above). Therefore, "PLRenderer::ProgramGenerator" is required to also add "#version"... but I don't
  think that's a real problem. For Cg, one already had to provide a "profile"... I extended this to GLSL so that "PLRenderer::ProgramGenerator" adds a GLSL
  version if the current shader language is GLSL and profile, which is this case now contains the GLSL version, if not empty.
- Added some important GLSL comments to "Shader::SetSourceCode()" so that I hopefully never again stumble over this GLSL version issue...



>> 28.03.2011
[CO]
- Added "Renderer::GetTexelToPixelOffset()" returning the pixel origin to texel origin offset, usually (0.0, 0.0) or (-0.5, -0.5).
  OpenGL/D3D10/D3D11 have no offset while D3D9 has an offset of -0.5 (see http://msdn.microsoft.com/en-us/library/bb219690%28VS.85%29.aspx)
  -> The "libRocket"-interface requires this type of renderer API information and this is possibly not the only use case for this offset
     information



>> 25.03.2011
[CO]
- "GeometryShader" input/output primitive type and the number of output vertices can now be set by the user



>> 22.03.2011
[CO]
- PLRendererOpenGL & PLRendererOpenGLES: When there's an image without data, e.g. "glTexImage2D()" is called with nullptr instead of
  "ImageBuffer::GetData()" which creates internal image data although it's not required
PLRendererOpenGLCg:
- "ProgramCg::GetCompiledProgram()": ... when not using "cgIsProgramCompiled()", "cgGetProgramString()" may just crash in case the
  program is not compiled... crashs are never a good thing, so I added a check...
PLRenderer:
- Added "Program::IsValid()"
- Added "Renderer::GetSwapInterval()" and "Renderer::SetSwapInterval()"



>> 18.03.2011
[CO]
PLRendererD3D11:
- Continued the work on the renderer backend, it's now possible to render into multiple windows - clear to color is up and running



>> 15.03.2011
[CO]
PLRendererD3D11:
- After some discussion within the PixelLight forum at http://dev.pixellight.org/forum/viewtopic.php?f=3&t=8 I noticed that there's really interesting
  in an up and running D3D11 renderer backend... and I wanted to have a look at the latest graphics API evolution of OpenGL/D3D11 anyway. I started the
  PLRendererD3D11 project by using PLRendererNull as usual as start point.
- Device and device context creation is now implemented, I really like those feature levels of DirectX 11



>> 08.03.2011
[CO]
PLRendererOpenGL:
- Linux: My OS OpenGL header automatically (!) included "glext.h", which was of course out-of-date... so, I was forced to define "GL_GLEXT_LEGACY" to
  deactivate this include behaviour
- Linux: "ContextLinux::SwapInterval()" was using "glXSwapIntervalSGI" without checking whether or not the extension is actually available
- Linux: Wow, "glXSwapIntervalSGI" was used without been defined or initialized, I wonder why it worked at all...
  ... at least for most people. This bug was found by a user which got an "libPLRendererOpenGL.so: undefined symbol: glXSwapIntervalSGI"
  (PixelLight forum post: http://dev.pixellight.org/forum/viewtopic.php?f=6&t=5)



>> 25.02.2011
[CO]
- Added "PLRenderer::Program::GetCompiledProgram()"
PLRendererOpenGL:
- Added support for "GL_ARB_get_program_binary" - but sadly, "glGetProgramivARB(nOpenGLProgram, GL_PROGRAM_BINARY_LENGTH, &nBinaryLength);" returns
  always 0? (Catalyst 11.2 - there are forum posts reporting similar problems, a driver issue?)
  As a result, I can't implement "load from binary object" because I'am not able to test it right now. :/
  At least the Cg implementation of this new method works, in my test, I received the GLSL codes compiled from the provided Cg shader codes.



>> 19.02.2011
[CO]
PLRendererOpenGL:
- Implemented "RenderState::PointScaleEnable"



>> 28.01.2011
[CO]
- Bugfix: "Texture::Load()": There can be the situation that the image loading was successfully, but there's still no image buffer -
  we really have to deal with this situation properly to avoid a crash



>> 27.12.2010
[CO]
- "PLRenderer::TextureBuffer::GetFormatFromImage": Added L32F support
- "PLRenderer::Texture": For floating point image data: GrayscaleA and RGB data is converted into RGBA internally so it can be used as texture



/*********************************************************\
 *  The entries below are in German only
\*********************************************************/



>> 01.12.2010
[CO]
- Ich hatte heute kurz die Gelegenheit den Dungeon Demo auf einem NVIDIA System an der Hochschule, wo ich derzeit fÃ¼r meinen
  Master studiere, zu testen... leider bekam ich tausende von Shader Compiler fehler, die Ã¤ltere Version mit GLSL hack ging
  allerdings - verdammt. Hab den Hack erstmal wieder rein und schau zu morgen auf diesem NVIDIA System mal die neusten Treiber
  zu installieren und nochmals zu testen... unglaublich dieses unterschiedliche Treiber verhalten, vorallem wenns laut OpenGL
  Spezifikation gehen sollte (diesmal sich also die ATI Treiber korrekt verhalten)...



>> 26.11.2010
[CO]
- Die am "07.07.2010" (siehe entsprechenden Tagebucheintrag fÃ¼r mehr Informationen) erstellte Methode "PLRenderer::ProgramGenerator::ApplyGLSLHacks()"
  entfernt da es scheinbar mittlerweile auch ohne geht - hoffentlich wirklich ohne Probleme auf NVIDIA-Karten... denn solche Hacks (nur weil ein GPU-Treiber
  sich nicht an den Standard hÃ¤lt!) sind einfach nur dÃ¤mlich und bÃ¶se Seiteneffekte sind da natÃ¼rlich nicht auszuschlieÃen. WÃ¤re nett wenn jemand mit einer
  NVIDIA-Karte und aktuellen Treibern das nochmals gegentesten kÃ¶nnte.



>> 08.10.2010
[CO]
- "PLRendererOpenGL::ProgramGLSL" & "PLRendererOpenGLCg::ProgramCg": "RelinkRequired()" wird nur noch in "RestoreDeviceData()" und nicht mehr auch in
  "BackupDeviceData()" aufgerufen, es ist einfach am Geschicktesten wenn das "Dirty"-Event dann kommt, wenn es mÃ¶glich ist wieder ein neues internes
  Program zu erzeugen (von dem man sich dann z.B. direkte Zeiger auf Attribute/Uniforms speichern kann)



>> 05.10.2010
[CO]
- "DrawHelpersBackend::DrawText": Scale & Bias Parameter wurden nicht verwendet



>> 01.10.2010
[CO]
- "AbstractShader" in "Shader" umbenannt da der Name "Shader" durch das entfernen des alten Shader-Interfaces nun wieder frei ist und es so konsistenter
  zu den anderen PLRenderer Klassennamen ist



>> 28.09.2010
[CO]
- Dank der Umbauten in der letzten Zeit, konnte ich nun endlich Cg-Support von PLRendererOpenGL in ein seperates Plugin Namens PLRendererOpenGLCg
  verschieben. (ein Plugin fÃ¼r ein Plugin *g*) Cg hat seine Vorteile, hat aber leider genauso auch einige Nachteile - z.B. eher mangelhafter Support
  fÃ¼r ATI Grafikkarten, ist nicht OpenSource + die Header & Libs darf man nicht weiterverbreiten so das jeder der PL Ã¼bersetzen will zuerst Cg installieren
  muss... und ganz nebenbei sind die Cg dlls mittlerweile 6,5 MB groÃ und scheinen mit jedem neuen Release auch weiter zu wachsen. Dies sind also mehr
  als genug GrÃ¼nde die dafÃ¼r sprechen Cg nun komplett Optional zu machen, mit GLSL ist man einfach etwas leichtgewichtiger unterwegs da die Shader-Compiler hier
  direkt in den Grafikkarten-Treibern integriert sind.



>> 27.09.2010
[CO]
- "ShaderLanguage"-Schnittstelle eingefÃ¼hrt. Da zukÃ¼nftig in z.B. PLRendererOpenGL Shader Sprachen Ã¼ber Plugins hinzugefÃ¼gt werden kÃ¶nnen sollen
  (z.B. Cg wird rein optional Ã¼ber Plugin), macht eine eigene Schnittstelle denke ich wirklich Sinn. In der "Renderer" Klasse wurden die Methoden
  CreateVertexShader(), CreateGeometryShader(), CreateFragmentShader(), CreateProgram() entfernt - diese Methoden liegen nun in "ShaderLanguage".
  (mittlerweile gibts noch einige weitere neue Shader Typen die wir noch nicht unterstÃ¼tzen... da wÃ¼rde es auf die Dauer in "Renderer" auch ziemlich
  voll werden :/)
  Ãber z.B. "Renderer::GetShaderLanguage(<Name>)" lÃ¤sst sich eine Instanz einer Shadersprache anfragen.
PLRendererOpenGL:
- ProgramCg::BuildUniformInformation(): Einzelnde Array Elemente kÃ¶nnen nun z.B. Ã¼ber "MyArray[1]" angesprochen werden
- ProgramCg::BuildAttributeInformation(): Elemente einer Struktur kÃ¶nnen nun Ã¼ber z.B. "MyStructure.MyPosition" angesprochen werden
- ProgramCg & ProgramGLSL sind nun von der Basisklass Program, und ProgramUniformCg & ProgramUniformGLSL sind nun von der Basisklass ProgramUniform
  abgeleitet, damit fallen an zwei stellen Shadersprachen-Fallunterscheidungen weg



>> 26.09.2010
[CO]
- Effekt-Klassen auf das neue Shader-Interface umgestellt
- Das alte Shader-Interface endlich entfernt :D



>> 17.09.2010
[CO]
PLRendererOpenGL:
- "FixedFunctions::SetVertexBuffer()": Vertex Attribute werden nun nicht mehr in "VertexBuffer::MakeCurrent()" an z.B. "glNormalPointer" fÃ¼r Fixed Functions
  Rendering Ã¼bergeben, sondern in "FixedFunctions::SetVertexBuffer()" so das die (grausamen) Fixed Functions Dinge beisammen sind
- "VertexBuffer::MakeCurrent()" durch "BindAndUpdate()" ersetzt - die neue Implementation ist *sehr* schlank, im Grunde nur "glBindBufferARB" und falls nÃ¶tig
  ein "glBufferSubDataARB" um die VBO Daten auf der GPU zu aktualisieren



>> 07.09.2010
[CO]
PLRendererOpenGL:
- ProgramCg: MakeCurrent()/UnmakeCurrent() dÃ¼rfen cgGLEnableClientState/cgGLDisableClientState NUR bei Vertex Program Attributen aufrufen
- Renderer::SetProgram(): Bis das alte Shader Interface raus ist, wird hier noch geprÃ¼ft ob momentan ein Shader Ã¼ber das alte Shader Interface gesetzt wurde,
  wenn ja, wird das hier zurÃ¼ckgesetzt.
- "Renderer::SetProgram(" setzt kein "glUseProgramObjectARB(0)" mehr, das ist Job von "ProgramGLSL::UnmakeCurrent()"... das machte als ich das neue Shader Interface
  implementierte noch Probleme, nun scheint es aber mittlerweile endlich sauber zu laufen :D



>> 06.09.2010
[CO]
PLRendererOpenGL:
- "ATI2N" Support lÃ¤uft (es folgen noch ein paar Arbeitsschritte). GegenÃ¼ber "DXT5 xGxR" hat man zwar keine Speicherersparnis, die QualitÃ¤t ist allerdings besser.
  (siehe http://developer.nvidia.com/object/real-time-normal-map-dxt-compression.html und http://www.ozone3d.net/tutorials/bump_map_compression_p4.php)
  Von den Namen her ist das wieder herrlich, ATI fÃ¼hrte das unter dem Marketingnamen 3DC ein, technisch bezeichnet man das als ATI2N, mittlerweile
  gibts ne universellere OpenGL Extension die auch auf NVIDIA Karten lÃ¤uft und das LATC2 nennt, in DirectX 10 ist es unter BC5 bekannt... *g*
  Ich unterstÃ¼tze ebenfalls "Alternate XY Swizzle ATI2N", dies ist vergleichbar zu "DXT5 xGxR", beides kann mit "The Compressonator" von ATI erzeugt werden...
  das hat den Vorteil das ich die Shader in den Compositing Schritten NICHT erweitern muss, da bei "ATI2N" der Rest wie bei "DXT5 xGxR" ablÃ¤uft.
  (sprich, 3'te Komponente errechnen)
- "GL_ATI_texture_compression_3dc" scheint am Aussterben zu sein, "GL_EXT_texture_compression_latc" heiÃt der "quasi Nachfolger" der ebenfalls auf NVIDIA Karten lÃ¤uft.
  "ATI2N" in "LATC2" umbenannt (das Format an sich ist das gleiche!) und Support fÃ¼r "GL_EXT_texture_compression_latc" hinzugefÃ¼gt das StandardmÃ¤Ãig verwendet
  wird, erst wenn diese Erweiterung nicht vorhanden ist, wird nach "GL_ATI_texture_compression_3dc" gesucht. (hÃ¤tte ich RGTC2 gewÃ¤hlt, wÃ¤re das nicht RÃ¼ckwÃ¤rtskompatibel
  zu 3DC und weitere Fallunterscheidungen mÃ¼ssten her, das wollte ich aber vermeiden)
  Ist weder "GL_EXT_texture_compression_latc" noch "GL_ATI_texture_compression_3dc" vorhanden, wird die Texture zu L8A8 auf der CPU dekomprimiert und dann so zur
  GPU gegeben, so das man trotzdem was sehen kann auch wenn dann natÃ¼rlich der Speicherverbrauch hÃ¶her ist.
  -> Da ich keine NVIDIA Karte habe, kann ich das natÃ¼rlich nicht gegentesten ob das auch sauber auf NVIDIA Karten lÃ¤uft. ZukÃ¼nftig werde ich "LATC2" im Dungeon
     Demo nutzen da dieses Feature mittlerweile eigentlich von allen halbwechs aktuellen GPU's unterstÃ¼tzt werden sollte, im PL SDK bleibe ich zur Sicherheit auf
     "DXT5 xGxR" da ich hier hÃ¶chstmÃ¶gliche KompatibilitÃ¤t haben will.
- "ATI1N" (zu dem es nicht wirklich Informationen im Netz gibt) in "LATC1" umbenannt und PLRenderer um Support fÃ¼r dieses Texture Format erweitert. Damit ist es
  endlich auch mÃ¶glich reine Luminance Texturen (z.B. Height Map) vernÃ¼mpftig zu komprimieren. Ist "GL_EXT_texture_compression_latc" nicht vorhanden, wird auf der
  CPU dekomprimiert bevor die Daten an die GPU weitergereicht werden. Wie schon bei "LATC2" hat auch "LATC1" *nur* QualitÃ¤tsvorteile, aber keinen geringeren
  Speicherbedarf gegenÃ¼ber "DXT1".



>> 05.09.2010
[CO]
PLRendererOpenGL:
- ProgramCg::UnmakeCurrent(): Hier sollte cgGLDisableClientState fÃ¼r alle Attribute aufgerufen werden... macht man das nicht und nutzt
  natives GLSL und Cg gleichzeitig, kann man Probleme bekommen was ich gerade hatte, die Vertex Daten waren dann im Cg Shader kaputt. :/
  (und dann sucht man ertmal Ewig was denn im Shader falsch sein kÃ¶nnte, obwohl dort alles richtig ist...)



>> 01.09.2010
[CO]
PLRendererOpenGL:
- SurfaceWindow: Gamma wird am Ende nur noch zurÃ¼ckgesetzt, wenn Gamma durch "SetGamma()" verÃ¤ndert wurde. Sollte das setzen von Gamma
  unerwartet mal Probleme machen, so hat man nun wenigstens keine Probleme, wenn man von der Anwendung aus nie Gamma verÃ¤ndert :D



>> 20.08.2010
[CO]
PLRendererOpenGL:
- ContextWindows::QueryDisplayModes/ContextLinux::QueryDisplayModes stellen sicher das sich unter keinen UmstÃ¤nden doppelte EintrÃ¤ge
  in der Liste befinden



>> 17.08.2010
[CO]
PLRendererOpenGL:
- "GL_ARB_texture_float"-Extension wird nun unterstÃ¼tzt und Vendor-AbhÃ¤ngigen Extensions vorgezogen, so funktionieren nun auch Float-Texturen
  unter Linux und damit auch der Deferred Renderer :D
- Capabilities::bR16G16B16A16 entfernt da mittlerweile irgendwie Witzlos



>> 11.08.2010
[CO]
- PLRendererOpenGL & PLRendererOpenGLES: "FontTexture" speicherte nur den Dateinamen der Font, aber ohne Pfad so das der Font-Manager
  dann nicht mehr wirklich prÃ¼fen konnte ob eine Font bereits im Cache ist



>> 10.08.2010
[CO]
- "FontManager::CreateFontTexture(": Hier war noch "Data/Fonts/" fest eingebaut was natÃ¼rlich nicht ok war
  (ACHTUNG: am besten alls Configs lÃ¶schen da dort auch ein Font Dateiname steht...)



>> 07.08.2010
[CO]
- SPDefault Ã¼berarbeitet. Hier fliegt nun das PixelLight Logo gemÃ¼tlich durch die Gegend + ein Text erklÃ¤rt was los ist. Dadurch das nur DrawHelpers
  Dinge verwendet werden, ist das nun auch Shader & Fixed Functions unabhÃ¤ngig.



>> 04.08.2010
[CO]
- "DisplayMode": "nZBufferBits" & "nStencilBits" mÃ¼ssen wie schon die Multisample Einstellung nun einmal beim erzeugen einer Renderer Instanz
  Ã¼bergeben werden. Hintergrund ist, das diese Einstellungen scheinbar auch "global" fÃ¼r den gesamten OpenGL Context zu gelten scheinen. Versucht
  man mehrere Fenster in einem OpenGL Context zu erzeugen die z.B. unterschiedliche Stencil-Bits haben, so scheint dies auf ATI Grafikkarten zu
  funktionieren, bei NVIDIA Grafikkarten hingegen sieht man dann absolut nix mehr. Im Internet konnte ich leider keine Informationen dazu finden,
  scheinbar verwendet alle Welt nur ein einziges Fenster zum Rendern, brrr. Da wir nun mehrmals Ã¼ber dieses dÃ¤mliche Problem gestolpert sind,
  und es wohl bei diesen Einstellungen ok ist das diese fÃ¼r alle Fenster eines Renderers verwendet werden, nun diese kleine Ãnderung. Da man
  heutzutage meist erstmal in Texturen Rendert und dort wiederum andere Tiefen/Stencil Einstellungen haben kann, fÃ¤llt diese globale Einstellung
  fÃ¼r das OS Fenster wohl nochmals weniger ins Gewicht.
PLRendererOpenGL:
- Argh, neue Treiber Probleme: Seit der neusten ATI Catalyst Version ging bei mir irgendwie kein Antialiasing mehr... ein Blick in die unterstÃ¼tzten
  Pixel-Formate zeigte was los ist: 32 Bit Farbtiefe und Antialiasing scheint nicht mehr unterstÃ¼tzt zu werden. Daher musste ich das suchen eines
  geeigneten Pixel-Formates noch etwas erweitern: Wenn das gewÃ¼nschte Pixel-Format nicht vorhanden ist, wird die Farbtiefe von 32 Bit auf 24, und dann
  von 24 auf 16 Bit veringert... dadurch steigt die Chance einen Treffer zu haben. brr (ja, da habe ich doppelten Code in zwei unterschiedlichen Klassen,
  das ist mir nun aber zu Riskant hier grÃ¶Ãere Umbauten zu machen da das praktisch jedesmal zurÃ¼ckschlÃ¤gt und dann auf einem anderen System einen
  totalausfall der Grafik produziert :/)



>> 03.08.2010
[CO]
- "TextureBufferRectangle::GetNumOfBytes": Warum auch immer wurde hier die Anzahl der benÃ¶tigten Bytes anderst, und zwar scheinbar falsch, berechnet
  so das es bei mir dann abschmierte sobald ich einen Bildschirm-Modus wechsel vornehmen wollte bei dem die Texturen von der GPU zurÃ¼ckgeladen werden



>> 27.07.2010
[CO]
- DrawHelpers::DrawImage() um Texture Matrize erweitert
- Parameter::GetValueTexture() nutzt nun TextureHandler::GetTexture() statt TextureHandler::GetResource() damit gehen auch Texture Animationen
- Animation um EventStart & EventStop Events erweitert



>> 25.07.2010
[CO]
PLRendererOpenGL:
- Log-Information wie z.B. "[Info]: Extension 'GL_ATI_separate_stencil' not found!" in
  "[Info]: Extension 'GL_ATI_separate_stencil' not found (nothing critical)" geÃ¤ndert da diese Log-Ausgaben bei PL-Problemen eigentlich immer
  erwÃ¤hnt wurden ob dies das Problem sein kÃ¶nnte - ist es aber eigentlich nie da die Extensions Optional sind, z.B. fast alle. Dies ist eigentlich
  nur eine Information. (daher auch [Info])



>> 11.07.2010
[CO]
- "Font::Mipmapping" hinzugefÃ¼gt damit man einstellen kann ob beim Schrift zeichnen Mipmapping verwendet werden soll oder nicht -
  da die Schrift dadurch etwas vermatscht und oder transparenter als sonst rÃ¼ber kommen kann, muss man soetwas von AuÃen einstellen kÃ¶nnen



>> 07.07.2010
[CO]
- "ProgramGenerator" um einen unschÃ¶nen Hack erweitert der auf Wunsch die GLSL Precision Qualifiers im Ã¼bergebenen
  Shader Quellcode entfernen kann - Hintergrund ist, das auf Stefans Notebook mit NVIDIA GPU der Compiler fehler raushaut
  sobald Precision Qualifiers verwendet werden. Dies ist laut OpenGL Spezifikation allerdings ein Fehlerhaftes
  Verhalten + bei OpenGL ES 2.0 sollte man immer Precision Qualifiers nutzen - ich will aber mÃ¶glichst nur jeweils
  einen Shader fÃ¼r alles schreiben. Da so eine Quellcode Modifikation schnell nach hinten gehen kann, habe ich das daher
  nur in "ProgramGenerator" eingebaut. Ebenfalls wird in Vertex Shadern soetwas wie "out vec4 VertexColorVS;"
  durch "varying out vec4 VertexColorVS;" ersetzt.
- ProgramGenerator Konstruktor um Profile Parameter erweitert, die ich bei mir unter Cg immer angeben sollte da
  es sonst vorkommen kann das z.B. "discard" bei mir nicht mit GLSL Profile lÃ¤uft



>> 04.07.2010
[CO]
- Dem Renderer kann man beim Erzeugen im Konstruktor nun noch optional die gewÃ¼nschte Default Shader Sprache Ã¼bergeben



>> 03.07.2010
[CO]
PLRendererOpenGL:
- Cg Shader fÃ¼r Font Rendering hinzugefÃ¼gt



>> 30.06.2010
[CO]
- "DrawHelpersBackend::DrawText()" stellt die Schrift wieder in der gleichen grÃ¶Ãe da wie frÃ¼her so das erstmal alles wieder ok aussieht. (hoffentlich)
  Die Methode sollte man bei Zeiten nochmal krÃ¤ftig durchdenken - allerdings sind die Schrift grÃ¶Ãe relevanten Teile nun zum GlÃ¼ck nur noch
  in DrawHelpersBackend - die konkreten Renderer Implementationen arbeiten auÃschlieÃlich mit FreeType SchriftgrÃ¶Ãen & Clip Space.
- Fonts: Auch Deutsche Umlaute gehen nun



>> 29.06.2010
[CO]
- MultisampleEnable Render State hinzugefÃ¼gt. Bei OpenGL (bei OpenGL ES 2.0 nicht) gibt es die MÃ¶glichkeit Multisample Antialiasing
  beliebig an/aus zu schalten. Bei Image Based Verfahren funktioniert Multisample Antialiasing nicht "automatisch" sondern man muss
  spezielle GLSL Befehle verwenden, die nur die aktuelleren Grafikkarten kÃ¶nnen. (und Cg/ATI Kombination geht natÃ¼rlich schonmal hier
  auch nicht) Resultat ist, dass die Performance total mies ist wenn Multisample Antialiasing aktiv ist wenn der Deferred Scene Renderer
  verwendet wird - ohne das man einen Antialiasing Effekt hat. Daher hier nun diese MÃ¶glichkeit das gezielt zu deaktivieren - dies
  passiert in der Regel automatisch durch die Surface Klasse so das man sich nicht weiter drum kÃ¼mmern muss... sondern nur beim
  erzeugen eines Render Targets sagen muss ob man Multisample Antialiasing haben will, oder nicht.



>> 27.06.2010
[CO]
- DrawHelpersBackendShaders nutzt nun ebenfalls ProgramGenerator da der fÃ¼r "DrawImage()" benÃ¶tigte Shader durch zahlreiche
  Features, die benÃ¶tigt werden kÃ¶nnen, oder nicht, schon wieder zu kompliziert wurde
- StandardmÃ¤Ãig wird nun DrawHelpersBackendShaders als DrawHelpers Implementation verwendet, Shader sind einfach deutlich Handlicher
  und direkter als Fixed Functions
- CreateTextureBufferRectangle() gibt nun "TextureBuffer" zurÃ¼ck, ob dies dann TextureBufferRectangle oder TextureBuffer2D
  ist hÃ¤ngt von der Implementation ab. Hintergrund ist, das OpenGL ES 2.0 hier keinen Unterschied macht - und nun an zig Stellen in
  allen Codes Fallunterscheidungen zu machen wÃ¤re doof. Das einfachste ist daher Rectangle Texturen in PixelLight weiterhin Ã¼ber
  CreateTextureBufferRectangle() zu erzeugen, also weiterhin als eigenstÃ¤ndige Texture damit es mit anderen API's lÃ¤uft - die Implementation
  kann dann aber auch TextureBuffer2D zurÃ¼ckgeben... und fÃ¼r den Rest ist es im Grunde eigenltlich immer egal da man den TextureBuffer
  Typ testet. Sollte der Typ dann TextureBuffer2D sein, wird es wie eine normale 2D Texture behandelt, das es intern dann auch mal eine
  none-power-of-two Texture sein kann, ist total wurscht weil weiterhin hier mit normalisierten Texture Koordinaten gearbeitet wird und
  in GLSL weiterhin sampler2D/texture2D verwendet wird. (OpenGL ES 2.0 kenn z.B. auch kein sampler2DRect/texture2DRect)
PLRendererOpenGLES:
- In Texturen Rendern ist noch nicht implementiert, daher sollte hier dann auch immer NULL zurÃ¼ckgeben werden da man sonst z.B.
  durch aktives Shadow Mapping keinerlei Lichter mehr sieht da die Shadow Map nicht wirklich gefÃ¼llt wurde
- TextureBufferRectangle entfernt, TextureBufferRectangle lÃ¤uft *g*



>> 26.06.2010
[CO]
- DrawHelpers: "DrawPlane()" aktualisiert
- DrawHelpersBackendShaders: Primitive (Punkt, Linie, Dreieck, Quad) lassen sich Darstellen. Somit ist es nun also auch unter
  OpenGL ES 2.0 mÃ¶glich zahlreiche Debug Visualisierungen zu sehen. :D
- DrawHelpers: "DrawImage()" als Ersatz fÃ¼r "DrawBitmap()" hinzugefÃ¼gt, leider mit zahlreichen Parametern - aber ich wÃ¼sste nicht
  was ich davon weglassen kÃ¶nnte ohne dann direkt den Nutzen einzuschrÃ¤nken :(



>> 25.06.2010
[CO]
- Resource: Type-Enums umbenannt damit es keine Namenskonflikte mehr mit den dazugehÃ¶renden Klassen gibt
- "Shader2" in "AbstractShader" umbenannt damit es keine Namenskonflikte mit der anderen "Shader" Klasse gibt
  die so glaub ich erstmal am besten drinnen bleibt.
- Beim erzeugen einer Renderer Instanz kann nun noch ein "Renderer Modus" eingestellt werden, so das es mÃ¶glich ist
  die verwendung von Fixed Functions, oder Shadern zu unterbinden - soweit vom Renderer unterstÃ¼tzt. Damit kann man z.B.
  Fixed Functions Support im OpenGL Renderer abschalten, das hilft beim Testen wie es ohne Fixed Function lÃ¤uft - und
  gibt auch minimal bessere Performance da mit weniger ZustÃ¤nden herumjongliert werden muss.
- DrawHelpersBackend in DrawHelpersBackendFixedFunctions und DrawHelpersBackendShaders unterteilt. Ein paar Dinge kÃ¶nnen
  direkt in DrawHelpersBackend fÃ¼r beides Implementiert werden, wÃ¤re umstÃ¤ndlich wenn man komplett alles immer neu Implementieren mÃ¼sste.
- "FixedFunctions::RenderState::Lighting" ist nun StandardmÃ¤Ãig aus... so wie es am hÃ¤ufigsten verwendet wird und Ã¼brigens auch
  die Default Einstellung von OpenGL ist
- DrawHelpers: "DrawPoint()", "DrawLine()", "DrawBox()", "DrawTriangle()" und "DrawQuad()" Ã¼berarbeitet. Wie schon bei Font muss
  auch hier nun die World Space Projection Matrize als Parameter Ã¼bergeben werden. Dadurch konnte nun an einigen Stellen die Verwendung
  von Fixed Functions entfernt werden und alles wird etwas Ãberschaubarer vom Ablauf her.



>> 24.06.2010
[CO]
- Das bisherige PLRenderer Font Interface entfernt, auch "FontManager" im Grundordner + FTGL das wir nun nicht mehr nutzen
- FontManager ist nun ebenfalls Backend-Basierend, daher kann man eine Instanz davon nun Ã¼ber Renderer::GetFontManager() erhalten...
  dabei wird eine Referenz zurÃ¼ckgeben so das man weis das hier immer was gÃ¼ltiges zurÃ¼ckgegben werden muss - ansonnsten wÃ¼rde
  es in zuvielen unschÃ¶nen NULL-Zeiger Abfragen im Code enden.
- Das neue Font Interface habe ich auf Basis dessen entwickelt was ich bereits fÃ¼r den OpenGL ES 2.0 Renderer in den letzten
  Tagen implementiert habe
- "2D Texte" werden zukÃ¼nftig Ã¼ber "DrawHelpers" (derzeitiges 2D Interface) gezeichnet. Font kennt nur frei im Raum platzierbare
  Texte, also das universelle. Ich denke so sind die Aufgaben besser verteilt.
- Die Font Implementation von PLRendererOpenGLES und PLRendererOpenGL ist fast identisch, nur das PLRendererOpenGL auch noch
  zusÃ¤zlich Fixed Functions unterstÃ¼tzen muss



>> 21.06.2010
[CO]
PLRendererOpenGLES:
- Frei im Raum positionierbare Schriften funktionieren mittlerweile recht gut (was die Grundlage fÃ¼r alles weitere Darstellt da
  selbst "2D"-Schrift Polygone sind...)
- Auch das Darstellen von 2D Schriften funktioniert nun... als nÃ¤chstes sollte dann das PLRenderer Font Interface neu aufgebaut
  werden da es etwas zugemÃ¼llt ist. Dies ist allerdings nix Technisches mehr, sondern nur noch eine reine Design-Frage. :D



>> 20.06.2010
[CO]
PLRenderer:
- Program: "EventDirty"-Event hinzugefÃ¼gt das ausgelÃ¶st wird wenn Attribute und Uniforms hÃ¶chstwahrscheinlich ungÃ¼ltig werden.
  "ProgramGenerator" hÃ¶rt auf dieses Event und zerstÃ¶rt die Benutzer Daten zu einem erzeugten Program. Somit mÃ¼ssen dann beim
  nÃ¤chsten mal z.B. Uniforms und Attributes von neuem ermittelt werden. (aber immer noch besser als das in jedem Frame x mal
  zu machen! :)
PLRendererOpenGLES:
- Renderer::SetRenderState Implementation komplettiert
PLRendererOpenGL:
- Backup/Restore bei den neuen Shader Implementationen hinzugefÃ¼gt - damit ist nun auch nach einem Vollbildmodus wechsel noch
  alles da. Bei PLRendererOpenGLES habe ich kein Backup/Restore da ich z.B. keine Texture Daten zurÃ¼cklesen kann - wenn ganz, oder
  gar nicht, also bei OpenGL ES 2.0 gar nicht.
  Bei der Gelegenheit direkt das Shader Interface noch minimal erweitert.



>> 19.06.2010
[CO]
- ProgramGenerator: Das erzeugte Program wird nun in "GeneratedProgram" zusammen mit Zusatzinformationen gespeichert anstatt direkt
  ein Zeiger auf das erzeugte Program. "GeneratedProgram" hat ebenfalls "pUserData", dadurch kann man einem erzeugten Program noch
  Benutzereigene Informationen hinzufÃ¼gen - z.B. etwas das direkte Zeiger auf alle Uniform & Attribute Parameter des Programs hÃ¤lt
  so das man einen performanteren Zugriff darauf hat.
PLRendererOpenGLES:
- Cube Maps Implementiert - ok, das war fast nur ein rÃ¼berkopieren aus PLRendererOpenGL *g*
PLRendererOpenGL:
- "FrameBufferObject::Initialize()" Multisample Antiasing Support wieder aktiviert da es scheinbar mittlerweile soweit sauber lÃ¤uft
  (hatte am 12.06.2010 ja etwas daran gearbeitet)



>> 17.06.2010
[CO]
- "PLGui::ProgressWindow" Nutzung entfernt. Das sollte, wenn Ã¼berhaupt, zukÃ¼nftig Ã¼ber Events laufen. (die gabs damals noch nicht :)
- "PreviewWindow" von PLRenderer nach PLEngine verschoben
- "WindowConnection", "RenderWindow" und "RenderFrame" von PLRenderer nach PLEngine verschoben
- "Renderer::GetDisplayModes()" entfernt da der "Mehrwert" praktisch nicht vorhanden war
-> PLRenderer und dessen Backends sind nun komplett unabhÃ¤ngig von PLGui, das mÃ¼sste die FlexibilitÃ¤t und EinsatzmÃ¶glichkeiten weiter erhÃ¶hen
PLRendererOpenGL & PLRendererOpenGLES:
- Jedesmal wenn ein Program aktiviert wird, wird nun glEnableVertexAttribArray fÃ¼r alle Attribute ausgefÃ¼hrt, wenn ein Program deaktiviert wird,
  wird hingegen glEnableVertexAttribArray ausgefÃ¼hrt. Wird dies nicht getan, so kann es schnell zu Konflikten mit Fixed Functions kommen.
  (*Kaputte Grafik*)



>> 16.06.2010
[CO]
- Die Renderer Backends nutzen kein PLGui mehr
PLRendererOpenGL:
- Da "OpenGLRenderContext" ein Krampf war, habe ich eine neue "Context" Klassen eingebaut - hatte genau soetwas schon vor Monaten nochmal fÃ¼r meine
  Bachelor sauber von 0 angefangen. "ContextWindows" fÃ¼r Windows lÃ¤uft, "ContextLinux" hab ich soviel zusammengeraten wie ich konnte - wird aber
  sicherlich noch nicht laufen... ich hoffe aber das es weniger Arbeit macht das lauffÃ¤hig zu machen als das alte "OpenGLRenderContext". :D



>> 15.06.2010
[CO]
- "ProgramGenerator" aus "PLCompositingShaders" nach "PLRenderer" verschoben, das ist etwas recht allgemeines das mitterweile auch recht ordentlich lÃ¤uft



>> 14.06.2010
[CO]
- Renderer: Altes Shader Interface in einen "Depreciated shader interface" Block geschoben damit das alles Ã¼bersichtlich beisammen ist was bei
  Zeiten wegkommt
- "GetVertices()" und "SetVertices()" vom Renderer in das FixedFunctions Interface verschoben und in "GetVertexBuffer()" und "SetVertexBuffer()"
  umbenannt. Das zuweisen von Vertex Daten an Shader Attribute lÃ¤uft mittlerweile bei Shadern Ã¼ber ProgramAttribute ab. (was auch viel schÃ¶ner
  und universeller ist :D)
- "GetIndices()" und "SetIndices()" in "GetIndexBuffer()" und "SetIndexBuffer()" umbenannt



>> 12.06.2010
[CO]
- Wow, OpenGL ES 2.0 kann sogar Multisample Antialiasing, dass muss natÃ¼rlich genutzt werden da es die BildqualitÃ¤t deutlich steigert.
  (weiche Kanten und generell weniger bis kein Pixelrauschen mehr, insgesamt ein ruhigeres und Angenehmeres Bild :)
  Damit hier eine Initialisierung nicht fehlschlÃ¤gt nur weil man z.B. einen zu groÃen Samples Wert wÃ¼nscht, hab ich hier einige Fallbacks
  eingebaut. Im Gegensatz zu OpenGL kann man Multisample allerdings nicht ein/ausschalten wenns erstmal ausgewÃ¤hlt wurde, aber das ist
  nicht wirklich schlimm. Ich hatte auch geprÃ¼ft ob man das pro Surface einstellen kÃ¶nnte, sprich, Surfaces mit anderen EGL Config Einstellungen...
  beim internen Dummy Fenster bekam ich einen Crash, und bei normalen Fenstern - sah ich nur MÃ¼ll. Sprich, es darf scheinbar nur eine einzige
  EGL config fÃ¼r *alles* verwendet werden. (zumindestens beim Emulator) Hm, das macht die Entscheidung etwas einfacher wie man von auÃen
  Multisample Antialiasing Einstellt - und zwar beim PLRenderer initialisieren!
- Aufgrund der gemachten Multisample Antialiasing Erfahrungen in OpenGL ES 2.0 habe ich mich dazu entschlossen das Multisample Antialiasing
  Samples am besten als Parameter bei "RendererContext::CreateInstance()" Ã¼bergeben wird
- Auch bei OpenGL ist das so das wenn man einmal ein Fenster mit Multisample nutzt, alle anderen Fenster ebenfalls Multisample nutzen mÃ¼ssen -
  hm, hÃ¤tte schwÃ¶ren kÃ¶nnen das wÃ¤re auch mal anderst gegangen. Ok, "DisplayMode::AntiAliasing" entfernt da witzos - Multisample Antialiasing
  wird nun also einmal beim Renderer Instanz erzeugen definiert, und dann wird das Ã¼berall so verwendet.
- Renderer: "Init()" und "DeInit()" -> unnÃ¶tig und gefÃ¤hliche Methoden entfernt



>> 09.06.2010
[CO]
PLRendererOpenGLES:
- Sampler States eingebaut
- OpenGL ES 2.0 hat keinen Support fÃ¼r Occlusion Queries
- "Renderer::MakeScreenshot()" implementiert. Zuerst freute ich mich das dies ein 1:1 kopieren aus dem OpenGL Backend war... bis ich
  merkte, das glReadPixels nur einen Fehler zurÃ¼ckgab. Unter OpenGL ES 2.0 unterstÃ¼tzt glReadPixels kein GL_RGB was ich bisher verwendete,
  daher Ã¤nderte ich das in GL_RGBA, und auch im OpenGL Backend - speichert man das als png hat man nun also auch noch eine Alpha Maske was
  ja auch mal von Vorteil sein kann. Mache ich einen Screenshot von "Mipmaps.scene", welches einen "leeren" Hintergrund hat, so hab ich im
  png hier nun eine Transparenz - nett. Sollte das jemand mal nicht wollen, kann man den Alpha Kanal nachtrÃ¤glich entfernen lassen.



>> 08.06.2010
[CO]
- Bis auf "Shader2": Die "2" aus den Namen des neuen Shader-Interfaces rausgenommen da es keine Konflikte gibt und es nun langsam an die
  Abschlussarbeiten geht... und es mehr Arbeit wÃ¤re nun alles umzustellen, und dann spÃ¤ter nochmal die Namen anzupassen. :D
- Sampler Uniforms bekommen nun wie in Cg eine Texture Unit fest zugeteilt, so das man eine Texture nur einem Uniform zuweisen muss und
  der Rest intern automatisch gehandhabt wird. Das hat sich in der Vergangenheit als sehr Praktisch herausgestellt, die konkrete Texture
  Unit wird wie gehabt von der entsprechenden Methode als Parameter zurÃ¼ckgegeben oder kann durch "GetTextureUnit()" ermittelt werden.
- ProgramUniform um etliche Methoden erweitert
- Etwas mit den OpenGL Shader Language Versionen auseinandergesetzt, dazu werden im Log nun vom Renderer die jeweiligen Versionen rausgeschrieben.
  OpenGL ES 2.0 unterstÃ¼tzt nur "#version 100", das aktuelle OpenGL unterstÃ¼tzt NICHT "#version 100". Laut OpenGL GLSL Spezifikation sollte
  man die Version immer dazuschreiben, im Internet findet man eigentlich dann auch fast nur GLSL Codes wo die Version immer dabei steht -
  das dumme ist hier allerdings das ich nicht zwanghaft zwei GLSL Shader Code Versionen machen will "nur" weil halt die Version ne andere ist.
  Solange es auch ohne Versionsangabe dann auf OpenGL ES 2.0 und mit OpenGL lÃ¤uft, machen wir es so. Dazu schreibe ich aber immer ein entsprechendes
  Kommentar in die GLSL Codes so das man nicht spÃ¤ter mal denkt "huch, da sollte aber ne Versionsinfo" rein, sich dann freut das man sich nun
  an die Spefizikation hÃ¤lt, und dann irgendwann spÃ¤ter erst merkt das nun bei der anderen OpenGL Version nun gar nix mehr geht. Mal schaun
  wann dann bei den Scene Renderer Schritten der Punkt kommt wo ich unterschiedliche GLSL Codes schreiben muss da ich Features nutzen will/mÃ¼sste
  die erst die neueren Sprachen haben. Da muss ich mir dann wohl jeden Punkt anschaun - z.B. glaub ich nicht das es dann lohnen wÃ¼rde z.B. fÃ¼r
  SSAO Shader OpenGL ES 2.0 Versionen zu schreiben... denn damit wÃ¤ren die kleinen Maschienchen eh total Ã¼berfordert + kÃ¶nnen auch kein MRT was
  ich fÃ¼r Deferred Rendering aber nutze, und z.B. SSAO nutze ich auch nur beim Deferred Renderer. Da muss man dann wohl immer Ordentliche
  Kommentare verfassen damit klar ist wie was. :D
  Ich hoffe das lÃ¤uft so dann ohne Versionsangaben auch direkt z.B. auf dem Nokia N900, nicht das der Emulator hier zu nett zu mir ist. *g*
- Die abgeleiteten Renderer-Klassen heiÃen nun ebenfalls "Renderer", das macht deren Verwendung etwas angenehmer da man nicht immer
  "PLRendererOpenGLES::RendererOpenGLES" und "PLRendererOpenGL::RendererOpenGL" schreiben muss sondern nur noch z.B.
  "PLRendererOpenGLES::Renderer" - damit kann man etwas komforabler Ã¼ber z.B. die Konfigurations-Datei den Renderer wechseln ohne immer darauf
  achten zu mÃ¼ssen das man alles anpasst. Damit ist das nun konsistent zu den anderen Backend-Klassen - frÃ¼her ging das leider nicht anderst
  da das alte RTTI keine Namespaces unterstÃ¼tzte. :D
  -> ACHTUNG: Sicherheitshalber die "cfg" Dateien lÃ¶schen damit nun kein ungÃ¼ltiger Renderer angegeben wird.
  -> Die anderen Backend-Systeme sollten am besten genauso angepasst werden, das mit der Namespace nutzung ist einfach viel schÃ¶ner und
     Handlicher :D



>> 07.06.2010
[CO]
- Die Geometry-Shader Implementation ist korrekt, die Nutzung im Beispiel war falsch... natÃ¼rlich muss man auch hier schaun das die Daten
  sauber von der Vorstufe aufgenommen, und an die Nachstufe weitergegeben werden.
- "ShaderToolsGLSL::WriteProgramInformationIntoLog" war nicht ok... hm, das kommt eher selten vor das sich Dinge die frÃ¼her Extensions waren
  und dann in den Kern Ã¼bernommen wurden sich anderst verhalten und andere Funktionen da sind :/
- Wird der Shader Quellcode mit "SetSourceCode" gesetzt, so kann man nun ebenfalls das Profile als String Ã¼bergeben - eigentlich nur fÃ¼r Cg
  relevant! Als Standard Profile nutzte ich bei Cg die GLSL Profile da ich so auch auf meiner ATI Karte ordentliche Shader schreiben kann -
  denn ansonnsten kann ich nur die ersten primitiven Shader Generationen auf meiner ATI Karte nutzen - der Rest geht *natÃ¼rlich* nur auf
  NVIDIA Karten. Das war noch ein weiterer Grund wieso ich Cg nicht mehr als Hauptshadersprache haben will - als ATI Nutzer fÃ¼hle ich mich
  da etwas verÃ¤ppelt. *g*
  Mittlerweile lÃ¤uft auch "glslv" korrekt... der Trick bestand darin "cgCombinePrograms2" zu nutzen was in Cg 1.5 eingefÃ¼hrt wurde... sprich,
  die einzelnden Cg Programme werden zu einem Cg Program zusammengematscht - Cg intern wohl u.a. wegen GLSL das nur ein gemeinsames Programm
  kennt. Nett. Das fand ich nun eher per Zufall. Sprich, das aktuelle PL Shader-Interface ist sehr gut so - da man einfach ein gesamt Programm
  braucht wenn es auf sovielen APIs wie mÃ¶glich laufen soll.
  Cg ist irgendwie Horror, ich habe nun etliche Stunden damit verbracht zu Analysieren wie sich was verhÃ¤lt, denn die Cg-Dokus sind eher schwach
  und im Internet gibts meist auch keine Antworten auf meine speziellen Fragen. Sobald GLSL Profile verwendet werden, bricht in Cg die HÃ¶lle aus
  und einiges verhÃ¤lt sich schlichtweg anderst! Ich habe mir nun selbst zusammengereihmt das die FauÃregel ist "Ein Shader mit GLSL, alles GLSL!".
  Ich habe entsprechende Log Fehlernachrichten eingebaut wenn man versucht Shader Profile zu mischen so das man nicht wie ich nun Stundenlang braucht
  um Fehlerquellen zu finden! Wenn man also nun ein GLSL Program hat, ein "Cg Combined Program", kann man z.B. mit "cgGLIsProgramLoaded" direkt
  testen ob alles geklappt hat. Verwendet man aber nicht GLSL, so geht "cgGLIsProgramLoaded" intersanterweise nicht, und man muss dann die Unterprogramme
  aus dennen sich das "Cg Combined Program" zusammensetzt einzelnd abtesten.
  Weitere Stunden gingen fÃ¼r den Cg Shader von SPTriangleShaders drauf - denn sobalg GLSL Profile genutzt werden, lassen sich auf einmal die Shader
  nicht mehr Ã¼bersetzen wenn man nicht unverschÃ¤mt strickte Regeln einhÃ¤lt. Z.B. dÃ¼rfen Attribute wie Vertex Positionen dann nicht mehr frei mit
  z.B. "ATTR0" gekennzeichnet werden, nein, dann MUSS die Semantic auf einmal "POSITION", "COLOR" etc. sein. Das Spielchen mit den Semantics geht
  an anderen Stellen so weiter - so das hier wieder alles etwas Altbacken wirkt da man scheinbar mit FestverlÃ¶teten Daten-Bedeutungen arbeitet.
  Hat ja alles vor und Nachteile mit den Semantics, z.B. muss Cg ja wissen wie die einzelnden Daten Pipelines zusammengestÃ¶ppelt werden, ist aber einfach
  ein zu GLSL anderer Ansatz wo man sich Gedanklich dann immer Umstellen muss.
  Das ist im naiven GLSL, also nicht Cg, alles viel schÃ¶ner, da GLSL Attributen keine feste Bedeutung unterstellt - das einzige was "fest" ist, ist
  die Vertex-Position... denn die Vertex Position wird dazu verwendet um ein Dreieck zu Rasterisieren... hier muss die Hardware also wissen wo die
  Vertex Positionen zu finden sind. Alle anderen DatenstrÃ¶me braucht die GPU nicht zu interessieren!
  Gefreut habe ich mich darÃ¼ber das es Funktionen wie "cgGetProfileProperty(m_pCgProfile, CG_IS_VERTEX_PROFILE)" gibt mit denen man PrÃ¼fen kann ob
  der Benutzer fÃ¼r einen Vertex Shader ein Profil angibt das nicht fÃ¼r Vertex Shader ist... geflucht hab ich als ich merkte das sobald "CG_IS_OPENGL_PROFILE"
  ja sagt, "CG_IS_VERTEX_PROFILE" etc. nicht gesetz sind so ich per Hand auf z.B. "CG_PROFILE_GLSLV" hin prÃ¼fen muss. Na also wirklich brauchbar
  sind diese Eigenschaften ja dann doch irgendwie nicht wann man am Ende dann wieder individuelle Profile in die Hand nehmen muss. (von dennen es in Cg
  so einige gibt und regelmÃ¤Ãig neue hinzukommen...)
  Geometry-Shader in Cg zum laufen zu bringen war natÃ¼rlich genauso wenig lustig... umso mehr froh bin ich das nun scheinbar alles soweit lÃ¤uft und
  das PL Shader-Interface einiges vom Cg Horror intern verbergen kann. Z.B. hab ich nirgends eine wirkliche Dokumentation fÃ¼r die Geometry-Shader
  gefunden. "emitVertex" sieht man oft, aber dann kam die Frage auf wie man denn nun ein neues Primitive anfÃ¤ngt, Ã¼ber Umwege fand ich dann
  "restartStrip". Dann wollte ich es wissen und durchsuchte nochmal das Cg-SDK... da liegt ein Dokument "Cg-2.0.pdf" bei, das sind Folien einer
  PrÃ¤sentation, "restartStrip" taucht dort als Randnotiz auf einer Folie auf. Also offen gesagt, das ist schlichtweg Unprofessionel, das kann man
  doch nicht bringen fÃ¼r soetwas wie Cg eine derart schlampige Dokumentation zu haben. *gruml*
- Wird der Shader Quellcode mit "SetSourceCode" gesetzt, so kann man nun auch den Einstiegspunkt als String Ã¼bergeben. GLSL kennt soetwas
  nicht, Cg aber schon. Standard ist "main".



>> 06.06.2010
[CO]
- Geometry Shader hinzugefÃ¼gt, das ist etwas was heute umbedingt da sein sollte - damit hatte ich schon wÃ¤hrend meiner Bachelorarbeit etwas
  herumgespielt. Irgendwie schlÃ¤gt aber momentan das Program linken ganz ohne Fehlermeldung fehl sobald ich einen Geometry Shader nutzen will,
  hm, das muss ich mir genauer anschaun. Aber fÃ¼r's erste sind schonmal die Geometry Shader Klassen drinnen.
PLRendererOpenGL:
- GLSL Implementation fÃ¼r das neue Shader-Interface hinzugefÃ¼gt. Im Grunde musste ich nur das was ich fÃ¼r OpenGL ES 2.0 machte rÃ¼berkopieren,
  und dann die OpenGL Funktionen anpassen da hier GL_ARB_shader_objects & GL_ARB_vertex_shader verwendet wird. Uff, GL_ARB_shader_objects war
  einiges an FleiÃarbeit bis alle Funktionen eingebunden waren. Schade das man hier in verschiedenen Projekten fast identsichen Code hat, aber
  mit Kopieren arbeiten muss damit das kein Chaos gibt. :/
  Die SDK Demos PLDemoRendererTriangle und PLDemoMeshTeapot laufen nun auch mit PLRendererOpenGL unter GLSL. Hier also absolut keinen Unterschied
  ob gerade OpenGL ES 2.0 oder OpenGL verwendet wird, GLSL ist GLSL. Das ist wohl ein weiteres Argument dafÃ¼r das GLSL zukÃ¼nftig unsere
  Hauptshaderprache wird.
- Cg Implementation fÃ¼r das neue Shader-Interface hinzugefÃ¼gt



>> 05.06.2010
[CO]
PLRendererOpenGLES:
- TextureBuffer2D implementiert, ist fast genauso wie beim OpenGL Backend, nur das man Texturen nicht mehr von der GPU herunterladen kann
  und es keine DXT Kompressions Formate gibt (... dafÃ¼r ein anderes Kompressions Format...)



>> 04.06.2010
[CO]
PLRendererOpenGLES:
- Leider braucht auch OpenGL ES immer ein gesetztes Fenster, sonst gehen Anfragen ins Leere (auch wenn diese eigentlich im Context
  gespeichert werden...)



>> 03.06.2010
[CO]
- Schnittstellen ProgramAttribute & ProgramUniform hinzugefÃ¼gt, das erstere um Vertex Eingabestreams setzen zu kÃ¶nnen, das zweite
  fÃ¼r die Program Parameter. Auch hier orientierte ich mich wieder an OpenGL & GLSL, das mÃ¼sste sich dann recht einfach auf Cg
  und sicherlich auch HLSL Ã¼bertragen lassen und z.B. auch bei Cg werden Program Parameter im Shader Code mit "uniform" gekennzeichnet -
  von der Terminology her ist das also stimmig. :D



>> 02.06.2010
[CO]
- Neue Funktion "VertexBuffer::GetVertexAttribute" die ein Vertex Attribute anhand Semantic zurÃ¼ckgibt
- Mit dem neuen Shader-Interface begonnen, ich nenne alles erstmal "VertexShader2" und so weiter. Beim Design und den Namen versuche
  ich mich soweit wie mÃ¶glich an GLSL zu halten da dies wohl unsere Hauptshadersprache wird - und z.B. Cg kennt kein "Program" Objekt
  in dem Sinne wie GLSL, von daher wird am Ende z.B. Cg wohl einfacher zu implementieren sein da das "Program" Objekt dort dann im
  grunde nur eine Vertex & Fragment Shader Sammlung ist, aber ohne das das "Program" noch "gelinkt" werden mÃ¼sste. Die Methode
  "Renderer::SetVertices" wird es ZukÃ¼nftig wohl nicht mehr geben, bzw. nicht mehr im Hauptinterface. (fÃ¼r Fixed Function wohl schon
  noch) Mittlerweile ist das alles viel offener und Dynamischer und z.B. "Vertex Shader Attribut" und "Vertex Buffer Attribut" werden
  nur "verlinkt". Ich mache diesmal auch direkt "VertexShader" etc. Klassen damit das sauberer ist als vorher wo alles Ã¼ber eine
  gemeinsame "Shader" Klasse lief. Insgesamt versuche ich die Shader Interfaces & Implementationen so direkt und leichtgewichtig wie
  mÃ¶glich zu machen - das ist sehr Grundliegend, und ich denke gerade bei Mobilen GerÃ¤ten sollte man darauf achten nicht unnÃ¶tig viel
  Overhead einzubauen wenn sich das auch umgehen lÃ¤sst.



>> 31.05.2010
[CO]
- "RendererBackend" und "DrawHelpersBackend" liegen nun direkt in PLRenderer



>> 30.05.2010
[CO]
- Nutzung von "glGetError" entfernt, das sollte im Allgemeinen nur fÃ¼r konkretes Debugging verwendet werden und in den meisten FÃ¤llen
  war die Verwendung von "glGetError" ohnehin nicht korrekt da wenn ein Fehler gefunden wurde, keine weiteren Fehler registiert werden
  bis der Fehler abgefragt wurde.



>> 29.05.2010
[CO]
- IndexBuffer: UByte wird als Index Datentyp nun ebenfalls unterstÃ¼tzt. UInt wird von OpenGL ES 2.0 nicht unterstÃ¼tzt,
  dafÃ¼r wird UByte von DirectX 9 nicht unterstÃ¼tzt - UShort scheint das Format zu sein, das auf allen bisher unterstÃ¼tzten
  Grafik-API's lÃ¤uft. Daher ist UInt nun nicht mehr der Default-Wert, sondern UShort damit es mÃ¶glichst immer sofort lÃ¤uft
  wenn man das mal von Hand fÃ¼llt. (was in der Praxis eigentlich eher seltener vorkommt)
PLRendererOpenGLES:
- Mit der konkreten OpenGL ES 2.0 Implementation begonnen
- (Fensterloser) Context wird erzeugt und zerstÃ¶rt. Das geht mit der OpenGL ES API viel angenehmer als mit der alten OpenGL API. :D
- Renderer: SetViewport, SetScissorRect, SetColorMask, Clear, SetIndices und SetVertices implementiert, diese sind fast komplett
  identisch zu den OpenGL Implementationen
- Renderer: DrawPrimitives und DrawIndexedPrimitives implementiert. Prinzipiell identisch mit den OpenGL Implementationen, nur das es
  bei OpenGL ES 2.0 viel weniger 'Draw'-Varianten gibt, so das der Code zwanghaft kompakt bleiben muss.
- IndexBuffer implementiert. Praktisch identisch zu OpenGL, nur das Index Buffer in OpenGL ES 2.0 so direkt implementiert sind und
  man daher nicht Ã¼ber Extensions gehen muss. "MapBuffer" lÃ¤uft weiterhin Ã¼ber Extensions, wird aber eher selten bis gar nicht genutzt
  da wir normalerweise dann direkt den Buffer Inhalt Host Seitig Buffern.
- VertexBuffer implementiert. Der Kern ist praktisch identisch zu OpenGL, nur das Vertex Buffer in OpenGL ES 2.0 so direkt implementiert
  sind und man daher nicht Ã¼ber Extensions gehen muss. "MapBuffer" lÃ¤uft weiterhin Ã¼ber Extensions, wird aber eher selten bis gar nicht
  genutzt da wir normalerweise dann direkt den Buffer Inhalt Host Seitig Buffern. Ein zuweisen der Vertex Daten an Shader Attribute lÃ¤uft
  natÃ¼rlich etwas anderst ab als frÃ¼her bei Fixed Functions - aber dieser Code stand ohnehin schon lÃ¤nger auf meiner Refactoring Liste und
  jetzt hab ich nen Grund das endlich mal zu Ã¼berarbeiten damit es besser zu den modernen Grafik-API's passt. (und trotzdem auch noch mit
  Fixed Function lÃ¤uft)



>> 03.05.2010
[SB]
- TextureBuffer::FixNANValues(): Da die Umwandlung von float in half noch nicht funktioniert, kan der Ã¼bergebene
  Farbwert natÃ¼rlich nicht konvertiert werden, hier kommt also immer 0 heraus. Das macht diese Funktion noch ziemlich
  nutzlos, denn "schwarz" anstelle von "schwarz" ist, naja, ... Habe darum erstmal hier feste Werte eingebaut, die
  Rot ergeben sollten. Neim Setzen der Farbe gab es auch noch einige kleine Fehler. Allerdings scheint die Methode dennoch
  nicht zu funktionieren, es ist jedenfalls nichts zu sehen, wenn ich das aufrufe (vermute, dass das eher daran liegt,
  dass die Textur nicht geupdatet wird, als am Farbwert).



>> 01.05.2010
[CO]
- TextureBuffer: Statische Funktionen GetComponentsPerPixel(), GetBytesPerPixelComponent() und GetBytesPerPixel() hinzugefÃ¼gt. Damit sich
  das genauso verwenden lÃ¤sst wie PLGraphics::ImageBuffer bleibt "Pixel" hier im Namen - eine Unterscheidung in Texel/Voxel wÃ¤re eine
  unnÃ¶tige verkomplizierung.
- TextureBuffer::GetNumOfComponents() in TextureBuffer::GetComponentsPerPixel() umbenannt und weitere Funktionen GetBytesPerPixelComponent()
  und GetBytesPerPixel() hinzugefÃ¼gt damit sich das genauso verwenden lÃ¤sst wie PLGraphics::ImageBuffer
- TextureBuffer::IsCompressedFormat(), TextureBuffer::GetUncompressedFormat() und TextureBuffer::IsFloatingPointFormat() hinzugefÃ¼gt
- Renderer::IsTextureBufferPixelFormatCompressed() entfernt, dafÃ¼r gibts nun TextureBuffer::IsCompressedFormat()
- Renderer::GetTextureBufferPixelFormat() nach TextureBuffer verschoben und in GetFormatFromImage() umbenannt
- Neue Funktion TextureBuffer::GetNumOfFaces()
- Neue Funktion TextureBuffer::GetNumOfNANValues(): FÃ¼r FlieÃkommezahlen Formate kann man hiermit die Anzahl der NANs in der Texture zusammenzÃ¤hlen
  lassen. Funktioniert im Augenblick noch nicht fÃ¼r 16 Bit FlieÃkommazahlen (half)... daher fÃ¼r den DOF Bug Test im "Begin" Render Schritt ein 32 Bit
  FlieÃkommazahlen Ziel einstellen. (ist unabhÃ¤ngig von "Float32" in "SRPDeferredGBuffer")
- TextureBuffer::GetNumOfNANValues() nutzt die neue PLMath::Half-Hilfsklasse, nun funktioniert auch der Test bei 16 Bit FlieÃkommazahlen Texturen
- TextureBuffer::FixNANValues() hinzugefÃ¼gt, ist Ã¤hnlich zu TextureBuffer::GetNumOfNANValues(), ersetzt gefundene Pixel die irgendwo ein NAN haben
  jedoch direkt durch eine Ã¼bergebene Farbe und lÃ¤d am Ende den "geflickten" Buffer wieder hoch. Damit wÃ¼sste man zumindestens das nach einem Aufruf
  dieser Funktion der Buffer nur gÃ¼ltige Werte hat - kÃ¶nnte helfen NAN Fehler weiter einzugrenzen da weniger Ungewissheiten.



>> 18.04.2010
[CO]
- WindowConnection, RenderFrame, RenderWindow, PreviewWindow, SPDefault und SPDefault vom "Renderer"-Verzeichnis in den Grundordner von PLRenderer
  verschoben. Im "Renderer"-Verzeichnis sollten eigentlich nur Backend-Relevante Dinge liegen, also der Technische Kern. Die verschobenen Klassen
  sind hingegen bereits Klassen die auf dem System aufsetzen um es noch einen Tick einfacher nutzbar zu machen. Alles was man also braucht um sich
  einen "Renderer" zu erzeugen liegt nun im Grundverzeichnis.
- WindowConnection::SetToggleFullscreenMode() kÃ¼mmert sich nun um die Registrierung der Hot-Keys
- WindowConnection-Konstruktor: Da ein PLGui Content-Window die Nachrichten nur an sein Parent weiterleitet, muss man leider im Falle von PLGui::Frame
  die Ereignisse von PLGui::Frame und nicht vom Content-Window abgreifen :/
- WindowConnection: Da ich gerade schon wieder darÃ¼ber gestolpert bin, speichert WindowConnection nun selbst den aktuellen Vollbild-Modus so das man
  das interne Surface lÃ¶schen kann, aber immer noch korrekte verwendete Einstellungen ermitteln kann.



>> 17.04.2010
[CO]
- Das meiste aus RenderFrame liegt nun in der neuen Klasse WindowConnection. RenderFrame und RenderWindow sind beide davon abgeleitet, dadurch sind
  beide Klassen nun fast leer was aber auch gut so ist. Diese zwei Klassen sollten nur "erweiterte" GUI Elements sein die man nutzen *kann* um
  direkt ein GUI Element Instanzieren zu kÃ¶nnen in das was gerendert wird. Auch ist endlich der Code nicht mehr doppelt was mich nun schon einige
  male etwas StÃ¶rte - das bedeutet aber, das man Prinzipiell auch ein RenderWindow in einen Vollbild-Modus versetzen kann. Dies finde ich aber ok
  denn das kÃ¶nnte durchaus mal benÃ¶tigt werden. (z.B. um ein Render-Fenster in einem Editor in den Vollbild-Modus zu schalten wie wir es vor langer
  laaaaaannger Zeit mal in PixelLab hatten :)
  WindowConnection mÃ¼sste es nun auch etwas Einfacher machen ein PixelLight Render Fenster in eine andere Anwendung einzubetten... den Nativen OS
  Fenster Handle verpackt man dann wie gehabt in NativeWindow, und Ã¼bergibt dieses dann WindowConnection. Ein weiteres GUI-Fenster wird also intern
  nicht mehr zwangslÃ¤ufig erzeugt. Daher war ein Design-Ziel von WindowConnection auch, das es mÃ¶glichst GUI unabhÃ¤ngig ist und wenn irgend mÃ¶glich
  nichts am Ã¼bergebenen GUI Fenster manipuliert. Wenn beispielsweise in den Vollbild-Modus geschaltet wird, ist es der Job von beispielsweise
  RenderFrame sich darum zu kÃ¼mmern das das GUI Fenster links oben plaziert und auf die richtige grÃ¶Ãe gesetzt wird. Auch ob der Fensterrahmen
  sichtbar sein soll oder nicht ist nicht Job von WindowConnection.
- RenderFrame: "sTitle"-Parameter aus dem Konstuktor entfernt, das bringt hier nicht wirklich viel an Mehrnutzen und blÃ¤ht das Interface nur
  unnÃ¶tig auf
- PLRendererOpenGL: Bugfix: Wenn Mipmaps nicht bis 1x1 Definiert sind, werden die restlichen Mipmaps automatisch erzeugt da dies nÃ¶tig ist... allerdings
  wurde m_nTotalNumOfBytes nicht aktualisiert
- TextureBuffer3D & TextureBuffer2D: GetSize(): Autsch, die kleinste Mipmap wurde nicht richtig zurÃ¼ckgegeben und konnte auch mal 0x1 oder so sein
  was ja nicht sein kann -> Der Fehler ist am 05.04.2010 reingekommen wo ich auf PLMath::Vector2i umgestellt habe.



>> 14.04.2010
[CO]
PLRendererOpenGL:
- FrameBufferObject: Depth&Stencil Support lÃ¤uft, zumindestens Ã¼ber die GL_EXT_packed_depth_stencil-Erweiterung die man nutzen kann wenn man
  mit 24 Bit Tiefenbuffer und 8 Bit Stencilbuffer auskommt. Interessanterweise ging ein *seperater* Stencilbuffer immer noch nicht und ich konnte
  im Netz auch kein einziges laufendes Beispiel sehen das GL_EXT_packed_depth_stencil nicht nutzt.



>> 13.04.2010
[CO]
- Transform State Ãnderungen von gestern komplettiert... hui, das zog wirklich einige (kleine und immer gleiche :) Anpassungen in anderen Projekten
  nach sich da an vielen Stellen wo etwas gezeichnet wird derzeit direkt Fixed Function Zeug genutzt wird. Durch die Entfernung der Semantics aus
  Effect gehen derzeit ein paar Effekte wie z.B. "Volumetric Line" nicht. Daher werd ich heute mal schaun wo/wie ich Fixed Functions Nutzung
  einschrÃ¤nken kann bzw. es so zu Ã¤ndern das es mit und ohne Fixed Functions lÃ¤uft. (vorher macht es auch weniger Sinn z.B. sofort mit OpenGL ES
  anzufangen)
  Wie man am besten *bekannte* Effekt Shader Parameter setzt werd ich mir auch anschaun. Wird wohl darauf hinauslaufen das Scene Renderer das machen
  und Stellen die direkt zeichnen ohne Ã¼ber Scene Renderer zu gehen - aber in PLRenderer selbst sollte soetwas nicht mehr fest eingebaut sein, das
  ist einfach zu Chaotisch. :D



>> 12.04.2010
[CO]
- RenderState::ShadeMode nach FixedFunctions verschoben
- In OpenGL 3 und DirectX 10 wurden Clip Planes durch einfachere Clip Distances ersetzt die zumal anderst Verwendet werden. IsClipPlaneEnabled(),
  SetClipPlaneEnabled(), GetClipPlane() und SetClipPlane() daher nach FixedFunctions verschoben. Clip Distances bau ich aber erstmal nicht ein
  da wir das derzeit nicht benÃ¶tigen.
- Ok, "Alpha-Test" scheint es bei den modernen Grafik-APIs ebenfalls nicht mehr zu geben. Hm, ok, dann geht das wohl zukÃ¼nftig *nur* noch darÃ¼ber das
  man in seinem Fragment-Shader selbst einen Alpha-Test realisiert und dann Ã¼ber "discard" (texkill) Fragmente verwirft. Gut, dann ist die Frage ob man
  lieber Alpha-Test oder "discard" verwendet geklÃ¤rt. *g*
  Alpha-Test durch "discard" sollte weiterhin sparsam Eingesetzt werden da es laut diverser Quellen Tiefenbuffer Optimierungen deaktiviert.
  (z.B. laut http://developer.amd.com/media/gpu_assets/Depth_in-depth.pdf Early-Z... aber nur wenn man gerade auch in den Tiefen-Buffer schreibt)
  RenderStates AlphaTestEnable, AlphaFunc und AlphaRef nach FixedFunctions verschoben und die letzten zwei States in AlphaTestFunction und
  AlphaTestReference umbenannt damit das vom Namen her klar ist wozu das gehÃ¶rt.
- VertexBuffer: GetColor() und SetColor() arbeiten nun mit PLGraphics::Color4
- TextureBuffer: GetPriority(), SetPriority() entfernt da scheinbar bei allen aktuellen Grafik-APIs (OpenGL 3, OpenGL ES, DirextX 10>) Depricated
  oder bereits weg - selbst genutzt hatten wir das eigentlich nie
- GetColor() und SetColor() nach FixedFunctions verschoben und auf PLGraphics::Color4 umgestellt
- Renderer: ModifyProjectionMatrix() entfernt, nutzten wir schon seit einer Weile nicht mehr und soetwas sollte zukÃ¼nftig nicht mehr direkt
  in PLRenderer sein
- Renderer: ResetTransformStates(), GetTransformState() und SetTransformState() nach FixedFunctions verschoben
- ShaderProgramCgBackend: BindSemanticParameters() und RefreshSemanticParameter() entfernt, das zog nochmal eine ganze Reihe von Ãnderungen nach sich.
  Auch wenn das frÃ¼her mal ganz nett war, passt dies nun einfach soetwas von Ã¼berhaupt nicht mehr ins Konzept. Es machte in PLRenderer vieles zu
  kompliziert und inperformant... PLRenderer muss zukÃ¼nftig "Leichtgewichtiger" sein wenn wir auch soetwas wie OpenGL ES unterstÃ¼tzen wollen.
  Das mit den "Benutzer Shader Ã¼ber Effekte" klappt mit dem Scene Renderer Konzept ohnehin nicht mehr so richtig dolle, da muss ich mir bei Zeiten
  wohl was neues ausdenken, falls dies wirklich nÃ¶tig werden sollte. (was ich zumindestens derzeit nicht sehen kann)



>> 10.04.2010
[CO]
- Renderer: Begin2DMode(), Is2DMode(), Get2DMode(), End2DMode(), Get2DZValue(), Set2DZValue() und DrawBitmap() nach DrawHelpers verschoben. Bisher war
  das ja irgendwie nett mit einem "2D-Modus", aber jetzt mit Shadern wirkt das irgendwie nur noch UmstÃ¤ndlich. Das hab ich gerade in den letzten
  Wochen gemerkt als ich viel im "Image-Space" gearbeitet habe - da ist es einfacher wenn man auf all die World, View, Projektion und so weiter
  Matrizen verzichtet und *direkt* Clip-Space Koordinaten Ã¼bergibt ohne wenn und aber. ZukÃ¼nftig sollte man das also hÃ¶chstens noch fÃ¼r
  "mal schnell was ausprobieren" nutzen, ansonnsten sollte man das entweder selbst richtig machen, oder Ã¼ber Hilfs-Klassen wie "PLScene::FullscreenQuad"
  die im Grunde fast schon die "DrawBitmap()"-FunktionalitÃ¤t ist... aber auf einer hÃ¶heren Ebene und mit deutlich mehr EinflussmÃ¶glichkeiten.
  Wie auch bei den anderen DrawHelpers-Funktionen wird das allerdings derzeit noch hier und da ersthaft genutzt und ich habe alles nur soweit
  angepasst das es noch Ã¼bersetzbar ist und lÃ¤uft. Die Stellen muss ich mir dann im einzelnden anschaun und aktualsieren - so das am Ende dann
  auch *alles* lÃ¤uft wenn das "FixedFunctions"-Interface nicht vorhanden ist. (sprich, auch alles sauber unter OpenGL ES lÃ¤uft!)
- Renderer: GetLineWidth() und SetLineWidth() zu RenderState gemacht (hey, und das ist sogar noch Bestandteil von OpenGL 3>=!... auch wenn es bereits
  auf der Abschussliste steht *g*)
- DrawHelper-Funktionen haben nun Farbe als Parameter da hier SetColor() ohnehin schon ohne Wirkung war und man SetColor() nur noch wirklich fÃ¼r reine
  Fixed-Function Draw-Calls nutzen sollte
- Font::Draw() muss man nun die Farbe Ã¼bergeben



>> 09.04.2010
[CO]
- DrawPoints2D(), DrawPoints3D(), DrawLines2D() und DrawLines3D() entfernt, diese Funktionen sind einfach nur daneben da totaler Overkill und
  umstÃ¤ndlich. Will man viele Punkte und Linien zeichen, sollte man wirklich wirklich einen Vertex Buffer anlegen, das ist nicht sooo viel
  Arbeit und deutlich sauberer und Effizienter. DrawPoint() und DrawLine() hingegen sind noch ok, wenn man fÃ¼r Debugging mal schnell was kleines
  anzeigen will. (aber wirklich nur fÃ¼r Debugging bzw. Debugging Visualisierung, ein Draw-Call pro Element, das geht einfach nicht :)
- Neues Interface "DrawHelpers". DrawPoint(), DrawLine(), DrawTriangle(), DrawQuad(), DrawBox() und DrawPlane() hierhin verschoben. Das sind alles
  Dinge die man eigentlich nur "mal schnell was ausprobieren" oder "kleine schnell realisierte Debug-Visualisierung" nutzen solle, aber NIEMALS
  ernsthaft fÃ¼r richtige Grafik. (auch wenn das derzeit noch an wenigen Stellen so ist) DafÃ¼r ist es schlichtweg zu Ineffektiv einzelnde Elemente
  zu zeichen + auch viel zu EinschrÃ¤nkend da man keine Texture Koordinate, Vertex Farben und und und und angeben kann. (wÃ¤re auch der totale Overkill
  wenn man das alles in den Funktionen bieten wollte :)
  Auch hier heist die Diverse: Lieber einen kleinen eigenen Vertex Buffer anlegen, mit Daten fÃ¼llen und dann auf einen Schlag zeichnen lassen.
  Im Renderer-Interface kommt man Ã¼ber die Funktion "GetDrawHelper()" an dieses Helper-Interface... hier wird eine Referenz zurÃ¼ckgegen da das
  Objekt *immer* gÃ¼ltig sein sollte, es wÃ¤re etwas am "schnell und einfach was ausprobieren"-Sinn vorbei wenn man erst PrÃ¼fen mÃ¼sste ob der
  Zeiger Ã¼berhaupt gÃ¼ltig ist.



>> 08.04.2010
[CO]
- "FixedFunctions"-Schnittstelle begonnen - hierhin werde ich nun Schrittweise alle FunktionalitÃ¤ten verschieben die frÃ¼her in Grafik-APIs und GPUs
  fest Verdrahtet waren, heute aber universell und frei Ã¼ber Shader realisiert werden. Dinge die es in DirectX 10 nicht mehr gibt, und in OpenGL 3.0
  Depreciated sind. Renderer Backends sind nicht gezwungen das Interface zu Implementieren - z.B. PLRendererOpenGLES wird es nicht implementieren.
- GetDefaultMaterialState(), ResetMaterialStates(), GetMaterialState(), SetMaterialState() nach FixedFunctions verschoben
- ShaderProgramCgBackend: Die "Verdrahtung" von Fixed-Function Render States und Shadern werd ich nun ebenfalls Schrittweise rausnehmen, das ist aus
  heutiger Sicht einfach nur noch dÃ¤mlich und umstÃ¤ndlich und viel zu EinschrÃ¤nkend. (haben wir eh nie ernsthaft genutzt) Entweder nutzt man Fixed-Function,
  oder gleich saubere Shader basierende Konzepte.
- GetDefaultLightSettings(), ResetLights(), IsLightEnabled(), SetLightEnabled(), GetLight(), SetLight() nach FixedFunctions verschoben
- Lighting, Ambient, NormalizeNormals von "RenderState" nach "FixedFunctions::RenderState" verschoben
- FogEnable, FogColor, FogDensity, FogStart, FogEnd, FogMode von "RenderState" nach "FixedFunctions::RenderState" verschoben
-> Achtung: In plfx-Dateien muss nun z.B. "Lighting" in "FixedFunctionsRenderStates" und nicht mehr "RenderStates" stehen
   (das ist schon OK das diese Namen nun lÃ¤nger sind - denn man sollte es NICHT mehr nutzen weils immer mehr Hardware gibt wo das einfach nicht mehr lÃ¤uft *g*)
- Renderer-Flags BindNoTextures, BindNoShaders, LockModeStates, LockZBufferStates, LockAlphaStates, LockBlendStates, LockStencilStates, LockPointStates,
  LockTessellationStates, LockScissorTestStates entfernt... soetwas war noch nie schÃ¶n und das ist mit dem Scene Renderer Konzept eh nun Ã¼berflÃ¼ssig.
  (und wer das nicht nutzt, muss sich eh um alles selbst kÃ¼mmern)
- Renderer: GetFlags() und SetFlags() entfernt, das einzige Argument dafÃ¼r war das von eine Zeile weiter oben
- Accumulation Buffer Support entfernt, das stand schon lange auf meiner Abschussliste. Zum einen gibs das nur fÃ¼r OpenGL, in OpenGL 3.0 scheint das auch
  Depriciated zu sein und ich wÃ¼sste auch nicht wofÃ¼r man das noch brÃ¤uchte - denn mittlerweile kann man dafÃ¼r genauso gut FBO nutzen das weit mehr bietet.
  (FlieÃkommazahlen, Blend Funktionen und und und) TiefenunschÃ¤rfe, Motion Blur - alles was man immer liest das dies so toll mit Accumulation Buffer geht,
  geht heute mit FBO und Shadern noch viel besser und Universeller. :D
- Renderer: ReadDepthComponent() entfernt... obwohl ich das ja eigentlich erst vor 6 Jahren eingebaut habe! *g*
  FÃ¼r die Performance ist das *zurÃ¼cklesen* von Werten Ã¼ber die traditionellen OpenGL Funktionen tÃ¶tlich, unter DirectX gibts soetwas nÃ¼sch. Entweder kann
  man Occlusion Queries nutzen um zu ermitteln ob was verdeckt ist, oder man nutzt Render To Texture und holt sich dann die Texture Daten zurÃ¼ck.
  (das meiste wird eh mittlerweile direkt in Texturen gerendert so das man genauso gut "TextureBuffer::Download()" nutzen kann, es aber natÃ¼rlich wegen
  mieser Performance nicht sollte) Wurde auch nirgends mehr verwendet.
- GetDefaultTextureStageState(), ResetTextureStageStates(), GetTextureStageState(), SetTextureStageState() nach "FixedFunctions::RenderState" verschoben
- "TextureStageStates"-Klasse in "FixedFunctionsTextureStageStates" umbenannt
-> Achtung: In plfx-Dateien muss nun z.B. "TexGen" in "FixedFunctionsTextureStageStates" und nicht mehr "TextureStageStates" stehen



>> 07.04.2010
[CO]
- GL_ATI_pn_triangles ("PNTriangles" = "TruForm") durch GL_AMD_vertex_shader_tessellator ersetzt. ATI hat GL_ATI_pn_triangles mittlerweile aus den Treibern
  entfernt und NVIDIA hat das leider nie unterstÃ¼tzt. FÃ¼r Tessellation wird auf ATI Karten seit der HD2000 GL_AMD_vertex_shader_tessellator verwendet, unter
  OpenGL 4 und DirectX 11 ist das dann sogar "Standardisiert" und NVIDIA hat dort ebenfalls Tessellation. Da ich leider keine entsprechende GPU habe, ist das
  fÃ¼r mich derzeit uninteressant - da aber GL_AMD_vertex_shader_tessellator geht kann ich damit erste Tessellation und Displacement Mapping gehversuche machen.
  Displacement Mapping lÃ¤uft bei den *modernen Tessellation Verfahren* ja genauso ab so das man dann die Daten weiternutzen kann.
  GL_AMD_vertex_shader_tessellator wird Ã¼ber GLSL "angesteuert", da wir derzeit nur Cg als Shader Sprache unterstÃ¼tzen konnte ich das noch nicht ausprobieren.
  (ein Grund fÃ¼r mich mehr auch GLSL direkt zu unterstÃ¼tzen *g*)
  Im grunde wollte ich HauptsÃ¤chlich erstmal GL_ATI_pn_triangles drauÃen haben, war aber einfacher das direkt durch GL_AMD_vertex_shader_tessellator zu ersetzen
  als das erstmal ganz rauszunehmen, und spÃ¤ter wieder einzubauen.



>> 05.04.2010
[CO]
- Dort wo angebracht wird nun PLMath::Vector2i & PLMath::Vector3i anstatt GetWidth(), GetHeight() und GetDepth() verwendet



>> 04.04.2010
[CO]
- "Renderer::Clear()": Die Farbe Ã¼bergibt man nun als PLGraphics::Color4 und nicht mehr als PLGeneral::uint32. Zum einen war das UmstÃ¤ndlich, aber noch
  viel wichtiger - nun ist es auch mÃ¶glich z.B. einen Buffer mit der Farbe "2 2 2 2" zu lÃ¶schen, etwas was man u.B. bei FlieÃkommazahlen Render Targets
  brauchen kann!
RendererOpenGL:
- Die Extension "GL_ARB_color_buffer_float" wird nun unterstÃ¼tzt, damit kann man beeinflussen ob wo Automatisch Zahlen auf den Bereich [0, 1] beschrÃ¤nkt werden



>> 02.04.2010
[CO]
RendererOpenGL:
- "RendererOpenGL::SetColor()" setzt nun sofort die Farbe mit "glColor4f()", damit passiert das nur noch an einer Stelle - aber viel wichtiger ist,
  das "glColor4f()" im Zusammenspiel mit Shadern nix bringt und bisher in "RendererOpenGL::DrawPrimitives()" dann Overhead drinnen war.
- "RendererOpenGL::m_bWorldMatrixChanged" entfernt. Die Lazy-Evaluation ist zwar fÃ¼r Fixed-Function Rendering ganz nett, aber bei Shadern ist
  "glLoadMatrixf()" witzlos sofern man die States nicht Ã¼ber GLSL ausliest, was ich aber nicht mache und nicht machen werde. Noch ein Overhead
  bei verwendung von Shadern weniger.
- "RendererOpenGL::SetRenderTarget()": Vertex & Fragment Shader werden nicht mehr zurÃ¼ckgesetzt, das ist wirklich ziemlich stÃ¶rend - hab alles
  durchgetestet, geht alles noch.



>> 01.04.2010
[CO]
- Neue Funktion "SurfaceTextureBuffer::TakeDepthBufferFromSurfaceTextureBuffer()", damit kann eine Render Texture einer anderen den Tiefen Buffer
  Stehlen... oder freundlicher ausgedrÃ¼ckt: Der Tiefenbuffer wird Freundschaftlich herumgereicht, wie die Fackel bei der ErÃ¶ffnung der Olympischen
  Spiele. *g*
  Ich weis noch nicht ob das final so bleibt, aber momentan will ich hier noch keine zu groÃen Umbauten machen. "PLScene::SRPDeferred" Implementationen
  nutzen das bereits und es klappt zumindestens recht gut.



>> 29.03.2010
[CO]
- Material: DetailNormalMap, HorizonMap, DiffuseRampMap, SpecularRampMap und EdgeRampMap Strings entfernt da schon viel zu sepeziell



>> 27.03.2010
[CO]
- Parameters: Integer, Integer2, Integer3, Integer4 und float3x3 Typen hinzugefÃ¼gt... alles Typen die ich nun schon mehrmals nutzen
  wollte und mich jedesmal etwas Ãrgerte als die nicht Existierten und es dadurch UmstÃ¤ndlicher wurde



>> 25.03.2010
[CO]
- Material: "AmbientOcclusionMap"-String hinzugefÃ¼gt - da wir diesen Map-Typ mittlerweile unter dem Namen "LightMap" bereits fÃ¼r
  viele Projekte verwendet haben, und laut Jens auch superduper wichtig ist und bleibt, ist das wohl gerechtfertigt das zu einem
  "bekannten Standard Parameter" zu machen.



>> 20.03.2010
[CO]
- Neue Funktion "SurfaceTextureBuffer::SetMaxColorTargets()"
-> Das "Render To Texture"-System muss ich umbedingt mal komplett Ã¼berarbeiten... seit ich das System Implementiere hatte, hat sich enorm
   viel getan und es ist viel neues hinzugekommen. Das Rendern in Texturen ist heute Ã¼ber FBO in OpenGL aber sehr schÃ¶n und einfach zu realisieren
   und verdammt mÃ¤chtig. Das aktuelle PLRenderer-Interface beschrÃ¤nkt die MÃ¶glichkeiten derzeit noch und es ist ein viel zu groÃer interner Overhead
   vorhanden. ZukÃ¼nftig muss FBO und Render Texturen getrennt werden, denn ein FBO kann man fÃ¼r sehr viele Dinge direkt so wiederverwenden und
   braucht nicht jedesmal wenn man in eine Texture Rendern will dazu ein neues FBO. Anhand des Deferred Scene Renderers kann man schÃ¶n sehen
   wie das Render To Texture heute normalerweise eingesetzt wird.
- "RendererOpenGL::GetOpenGLFormat()": Ich bin hier gerade wieder Ã¼ber etwas gestolpert das mir bei meiner Bachelorarbeit, wo ich u.a. krÃ¤ftig mit
  OpenGL 3.2 herumspielte, aufgefallen ist. Will ich in Texturen Rendern die nur eine Komponente haben, muss man bei z.B. glTexImage2D
  GL_RED als Format angeben und nicht GL_LUMINANCE oder GL_INTENSITY. Alles andere geht nicht. Ich hab noch irgends wirklich Literatur gefunden die dieses
  Verhalten erklÃ¤rt... na hoffentlich gehts so auch auf NVIDIA Karten. (zumindestens auf dem FH System mit NVIDIA Karte ging das damals in meiner Bachelorarbeit)



>> 17.03.2010
[CO]
- RendererOpenGL: Multi-Render-Targets Support lÃ¤uft, in "FrameBufferObject::Finish()" fehlte nur ein "glDrawBuffer(GL_NONE);". Man bin
  ich froh das dies endlich lÃ¤uft... vor einigen Jahren ging das ja gar nicht so richtig, Crashte etc. - das lag glaub ich aber an meiner
  damaligen Hardware. Im PLSample "PLSampleRTT" kann man testen ob alles lÃ¤uft, da mÃ¼ssten nun einige Teapots mit Grundfarben sein.
  GL_COLOR_ATTACHMENT0_EXT - GL_COLOR_ATTACHMENT15_EXT sind definiert, daher werden nun in diesem Renderer Backend 16 Render Targets
  UnterstÃ¼tzt... meine GPU hat beispielsweise 8 davon.



>> 15.03.2010
[CO]
- "nBitsPerPel" in "nColorBits" umbenannt da es so an anderen Stellen geschrieben wird und besser lesbar ist
- "RenderWindow": Neue Funktionen: "GetDisplayMode()" und "SetDisplayMode()", damit ist das Interface Ã¤hnlich zu "RenderFrame"



>> 14.03.2010
[CO]
- An die Ãnderungen des Konfigurations-Systems angepasst
- Texture-Manager: Neue Funktionen: "GetTextureQuality()" und "SetTextureQuality()"
- Texture-Manager: Neue Funktionen: "AreTextureMipmapsAllowed()" und "SetTextureMipmapsAllowed()"
- Texture-Manager: Neue Funktionen: "IsTextureCompressionAllowed()" und "SetTextureCompressionAllowed()"
- "RenderFrame"-Konstruktor Ã¼berarbeitet. Wenn ein Fenster sofort im Vollbild-Modus erzeugt werden soll, so muss man nun
  noch weitere Einstellungen Ã¼ber "DisplayMode" Ã¼bergeben. (wurde bisher fest verdrahtet Ã¼ber eine globale Konfiguration ausgelesen)
  Das mÃ¼sste alles etwas Flexibler machen.
- "RenderFrame": Neue Funktionen: "GetDisplayMode()" und "SetDisplayMode()"
- "RenderFrame": Neues Event: "EventDisplayMode"
- "Renderer::CreateFrame()" entfernt da nicht wirklich nÃ¶tig
- "Config" nach "PLEngine" verschoben und in "RendererConfigGroup" umbenannt
- "DisplayMode" um "nZBufferBits", "nStencilBits", "nAccumBits" und "nAntiAliasing" erweitert, diese Informationen werden ebenfalls
  benÃ¶tigt wenn ein Fenster zum Rendern eingerichtet werden soll (wurde bisher fest verdrahtet Ã¼ber eine globale Konfiguration ausgelesen)
- "RenderWindow"-Konstruktor Ã¼berarbeitet
- "Renderer::GetConfigs()" entfernt da nicht mehr benÃ¶tigt. Dort war bisher eh nur eine "DisplayMode"-Instanz enthalten, was noch aus den
  Anfangszeiten stammt... mittlerweile kanns ja mehrere Fenster geben, und im Grunde eigentlich Prinzipiell auch mehrere Vollbild-Fenster -
  darum macht eine DisplayMode Information pro Renderer keinen Sinn. Diese Information ist pro Render-Fenster. Andere Renderer EinstellmÃ¶glichkeiten
  gehen direkt Ã¼ber das Renderer-Interface.
- "RendererBackend::UpdateCurrentDisplayModeInformation()" entfernt da unnÃ¶tig



>> 10.09.2009
[CO]
- "Texture::Load()" nutzt das neue "PLGraphics::ImageEffects::RemovePalette()" um Paletten aufzulÃ¶sen da Texturen mit
  Paletten nicht unterstÃ¼tzt werden



>> 02.08.2009
[CO]
- "EventListener" entfernt -> ein Ãberbleibsel aus unserer "Listener Zeit". :D
  Stattdessen gibts nun in "Animation" ein neues "EventSpecialFrame"-Event.
  Die Funktionen "GetNumOfEventListeners()", "IsEventListener()", "AddEventListener()", "RemoveEventListener()" und
  "ClearEventListeners()" in den Ruhestand geschickt.



>> 07.07.2009
[CO]
PLRendererOpenGL:
- "RendererOpenGL::MakeScreenshot()": Da bei OpenGL der Bildmittelpunkt links unten ist, mÃ¼ssen wir das erhaltene
  Bild um die Y Achse Spiegeln (die alte Image Klasse machte das Automatisch)
- "RendererOpenGL::MakeScreenshot()": Falls gerade ein FBO verwendet wird, wird "SurfaceTextureBuffer:::Finish()"
  aufgerufen damit im Falle von Multisample der Inhalt aktualisiert wird... macht man das nicht, bekommt man nur
  einen schwarzen Inhalt zu sehen



>> 11.06.2009
[SB]
PLRendererOpenGL:
- Linux-Implementation an neue OpenGL-Extensions angepasst und einige Ãbertragungsfehler behoben.
- Das Projekt lÃ¤sst sich nun auch wieder fehlerfrei unter Linux/gcc Ã¼bersetzen. 



>> 04.06.2009
[CO]
PLRendererOpenGL:
- "TextureBuffer2D::RestoreDeviceData()": Wenn es eine Tiefentexture ist mÃ¼ssen auch entsprechende Einstellungen
  wie in "TextureBuffer2D::TextureBuffer2D()" gemacht werden da ansonnsten z.B. Shadow Maps nach einem Bildschirm
  Modus wechsel nicht mehr sichtbar sind.



>> 31.05.2009
[CO]
PLRendererOpenGL:
- "GL_ARB_multisample" OpenGL Extension wird nun unterstÃ¼tzt fÃ¼r Anti-Aliasing
- "GL_EXT_framebuffer_multisample" & "GL_EXT_framebuffer_blit" OpenGL Extensions werden nun unterstÃ¼tzt fÃ¼r
  Anti-Aliasing wÃ¤hrend in Texturen gerendert wird
- "FrameBufferObject" & "SurfaceWindow" um Multisample Support erweitert
- In der Renderer-Config (z.B. "PLRendererOpenGL.cfg") gibts die neue Option "AntiAliasing" fÃ¼r Anti-Aliasing.
  StandardmÃ¤Ãig ist das 0, also aus, da das natÃ¼rlich etwas an Leistung kostet. (sieht aber schick aus :)
  Typische Werte sind: 2, 4, 8...
- "SurfaceTextureBuffer": Neues Flag "NoAntiAliasing": Damit lÃ¤sst sich Anti-Aliasing unterdrÃ¼cken - das ist z.B.
  beim Shadow Map rendern nÃ¼tzlich da der QualitÃ¤tsunterschied hier praktisch nicht sichtbar ist... aber der Leistungs
  unterschied schon!



>> 29.05.2009
[CO]
- "Texture::Load()": Ich entschloss mich dazu CubeMaps Ã¼ber 'plt'-Dateien und dann entsprechende Dateinamen fÃ¼r die
  anderen CubeMap Seiten komplett herauszunehmen. Das ist einfach zu kompliziert und auch fehleranfÃ¤llig da sehr
  schnell dann mal CubeMap Seiten nicht den Anforderungen entsprechen. Das zusammenfummeln der CubeMap Ã¼ber die
  'plt'-Datei und Dateinamen war auch nicht sonderlich Benutzerfreundlich. CubeMaps kann man wirklich sehr schÃ¶n Ã¼ber
  das 'dds'-Dateiformat einladen und es gibt auch sehr einfach zu bedienende Tools wie z.B.
  http://ati.amd.com/developer/cubemapgen/index.html um "mal schnell" eine dds CubeMap zu erzeugen. Mir viel kein
  einziger Grund ein der dafÃ¼r sprach das noch drinnen zu lassen.
- "Renderer::CreateTextureBufferCube()" bekommt nun nur noch ein Image-Objekt und kein Feld aus Image-Objekten
  mehr. Damit kann man CubeMaps dem Renderer also NUR noch Ã¼ber ein Image-Objekt das aus verschiedenen Teilen
  besteht Ã¼bergeben - aber das ist dank der neuen Image-Klasse ja absolut kein Problem mehr. :D



>> 28.05.2009
[CO]
- "PLRendererOpenGL": "TextureBufferRectangle::TextureBufferRectangle()": Komprimierte Rectangle Texturen scheinen
  mittlerweile auch ganz wunderbar zu funktionieren



>> 26.05.2009
[CO]
- "Texture::Load()": "gamma correction" rausgenommen da hier nicht wirklich umbedingt nÃ¶tig



>> 21.05.2009
[CO]
- "Renderer::DrawBitmap()" schaltet nicht mehr automatisch in einen "2D Modus" da dies einfach nur unpraktisch ist
  und es nicht mehr mÃ¶glich ist z.B. eine Bitmap "frei" im 3D Raum zu zeichnen. "Renderer::DrawPoint()" schalteten
  ebenfalls nicht automatisch in einen "2D Modus" und von der Seite aus war das zusÃ¤zlich sogar noch inkonsequent.
  Durch diese kleine Ãnderung/Vereinfachung ist "Renderer::DrawBitmap()" nun vielseitiger einsetzbar.



>> 20.05.2009
[CO]
- "Font": "Draw()"-Funktion ohne Positionsangabe Ã¼berarbeitet und die hinteren Parameter entfernt. Diese Funktion
  zeichnet nun "nur" noch Text ohne noch zig Render States zu verÃ¤ndern. Dadurch wird der Text z.B. nicht automatisch
  auf "2D" ausgerichtet - was immer mal wieder gewÃ¼nscht ist um den "flachen" Text frei in einer 3D Szene plazieren
  zu kÃ¶nnen.



>> 19.05.2009
[CO]
- "PLRendererOpenGL": "Font2D" & "Font3D": "Draw()": Die aktuelle OpenGL-Farbe braucht nicht weggespeichert und
  wiederhergestellt werden



>> 10.05.2009
[CO]
- "OpenGLRenderContext" etwas aufgerÃ¤umt



>> 06.05.2009
[CO]
- "Animation": "EventFrameChange"-Event hinzugefÃ¼gt damit man von auÃen mitbekommen kann wenn sich etwas Ã¤nderte
  und dann z.B. ein Mesh aktualisieren kann... oder auch nur ein Flag das notiert das ein Mesh Update nÃ¶tig ist :)
- "AnimationManager"-Klasse hinzugefÃ¼gt
- "AnimationManager" besitzt nun ein "EventAnimationFrameChange"-Event das eine "Sammelstelle" fÃ¼r "EventFrameChange"-
  Events darstellt, das vereinfacht die Arbeit wenn man auf alle "EventFrameChange" hÃ¶ren will
- "Surface": Um "EventPaintBegin", "EventPaint" und "EventPaintEnd" Events erweitert damit man z.B. Texturen
  aktualisieren kann bevor das Zeichen beginnt



>> 29.04.2009
[CO]
- "RendererContext" hat nun ein "EventUpdate"-Event das in der neuen "Update()"-Funktion ausgelÃ¶st wird
- "TextureHandler" hat keine "Update()"-Funktion mehr. "TextureHandler::AnimationState()" hÃ¤ngt sich
  in das neue "EventUpdate"-Event von "RendererContext" ein. Dadurch folgen nun einige vereinfachungen
  die dazu fÃ¼hren das viele "Update"-Funktionen wegfallen und dadurch pro Frame weniger Arbeit direkt fÃ¼r
  die Tonne anfÃ¤llt. :D
- "ShaderManager" hat keine "Update()"-Funktion mehr, die war eh praktisch leer
- "TextureManager" hat keine "Update()"-Funktion mehr, die war eh praktisch leer
- "Material" und "MaterialHandler" haben keine "Update()"-Funktionen mehr, dienten nur zum "TextureHandler"-Update
- "Mesh::UpdateMaterials()" entfernt
- "Effect::Update()" macht kein "TextureHandler"-Update mehr, "derzeit" noch drinnen wegen "m_fTimer"
- ... in auf PLRenderer aufbauenden Projekten konnten nun ebenfalls einige "Update"-Funktionen Ã¼ber den Jordan
  gehen. Wie man sehen kann zog das "Texture Animation"-Feature bis jetzt einen heftigen Rattenschwanz quer
  durch alle Projekte "nur" damit "falls eventuell vorhanden" Texture Animationen aktualsiert wurden. Dort gabs
  dann auch noch "Update"-Konflikte so das z.B. eine Animation pro Frame mehrmals an verschiedenen Stellen
  aktualisiert wurde und dadurch die Animation einmal schneller, einmal langsamer abspielte. Das war mir schon
  sehr lange ein Dort im Auge - und Ã¼ber die Events lies sich das nun denke ich recht einfach und ordentlich lÃ¶sen.
- Bugfix: "RendererOpenGL::SetLight()": Directionale Lichter setzen war nicht ok, den Richtungsvektor setzt man
  lustigerweise Ã¼ber die "Position"



>> 26.04.2009
[CO]
- Hoffnunglos veralteten "Selection Buffer" vom Renderer entfernt. Folgende Funktionen gibt es also im
  "Renderer"-Interface nicht mehr: "GetSelectionBuffer()", "SetSelectionBuffer()", "GetRenderMode()",
  "SetRenderMode()", "InitNames()", "PushName()", "PopName()" und "LoadName()"
  In den anderen Projekten musste ledeglich  "PLSampleSceneNodes::SNSampleSelection" angepasst werden,
  ansonnsten wurde das nirgends genutzt da eher umstÃ¤ndlich und eingeschrÃ¤nkt in der Nutzung.
  "Selection Buffer" gab es nur "frÃ¼her" in OpenGL, in DirectX gab es soetwas nie - und ab OpenGL
  3.1 wurde dieses Feature entfernt. So wie es aussieht war das schon in den alten OpenGL Versionen immer
  nur eine "halbe" Sache und wurde in der CPU ausgefÃ¼hrt. Sobald VBO dazu kam ging es schon nicht mehr
  richtig und die Performance lag im einstelligen FPS Bereich... auf meinem aktuellen Notebook scheint es
  sogar Ã¼berhaupt nicht mehr zu funktionieren. HÃ¶chste Zeit also uns komplett davon zu trennen - vorallem
  da man es eh nie wirklich nutzen konnte da es soetwas von Ã¼berhaupt nicht in das PixelLight Scene Renderer
  Konzept passt. :D
- "RenderApplication" von PLRenderer nach PLEngine verschoben
- PLRendererOpenGL: Upsala, "GL_INDEX_ARRAY"/"glIndexPointer()" hat nix mit "Vertex Indices" zu tun sondern
  dies ist fÃ¼r "Color Index Arrays"
- "GetOcclusionQuery()" aus dem "Renderer"-Interface entfernt da dies nicht wirklich nÃ¶tig ist und wohl schnell
  Probleme macht wenn von mehreren Stellen dieser Occlusion Query gleichzeitig genutzt werden wÃ¼rde. Es musste
  nichts weiter angepasst werden da diese Funktion nirgends verwendet wurde. *Ã¼berbleibsel aus vergangenen Zeiten*



>> 22.04.2009
[CO]
- "ShaderLoaderCg::Load()": Implementation Optimiert: Falls die Ã¼bergebene Datei bereits im Speicher liegt
  und am Ende eine "\0" ist, so wird die Datei nicht nochmals "Zwischengespeichert" sondern das bereits
  im Speicher liegende kann direkt so genutzt werden.



>> 15.04.2009
[CO]
- "ShaderManager": "Load()"-Funktion hinzugefÃ¼gt der man direkt ein "File"-Objekt Ã¼bergeben kann
- "ShaderManager" hat keinen "Default Shader" mehr da dieser nicht wirklich einen Sinn hat (Shader
  sind einfach speziell und lassen sich nicht einfach produktiv Ã¼berall drauf klatschen wie z.B.
  das bei Texturen mÃ¶glich ist) und nur dazu fÃ¼hrt das ein total nutzloser Shader immer am Anfang
  eingeladen wird was dann dazu fÃ¼hrt das "Cg" Initialisiert wird auch wenn man in einem Projekt
  Ã¼berhaupt keine Shader nutzt.
- "EffectManager": "Default.plfx" wird nicht mehr geladen sondern dynamisch erzeugt damit man nicht
  immer gezwungen ist "Standard.zip" auszuliefern



>> 11.04.2009
[SB]
- PLRendererOpenGL: Habe versucht, die Ãnderungen mit dem OpenGLRendererContext auf Linux anzupassen. Leider
  sind mir so so beim drÃ¼berschauen, ohne die Ãnderungen selbst gemacht zu haben, nicht wirklich alle
  ZusammenhÃ¤nge klar, weshalb dieses Unterfangen nicht gerade leicht ist. Deshalb wÃ¤re es wirklich gut,
  wenn gerade bei solchen StrukturÃ¤nderungen auch *immer* die Linux-Variante mit angepasst wird, damit
  das nicht spÃ¤ter immer schwieriger wird, das ganze noch anzupassen. Ich weiss, dass das etwas blÃ¶d ist,
  wenn man selbst nicht unter Linux arbeitet und dazu der Linux-Port noch gar nicht funktionsfÃ¤hig ist. Aber
  fÃ¼r mich wird es auch immer schwieriger, das System unter Linux zu warten, wenn ich stÃ¤ndig 
  hinterherarbeiten muss, weil nach ein paar Wochen grundsÃ¤tzlich irgend eine Ãnderung dazu gefÃ¼hrt hat,
  dass das Projekt sich unter Linux nicht einmal mehr Ã¼bersetzen lÃ¤sst. Also bitte in Zukunft mal mehr
  darauf achten, insbesondere bei solchen Ãnderungen, wo dann sogar eine wgl-Funktion aus dem #ifdef
  herausgezogen wurde. Dann kann ich zumindest weiter unter Linux arbeiten und das System bleibt einiger
  Massen aktuell auch unter Linux. Und dann kann ich in der nÃ¤chsten Zeit endlich den Linux-Port komplett
  neu aufsetzen, dann wird das ganze auch sinnvoller zu warten, wenn es auch endlich mal funktioniert :-)
  Aber bis dahin wÃ¤re es nett, wenn ich zumindest nicht stÃ¤ndig damit kÃ¤mpfen mÃ¼sste, dass es sich mal
  wieder nicht einmal mehr Ã¼bersetzen lÃ¤sst.



>> 08.04.2009
[CO]
- "RendererBackend::GetOcclusionQuery()" erzeugt die interne Instanz erst wenn diese zum ersten mal benÃ¶tigt wird



>> 05.04.2009
[CO]
- "RendererOpenGL::Font2D" & "RendererOpenGL::Font3D": Die Fonts werden intern erst dann erzeugt wenn diese zum
  ersten mal benÃ¶tigt werden (falls dies Ã¼berhaupt mal der Fall ist... :)



>> 01.04.2009
[CO]
- "OpenGLRenderContext" hinzugefÃ¼gt damit diese Dinge zukÃ¼nfig Ã¼berschaubar beisammen sind
- "RendererOpenGL::GetRenderingContext()" in "RendererOpenGL::GetOpenGLRenderContext()" umbenannt, gibt nun
  "OpenGLRenderContext" zurÃ¼ck
- "RendererOpenGL::BackupDeviceObjects()" & "RendererOpenGL::RestoreDeviceObjects()": Der OpenGL Rendering Context
  muss hier NICHT zerstÃ¶rt und wieder erzeugt werden
- "RendererOpenGL::CreateContext()" & "RendererOpenGL::DeleteContext()" entfernt, der OpenGL Render Context
  wird nun direkt in "RendererOpenGL::Init()" & "RendererOpenGL::DeInit()" erzeugt und zerstÃ¶rt
- Die OpenGL-Extensions werden nun im "OpenGLRenderContext"-Konstruktor initialisiert und nicht mehr in
  "SurfaceWindow::Init()" bzw. "SurfaceLinux::Init()"



>> 08.03.2009
[CO]
- "Material::Load()"-Implementation Ã¼berarbeitet. Wenn man im Material eine "einfache Texture" einladen wollte MUSSTE diese immer eine
  bekannte Dateiendung haben oder das Laden schlug fehlt. Da man aber durchaus auch z.B. Dynamische Texturen haben kann die irgendeinen beliebigen
  Namen mit oder ohne "bekannte Dateiendung" haben sollte man hier keinen Namenscheck machen sondern einfach den Namen der zu verwendenden
  Texture "durchreichen".
- "Texture::Load()": Beim skalieren aufgrund von veringerter QualitÃ¤t wurden Warnungen rausgeschrieben das die Texture grÃ¶Ãe nicht passt...
  das sollte natÃ¼rlich nicht sein und die "NUR die Original" grÃ¶Ãe sollte auf passende Dimensionen hin geprÃ¼ft werden und nicht die errechnete
  verkleinerte Dimension!
- "Texture::Load()": Beim skalieren wird nun auch noch ins Log geschrieben wie groÃ die Texture ursprÃ¼nglich war



>> 07.02.2009
[CO]
- 'RendererBackend::UpdateCurrentDisplayModeInformation()': Wird die 'gegebene' AuflÃ¶sung nicht gefunden, so wird nun zuerst versucht eine
  AuflÃ¶sung zu finden 'die nah dran ist' - erst wenn auch das fehlschlÃ¤gt wird die erstbeste AuflÃ¶sung genommen
- 'Parameters': 'GetParameterTexture()' & 'SetParameterTexture()' hinzugefÃ¼gt so das man nicht zwanghaft direkt Ã¼ber 'TextureBuffer' gehen muss.
  ('Texture' kann als eine art 'TextureBuffer Handler' angesehen werden)
- 'Parameters': 'GetParameterString()' in 'GetParameterString()' und 'SetParameterString()' in 'SetParameterString()' umbenannt damit konsistent
  zu den anderen Funktionen



>> 06.02.2009
[CO]
- 'RendererOpenGL::Init()': 'PLRendererOpenGL.cfg' wurde zwar geladen aber intern gibts derzeit noch ein
  'm_sConfigs.sDisplayMode' das nicht auf die gelesenen Werte gesetzt wurde



>> 05.02.2009
[SB]
- Animation: Wenn man eine Animation z.B. von Frame 0 - 50 abspielen lÃ¤Ãt, sprang diese am Ende wieder auf
  Frame 0 zurÃ¼ck, da bei Stop() automatisch Reset() aufgerufen wurde. Habe dies nun geÃ¤ndert und in Stop()
  nur noch das aktuelle Abspielen beendet, nicht aber die gesamte Animation zurÃ¼ckgesetzt. Bitte mal in den
  aktuellen Projekten prÃ¼fen, ob irgendwo das alte Verhalten vorausgesetzt wurde.



>> 04.02.2009
[SB]
- Projekt auf Basis von RendererNull begonnen. Dies soll ein OpenGL ES 2.0 kompatibler Renderer fÃ¼r PixelLight werden.
  ZunÃ¤chst implementieren wir dies anhand des OpenGL ES Emulator SDKs und dessen Samples.
- SurfaceWindow implementiert. Es kann erfolgreich ein Fenster mit diesem Renderer geÃ¶ffnet und ein Kontext erzeugt werden.
  Testweise rendere ich in Present() ein simples Dreieck (Ã¼bernommen aus dem Sample), damit man schonmal was sieht :-)  



>> 04.02.2009
[CO]
- 'RendererOpenGL' & 'RendererD3D9': 'QueryDisplayModes()' filtert nicht mehr kÃ¼nstlich ohne das man dies von auÃen
  beeinflussen kÃ¶nnte
- 'Renderer': Neue Funktion: 'GetDisplayModes()': Kann eine Liste 'sicherer' Bildschirm-Modi zurÃ¼ckgeben, man sollte
  wenn mÃ¶glich immer diese Funktion nutzen um auf der halbwechs sicheren Seite zu sein
- 'RendererBackend::UpdateCurrentDisplayModeInformation()' nutzt nun als Fallback die erste gefundene 'sichere'
  BildschirmauflÃ¶sung
- 'RendererBackend::UpdateCurrentDisplayModeInformation()': Hier MUSS man derzeit auch noch die Einstellungen in der
  Konfiguration aktualisieren



>> 01.02.2009
[CO]
- 'Font': Derzeit gibts hier ein kleines Problem mit der 'virtuellen BildschirmgrÃ¶Ãe'... 'Renderer::Begin2DMode()' hat als Default eine
  'normalisierte BildschirmgrÃ¶Ãe', sprich, Breite und HÃ¶he sind immer 1... das beiÃt sich allerdings wenn man Font grÃ¶Ãe in Pixel angeben will.
  Wir mÃ¼ssen uns das hier nochmal ganz genau anschaun und uns Ã¼berlegen was wir hier machen wollen. Das einfachste wÃ¤re wenn man keine
  'normalisierte BildschirmgrÃ¶Ãe' unterstÃ¼tzen wÃ¼rde, allerdings hÃ¤tte das den Nachteil das man dann immer wissen muss was gerade die
  BildschirmgrÃ¶Ãe (virtuell oder nicht) ist. Damit das nach auÃen hin erstmal wie gehabt funktioniert baute ich einen Hack ein.



>> 31.01.2009
[CO]
- 'ParameterManager::SetParameterTextureBuffer()': Wenn die interne Texture nur durch einen Texture Handler genutzt wird ist es relativ sicher
  einfach der Texture einen neuen Texture Buffer zu geben - dadurch werden nicht mehr so oft dynamisch Texturen erzeugt und wieder zerstÃ¶rt.
  (viel mir bei 'SCMirror' auf)



>> 30.01.2009
[CO]
- 'Font': Die 'Draw()'-Funktionen nutzen nun standardmÃ¤Ãig die 'virtuelle BildschirmgrÃ¶Ãe' anstatt die gerade im Viewport eingestellte grÃ¶Ãe...
  dadurch passt sich die Schrift der Fensterskalierung "automatisch" an. Will man das 'alte' Verhalten, also SchriftgrÃ¶Ãe unabhÃ¤ngig von Viewport
  grÃ¶Ãe, so kann man dies Ã¼ber einen optionalen Parameter einstellen.
  Gleiche Ã¤nderung bei 'GetWidthRelative()' und 'GetHeightRelative()'.



>> 29.01.2009
[CO]
- 'RenderApplication::Update()': Auch bei gesetzten 'bForceUpdate' MUSS natÃ¼rlich 'Timing::GetInstance()->Update()'
  aufgerufen werden



>> 25.01.2009
[CO]
- 'Renderer': 'GetVendor()' hinzugefÃ¼gt damit man z.B. rausfinden kann ob man gerade eine ATI oder NVIDIA GPU vor sich hat



>> 21.01.2009
[CO]
- 'RenderStates': 'DstBlendFunc' hat nun als Default-Einstellung 'InvSrcAlpha' statt 'One' da dies gÃ¤ngiger und viel nÃ¼tzlicher ist und
  wir selbst auch 'meistens' nutzen
- 'Animation': 'GetStartFrame()' & 'GetEndFrame()' & 'GetNumOfFrames()' hinzugefÃ¼gt



>> 20.01.2009
[CO]
- 'ShaderManager::Load()': Diese Funktion unterscheidet nun zwischen 'Dateiname' und 'Name'... denn aus einer
  Shader Datei kÃ¶nnen Ã¼ber Defines eine vielzahl spezieller Shader erzeugt werden.



>> 10.01.2009
[CO]
- 'RenderFrame': Neben 'Alt-Return' kann man nun auch 'AltGr-Return' zum Vollbildmodus wechseln nutzen, das scheint so gÃ¤ngig zu sein
  (und ist auch viel 'bequemer' da man das auf normalen Tastaturen mit nur einer Hand machen kann *g*)



>> 09.01.2009
[CO]
- 'RenderApplication': 'IsFullscreen()' & 'SetFullscreen()' & 'OnFullscreenMode()' hinzugefÃ¼gt
- 'RenderFrame': 'SetFullscreenMode()' in 'SetFullscreen()' umbenannt damit konsistent zu den anderen Ã¤hnlichen
  Funktions Namen
- 'SurfaceWindow::Init()': Der OS Mauszeiger wird nicht mehr sichtbar/unsichtbar gemacht - auch im Vollbild
  Modus kann der OS Mauszeiger scheinbar korrekt angezeigt werden... auf jedenfall auf den bis jetzt getesteten
  Systemen - meine mich erinnern zu kÃ¶nnen das dies vor Jahren mal Probleme machte - so wie es jetzt ist ist's
  jedenfalls viel besser.



>> 03.01.2009
[CO]
- 'Parameters' um 'String'-Typ erweitert den man fÃ¼r alles nutzen kann das nicht so recht in die anderen Typen passen mag. Nun hat
  man auch in 'ParameterManager::SetParameterString()' keine Probleme mehr 'automatisch' einen entsprechenden Parameter hinzuzufÃ¼gen.
 (kein Sonderfall mehr :) Dummerweise muss man nun 'PLGeneral::String' in dieser + davon abgeleiteten Klassen schreiben da sonst der
 Compiler nicht weis was man nun meint... aber ich hÃ¤tte es noch weniger schÃ¶n gefunden den 'String'-Typ irgendwie anderst zu nennen.



>> 01.01.2009
[CO]
- 'SurfacePainter' etwas umgebaut. Diese Objekte werden nun statt Ã¼ber 'Surface::CreatePainter()' mit 'Renderer::CreateSurfacePainter()'
  erzeugt und wie gehabt Ã¼ber 'Surface::SetPainter()' gesetzt. 'SurfacePainter' sind nur noch von 'Renderer' zu 100% abhÃ¤ngig, das aktuelle
  'Surface' wird bei den 'Paint'-Funktionen als Parameter Ã¼bergeben. So kann man nun sehr einfach einen SurfacePainter gleichzeitig fÃ¼r
  verschiedene Surfaces nutzen.



>> 31.12.2008
[CO]
- 'RenderApplication::Update()': Ãbernimmt nun den 'Timing' Test so das dies nicht in verschiedenen 'OnUpdate()' Implementationen immer
  wieder aufs neue implementiert werden muss. Ãber 'Update(true)' kann man ein Update erzwingen auch wenn es ein FPS Limit gibt und es
  eigentlich noch gar nicht Zeit fÃ¼r ein Update ist.



>> 03.12.2008
[SB]
- RenderApplication: Neue Methode Update(), die intern OnUpdate() aufruft. In der Mainloop wird nun Update() statt OnUpdate() aufgerufen,
  ausserdem wurde das Abfragen der Gui-Nachrichten aus OnUpdate() entfernt und in die Gui-Mainloop verschoben, damit dies auch wirklich nur
  bei Run() passiert, nicht aber bei eingebetteten Aufrufen. Die Methode Update() muss von aussen aufgerufen werden, wenn nicht per Run()
  eine einige Mainloop ausgefÃ¼hrt wird, sondern die Applikation beispielsweise irgendwo eingebettet wurde.
- RenderApplication: Es wurde bisher nur RenderFrame als Fenster akzeptiert, nicht aber RenderWindow. Es muss aber immer beides beachtet werden,
  damit nicht nur eigenstÃ¤ndige Fenster sondern auch eingebettete Fenster mit 3D-Kontext benutzt werden kÃ¶nnen. Also bitte das RenderWindow
  in Zukunft nicht weiter so vernachlÃ¤ssigen, wie bisher ;-)
- RenderApplication: In OnCreateMainWindow() wird jetzt Ã¼berprÃ¼ft, ob die Applikation eingebettet werden soll, oder nicht, und je
  nachdem wird entweder ein RenderWindow oder ein RenderFrame instanziiert. Das bekommt man vielleicht noch allgemeiner hin, aber
  erstmal sollte es so in Ordnung sein.



>> 12.10.2008
[CO]
- RenderApplication: Wie besprochen geben 'OnCreateRendererContext()' & 'OnCreatePainter()' nix mehr zurÃ¼ck sondern
  setzen 'direkt' in diesen Funktionen



>> 06.10.2008
[CO]
- RendererApplication von PLEngine nach PLRenderer verschoben
- SPDefault: von PLEngine in PLRenderer verschoben



>> 27.09.2008
[CO]
PLRendererOpenGL:
- Nachdem ich gerade ein Grafikkarten-Treiber Update gemacht habe (Catalyst 8.9) Crashten auf einmal viele PL-Szenen....
  Konnte das Problem auf Tiefen Texturen zurÃ¼ckfÃ¼hren:
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  Nach dem erzeugen der Texture ausfÃ¼hren und schon war der Treiber-Crash weg...



>> 12.09.2008
[CO]
PLRendererOpenGL:
- RendererOpenGL::SetupCapabilities(): Merkte gerade das auf meinem benntec-Computer 'nMaxTextureUnits' auf 4 stand, das aber hÃ¤tte
  32 sein mÃ¼ssen. Schaute mir das hier also mal an... so wie es aussieht gabs bei GL_ARB_multitexture eine Ãnderung bzw. wie man
  mit 'Texture Units' umgeht. "http://developer.nvidia.com/object/General_FAQ.html" hier steht auch etwas darÃ¼ber. Machte erstmal
  ein Kommentar in den Code - das muss ich mir nun genauer anschaun und Ã¼berlegen wie ich das korrekt Umbauen kann.
  Wird wohl Zeit das PLRenderer Refactoring langsam mal in Angriff zu nehmen...



>> 04.09.2008
[CO]
- Renderer::GetDescription() in Renderer::GetAPI() umbenannt das z.B. 'OpenGL' oder 'Direct3D' zurÃ¼ck gibt... das bringt mehr
  als eine 'Beschreibung' da man dann einfach testen kann welche API gerade genutzt wird. Desweiteren kann man Ã¼ber diese Funktion
  auf Wunsch auch die 'Version' bekommen - wobei diese API abhÃ¤ngig ist.
PLRendererOpenGL:
- VertexBuffer::Allocate: Wenn kein VBO verfÃ¼gbar ist wird die Software-Implementation genutzt
- IndexBuffer::Allocate: Wenn kein VBO verfÃ¼gbar ist wird die Software-Implementation genutzt
- VertexBuffer::MakeCurrent(): Das 'return' beim setzen der Vertex Daten war definitiv KEINE gute Idee von mir... denn sobald
  'GL_ARB_vertex_program' nicht vorhanden war sah man dann gar nix mehr. Jetzt sieht man selbst dann bei 'Basic.sr'
  noch etwas wenn man seinen Grafikkarten-Treiber Deinstalliert - hatte nÃ¤mlich heute hier den Fall das jemand keinen
  OpenGL Treiber Installiert hatte und der sich dann wunderte das nix ging...



>> 27.08.2008
[CO]
- 'Window' zu 'RenderWindow' und 'Frame' zu 'RenderFrame' gemacht damit man ohne Namespace keine Namenskonflikte mit den
  gleichnamigen PLGui Klassen bekommt was schon ziemlich stÃ¶rend war
- 'RenderWindow' und 'RenderFrame' ans RTTI angestÃ¶ppelt damit man fÃ¼r 'sicheres Casting' 'IsInstanceOf()' nutzen kann



>> 24.08.2008
[CO]
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da fÃ¼r 32 Bit als auch fÃ¼r 64 Bit



>> 20.08.2008
[SB]
- Font2D: Texte kÃ¶nnen nun auch transparent gerendert werden, zuvor wurde der Alpha-Wert der Farbe ignoriert.



>> 17.08.2008
[CO]
- Frame: Registriert 'Hot Key' fÃ¼r 'Alt-Return' zum Vollbild-Modus wechseln was eine recht gÃ¤ngige Kombination ist.
  Durch die kleine PLGui Erweiterung von heute muss man endlich nicht mehr 'Strg-Alt-Return' drÃ¼cken (sonst konnte man das nicht
  abfragen) was umstÃ¤ndlich war und auf das man auch nicht wirklich von selbst kam.
- Frame: 'EventFullscreenMode'-Event hinzugefÃ¼gt das ausgelÃ¶st wird nachdem sich der Vollbild-Modus verÃ¤ndert hat



>> 08.08.2008
[CO]
- Wie von Stefan gewÃ¼nscht erzeugt ParameterManager nun automatisch 'fehlende' Parameter wenn man z.B. "SetParameter3f()" nutzt.
  "SetParameterString()" ist jedoch nicht in der lage automatisch Parameter zu generieren, denn diese Funktion bekommt nur einen
  String, zum Parameter erzeugen muss aber bekannt sein von welchem Typ dieser Parameter ist. Einen 'String' Typ gibts nicht, der
  wÃ¼rde nicht wirklich sinn hier machen + wenn man floats als String Ã¼bergibt bekommt man sicherlich nicht das als Ergebniss was
  man wollte, z.B. einen Float3-Parameter. Man kÃ¶nnte aufwÃ¤ndig Parsen und 'raten' was der User wollte, aber das wÃ¤re denke ich
  nicht gut da fehleranfÃ¤llig. Man kÃ¶nnte irgendwie versuchen das gesammte 'Parameter System' noch universeller und flexibler zu
  machen, sehe aber momentan keinen Anlass dafÃ¼r wichitgere Arbeiten fallen zu lassen um mich wieder was neuem zuzuwenden. :D



>> 06.08.2008
[CO]
PLRendererOpenGL:
- Mipmaps mÃ¼ssen bis 1x1 runter definitert werden. Ãbergibt man die Mipmaps direkt Ã¼ber ein 'Image', so wurde bis jetzt 'nur' im
  Log gewarnt wenn die kleinste Mipmap nicht 1x1 ist. Es ergab sich nun allerdings 'wieder einmal' (!) die Situation das wir
  'dds'-Bilder bekamen die zwar Mipmaps hatten, aber z.B. nur bis 2x2. Das Resultat verdutzte mich diese mal etwas, denn 'per'
  Zufall 'verschwanden' immer mal wieder, je nach Blickwinkel etc. (= 'scheinbar ZufÃ¤llig' *g*) Lightmaps die genutzt wurden.
  Zuerst konnte ich nicht sofort das 'Problem' auf die fehlenden Mipmaps zurÃ¼ckfÃ¼hren, tests zeigten das "scheinbar" die Texture
  Koordinaten nach 'links unten sprangen'. (fÃ¤rbte hierzu eine Test-Texture entsprechend)
  Nachdem ich dann auf die Idee kam erstmal alle "Mipmaps mÃ¼ssen bis 1x1 definiert werden"-Warnungen im Log zu beseitigen stellte
  ich fest das das 'Problem' verschwunden war. Wie man anhand dieser Situation sehen kann, kÃ¶nnen die Auswirkungen ziemlich
  happig werden und man erkennt eventuell nicht 'sofort' was das Problem ist. Ich entschloss mich daher die fehlenden Mipmaps
  nun automatisch zu erzeugen - einfach Ã¼ber einen 'weiÃen'-Buffer. Die Textur aufwÃ¤ndig runterzuskalieren war mir offen gesagt
  zu dÃ¤mlich, denn die Log Warnung sagt hier 'Du hast hier noch was zu tun!' und ich will offen gesagt 'schlamperei' nicht
  unterstÃ¼tzen... vorallem da dies sich auch etwas auf die Ladezeit auswirkt wenn man Daten 'selbst erzeugen muss' die 'eigentlich'
  hÃ¤tten mitgeliefert 'werden mÃ¼ssen'. Wenn nur die 1x1 Mipmap fehlt, fÃ¤llt das mit 'weis' nicht wirklich auf - sieht dann hÃ¶chstens
  wie ein kleiner Pixel-Fehler aus, aber dabei bleibts dann wenigstens und lÃ¶st keine Lawine der merkwÃ¼rdigsten Grafig-Bugs aus.



>> 22.07.2008
[SB]
- Font, Font2D, Font3D: Die Methoden, um die GrÃ¶Ãe eines Strings auf dem Bildschirm zu messen, geben anscheinend die tatsÃ¤chliche
GrÃ¶Ãe auf dem Bildschirm, also abhÃ¤ngig von der gewÃ¤hlten AuflÃ¶sung, zurÃ¼ck. Das mag in vielen FÃ¤llen die gewÃ¼nschte Information
sein, ist jedoch unbrauchbar, wenn es z.B. um GrÃ¶Ãen von Strings innerhalb der Ingame-GUI geht. Hier hat man eine virtuelle
AuflÃ¶sung (z.B. 1024x768), daher muÃ das Ergebnis hier auch auf diese virtuelle GrÃ¶Ãe bezogen werden. Das kann jedoch hier nicht
mehr vernÃ¼nftig gemacht werden, weil man dazu z.B. die GrÃ¶Ãe des Fensters wissen mÃ¼Ãte, in dem die Scene gerendert wird in der
die Ingame-GUI angezeigt wird, da die Schrift entsprechend der FenstergrÃ¶Ãe ja auch noch skaliert wird ... :-) An diese
Informationen kommt man aber nicht mehr heran und das wÃ¤re auch nicht gut und nicht wÃ¼nschenswert, da ein Element in z.B. der
Ingame-Gui nicht mehr wissen muss, auf was fÃ¼r einem Surface mit was fÃ¼r einer GrÃ¶Ãe etc. es gerendert wird. Daher habe ich
zusÃ¤tzliche Methoden hinzugefÃ¼gt, um die SchriftgrÃ¶Ãe auf einer virtuellen Skala von 0.0 - 1.0 zu messen. Die Font-Klasse
von GuiPL nutzt dann diese Methode, und rechnet das Ergebnis wiederum auf die virtuelle Gui-GrÃ¶Ãe um. Damit dÃ¼rften nun die
GrÃ¶Ãen-Messungen von Texten auch innerhalb der Ingame-Gui korrekt funktionieren, was bisher immer fehlerhaft war.



>> 17.07.2008
[CO]
- TextureAniLoaderPL & MaterialLoaderPL & EffectLoaderPL & Texture (plt): Um Format Versions Informationen erweitert



>> 11.07.2008
[CO]
- Texture::Load(): Tests auf 'm_nCompressionHint' etc. sollten erst 'nach' dem eventuellen Skalieren der Texture
  gemacht werden... denn dadurch kann es sein das die vorhandene Kompression verworfen werden muss.



>> 24.05.2008
[CO]
PLRendererOpenGL:
- Texturen: 'm_nSamplerState' wurde nicht initialisiert + in RendererOpenGL::RestoreDeviceStates() sollten diese Werte zurÃ¼ckgesetzt werden.
  Da OpenGL diese Einstellungen 'pro Texture' und nicht wie D3D (und bei uns im Renderer Interface) 'pro Stage' eingestellt ist dies
  eine Performance Optimierung da wir vergleichen kÃ¶nnen ob es nÃ¶tig ist einen OpenGL API Call (die man so gering wie mÃ¶glich halten sollte) zu
  machen oder ob die aktuellen Einstellungen noch immer passen.
- TextureBuffer1D::TextureBuffer1D(): Und nochmal ein Hack der Ã¼blen Sorte: Das hochladen komprimierter 1D Texturen scheint zu klappen, aber wenn
  ich dann die Daten wieder von der GPU hole und wieder hochlade (nach Bildschirm wechsel) habe ich irgendwie Schrott in den HÃ¤nden. Wollte zuerst
  das wie in TextureBufferRectangle::BackupDeviceData() machen, also erst hier dann auch nicht Komprimiert schalten, aber sogar das funktionierte
  nicht richtig. Darum habe ich hier nun erstmal intern Texture Kompression fÃ¼r 1D Texturen komplett deaktiviert bis bekannt ist warum da was nicht
  geht und wie man es beheben kann. (Treiber Bug oder wieder etwas das mir einfach nur unbekannt ist?)
  Nicht schÃ¶n, aber noch weniger schÃ¶n ist es in z.B. der 'Cartoon'-Demo Szene nach einem Bildschirm Modus wechsel kaputte Grafik zu haben...



>> 23.05.2008
[CO]
PLRendererOpenGL:
- TextureBufferRectangle::BackupDeviceData(): Baute hier einen doofen Hack ein weil ich momentan keine Ahnung habe was hier los ist und es so herum
  immer noch besser ist als... Hat man eine 'RGB Rectangle Texture' klappt irgendwie das herunterladen der Daten von der GPU nicht so richtig, man
  bekommt die Daten leicht verschoben und wenn man das paar mal macht hat man nur noch Schrott in der Texture. (im schlimmsten Fall kann es sogar
  zu einem Crash im Treiber kommen...) Ist bei meinen ATI und NVIDIA Systemen der Fall wie meine Tests zeigten... mit RGBA gehts, darum stelle ich
  dann hier auf RGBA um. Entweder haben beide Hersteller hier einen Treiber-Bug oder es gibt iiirrgendetwas das man noch beachten muss - aber nicht
  wirklich offensichtlich Dokumentiert wurde. (generell scheint mir RGB eher schlecht denn recht Supported zu sein und irgendwie eher RGBA bevorzugt
  wird, hat wohl was mit der 32 Bit Speicherausrichtung zu tun)



>> 17.05.2008
[CO]
PLRenderer:
- 'Get2DCoordinate() 'und 'Get3DCoordinate()' herausgenommen da dies API unabhÃ¤ngige Mathematische Funktionen sind bzw. 'zu sein haben'. In
  'PLMath::Vector3' finden sich dafÃ¼r nun zwei neue Funktionen Namens 'To2DCoordinate()' und 'To3DCoordinate()' die genau diese Aufgabe Ã¼bernehmen.
- 'Renderer::PickMatrix()' entfernt da 'PLMath::Matrix4x4::RestrictedProjection()' ausreichend ist
- 'Renderer::CreateSelectionPlanes()' entfernt da 'PLMath::PlaneSet::CreateSelectionPlanes()' ausreichend ist



>> 16.05.2008
[CO]
- Neue Klasse: PreviewWindow: Implementiert eine einfache Kamera-Steuerung, das ist recht nÃ¼tzlich und wird bereits an verschiedenen Stellen genutzt
- "EffectLoaderFX" Effect Loader in neues "PLDefaultFileFormats"-Projekt verschoben
PLRendererOpenGL:
- RendererOpenGL::InitWrappers(): 'PLRenderer::TextureBuffer::D16' etc. mappen nun auf 'GL_DEPTH_COMPONENT16' etc. statt alle auf 'GL_DEPTH_COMPONENT'
  da dies nun korrekt zu funktionierten scheint - frÃ¼her ging das mal nicht richtig mit diesen Einstellungen, so herum ist es aber korrekt.



>> 14.05.2008
[CO]
- RendererBackend::Get2DCoordinate() Implementation vereinfacht



>> 12.05.2008
[CO]
PLRendererOpenGL:
- RendererOpenGL::Accum(): Da es warum auch immer bei mir zum Crash kommen 'konnte' (war z.B. in 'PLSampleInGameGui' der Fall) wenn ein 'glAccum'
  Befehl aufgerufen wird wÃ¤hrend man gerade in eine Texture Rendert habe ich das erstmal so gelÃ¶st das Accumulation Buffer NUR fÃ¼r nicht Texture
  Render Targets genutzt wird... auf dauer wird diese FunktionalitÃ¤t dann sowieso in ein 'Legacy'-Interface verschoben darum machte ich mir nun
  nicht die MÃ¼he mich Stundenlang hinzusetzen und rauszubekommen warum das probleme machen kann.



>> 10.05.2008
[CO]
- Material::Load(): Wird nur eine einfache Texture als Material Ã¼bergeben so wird nun kein 'Standard Effekt' mehr gesetzt da sich das in der
  Praxis als "sehr" ungeschickt und umstÃ¤ndlich herausstellte. Am besten fÃ¤hrt man wirklich wenn man wo immer mÃ¶glich nur 'DiffuseMap' etc.
  Material Parameter setzt und den Rest komplett einem Scene Renderer Ã¼berlÃ¤sst. "Effekte" sollte man nach mÃ¶glichkeit nur gaaanz selten
  nutzen da diese natÃ¼rlich nicht mit 'Uniform Lighting and Shadowing' Harmonieren kÃ¶nnen + nicht sonderlich Performant sind weil sich einfach
  jeder Render State potentiell unkontrolliert verÃ¤ndern kann. Und wenn man spÃ¤ter mal einen 'Raytrace Scene Renderer' haben sollte geht das
  schonmal Ã¼berhaupt nicht mehr mit 'Custom Effects' in dieser Art.



>> 01.05.2008
[CO]
PLRendererOpenGL:
- Ich fand gerade heraus wieso z.B. der 'Bloom' Post Processing Effekt so grausam 'blockig' aussah... RendererOpenGL::GetCombinedMinMipFilter()...
  die Kommentare waren richtig, aber dann wurde statt 'GL_LINEAR' einfach 'GL_NEAREST' genommen. *gruml* Auf jedenfall passt das nun wieder
  und 'Bloom' etc. sieht endlich wieder wie 'Bloom' aus.



>> 27.04.2008
[CO]
PLRendererOpenGL:
- RendererOpenGL::RestoreDeviceStates(): Hier sollten natÃ¼rlich auch die Texture Matrizen zurÃ¼ckgesetzt werden... und schon sieht man z.B. in der
  Cartoon-Szene wieder den Himmel...



>> 25.04.2008
[CO]
- Copy-Operators und Copy-Constructors hinzugefÃ¼gt
- Renderer: Font-Funktionen DrawText(), DrawText3D(), GetFontSize(), SetFontSize(), GetFont2D(), SetFont2D(), GetFont3D() und SetFont3D()
  heraus genommen. Die 'Font'-Klasse hat dafÃ¼r nun Draw()-Funktionen... so herum ist es das einfacher zu nutzen und die Ã¼bergewichtige
  'Renderer'-Klasse ist minimal schlanker geworden.
  -> Passte alle Projekte daran an
- Renderer Context um einen einfachen Font Manager erweitert



>> 19.04.2008
[CO]
- Renderer::Clear(): 'nColor' als Default auf '0' gestellt da 'Color4::Black' bei Alpha 1 hat, (da es eine 'Farbe' ist) es aber gÃ¤ngig ist Alpha
  als Default ebenfalls auf 0 zu haben
- Renderer::CreateFont2D() muss man nun noch die Schrift grÃ¶Ãe als Parameter mitgeben
- Font Interface etwas erweitert
- 'Renderer::CreateFont2D()' mit Texture Handler entfernt da ich nicht wirklich einen Grund finden konnte wieso man das mal noch brauchen kÃ¶nnte +
  die Implementation wird dadurch gleich viel Ãbersichtlicher
PLRendererOpenGL:
- Font2D Implementation komplett Ã¼berarbeitet. Wie von Stefan vorgeschlagen wird intern nun FreeType genutzt. Da die Implementation allerdings wieder
  immer unÃ¼bersichtlicher und aufwÃ¤ndiger wurde entschloss ich mich dazu FTGL zu nutzen welches eine 'FreeType->OpenGL'-Schnittstelle darstellt. Damit
  war es bis auf zwei Stellen vergleichsweise einfach bessers Schriften zu realisieren. Das Einladen der Schrift 'direkt aus Speicher' war erstmal
  ungewohnt da das was aus der Datei gelesen wurde erhalten bleiben muss wÃ¤hrend die Schrift verwendet wird. Momentan wird intern wie frÃ¼her auch
  eine 'Texture Font' genutzt da dies einfach die beste Performance hat - allerdings war die Schrift anfangst dann immer 'schwarz' da FTGL die Schrift
  in einer 'GL_ALPHA'-Texture hÃ¤lt. Gestern machte ich recht lange herum, kam aber auf keine LÃ¶sung wie man auch Schriften damit eine Farbe verpassen kann...
  Nachde ich eine Nacht Ã¼ber das Problem geschlafen hatte gelang mir das heute morgen sehr schnell eine saubere LÃ¶sung zu finden: Ãber 'glTexEnvi'
  wird der Alpha-Wert in der Schrift Texture zusammen mit der aktuell Ã¼ber 'glColor' eingestellten Farbe kombiniet - et voila, es sind wieder Farbige
  Texture Schriften mÃ¶glich! :D
  Die aktuelle Implementation ist noch nicht vollstÃ¤ndig, aber soviel wie frÃ¼her geht allemal und es sieht dazu noch besser aus + man kann komfortabel
  Schriften wie 'ttf' oder 'otf' nutzen. FÃ¼r PL sollten wir selbst immer 'otf', also 'OpenType' nutzen da es 'aktueller' ist und die Schrift Dateien
  normalerweise deutlich kompakter sind. (auÃer jemand hat einen guten Grund wieso wie das Format nicht nutzten sollten :)
  -> Passte alle Projekte an diese Ãnderungen an. Als Default-Schrift wird derzeit "Standard.pak/Data/Fonts/LinLibertine_Re-2.7.9.9.otf" genommen. Diese
     Schrift ist ganz ok und kann frei genutzt werden. 'Gefunden' habe ich diese Schrift hier: http://linuxlibertine.sourceforge.net/



>> 13.04.2008
[CO]
- 'RendererContext'-Klasse eingefÃ¼hrt. Diese verwaltet bereits 'Renderer', 'TextureManager', 'ShaderManager', 'EffectManager', 'MaterialManager'
  -> Passte alle Projekte entsprechend an
- Renderer API Wrapper Klassen in 'Renderer'-Unterordner verschoben
  -> Passte alle Projekte entsprechend an



>> 12.04.2008
[CO]
PLRendererOpenGL:
- Versuchte nochmals ein paar Minuten lang GLSL Ã¼ber Cg zu nutzen um Shader 3.0 auf meiner ATI Karte ('natÃ¼rlich' unterstÃ¼tzt Cg NUR NVIDIA Extensions
  fÃ¼r mehr als Shader 2.0!"$=!"$=!") nutzen zu kÃ¶nnen - auf Dauer kommen wir da nicht drum herum. Allerdings waren die Ergebnisse nicht sonderlich
  prall und bis auf supereinfache Shader ging im Grunde nix richtig + man benÃ¶tigt einen Hack der Shader wieder korrekt Deaktiviert, Cg scheint das
  nÃ¤mlich bei GLSL Profilen nicht selbst automatisch zu machen. Schade. Habe das mit Shader unter GLSL korrekt deaktivieren eingebaut, kann das aber
  Zeitlich erstmal nicht weiterverfolgen da noch anderes zu machen ist.



>> 06.04.2008
[CO]
- 'PLRenderer::Texture' in 'PLRenderer::TextureBuffer' umbenannt, das gleiche fÃ¼r die konkreten Typen, so gibt es keinen Namenskonflikt mehr mit
  'PLMesh::Texture'. Passte alle Projekte entsprechend an so das alles wieder lauffÃ¤hig ist. Allerdings muss man die Verwendung in den anderen
   Projekten nochmal genauer durchschaun und prÃ¼fen ob das nun 'Texture' oder 'TextureBuffer' ist damit das sauber getrennt ist.
- Alle Renderer-Backends haben nun ihren eigenen Namespace so wie es mittlerweile auch bei den anderen Ã¤hnlichen Projekten der Fall ist. Das ist
  so herum einfach viel Ã¼berschaubarer was wo liegt + man muss nicht mehr kÃ¼nstlich neue Namen wie z.B. 'TextureBuffer1DOpenGL' generieren.
- 'PLRenderer::Shader' in 'PLRenderer::ShaderProgram' umbenannt, so gibt es keinen Namenskonflikt mehr mit 'PLMesh::Shader'. Passte alle Projekte
  entsprechend an so das alles wieder lauffÃ¤hig ist.
- 'Texture', 'Shader', 'Effect', 'Material' + ein paar Animations-Klassen (da von 'Texture' benÃ¶tigt) von PLMesh nach PLRenderer verschoben. Passte
  alle Projekte entsprechend an so das alles wieder lauffÃ¤hig ist.



>> 05.04.2008
[SB]
- Surface: So geÃ¤ndert, dass der SurfacePainter von aussen gesetzt werden kann. FÃ¼r das neue Application-Framework sollte
  das mÃ¶glich sein, da nun alles im Rahmen einer Application-Instanz erzeugt und verwaltet werden sollt. Ich denke, die alte
  Methode Ã¼ber den Namen kann dann ganz gelÃ¶scht werden. Aber erst, wenn das Framework steht :-)



>> 31.12.2007
[CO]
PLRendererD3D9:
- Konstruktoren der Texture Implementationen noch etwas aufgerÃ¤umt so das man hier im Fehlerfall kein 'return' mehr hat +
  die Daten korrekt zurÃ¼ck gesetzt werden.
- ShaderD3D9::SetParameterTexture(): Die Funktion liefert nun die korrekte Texture Stage zurÃ¼ck an die die Textur gebunden wurde.
  Leider gab es keine 'direkte' MÃ¶glichkeit an diese Information zu kommen, darum musste ich hier etwas Tricksen. :D
- Texturen: Upsala, Image::Mode_DXTCDataFormat != Image::Mode_DXTCFormat ich sollte anfangen meine eigenen Kommentare zu lesen *g*



>> 28.12.2007
[CO]
PLRendererD3D9:
- Auf das "November 2007"-DirectX SDK umgestellt + alle unnÃ¶tigen Libs und Header entfernt (wir nutzen ja wirklich NUR das grundliegenste :)
- Shader gehen wieder soweit, musste dafÃ¼r 'nur' etwas mit ein paar Cg Features herumspielen. MerkwÃ¼rdig ist u.a. das Vertex und Fragment Shader 3.0
  irgendwie fast immer "Unkown error" produzieren. Aber im groÃen und ganzen gehts so nun erstmal. (was nicht heiÃt das Ã¼berall alles ok aussieht, da
  spielen noch andere Dinge mit rein :)



>> 27.12.2007
[CO]
PLRendererD3D9:
- Texture::R8G8B8 Kommentar erweitert da man NICHT davon ausgehen kann das es bei jeder Implementation intern wirklich 24-Bit sind. Unter D3D9
  muss ich z.B. D3DFMT_X8R8G8B8 anstatt D3DFMT_R8G8B8 nutzen da das letztere nicht sonderlich weit vom Hardware-Support her verbreitet zu sein
  scheint. (... egal welche API, immer das gleiche da die Hardware soetwas von unterschiedlich ist...)
- Das 'hochladen' von Textur Daten mit berÃ¼cksichtigung von Kompression und Mipmaps mÃ¼sste nun klappen (konnte jedenfalls keine Probleme
  feststellen)



>> 25.12.2007
[CO]
PLRendererOpenGL:
- Es fehlten Sicherheits-Abfragen fÃ¼r 'glActiveTextureARB' und 'glClientActiveTextureARB'... hab hier zum Testen gerade 'GDI Generic' als Renderer
  laufen, also das was bei Windows beiliegt - und das kann natÃ¼rlich praktisch nix und ich bekam immer sofort einen Crash wenn ich etwas laufen
  lassen wollte.



>> 24.12.2007
[CO]
PLRendererD3D9:
- Man 'sieht' wieder etwas, bei einer der xxx Anpassungen hatte ich die Matrizen falsch Ã¼bergeben



>> 22.12.2007
[CO]
PLRenderer:
- Auf "Cg 2.0 December 2007" umgestellt (keine PL Code Ãnderungen)



>> 21.12.2007
[CO]
PLRendererOpenGL:
- Fand gerade heraus wieso auf meinem neuem Notebook "scheinbar" 'Rectangle Texturen' nicht gehen - stellte sich heraus das auch
  im z.B. Texture Debug Dialog 'normale' Texturen nicht korrekt (bzw. gar nicht) angezeigt wurden... als ich etwas herum probierte
  landete ich am Ende in "RendererOpenGL::DrawBitmap()", genauer gesagt bei der Verwendung von "glMultiTexCoord2f()". Als ich zum
  Testen dort "glTexCoord2f()" einsetzte ging auf einmal alles wie auf dem alten Notebook!
  Googelte etc. etwas, fand aber nix was das erklÃ¤ren kÃ¶nnte... DAS kann eigentlich nur ein Treiber Bug von ATI sein, denn nicht
  nur in PL tritt das bei mir auf. Z.B. sehe ich beim "Starship Troopers"-Spiel (und noch bei anderen Dingen) das gleiche einfarbige
  flackern wie wenn ich in PL Post Processing an habe. ÃRGERLICH!
  Da mir das nun zu blÃ¶de wurde nahm ich die spezielle OpenGL "DrawBitmap()" von uns heraus so das immer mit Vertex Buffern gearbeitet
  wird. "glBegin()" etc. wird in OpenGL 3.0 nicht mehr dabei sein da es total veraltet ist und nicht mehr wirklich ins Konzept passt
  und alles nur umstÃ¤ndlich und langsam macht. (die OpenGL Treiber Entwicklung ist angeblich mittlerweile Horror da alles in zig
  mÃ¶glichkeiten ausartet wovon viele noch aus Zeigen stammen als es keine GPU's gab)
  Ãberlegte mir schon mehrmals ob ich "glBegin()" etc. komplett aus unserem OpenGL Renderer rausnehmen sollte... nun hab ich zumindestens
  einen Grund das an der Stelle rauszuhauen. :D



>> 23.10.2007
[CO]
PLRenderer:
- 'Types.h': Die verschiedenen Konstanten sind nun in Klassen anstatt Namespaces 'verpackt'. So herum sieht das in der
  von Doxygen erzeugten Dokumentation um einiges besser aus da die einzelnen Render-Definitionen nicht mehr als Namespaces
  auftauchen.



>> 20.09.2007
[CO]
PLRenderer:
- IndexBuffer: Neue Funktion namens 'SetElementTypeByMaximumIndex()' hinzugefÃ¼gt die 'automatisch' anhand eines Ã¼bergebenen
  maximalen Vertex Index einen passenden Element Typ setzt. Mir viel vor kurzem auf das wir hÃ¤ufige dieses Zeilen in den
  Codes stehen hatten:
    if (nVertices <= IndexBuffer::MaxVertexIndexUShort)
        pIndexBuffer->SetElementType(IndexBuffer::UShort);
    else pIndexBuffer->SetElementType(IndexBuffer::UInt);
  ... daher denke ich das diese neue Funktion recht Praktisch ist da man nun nur noch
      pIndexBuffer->SetElementTypeByMaximumIndex(nVertices-1);
  schreiben muss was viel Ã¼berschaubarer ist + ganz nebenbei muss man sich keine Gedanken mehr machen ob das nun nur '<'
  oder '<=' ist. *g*



>> 17.09.2007
[CO]
- Alle Projekte von PLBool auf bool zurÃ¼ckgestellt (siehe PLBase Diary-Entrag von heute)



>> 08.09.2007
[CO]
PLRendererOpenGL:
- SurfaceWindowOpenGL::GetGamma(): Der verwendete Buffer liegt nun direkt auf dem Runtime-Stack, in der Funktion konnte
  es sogar ein Speicherleck geben wenn GetDeviceGammaRamp() fehlschlug!
- SurfaceWindowOpenGL::SetGamma(): Der verwendete Buffer liegt nun direkt auf dem Runtime-Stack
PLRendererD3D9:
- TextureCubeD3D9-Konstruktor: Zeiger auf die 6 CubeMap-Seiten liegen nun direkt auf dem Runtime-Stack



>> 06.09.2007
[CO]
PLRenderer:
- Auf "Cg 1.5 August 2007" umgestellt (war nur header, libs und dlls austauschen)
- cgSetAutoCompile() auf CG_COMPILE_LAZY gestellt damit die Shader erst dann Ã¼bersetzt werden wenn diese wirklich benÃ¶tigt
  werden



>> 22.08.2007
[CO]
PLRenderer:
- RendererOpenGL::GeneralSettings(): Nahm [TODO] heraus... wir lassen einfach die Default Einstellungen, diese Dinge machen
  heute sowieso nicht mehr sonderlich viel aus :)
- Nahm die Funktion "DrawSphere()" aus der Renderer-Klasse heraus da dies etwas zuviel des guten ist und das unter D3D
  nicht sonderlich schnell implementiert wÃ¤re + man unter OpenGL nicht ohne weiteres rausbekommt wieviele Vertices denn nun
  rausgehauen wurden. Macht also mehr Ãrger als es Wert ist. Will man ne Sphere haben, kann man sich schnell so nen Mesh
  Ã¼ber einen Mesh-Creator erzeugen lassen, das ist kein Beinbruch. (wurde zudem auch nur in PLEngine::SceneNode::DrawDebug()
  verwendet)
  DrawTriangle() etc. lass ich mal drinnen da dies recht einfache Dinge sind und gerade DrawBox() etwas nettes ist.
RendererBackend:
- DrawPoints2D() & DrawPoints3D() & DrawLines2D() & DrawLines3D(): Nahm das [TODO] 'Implement more performant technique...
  (using m_pTempVertexBuffer)' heraus da soetwas nicht ganz unproblematisch wÃ¤re da man nicht wÃ¼sste wie groÃ dieser
  Zwischenbuffer sein mÃ¼sste. Das gÃ¤be eine ziemlich Chaotische Implementation zu versuchen da soetwas einzubauen... entweder
  wenn nÃ¶tig vergrÃ¶Ãern, dann hÃ¤tte man eventuell plÃ¶tzlich einen 20 MB Vertex Buffer oder so und mÃ¼sste wieder schaun wann
  man den wie wieder dynamisch verkleinern kann. Das lohnt alles irgendwie nicht, zudem ist diese Angebotene Implementation
  so oder so immer EingeschrÃ¤nkt da man nie ALLES bieten kÃ¶nnen wird was man in jeder mÃ¶glichen Situation mal brauchen
  kÃ¶nnte. (z.B. Vertex Farben, Textur Koordinaten etc) Wenn man VIELE solcher Elemente zeichnen will, muss man sich nen
  Vertex Buffer schnell selbst anlegen und fÃ¼llen - oft hat man ja diesen Buffer bereits. Das wÃ¤re also viel mehr Aufwand
  soetwas zu implementieren als es nutzen bringen wÃ¼rde. :)



>> 07.08.2007
[CO]
PLRenderer:
- SurfacePainter::OnPaintBegin() liefert nun einen Fehlerwert zurÃ¼ck



>> 03.08.2007
[CO]
PLRenderer:
- TextureRectangle::GetNumOfBytes(): FÃ¼r komprimierte Texturen eine andere Formel eingebaut, das mÃ¼sste so passen da dies
  so in der DirectX Dokumentation steht.



>> 06.07.2007
[CO]
PLRenderer + Backends:
- Wo mÃ¶glich/sinnig von Zeiger auf Referenzen umgestellt



>> 02.06.2007
[CO]
PLRenderer:
- Texture: Neue Funktionen: GetPriority() & SetPriority(): Damit lÃ¤sst sich die GPU Textur Speicherverwaltung etwas beeinflussen.
  OpenGL kennt auch noch 'glAreTexturesResident' worÃ¼ber man rausfinden kann ob eine Textur gerade im Textur-Speicher ist oder
  nicht - bei D3D konnte ich so eine Funktion bis jetzt noch nicht finden und fÃ¼gte daher erstmal keine solche Funktion
  ins Textur Interface ein.
PLRendererOpenGL:
- Ein paar unnÃ¶tige 'glClientActiveTextureARB' herausgenommen
- Sampler State Changes minimiert indem jede Textur noch ihre aktuellen States speichert und nur wenn nÃ¶tig etwas angeglichen
  wird... In OpenGL werden diese zustÃ¤nde pro Textur, in D3D pro Stage gespeichert - fÃ¼r PL entschied ich mich damals fÃ¼r
  die D3D Methode. :)
  Performance mÃ¤Ãig konnte ich keine Ãnderung feststellen, allerdings sind die API Aufrufe hier nun meistens um den Faktor
  10 weniger - das sah im Profiling schon etwas merkwÃ¼rdig aus wenn da immer z.B. '1000' Sampler State Changes stand obwohl
  nicht viel auf dem Bildschirm zu sehen war.



>> 21.05.2007
[CO]
PLMesh: Effekt-Komponente:
- Ein paar 'const' eingefÃ¼gt
- Ein paar Konstruktoren & Destruktoren hinzugefÃ¼gt, ein paar Dinge 'private' gemacht + sichergestellt das in den Konstruktoren
  auch ohne RTTI alle Variablen korrekt Initialisiert werden
- Ein paar Zeiger zu Referenzen gemacht damit man den 'NULL'-Fall wo Ã¼berhaupt nicht mÃ¶glich auch nicht berÃ¼cksichigen muss
- EffectPass-Interface aufgerÃ¤umt
-> Uh, merkte gerade das durch diese sÃ¤uberungen in der Beispiel-Szene 'PhysicsPlayground.scene' der merkwÃ¼rdige Grafik-Bug
   mit teils falsch gesetzten States verschwunden ist sobald das Wasser sichtbar wurde... das zeigt mal wieder deutlich das
   es sich definitiv lohnt immer mal wieder klar Schiff zu machen. *g*



>> 19.05.2007
[CO]
PLRenderer:
- SurfacePainter + davon abgeleitete Klassen durchgeschaut und wo nÃ¶tig Destruktoren hinzugefÃ¼gt + bestimmte Dinge 'protected'
  oder gar 'private' (wo z.B. nicht weiter abgeleitet werden kÃ¶nnen soll) gemacht so das die Sichtbarkeit soweit korrekt ist
- GetCustomFlags() & SetCustomFlags() aus dem Renderer-Interface herausgenommen da dies nicht sonderlich universell und
  nur sehr eingeschrÃ¤nkt nutzbar ist (wurde bis heute auch noch nie wirklich verwendet :)



>> 10.05.2007
[CO]
- Sortierte ins Diary so richtig alte EintrÃ¤ge aus "PLSDK/internal/old_diaries.zip" ein



>> 09.05.2007
[CO]
- Alte Diary EintrÃ¤ge von ab "21.03.04" einsortiert



>> 06.05.2007
[CO]
RendererOpenGL:
- RendererOpenGL::GetCombinedMinMipFilter() prÃ¼ft anfangs ob Mipmaps vorhanden sind, wenn nicht, so wird 'GL_NEAREST' als
  Fallback zurÃ¼ckgegeben damit OpenGL trotzdem noch etwas korrekt ausfÃ¼hren kann
- RendererOpenGL::SetSamplerState() prÃ¼ft ob Ã¼berhaupt eine Textur gesetzt ist, ist dem nicht so, so wird der interne Status
  nicht geÃ¤ndert + fÃ¼gte noch ein paar glGetError()-Abfragen ein damit man Informiert wird wenn etwas nicht klappte



>> 10.04.2007
[CO]
PLRenderer + Backends:
- Einige 'return' entfernt



>> 24.03.2007
[CO]
- PLRendererD3D9 Backend etwas aufgerÃ¤umt



>> 21.03.2007
[CO]
- PLRenderer Backends etwas aufgerÃ¤umt



>> 17.03.2007
[CO]
PLRenderer:
- Header & Namespace Ãnderungen wie in z.B. PLBase



>> 03.03.2007
[CO]
PLRendererOpenGL:
- FrameBufferObject: Hat nun ein weiteres Flag Namens 'Color'. Ist dieses nicht vorhanden, handelt es sich um einen reinen
  Tiefenbuffer und es darf KEIN eigener Tiefenbuffer hinzugefÃ¼gt werden - sonst gibts (zumindestens bei mir) einen Ã¼blen
  Treiber Crash :(



>> 21.02.2007
[CO]
PLRenderer:
- ShaderCgBackend::BackupDeviceData(): Statt 'strcpy' wird hier nun memcpy genutzt, wunderbar keine Compiler-Warnung mehr
  (memcpy scheint Sicherer zu sein *g*)
PLRendererOpenGL:
- OpenGLExtensions::CheckExtension() etwas vereinfacht und Ã¼bersichtlicher gemacht



>> 11.02.2007
[CO]
- Auf VC 2005 umgestellt
PLRendererD3D9:
- Da man hier 'd3dx9.h' einbindet bekam ich zuerst folgende Fehlermeldungen:
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(222) : error C2146: Syntaxfehler: Fehlendes ';' vor Bezeichner 'PVOID64'
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(222) : error C4430: Fehlender Typspezifizierer - int wird angenommen. Hinweis: "default-int" wird von C++ nicht unterstÃ¼tzt.
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(5940) : error C2146: Syntaxfehler: Fehlendes ';' vor Bezeichner 'Buffer'
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(5940) : error C4430: Fehlender Typspezifizierer - int wird angenommen. Hinweis: "default-int" wird von C++ nicht unterstÃ¼tzt.
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(5940) : error C4430: Fehlender Typspezifizierer - int wird angenommen. Hinweis: "default-int" wird von C++ nicht unterstÃ¼tzt.
  -> Fand aber zum GlÃ¼ck recht schnell raus was probleme machte bzw. wie man das 'lÃ¶st':
  Bei den 'zusÃ¤tzlichen Include Verzeichnissen' MUSS man
    '$(VCInstallDir)PlatformSDK/include'
  VOR
    'external/win32/dx_9/Include/'
  einfÃ¼gen, dann gehts. (ich erspare mir weitere MS-Kommentare *g*)



>> 28.01.2007
[CO]
- VC Projekt-Dateien wie besprochen in die jeweiligen Grundordner verschoben



>> 27.01.2007
[SB]
- CMake Projektdateien fÃ¼r alle PLEngine-Projekte hinzugefÃ¼gt 



>> 11.01.2007
[CO]
PLRendererOpenGL:
- Bugfix: Falls eine Renderer Textur aus einem gegebenen Bild erzeugt werden sollte, konnte es noch zu Format Problemen
  kommen wenn in dieser Ã¼bergebenen Textur z.B. Level-0 Daten Komprimiert waren, aber die anderen Mipmap Levels nicht. Nun
  kann man frei kombinieren.



>> 22.12.2006
[CO]
Allgemein:
- An ein paar Stellen wurde der Element Typ von Index Buffern nicht korrekt gesetzt da die Anzahl der Indices, und nicht
  die Anzahl der Vertices verwendet wurde... aber der Typ gibt natÃ¼rlich den grÃ¶Ãten speicherbaren Vertex Index an. :)
- Nahm einige Code Umformungen vor (hauptsÃ¤chlich bei for-Schleifen) um die Lesbarkeit zu erhÃ¶hen



>> 17.12.2006
[CO]
PLRenderer + Backends:
- In den BackupDeviceData() Funktionen der verschiedenen Resourcen wird das Backup auf NULL gesetzt wenn kein Backup vorhanden
  ist
PLRendererOpenGL:
- Texture3DOpenGL: 'm_nTotalNumOfBytes' wurde bei automatisch erzeugten Mipmaps nicht gesetzt



>> 16.12.2006
[CO]
PLRenderer:
- TextureStageStates.h, RenderStates.h, SamplerStates.h -> Hier wurde 'Config.h' aus PLGeneral includiert obwohl das
  Ã¼berhaupt nicht nÃ¶tig ist. Durch das entfernen musste man nun an verschiedenen Stellen z.B. 'Log.h' aus PLGeneral
  includieren was aber durchaus korrekt ist.



>> 01.12.2006
[CO]
PLRenderer + Backends:
- Gleiche Ãnderung wie in PLPhysics



>> 11.11.2006
[SW]
PLRendererOpenGL:
- in den Funktionene RendererOpenGL::BeginScene() und RendererOpenGL::EndScene() unter linux den aufruf von
  glXWaitX(in BeginScene) und glXWaitGL(in EndScene) hinzugefÃ¼gt. Diese Funktionen sorgen dafÃ¼r, das alle vor dem aufruf der Funktion
  entstandenen XEvents(glXWaitX) bzw. OpenGL Events(glXWaitGL) durchgefÃ¼hrt werden.
  Das ganze verbessert etwas das verhalten beim Verschieben/verÃ¤ndern der GrÃ¶Ãe des Fensters unter Linux.
- PLRenderer: fehlenden Constructor hinzugefÃ¼gt, hatte zu einem undefined reference beim laden der lib gefÃ¼hrt, trat aber nur im debug-build auf.
- In SurfaceWindowLinux das setzen und auslesen der Gamma werte und die Behandlung fÃ¼r die 32bit Farbtiefe eingefÃ¼gt.



>> 09.11.2006
[CO]
RendererOpenGL:
- SetShaderTexture(): Bugfix: Hier fehlte das aktivieren von Textur-Typen. (z.B. glEnable(GL_TEXTURE_2D)) Lief es mal
  richtig dumm, war eine Textur zwar gesetzt, aber nicht aktiviert. (in z.B. 'plfx_Effects.scene' konnte es dadurch zu
  'Grafik Bugs' kommen)



>> 04.11.2006
[CO]
PLRenderer:
- SurfaceTexture: Neues Flag: Mipmaps: Ist dieses Flag gesetzt, so werden von der GPU Mipmaps 'on the fly' erzeugt.
  (natÃ¼rlich nur falls dies auch unterstÃ¼tzt wird) Das kostet zwar etwas mehr Performance, jedoch 'pixeln' diese Texturen
  dann nicht mehr wenn diese 'etwas weiter' weg Dargestellt werden. Derzeit klappt das jedoch leider nur fÃ¼r FBO korrekt.
PLRendererOpenGL:
- FrameBufferObject::Initialize(): Tiefen Buffer crasht auf dem neuen Catalyst Treiber 6.10 nicht mehr :)



>> 31.10.2006
[CO]
PLRendererOpenGL:
- TextureCubeOpenGL::TextureCubeOpenGL(Renderer *pRenderer, uint32 nSize, EPixelFormat nFormat, uint32 nFlags):
  Anzahl der Bytes darf hier natÃ¼rlich nicht durch 6 geteilt werden. :)



>> 20.10.2006
[CO]
PLRendererOpenGL:
- Beim hochladen bereits komprimierter Bilder muss man (neuerdings??) auch prÃ¼fen ob wirklich komprimierte Daten vorliegen -
  denn Mipmaps scheinen nicht mehr in komprimierter Form vorzuliegen, auch denn das Hauptbild dieses tut. Sicherlich mal
  wieder so ne DevIL 'Ã¤nderung', das war zwar nicht fatal da es vom Renderer 'kompensiert' wurde - aber nicht wirklich
  optimal. :(
- RendererOpenGL::ChooseFormats(): Liegt eine Textur bereits Komprimiert vor, es soll aber gerade keine Textur Kompression
  verwendet werden, so wird diese Komprimierung einfach ignoriert.



>> 19.10.2006
[CO]
PLRenderer:
- Renderer: GetLightEnabled() in IsLightEnabled() umbenannt
- Surface: GetSwapY() in IsSwapY() umbenannt
- Surface: GetAPISwapY() in IsAPISwapY() umbenannt
- Surface: GetActive() in IsActive() umbenannt
- Surface: GetWidth() & GetHeight() 'const' eingefÃ¼gt
- Renderer: GetClipPlaneEnabled() in IsClipPlaneEnabled() umbenannt



>> 14.10.2006
[SW]
Alle Projekte: finale version fÃ¼r das visibility attribute feature vom gcc.



>> 11.10.2006
[SB]
Wieder diverse Anpassungen:
- Ãberbleibsel aus einem alten Merge-Error aus dieser Datei entfernt
- UnnÃ¶tigen [DEBUG]-Kommentar entfernt
- PLLOCAL entfernt - dieses Makro nutzen wir nicht!
- EingefÃ¼gte Konstruktoren und Destruktoren mit Kommentaren versehen und in die richtige Reihenfolge gebracht



>> 11.10.2006
[SW]
Alle Projekte: Die projekte verwenden das neue visibility feature vom gcc, wenn vorhanden.
- PLRenderer: den Klassen Frame und Window den virtuellen dtor hinzugefÃ¼gt,
  damit werden die probleme mit dem visibility-feature vom gcc behoben



>> 04.10.2006
[CO]
- An ein paar Stellen (ColorX & VectorX) "String::Format(" durch ".ToString()" ersetzt



>> 28.09.2006
[SW]
- Linux-port Folgende Project an Ãnderungen von PLBase angepasst: PLRenderer, PLMesh, PLRendererOpenGL
PLRendererNull:
- Linux projekt dateien hinzugefÃ¼gt.



>> 24.09.2006
[CO]
- PLRenderer + Backends: Fand noch ein paar auf PLBool umzustellende Stellen



>> 22.09.2006
[CO]
- PLRenderer + Backends auf PLBool umgestellt + die anderen Projekte wo es nÃ¶tig wurde angepasst



>> 14.09.2006
[CO]
- Beseitige Warnungen die erscheinen wenn der Compiler auf Warnungs-Level 4 gestellt wird



>> 13.09.2006
[CO]
- Dort wo PLRenderer::Buffer::Lock verwendet wird sollte immer mit angegeben werden was fÃ¼r Operationen auf dem Buffer stattfinden
  werden so das der Renderer intern das mÃ¶glichst geschickt handhaben kann. FÃ¼gte dort wo das noch nicht der Fall war jeweils
  einen entsprechenden Lock-Typ ein... der jedoch wirklich nur als 'Verwendung-Hinweis' zu verstehen ist. Gibt man 'Read' an
  kann man trotzdem noch Schreiben, aber eventuell nicht mehr ganz sooo Performant - das hÃ¤ngt von einigen Faktoren ab. :)



>> 23.08.2006
[CO]
PLRenderer:
- Frame::SetFullscreenMode(): Nach dem wechsel des Bildschim-Modus wurde die neue OberflÃ¤che des Painers nicht aktualisiert.



>> 09.08.2006
[CO]
PLRendererOpenGL:
- ShaderOpenGL::Init(): Konnte den kleinen GeForce4 Hack entfernen da es bei den neuen Cg Versionen korrekt geht... diesmal
  war es sogar so, das dieser Hack auf meiner GeForce4 einen Crash in cgGLLoadProgram verursachte. :)



>> 08.08.2006
[CO]
PLRendererOpenGL:
- SurfaceTextureOpenGL: Uh, durch irgendeine Umstellung kam hier etwas Ã¼bel durcheinander... eine kleine Klammer war falsch
  gesetzt, dadurch wurde aber der PBuffer intern als 'not managed' angesehen und der Speicher wurde am Ende nicht freigegeben...



>> 28.07.2006
[CO]
PLRenderer:
- RendererBackend::CheckTextureCube(): Sind die Seiten als einzelnde Bilder Ã¼bergeben worden, so wird zusÃ¤tzlich noch geprÃ¼ft
  ob alle Bilder gleich groÃ sind und das gleiche Format haben - ansonnsten klappt das nicht.
- Die TextureCube Implementationen erkennen nun ob direkt das erste Image eine Cube Map ist, ist dies der Fall, werden eventuell
  Ã¼bergebene weitere Images ignoriert.



>> 25.07.2006
[CO]
Renderer:
- Capabilities: Es wird nun zwischen nMaxTextureSize und nMaxRectangleTextureSize unterschieden da diese Werte unterschiedlich
  sein *kÃ¶nnen*
RendererOpenGL:
- CreateTexture3D() & CreateTextureCube(): Hier fehlte noch eine kleine Abfrage ob dieser Textur Typ unterstÃ¼tzt wird.
- Neben GL_ARB_texture_cube_map wird nun auch GL_EXT_texture_cube_map geprÃ¼ft, zwar wurde diese Extension scheinbar ziemlich
  schnell zum 'Standard', aber sicher ist sicher.
- Neben GL_ARB_occlusion_query wird nun auch GL_NV_occlusion_query unterstÃ¼zt das praktisch identisch ist - nur fÃ¼r alle FÃ¤lle.
- Ist GL_ARB_vertex_program nicht verfÃ¼gbar, wird in VertexBufferOpenGL::MakeCurrent() das gute alte glFogCoordPointerEXT verwendet,
  aber nur wenn GL_EXT_fog_coord vorhanden ist.
- Es wird geprÃ¼ft ob GL_EXT_secondary_color vorhanden ist
- Schrieb dazu das dies ein OpenGL 1.1 (aus dem Jahre 1992 :) Renderer ist und alles weitere Ã¼ber Extensions reinkommt, so sind wir
  vom Renderer so AbwÃ¤rtskompatibel wie irgend mÃ¶glich. So muss man auch keinem erklÃ¤ren wieso man das eine Testen sollte und
  das andere nicht. Noch gibt es jedoch einiges an entsprechenden Abfragen und Fallbacks einzubauen damit das auf so vielen (alten) Karten
  wie mÃ¶glich lÃ¤uft. Und dann mÃ¼sste man sich soetwas wie eine 'Versions-Nummer' ausdenken, wohl D3D9 vergleichbar so das ich als
  User auf einen Schlag prÃ¼fen kann auf welcher GPU Generation das hier gerade lÃ¤uft - um z.B. dann schon gleich beim Programmstart
  abbrechen zu kÃ¶nnen wenn das die aaalererste GPU Generation ist, ich aber mindestens die dritte erwarte da alles andere keinen
  Sinn machen wÃ¼rde.
- Nahm GL_EXT_polygon_offset heraus da dies bereits in OpenGL 1.1 vorhanden ist, und bei heutigen Karten scheint das Ã¼berhaupt
  nicht mehr in der Extension Liste aufzutauchen. (Stephan und ich konnten es auf unseren mittlerweile betagten Rechnern nicht finden :)



>> 24.07.2006
[CO]
PLRendererOpenGL:
- Neben GL_EXT_texture_rectangle und GL_NV_texture_rectangle gibts noch GL_ARB_texture_rectangle (jipi, es lebe die Freiheit!)
  welches das gleiche ist, und nur einen anderen Namen hat. Baute noch einen Test auf diese Extension ein damit das wirklich
  sicher erkannt wird ob das Feature verfÃ¼gbar ist oder nicht.



>> 21.07.2006
[CO]
RendererOpenGL:
- Das mit den OS-abhÃ¤ngigen Funktionen etwas aufgerÃ¤umt, so mÃ¼sste das nun etwas Ã¼bersichtlicher sein.



>> 09.07.2006
[CO]
PLRenderer:
- Ãnderte die Funktionen GetDefaultRenderStates() zu GetDefaultRenderState(), GetDefaultSamplerStates() zu GetDefaultSamplerState(),
  GetDefaultTextureStageStates() zu GetDefaultTextureStageState() und GetDefaultMaterialStates() zu GetDefaultMaterialState().
  Statt einen Array mit den Default Werten zu fÃ¼llen, fragt man nun einzelnde Default Werte ab. Zum einen ist das etwas sicherer
  da es wenn ein Array zu klein war natÃ¼rlich zu Problemen kam, zum anderen ist man meistens an einzelnen Default Werten interessiert
  und da ist es einfach Handlicher wenn man diese einzelnd anstatt als ganzen Brocken bekommen kann.



>> 07.07.2006
[CO]
PLRenderer:
- Frame: SetFullscreenMode() an die SurfacePainter Ãnderung angepasst: Hier muss der Surface Painter etwas unschÃ¶n 'weggespeichert'
  werden da ein zerstÃ¶ren & neu erzeugen hier 'etwas' viel Aufwand fÃ¼r nix wÃ¤re.



>> 03.07.2006
[CO]
PLRenderer:
- Nahm wie gestern mit Stefan besprochen den Surface Listener heraus. FÃ¼gte SurfacePainter hinzu. Surface um GetPainter() und
  CreatePainter() erweitert. Sobald eine 'OberflÃ¤che' aktualsiert wird, wird der SurfacePainter dieser OberflÃ¤che aufgerufen
  der fÃ¼r das 'Zeichnen' verantwortlich ist. Da diese Klasse an das RTTI gekoppelt ist, ist das die Entwicklung neuer
  'Surface Renderer' recht einfach und universell.



>> 30.06.2006
[CO]
PLRenderer:
- SetViewport() & SetScissorRect(); (0, 0) liegt nun wieder links-oben. Das passt zwar nicht mit unserem 3D Koordinatensystem
  zusammen, allerdings ist rechts-unten an vielen Stellen noch unhandlicher als das umrechnen von y an ein paar Stellen...
  gerade beim ingame gui hÃ¤tte man viel herumwurschteln mÃ¼ssen und das platzieren von 2D Texten wÃ¤re anderst gewesen als das
  platzieren von Gui Texten was eher verwirrend als hilfreich gewesen wÃ¤re.



>> 27.06.2006
[CO]
PLRenderer:
- GetViewport(), SetViewport(), GetScissorRect(), SetScissorRect() Arbeiten nun mit der neuen Klasse PLMath::Rectangle. Dadurch
  lÃ¤sst sich das nun um einiges netter Bedienen. Desweiteren ist der Punkt (0, 0) nun links unten anstatt links oben wie bisher
  -> so passt das auch mit unseren Koordinaten System (rechte Hand) zusammen.



>> 16.06.2006
[CO]
PLRendererOpenGL:
- Wenn die Extension GL_SGIS_generate_mipmap vorhanden ist, so muss man wenn man Texturen hochlÃ¤d nicht z.B. gluBuild2DMipmaps()
  verwenden um Mipmaps zu erzeugen sondern kann dies der GPU Ã¼berlassen. Dann kann man sogar eine eventuelle Kompression
  direkt Ã¼bernehmen... ich hoffe das wir so laangsam mal alles Textur mÃ¤Ãig mÃ¶gliche & Sinnige drinnen haben...
- Bugfixing: In Parameters::Semantic mussten die Enums noch angepasst werden. Damit Shadow Mapping funktioniert mussten
  ein paar kleine Einstellungen geÃ¤ndert werden.



>> 15.06.2006
[CO]
PLRenderer:
- Parameters: SetParameterTexture(): Der nStage Parameter durfte gehen da er hier Ã¼berflÃ¼ssig ist. Cg bindet die Textur selbst
  an eine geeignete Texture Stage welche man dann abfragen muss um die PL Renderer States korrekt zu setzen. In PLMesh::ParameterManager
  konnte man mit dieser Information sowieso nichts anfangen und daher ich bin froh das man diesen Parameter komplett entfernen
  konnte damit alles einheitlich ist. :)
  Da man wenn man Shader verwendet sowieso keine Kontrolle darÃ¼ber hat wo welche Textur landet, und im Prinzip auch gar keine
  haben muss da es bei Cg-Shadern egal ist, nahm ich die Texture<index>-Semantics heraus... im Effekt wurden diese sowieso
  nicht mehr verwendet da eine Textur in verschiedenen PÃ¤ssen/Schichten verwendet werden kann und man daher keine feste
  Texture Stage angeben konnte. Die TextureMatrix<index>-Semantic macht dadurch ebenfalls keinen Sinn mehr. Will man Textur
  Matrizen setzen um z.B. eine Textur durch verschieben zu 'animieren', so muss sich der Szene Renderer darum kÃ¼mmern das
  die Infos korrekt an die Shader weitergegeben werden... falls diese Ã¼berhaupt Textur Matrizen unterstÃ¼zen. :)



>> 13.06.2006
[CO]
PLRendererOpenGL
- RendererOpenGL::Init(): Ighh, kann mich gar nicht dran erinnern hier m_sCapabilities.nMaxClipPlanes auf 5 gesetzt zu haben.
  Das ist natÃ¼rlich totaler unfÃ¼g... hatte mich gerade schon gewundert wieso ich nur 5 Clipping Planes habe... :)
- TextureCubeOpenGL: Da GetNumOfBytes() den Speicherbedarf fÃ¼r ALLE Seiten zusammen fÃ¼r diese Mipmap Stufe zurÃ¼ckgibt, muss
  man an diversen Stellen durch 6 Teilen.



>> 10.06.2006
[CO]
PLRenderer:
- Renderer: CreateVertexShader(), CreateFragmentShader() Funktionen um Parameter fÃ¼r den Programm Einstiegspunkt erweitert -
  falls dieser mal nicht 'main' heiÃen sollte.... :)
- Stellte auf die aktuellste Cg Version um... da ich mich gerade mit diesem Gebiet befasse sollte das alles so aktuell wie
  mÃ¶glich sein.



>> 09.06.2006
[CO]
PLRenderer:
- RenderStates & TextureStageStates & SamplerStates: Enumerations werden nun groÃ/klein geschrieben. Zum einen ist das besser
  Lesbar, aber noch viel wichtiger, diese Namen stimmen nun genau mit den Renderer Einstellungen Ã¼berein so das man sich den Namen
  nur einmal merken muss. In den Default Einstellungen werden ebenfalls die Enumeration Namen anstatt der Nummer verwendet.



>> 07.06.2006
[CO]
PLRendererOpenGL:
- Bei den Upload/Download Funktionen fehlte natÃ¼rlich noch das Bind-Textur. Ganz GlÃ¼cklich bin ich noch nicht mit diesem
  'aktuelle Textur holen, eigene Textur setzen, Operation durchfÃ¼hren und alte Textur wieder herstellen'. Zum einen kann das
  superschnell in supervielen Texture State Changes ausarten wenn man z.B. sich nacheinander alle Mipmaps einer zurÃ¼ckgeben
  lÃ¤sst, und zum anderen weis ich nicht obs so wie es momentan ist wirklich funktioniert... was, wenn z.B. gerade eine 2D
  Textur gesetzt ist, ich aber momentan mir eine 1D Textur wegsichere - keine Ahnung ob das funkt. :)
  Da werd ich wohl bei Zeiten noch etwas anderes ausprobieren mÃ¼ssen, aber fÃ¼rs erste kann man es wohl lassen.
  (gibt derzeit wichtigeres zu tun :)



>> 06.06.2006
[CO]
PLRenderer:
- In der Renderer Textur Basisklasse Upload() & Download() hinzugefÃ¼gt damit man Textur Daten hoch/runterladen kann. GetNumOfBytes()
  um einen Optionalen Parameter erweitert damit es mÃ¶glich ist sich auch fÃ¼r ein anderes Format den benÃ¶tigten Speicher zurÃ¼ckgeben
  zu lassen.



>> 02.06.2006
[CO]
PLRenderer:
- Shader um Parameter Typen erweitert. Derzeit gibts nur diese Typ Definitionen + Funktionen um den Typen von seinem String zu
  ermitteln oder den Typen in einen String 'umzuwandeln'.
- Shader: GetSemanticParameter() Funktion hinzugefÃ¼gt um den Namen des Parameters zu ermitteln der die angebene Semantic hat.
  Eine Semantic kann NUR von einem Parameter verwendet werden, alles andere wÃ¼rde keinen Sinn machen und es zudem nur unnÃ¶tig
  komplizierter machen.



>> 01.06.2006
[CO]
PLRenderer:
- Arbeite an der Shader Semantic Implementation weiter. Innerhalb der Shader Backend Implementation passiert Semantic mÃ¤Ãig im
  Prinzip nichts, die Basis Klasse selbst Ã¼bernimmt die gesammte Arbeit. Innerhalb der konkreten Renderer Implementationen
  muss jedesmal wenn sich an einem Render State der auch als Shader Parameter Semantic bekannt ist etwas Ã¤ndert, so
  muss Shader::RefreshSemanticParameter() aufgerufen werden was intern nur ein 'is Dirty'-Flag setzt. Vor konkreten Zeichen
  Operationen muss intern dann Shader::BindSemanticParameters() aufgerufen werden - alle 'Schmutzigen' Shader Parameter mit
  bekannter Semantic werden dann auf aktuelle Render States gesetzt. Eine 'schÃ¶nere' Implementation viel mir hier einfach
  nicht ein, man muss einfach die Shader Parameter 'synchronisieren' und das geht wohl kaum besser. :(
  WÃ¤hrend das Shader Interface recht Ã¼bersichtlich ist und auch das mit der Semantic sehr einfach zu verwenden ist, ist die
  Implementation leider etwas weniger 'schÃ¶n' da ich mit vielen Bit-Operationen, Callback-Funktionen und Maps arbeite damit
  alles so flott wie irgend mÃ¶glich von dannen geht. Die Shader Parameter mit Semantic werden z.B. erst dann wenn wirklich
  benÃ¶tigt aktualsiert. Also bitte nicht 'aufschreien' das dies doch kein Mensch lesen oder gar verstehen kÃ¶nnte, wenn jemand
  das besser Implementieren kann OHNE einen totalen Performance Overkill zu produzieren soll er mir einfach bescheit geben. ;-)
  Da Shader mittlerweile sehr wichtig/unverzichtbar geworden sind, MUSS das einfach so flott wie irgend mÃ¶glich gehen auch
  wenn das dann auf kosten der Lesbarkeit der Implementation geht - an diesen internen Codes haben sowieso keine Fremden
  herumzudoktern, und jemand der dazu berechtig ist, wird wohl sicherlich kein Newbie Coder mehr sein. Die RTTI Codes sind
  fÃ¼r 'AuÃenstehende' ja auch nicht so ohne weiteres zu durchschauen. ;-)
  Aber dieser Aufwand lohnt definitv, in der Beispiel Szene 'NormalMapping.scene' kann man bereits sehen wie 'mÃ¤chtig' dieses
  System ist... nun haben endlich die Lichter der Szene einen Einfluss auf die Shader, zumindestens das 'PrimÃ¤re' Licht, denn
  mit mehrern Lichtern herumzujonglieren ist definitiv der Job eines entsprechenden Szene Renderers. Als nÃ¤chstes mÃ¼ssen die
  Material Parameter etwas Ã¼berarbeitet werden, wobei im Material weitere Shader Parameter Semantics hinzukommen werden fÃ¼r z.B.
  Timing, also etwas speziellere Dinge welche im Renderer selbst einfach nix zu suchen haben.
- Lies alle Projekte nach hÃ¤ufigen Englisch Fehlern durchsuchen auf die mich Stefan vor geraumer Zeit hinwies, hauptsÃ¤chlich
  'kown', 'were' und 'byself'.
- Schaute alle Stellen bei denen in Interfaces '-1' vorkommt durch und dort wo mÃ¶glich Ã¤nderte ich es (sammt Implementation)
  in <0 damit das etwas/allgemeiner Sicherer ist.



>> 31.05.2006
[CO]
PLRenderer:
- Ãberarbeite die Shader im Renderer da die aktuelle Implementation viel zu aufwÃ¤ndig war. Nahm dabei die Shader Parameter
  Klasse heraus da dies totaler Overhead war, also das 'Managen' der Uniform Shader Parameters innerhalb der Shader Klasse
  und das zwischenspeichern ('shadowing') der Einstellungen innerhalb der Shader Parameter Klasse. Die Shader API's bieten
  Funktionen an um einen gesetzten Wert auch wieder auszulesen, und die meisten API's bieten auch 'Shadowing' der Parameter
  an so das man dies wirklich nicht selbst zu machen braucht, zumindestens NICHT direkt im Shader Wrapper - im Renderer selbst
  sollte das so einfach wie irgend mÃ¶glich sein. Unser Material in PLMesh macht ja genau das gleiche, und so war das am
  Ende auch doppelt gemoppelt. Desweiteren war das auch in der Bedienung nicht so schÃ¶n da man sich zuerst einen Parameter
  zurÃ¼ckgeben lassen musste um ihn dann setzen/lesen zu kÃ¶nnen.
  Shader mÃ¤Ãig gibts nun nur noch eine Klasse im Renderer. Diese bietet u.a. Funktionen wie SetParameter2f() um direkt Shader
  Parameter zu setzen oder auszulesen. '2f' etc. am Ende des Namens ist eine gÃ¤ngige Namensgebung und daher machte ich es genauso,
  denn es gibt verschiedene Funktionen fÃ¼r die Shader Parameter, je nachdem um welchen Typ es sich handelt. Im Null Renderer
  gibts keine Shader Implementation. Passte alle Projekte an diese Ãnderung an. (waren nur minimale Anpassungen nÃ¶tig :)
- In den PLMesh Materialen kann man ja bereits seit langem Shader Parametern eine 'Semantic' zuweisen so das sobald ein
  Shader gesetzt wird z.B. die aktuelle World Matrix des Renderers einem Shader Parameter Ã¼bergeben wird so das man quasi
  'automatische Parameter' hat die immer einen aktuellen Wert haben was sich als relativ praktisch herausgestellt hat. Aber
  dieses System war leider nicht so mÃ¤chtig wie es sein kÃ¶nnte da es erst in PLMesh implementiert wurde und viele Dinge
  wie Nebel oder noch viel wichtiger Licht Einstellungen konnte man nicht so schÃ¶n dem Shader automatisch Ã¼bergeben lassen. Und
  da diese 'automatischen Parameter' NUR beim setzen/aktivieren eines Material Passes gesetzt wurden, waren diese Werte natÃ¼rlich
  nicht mehr korrekt wenn man z.B. die Welt Matrix des Renderer Ã¤nderte, und dann musste man nochmal selbst schaun das korrekte
  Werte gesetzt waren. Das stÃ¶rte mich gewaltig da hierdurch z.B. der Normal Mapping Shader des Soldaten immer etwas 'auÃerhalb'
  stand, z.B. war es schlichtweg unmÃ¶glich ohne aufwand die Shader Parameter fÃ¼r das Licht einzustellen. Es war auch nicht
  mÃ¶glich eine kleine Szene zu machen in der nur der Shader Soldat und eine Licht Scene Node waren wobei das Licht auch wirklich
  den Shader Soldaten 'beeinflusste' - denn da es komplett getrennte Systeme waren, konnten diese Dinge auch nicht automatisch
  miteinander Arbeiten. Die einfache LÃ¶sung des Problems bestand darin, die 'Parameter Semantic' von PLMesh direkt in die Renderer
  Shader zu verschieben, zumindestens die welche was mit dem Renderer zu tun hatten. Bei D3D 10 gibt es viele Render States
  wie z.B. fÃ¼r Nebel, Licht, Material NICHT mehr, es MUSS also komplett Ã¼ber Shader selbst implementiert werden. Und generell
  ist's ja so das diese Einstellungen auch nur 'verwendet' werden wenn gerade kein Shader aktiv ist - also Fixed Pipeline Render
  States... wobei es soetwas wie 'Fixed Pipeline' heute ja in den GPU's nicht mehr wirklich gibt. In der Renderer Shader Klasse
  kann man nun also wie gehabt 'per Hand' Parameter einstellen, oder ihnen eine Semantic zuweisen wodurch diese dann automatisch
  gesteuert werden - sprich, Set-Funktionen werden ignoriert, Get-Funktionen liefern die aktuellen Render States zurÃ¼ck. Sobald
  man einem Parameter eine Semantic zuweist, hat man also 'richtige' automatische Parameter die automatisch intern mit den aktuellen
  Renderer Einstellungen 'angeglichen' werden. Ãndere ich z.B. die Welt Matrix des Renderers, so hat AUTOMATISCH auch gleich
  ein gerade aktiver Shader die aktuelle Welt Matrix als Shader Parameter gesetzt wenn dieser die entsprechende Semantic hat.
  Nun hat man ein mÃ¤chtiges System welches zudem noch recht NatÃ¼rlich & Logisch zu bedienen ist. Stell ich nun z.B. in einem
  PLMesh Material eine Parameter Semantic ein, wird intern dieser Parameter mit dem Renderer 'zusammengeschlossen' - und nun haben
  automatisch aktuelle Renderer Einstellungen wie z.B. fÃ¼r Licht 'einfluss' auf den Shader. Im Falle der Szene mit dem Shader
  Soldaten und einem Licht (siehe PLSamples: NormalMapping.scene) 'beeinflusst' diese Licht Scene Node nun tatsÃ¤chlich wie man
  es auch erwarten wÃ¼rde den Soldaten. Bei mehreren Lichtern muss man auch mehrere Lichter dem Shader Ã¼bergeben, aber das
  ist wohl selbsterklÃ¤rend. ;-)
  Shader bietet zwei Statische Hilfsfunktionen Namens SemanticFromString() und SemanticToString() mit denen sich superflott
  ein Semantic String in eine Nummer 'umwandeln' lÃ¤sst und umgekehrt. Das kann man hauptsÃ¤chlich beim Laden & Speichern brauchen.
  Renderer Shader kennen derzeit 45 Semantics, das sollte fÃ¼r's erste reichen.
  Dieses System mÃ¼sste nun auch relativ Zukunftssicher sein, also wenn man spÃ¤ter z.B. noch ein D3D 10 Backend schreibt. In dem
  Fall MUSS man halt Shader fÃ¼r z.B. Beleuchtung schreiben, aber es sollte wohl Problemlos mÃ¶glich sein das IM Renderer Backend
  dann entsprechende Default Shader verwendet werden so das sich alles wie auch bei OpenGL oder D3D 9 bedienen lÃ¤sst. Und bedient
  wird es immer gleich, es 'sieht' also fÃ¼r den User so aus als obs weiterhin Nebel Einstellungen im Renderer gÃ¤be, ok, es gibt
  diese ja auch, nur werden diese dann im Renderer Backend selbst gemacht anstatt von fertigen API/GPU Funktionen.
  Da das mit den 'nicht automatischen' Shader Parametern nun viel direkter und einfacher zu Bedienen ist, sollte es auch
  viel einfacher als vorher sein einen netten Shader Beleuchtungs Szene Renderer zu schreiben - wo man also direkt im Code diverse
  Shader Parameter einstellt.
  Jipi, durch diesen Eintrag ist das PLEngine Tagebuch nun 300 KB groÃ - das was ich in diesem Monat erreichen wollte. HÃ¤tte nicht
  gedacht das ich heute noch die verbleibenden 5 KB fÃ¼llen kÃ¶nnte - aber das mit der Renderer Shader Ãnderung bot ja genug Stoff zum
  Labern. ;-)



>> 30.05.2006
[CO]
PLRenderer:
- RendererBackendCg entfernt, die Dinge welche dort gemacht wurden passieren nun direkt in den konkreten Shader Implementationen.
PLRendererOpenGL
- Codes etwas herausgeputzt: Leerzeichen/Tabs verbessert, Ã¼berflÃ¼ssige Includes entfernt, Ã¼berflÃ¼ssige 'using namespace'
  entfernt, String Anpassungen, diverse Konstruktoren protected gemacht, ein paar Kommentare verbessert
- Extensions Klasse: Neue Funktion: WriteExtensionStringIntoLog() schreibt einen Extensions String ins Log - da dies
  mittlerweile an mehreren Stellen mit verschiedenen Extensions Strings geschieht, war eine entsprechende Funktion sinnig. :)
- OpenGLExtensions: ShowGeneralOpenGLInformation() & ShowOpenGLShaderInformation() verbessert so das nun immer korrekte
  Informationen im Log stehen.



>> 29.05.2006
[CO]
PLRenderer & PLRendererNull & PLRendererD3D9:
- Codes etwas herausgeputzt: Leerzeichen/Tabs verbessert, Ã¼berflÃ¼ssige Includes entfernt, Ã¼berflÃ¼ssige 'using namespace'
  entfernt, String Anpassungen, diverse Konstruktoren protected gemacht, ein paar Kommentare verbessert



>> 23.05.2006
[CO]
PLRendererOpenGL:
- BackupDeviceData()/RestoreDeviceData() Implementationen der Texturen Ã¼berarbeitet. Nun werden auch Mipmaps sammt Kompression
  von der GPU heruntergeladen und danach wieder herauf was sogar ziemlich flott und stabil geht. :)



>> 22.05.2006
[CO]
- Stellen wo Tokenizer::Start() verwendet wird angepasst



>> 21.05.2006
[SB]
- Projekte an FS-Ãnderungen angepaÃt



>> 21.05.2006
[CO]
PLRenderer:
- Texturen um Funktionen erweitert welche zurÃ¼ckgeben wieviele Mipmaps eine Textur hat und wieviel Bytes the Textur zusammem
  mit allen Mipmaps und unter berÃ¼cksichtung des verwendeten internen Formats (sammt Kompression) benÃ¶tigt.
  GetNumOfBytes() sowie den Funktionen zum ermitteln der z.B. Textur Breite kann man nun noch die gewÃ¼nschte Mipmap als
  Parameter Ã¼bergeben.
- In den Renderer Statistiken steht nun auch wieviele Texturen derzeit auf der GPU sind und wieviel Speicher diese dort
  beanspruchen. Gerade bei groÃen Szenen ist diese Information wohl ziemlich wichtig damit man abschÃ¤tzen kann ob gerade
  einfach zuviele & zugroÃe Texturen verwendet werden oder ob man noch massig Spielraum hat. :)
  Da z.B. OpenGL keine MÃ¶glichkeit bietet abzufragen wieviel GPU Speicher gerade belegt ist/noch frei ist, ist es unumgÃ¤nglich
  selbst diese Infos zu Managen. Ich kann mir sehr gut vorstellen das diese Informationen bei grÃ¶Ãeren Projekten welche
  Dynamisch Texturen laden und entladen mÃ¼ssen wichtig ist um zu entscheiden ob es nun nÃ¶tig ist weniger wichtige
  Texturen/gerade nicht verwendete Texturen wieder zu entladen oder nicht.



>> 20.05.2006
[CO]
PLRenderer:
- Texture:EPixelFormat: Neues Texture Kompressions Format 'ATI2N' hinzugefÃ¼gt. 3Dc ist fÃ¼r Normal Map Kompression 
  gedacht wobei es sich um ein Format mit 2 Farbkomponenten handelt. Es gibt auch noch 'ATI1N' fÃ¼r nur Luminance,
  z.B. fÃ¼r BumpMaps, jedoch gibt es dieses Format unter OpenGL noch nicht und daher fÃ¼gte ich es nicht hinzu. Testen konnte
  ich 3Dc leider nicht da meine Karte es nicht kann, allerdings 'mÃ¼sste' es funktionieren. :)
  Ãnderte DXT1 von RGBA in ein RGB Format, unter OpenGL kann man zwar beides AuswÃ¤hlen, aber normalerweise versteht man unter
  DXT1 ein RGB Format. Musste 'glext.h' um GL_ATI_texture_compression_3dc erweitern.
- Da das Ã¼bergebene Bild bereits Komprimiert sein kann, kann der Renderer das komprimierte Bild direkt so Ã¼bernehmen -
  vorausgesetzt natÃ¼rlich das Kompressions-Format wird unterstÃ¼tzt. UnterstÃ¼tzt der Renderer das Format jedoch nicht, so
  muss 'er' bevor das Bild der GPU Ã¼bergeben wird das Bild dekomprimieren... sprich, der Renderer KANN beim erzeugen einer
  Texture aus einem gegebenen Bild dieses Bild manipulieren, konkret, es dekomprimieren. Zwar wollte ich es vermeiden das
  der Renderer selbst so ein Bild Ã¤ndert, aber gerade unter OpenGL bestimmen mehrere Faktoren darÃ¼ber OB die das komprimierte
  Bild direkt so Ã¼bernommen werden kann oder nicht... und ich denke das wÃ¤re unzumutbar/umstÃ¤ndlich die Renderer Capabilities
  so um die entsprechenden Detail Infos zu erweitern so das z.B. PLMesh::Texture dann prÃ¼fen kann ob dekomprimiert werden
  muss oder nicht. Wobei, da derzeit im DevIL Bild leider IMMER beim einladen automatisch auch eine Dekomprimierte Version
  angelegt wird, Ã¤ndert der Renderer ja derzeit nicht wirklich was am Bild. ;-)
- Texture::IsFormatCompressed() entfernt und im Renderer als IsTexturePixelFormatCompressed() eingebaut, so ist das universeller
- Renderer: GetTexturePixelFormat(): Ãber einen Parameter kann man nun noch bestimmen ob komprimierte Formate erwÃ¼nscht sind
- Texture: Neues Flag: Compression -> Ist dieses Flag gesetzt, so wird soweit mÃ¶glich die Textur intern komprimiert auf der GPU
  abgelegt. WÃ¼nscht der User beim erzeugen der Textur ein bestimmtes Format, so wird dieses Flag ignoriert.
- Erweiterte in Renderer::CreateTexture1D() die Anmerkungen
PLRendererOpenGL:
- Passte die Textur Klassen an das Ã¼bernehmen von Image bereitgestellter Mipmaps & Kompression an. Werden die Mipmaps nicht
  bis zu 1x1 herunter Definiert, so ist das ein Fehler und sobald man versucht eine solche Textur mit entsprechendem Filter zu
  verwenden, so bekommt man unter OpenGL normalerweise nur eine weiÃe Textur zu Gesicht. Dies kann man schÃ¶n Testen wenn man
  einer dds Textur Mipmaps verpasst die nicht bis 1x1 heruntergehen... baute hier daher gleich eine entsprechende Log Warnung
  ein. BackupDeviceData() und RestoreDeviceData() mÃ¼ssen noch angepasst werden.
- Da das AuswÃ¤hlen der konkret verwendeten Formate nun von einigen Parametern abhÃ¤ngt und das bei jedem Textur Typ benÃ¶tigt wird,
  fÃ¼gte ich in RendererOpenGL::ChooseFormats() eine entsprechende 'Auswahl'-Funktion hinzu.



>> 19.05.2006
[CO]
PLRendererOpenGL:
- Durch die kleine Verbesserung in PLGeneral::Image ist es nun mÃ¶glich die von z.B. einem dds Bild eingeladenen Mipmaps
  direkt an die GPU zu Ã¼bergeben. (siehe z.B. Texture2DOpenGL)
  Zum einen spart das etwas Zeit beim hochladen der Textur da die Mipmaps nicht noch extra erzeugt werden mÃ¼ssen, aber viel
  wichtiger ist, das nun die Grafiker direkte Kontrolle Ã¼ber diese Mipmaps haben... also diese selbst so anlegen kÃ¶nnen das
  diese immer Optimal aussehen... oder man kann damit auch einfach nur etwas Umfug treiben so das mit der 'Entfernung' sich
  das Bild der Textur Ã¤ndert. ;-)
  Hat man z.B. in jeder Mipmap eine andere Farbe, so kann man sehr schÃ¶n sehen wie die GPU mit der Entfernung verschiedene
  Mipmaps auswÃ¤hlt und filtert.



>> 18.05.2006
[SW]
PLRendererOpenGL:
- Abfragen fÃ¼r die Extension ARB_multisample, ATI_pixel_format_float und NV_float_buffer
  unter Linux hinzugefÃ¼gt. ZusÃ¤tzlich habe ich OpenGLExtensions::CheckExtension
  leicht modifiziert, damit auch alle verfÃ¼gbaren Extension-Strings fÃ¼r die PrÃ¼fung
  verwendet werden. Denn unter Linux(GLX) gibt es 2 zusÃ¤tzlich funktionen,
  neben glGetString(GL_EXTENSIONS), um die vorhandenen Extensions als String zu bekommen.
- Multi Render Target support auch unter Linux deaktiviert, da es zu sporadischen abstÃ¼rzen fÃ¼hrt



>> 16.05.2006
[CO]
- An PLGeneral Ãnderungen angepaÃt



>> 15.05.2006
[CO]
PLRenderer:
- Fehlerhafte -1 zuweisungen verbessert
- ~ShaderParameter() etwas umgebaut damit der gcc Compiler keine Warnung mehr ausspuckt (warning: deleting `void*' is undefined)
PLRendererOpenGL:
- IndexBufferOpenGL: LÃ¶schen des Buffers etwas umgebaut damit der gcc Compiler keine Warnung mehr ausspuckt
  (warning: deleting `void*' is undefined)
- Fehlerhafte -1 zuweisungen verbessert



>> 14.05.2006
[SW]
PLRendererOpenGL:
- einen fehler in linux part gefixed, welcher nen abstÃ¼rtz auf ATI karten gefÃ¼hrt hat.
  man sollte halt den RenderContext zum testen der vorhandenen OpenGL Extension nach gebrauch wieder freigeben.



>> 14.05.2006
[SB]
- An PLGeneral Ãnderungen angepaÃt



>> 11.05.2006
[SB]
- An PLGeneral Ãnderungen angepaÃt (DEFINE_GROUP entfernt, GetClasses())



>> 09.05.2006
[SB]
- Externe Libraries nach "external" verschoben und die Projekte entsprechend angepaÃt



>> 03.05.2006
[CO]
PLRenderer:
- SetSamplerState(): Wird 'Sampler::MipFilter' gesetzt und hat die gerade aktivie Textur KEINE Mipmaps, so wird automatisch
  als Wert 'TextureFiltering::None' angenommen so das die Texture korrekt Darstellt wird und man nicht selbst einen entsprechenden
  Wert setzen muss wenn eine Textur keine Mipmaps hat.
  Diese Ãnderung der Einstellung ist jedoch rein intern, wenn der User GetSamplerState() aufruft, so bekommt er seinen gesetzten
  Wert zurÃ¼ck. Sobald eine andere Textur gesetzt wird welche Mipmaps hat und daher die User einstellung gÃ¼ltig ist, wird diese
  automatisch verwendet. Nun wird die Textur immer korrekt Dargestellt, auch wenn man mal 'vergessen' hat einen anderen Filter 
  Modus zu wÃ¤hlen wenn die verwendete Textur keine Mipmaps hat... oder sich darum einfach nicht kÃ¼mmern wollte. ;-)



>> 23.04.2006
[CO]
PLRenderer:
- FÃ¼gte eine SetTransformState() Funktion fÃ¼r eine 3x4 Matrize hinzu damit man seine 3x4 Matrizen direkt so an den Renderer
  Ã¼bergeben kann. Intern wird dann aber trotzdem eine 4x4 Matrize verwendet und es gibt auch nur eine GetTransformState()
  Funktion welche eine 4x4 Matrize zurÃ¼ckgibt. Aber entsprechende Zuweisungen sind ja in den Matrizen Klassen implementiert.
  Ich wollte hier nur vermeiden das eine extra 4x4 Temp Matrize erzeugt wird wenn man z.B. seine 3x4 Welt Matrize dem
  Renderer Ã¼bergeben will.



>> 14.04.2006
[CO]
PLRenderer:
- RendererBackend::Get2DCoordinate(): Hier muss noch die World Matrix berÃ¼cksichtigt werden



>> 08.04.2006
[CO]
PLRenderer:
- Stellte auf 'Cg 1.5 Beta 1' um



>> 31.03.2006
[CO]
PLRenderer:
- Surface: Neue Funktionen: GetSwapY() & SetSwapY(): Da man bei D3D beim Rendern in Texturen die y Achse vertauschen muss, 
  entschloss ich mich dazu das gleich universell zu machen falls mal jemand sein Bild verdreht rendern will. :)
  Intern gibts noch eine virtuelle API abhÃ¤ngige Funktion namens 'GetAPISwapY()', der Renderer selbst verwendet nur diese 
  Funktion. Hier kann man unter z.B. D3D zurÃ¼ckgeben wie 'verdreht' werden soll. Wird verdreht, so muss der Renderer intern 
  auch entsprechend den Cull Mode anpassen.
PLRendererD3D9:
- Wird Reflection Mapping verwendet, so wird die Texture Matrix genauso wie im OpenGL Renderer verÃ¤ndert
- TextureRectangleD3D9: Wird Textur Kompression verwendet, so ist der Inhalt der Texture immer Schrott - noch habe ich 
  nicht herausgefunden wieso das so ist und wie man es besser machen kÃ¶nnte. :(



>> 30.03.2006
[CO]
PLRendererOpenGL:
- SurfaceTextureOpenGL: Implementation etwas Ã¼bersichtlicher gemacht. Die erzeugung von FBO/PBuffer findet nun in jeweils
  eigenen Funktionen statt, der Rest wie z.B. MakeCurrent() bleibt in einer Funktion. Auch wenn kein FBO und kein PBuffer 
  vorhanden sind kann nun immer noch in eine 'Textur gerendert' werden... Ã¼ber einfaches glCopyTexSubImage2D(). Hier wird 
  zwar der aktuelle Framebuffer Inhalt immer Ã¼berschrieben und man ist auf die BildschirmgrÃ¶Ãe beschrÃ¤nkt, aber besser 
  als nÃ¼schts. Allerdings ist dann die Verwendbarkeit sssehr eingeschrÃ¤nkt, nur das RTT Beispiel lief dann korrekt bei mir, 
  bei den anderen Beispielen wurde natÃ¼rlich immer der aktuelle Bildschirminhalt Ã¼berzeichnet da man hier nicht wirklich 
  die Reihenfolge wie etwas gerendert wird beeinflussen kann.
PLRendererD3D9:
- Bei Texturen wurde der letzte Pixel nicht korrekt von dem Ã¼bergebenen Bild Ã¼bernommen
PLRenderer:
- Neuer Render State: Ambient: (gleicher Name wie bei den beiden API's gÃ¤ngig) Als ich damit anfing den Renderer zu 
  schreiben, hatte ich diesen State ignoriert da er mir Ã¼berflÃ¼ssig vorkam... ist er ja auch irgendwie. ;-)
  Jedoch merkte ich, das D3D 9 und OpenGL jeweils andere Voreinstellungen hierfÃ¼r haben, bei D3D ist alles schwarz wenn 
  kein Licht in der Szene ist, so wie man es eigentlich auch erwartet. Bei OpenGL hinwegen hat die Szene als Voreinstellung 
  etwas Ambient so das selbst wenn kein Licht in der Szene ist man was sehen kann. Damit das aber jeder selbst so einstellen 
  kann wie er will nahm ich diesen Render State nun doch mit auf. Voreinstellung ist bei uns wie bei D3D schwarz.



>> 29.03.2006
[CO]
PLRendererD3D9:
- In Rectangle Texturen rendern funktioniert nun
- In Cube Texturen rendern funktioniert nun
PLRenderer
- RenderState::SlopeScaleDepthBias & RenderState::DepthBias sollte man nach mÃ¶glichkeit nie verwenden... als ich im D3D 
  Backend etwas nachging das fÃ¼r mich so aussah als ob der Tiefenbuffer Test deaktiviert ist, merkte ich das OpenGL & D3D
  diese 'Polygon Offset' Werte jeweils etwas anderst Interpretiert. Als ich etwas im Netz nachforschte las ich, das sogar 
  sich das Verhalten dieser Werte von GPU zu GPU unterscheidet, es gibt hier scheinbar keine feste Definition wie das zu 
  Handhaben ist... dadurch werden diese zwei Render States praktisch witzlos. Ich denke/hoffe das erklÃ¤rt wieso bei Jens 
  unberechenbarerweise beim PerPixelLighting Lichter 'flackerten/verschwanden'. Da das 'anheben' von Tiefenbuffer Werten 
  jedoch vorallem dann wenn etwas in meheren Schritten gerendert wird sehr wichtig ist um 'z-fighting' zu verhindern, 
  musste eine Alternative her. Daher fÃ¼gte ich einen neuen Render State Namens 'RenderState::ZBias' hinzu. Ist hier ein 
  Wert ungleich null gesetzt, manipuliert der Renderer automatisch etwas die Perspective Matrix. Laut diverser Foren hat 
  man so ein Ergebniss das in etwa auf jeder GPU & API gleich ist, und zumindestens bekam ich so nun bei OpenGL & D3D in 
  etwa gleiche Ergebnisse. :)
  Dokumentierte das auch gleich bei diesen Render State Kommentaren. Die 'anderen' zwei States lies ich jedoch drinnen 
  falls jemand diese aus welchem Grund auch immer verwenden will.



>> 28.03.2006
[CO]
- Renderer + Backends: Verbesserte ein paar Tab/Leerzeichen + schaute das Ã¼berall wo man einen Zeiger auf Zeiger hat 
  auch 'pp' im Variable Name steht.
PLRendererOpenGL:
- Wenn das hochladen komprimierter Texturen nicht funktioniert, muss im Fallback natÃ¼rlich ein korrektes anderes Format 
  ausgewÃ¤hlt werden...
PLRendererD3D9:
- Dieses Backend unterstÃ¼tzt nun ebenfalls Vertex Streaming. Vor jedem Draw Call wird geprÃ¼ft ob sich etwas an den Vertex 
  Daten geÃ¤ndert hat. Ist nur ein Vertex Stream aktiv, so wird die Vertex Declaration direkt von diesem Buffer Ã¼bernommen.
  Sind jedoch mehrere Streams aktiv, so muss eine Vertex Declaration dynamisch erzeugt werden.



>> 21.03.2006
[CO]
PLRenderer:
- TextureCube: Klassen Beschreibung um 2 ASCII Zeichnungen erweitert so das wirklich klar ist welche Cub Map Textur Seite 
  wo ist.
PLRenderer:
- Renderer::SetVertices(): Die Dokumentation von nOffset war nicht korrekt, der Index ist NICHT in Bytes sondern einfach 
  ein Vertex Index. Eine Bytes Angabe so wie es die API's selbst verlangen wÃ¤re hier sowieso gefÃ¤hrlich, denn wenn man das 
  nur um ein Byte verschieben wÃ¼rde stimmen die ganzen Vertex Daten ja nicht mehr! Diesen Doku Fehler merkte ich erst als 
  das Terrain unter D3D 9 nicht korrekt Dargestellt wurde, denn im Gegensatz zum OpenGL Backend wurde dieser Vertex Index 
  direkt an die API weitergeleitet ohne ihn erst mit der Vertex grÃ¶Ãe zu multiplizieren.
- Renderer::GetTransformState(): StandardmÃ¤Ãig wird nun die Matrize zurÃ¼ckgegeben welche man dem Renderer so Ã¼bergeben 
  hatte, denn normalerweise braucht man sich nicht um die Innereien scheren. Weglassen kann man diesen optionalen Parameter 
  allerdings nicht, PLMesh::MaterialPass::BindShaderParameter() verwendet diesen um Shader Parameter zu fÃ¼llen, und die 
  brauchen die konkreten API Matrizen!
PLRendererOpenGL:
- Unnnd ein weiterer Sonderfall den unser OpenGL Renderer automatisch behandeln muss: Ist die automatische Textur Generation 
  auf 'reflection map' gesetzt, so muss die Textur Matrix mit der inversen der View Matrix multipliziert werden - macht man 
  dies nicht, so hat man keine Kamera abhÃ¤ngigen Reflektionen! In dem einen PL Beispiel in dem die Umgebung dynamisch Ã¼ber 
  Cube Maps reflektiert wird hatte ich bis jetzt einen Shader fÃ¼r die Reflektion verwendet, dies ist hier nun unnÃ¶tig und 
  kompakter. :)
  Da es mittlerweile 2 Dinge sind (rectangle textures, reflection map) welche einfluss auf die Textur Matrizen haben,
  packte ich das alles gleich sauber in eine extra Funktion Namens UpdateCurrentOpenGLTextureMatrix().
PLRendererD3D9:
- VertexBufferD3D9 & IndexBufferD3D9: D3DUSAGE_DYNAMIC und D3DPOOL_MANAGED sind lustigerweise NICHT Kompatibel und wenn 
  man es trotzdem versucht, so geht gar nix mehr - wow, was fÃ¼r eine interne D3D Implementation! :)



>> 18.03.2006
[CO]
RendererOpenGL:
- Get3DCoordinate() war noch nicht ok da die abgefragte View Matrix eventuell gerade nicht aktuell war - daher verwende ich nun 
  die in unserem Renderer gespeicherten Matrizen direkt anstatt mir diese von OpenGL zurÃ¼ckgeben zu lassen. Das werd ich 
  wohl spÃ¤ter nochmal etwas umbauen da derzeit diese Funktion auch beim Null & D3D Backend nicht richtig implementiert ist.
  Aber fÃ¼r jetzt erstmal nur soweit das das unter OpenGL sauber funktioniert.



>> 12.03.2006
[SW]
PLRenderer(OpenGL):
- nun wieder Ã¼bersetzbar unter Linux, plus ein paar wgl* aufrufe im linuxteil entfernt(bÃ¶ser Chris ;)).



>> 10.03.2006
[CO]
PLRendererOpenGL:
- Fing damit an Sicherheits-Abfragen einzubauen falls eine Extension nicht vorhanden ist
- RendererOpenGL: DrawPrimitives() und DrawIndexedPrimitives() verwenden nun, wenn der verwendete Vertex Buffer im 
  Software Modus ist und falls die entsprechende Extension vorhanden ist, glLockArraysEXT() und glUnlockArraysEXT() was in 
  diesem Fall die Performance deutlich verbessert... aber insgesammt ist die Performance im Software Modus natÃ¼rlich 
  langsamer als die VBO Variante.



>> 09.03.2006
[CO]
PLRenderer:
- SetRenderState(), SetSamplerState(), SetTextureStageState(), SetMaterialState(): Haben nun wie besprochen boolsche 
  RÃ¼ckgabewerte
- WrappersBackend.inl etc. gibt es nicht mehr, das wird nun direkt in z.B. SetRenderState() geprÃ¼ft - dadurch mÃ¼sste man 
  besser auf Fehleingaben reagieren kÃ¶nnen.
- Resource: BackupDeviceData() & RestoreDeviceData() bekommen nun einen Zeiger auf einen Zeiger auf 
  PLGeneral::uint8 als Parameter. Hier kÃ¶nnen/sollten alle Resourcen ihre Backups anlegen und dann in RestoreDeviceData() 
  auch wieder freigeben. Zum einen muss dadurch nicht mehr ein Zeiger pro Resource auf ein eventuelles Backup gespeichert 
  werden (jipi, wir sparen 4 Byte :), aber der viel grÃ¶Ãere Vorteil ist, das es nun relativ leicht zu realisieren sein 
  sollte wÃ¤hrend der Laufzeit von einem Renderer zu einem anderen zu wechseln. (z.B. von Direct3D zu OpenGL) In dem Fall 
  werden einfach die Daten aller Resourcen 'weggespeichert' und dann dem neuen Renderer zum 'Restore' Ã¼bergeben. WIE genau 
  die jeweiligen Resource Typen ihre Daten wegspeichern ist dabei diesen Resourcen selbst Ã¼berlassen. Aber fÃ¼rs erste 
  ist dies wirklich nur zum einfachen Wiederherstellen der Daten nach z.B. dem wechsel des Bildschirm Modus.
- Die einzelnen Texturen haben nun nur noch GetNumOfBytes() anstatt AllocateMemory() Funktionen, diese Funktion gibt nur 
  zurÃ¼ck wie groÃ ein Buffer sein muss um diese Texture zu speichern und belegt nicht gleich Speicher. Mipmaps oder Texture 
  Kompression werden hier nicht berÃ¼cksichtigt.



>> 03.03.2006
[CO]
PLRenderer:
- IndexBuffer: MaxVertexIndexUShort (=65536) Konstante hinzugefÃ¼gt. Hat ein Vertex Buffer weniger als 65536 Vertices, so 
  kann man beim Index Buffer den Typ UShort nehmen.
- 'Renderer Flags'-Definitionen (PLERFlags) in die 'Renderer'-Klasse verschoben
- 'PL_MAX_PIPELINE_CHANNELS'-Definition in die 'VertexBuffer'-Klasse verschoben
- Nahm an einigen stellen wie z.B. 'RendererBackend::GetMaterialState()' unnÃ¶tige 'Sicherheit-Abfragen' raus... wenn solche 
  Werte kommen, dann lÃ¤uft gerade wirklich etwas total schief... ;-)
- Renderer Definitionen Umstellungen fertiggestellt, ob die Namen der diversen Namespaces so ok sind, wird sich noch zeigen
- Passte alle Projekte an diese Renderer Ãnderungen an



>> 02.03.2006
[CO]
- Dort wo mÃ¶glich werden nun die statischen Objekte von z.B. Quaternion verwendet statt neue TemporÃ¤re Objekte zu erzeugen
PLRenderer:
- 'Vertex Attribute Semantic'-Definitionen verschob ich direkt in die 'VertexBuffer'-Klasse da es nur hier verwendet wird
- 'Vertex Attribute Type'-Defintionen direkt in die 'VertexBuffer'-Klasse verschoben. Das alte 'PL_VAT_COLOR' musste ich in 
  'RGBA' umbennen da bereits die Semantic eine 'Color'-Definition hat.
- Die 'Vertex Attribute'-Struktur verschob ich ebenfalls direkt in die 'VertexBuffer'-Klasse
- 'Vertex index type'-Definitionen direkt in 'IndexBuffer'-Klasse verschoben
- 'Resource Types'-Definitionen (PLE_RT) in 'Resource'-Klasse verschoben... man kÃ¶nnte hier Theoretisch diese Resourcen 
  Klassen mit dem RTTI Verwalten, das wÃ¤re hier aber meines erachtens unnÃ¶tiger Overhead. Auch kÃ¶nnte man diese 
  Typ-Definitionen abstrakter halten und z.B. nur 'Buffer' als Resourcen Typ angeben und dann in Buffer weiter zwischen 
  'Index Buffer' etc. unterscheiden, aber auch das wÃ¤re ziemlich umstÃ¤ndlich. :)
- 'Texture Pixel Formats'-Definitionen (PLE_TPF) in die 'Texture'-Klasse verschoben
- 'Texture Flags'-Definitionen (PLE_TEXTUREFLAGS) in die 'Texture'-Klasse verschoben
- 'Surface Types'-Definitionen (PLE_ST) in die 'Surface'-Klasse verschoben
- 'Shader Parmeter Types'-Definitionen (PLE_SPT) in die 'ShaderParameter'-Klasse verschoben
- 'Texture Surface Flags'-Definitionen (PLETSFlags) in die 'SurfaceTexture'-Klasse verschoben
- Schaute die Header durch um nur nÃ¶tige Header einzubinden und Ã¼berall korrekte Predefinitions zu machen
- Passte alle Projekte an diese Renderer Ãnderungen an
... einige Renderer Definitionen mÃ¼ssen noch umgestellt werden, ist aber wirklich zuviel um alles auf einmal zu machen ;-)



>> 01.03.2006
[CO]
- Ãnderte wie besprochen im Renderer (Types.h) die Definitionen zu Namespace & Enum Kombinationen so das man alles besser  
  lesen kann. Ein paar gÃ¤ngige AbkÃ¼rzungen lies ich drinnen wie z.B. 'InvSrcColor' in 'BlendFunc' - hier jedesmal 
  'BlendFunction::InversedSourceColor' zu schreiben wÃ¤re heftig. (vorallem wenn Coder StundenmÃ¤Ãig viel Kohle kosten. ;-)
  Da ich auch gleich wie Ã¼blich alle Projekte an diese Ãnderungen anpasse, wurde ich heute mit dieser Umstellung nicht 
  ganz fertig.



>> 28.02.2006
[CO]
- Ein paar Leerzeichen/Tabs verbessert



>> 25.02.2006
[CO]
- Alles an Quaternion Ãnderungen angepasst



>> 25.02.2006
[SB]
- Alles an PLGeneral Ãnderungen angepasst



>> 24.02.2006
[CO]
- Alles an PLGui Ãnderungen angepasst
- Stellte wie dort wo mÃ¶glich/sinnig von globalen Definitionen auf Klassen abhÃ¤ngige enum Definitionen um. Beim Renderer 
  hab ich erstmal nichts gemacht da diese Umstellung dort eine grÃ¶Ãere Sache wird.



>> 23.02.2006
[CO]
- Alles an PLGeneral Ãnderungen angepasst



>> 22.02.2006
[CO]
- Die Haupt-Header der Projekte haben nun am Anfang des Namens wieder ein PL
- Doxygen Makefiles angepasst
- Alles an PLMath Ãnderungen angepasst



>> 21.02.2006
[CO]
- Alles an aktuelle PLMath Ãnderungen angepasst (ein paar Dinge sind noch nicht ganz ok)



>> 10.02.2006
[CO]
- Alles an Stack & PLMath Ãnderungen angepasst



>> 06.02.2006
[CO]
- Alles auf String::Format() umgestellt + dort wo mÃ¶glich von %f auf %g umgestellt da dadurch nur das nÃ¶tigste ausgegeben wird



>> 25.01.2006
[CO]
- PLRenderer auf Namespace umgestellt



>> 23.01.2006
[CO]
- An uint32 Ãnderungen angepasst



>> 19.01.1006
[CO]
- Alles an PLMath & PLGui Ãnderungen angepasst



>> 18.01.2006
[CO]
- Alles an PLGeneral Ãnderungen angepasst



>> 13.01.2006
[CO]
- Stellte alle Projekte 'Ã¼ber' PLGui auf die neue String Klasse um - nur an den stellen wo String Variablen vom RTTI genutzt 
  werden wird noch die alte Klasse verwendet.



>> 01.01.2006
[CO]
- Passte Ã¼berall das aktuelle Jahr an, also von 2002-2006
PLRendererOpenGL:
- FrameBufferObject::CheckFrameBufferStatus(): Arbeitet nun korrekt - hier muss man zuerst den Draw & Read Buffer auf Null 
  setzen, ansonnsten gibt 'glCheckFramebufferStatusEXT' IMMER einen Fehler zurÃ¼ck.
- Rendern in Cube Texturen funktioniert nun



>> 30.12.2005
[CO]
- Fand in den verschiedenen Projekten noch ein paar Stellen wo nun PLTString verwendet werden kann, und stellte entsprechend 
  um



>> 29.12.2005
[CO]
PLRenderer:
- Verschob ein paar Funktionen der Renderer Backends in die Backend Klasse
- Machte diverse Funktionen der Renderer Resourcen protected - somit sind die Interfaces etwas sauberer und der User 
  MUSS die entsprechenden Renderer Funktionen verwenden anstatt direkt die Resource Funktionen. Das machte zwar die 
  Implementation in den konkreten Renderer Backends teils etwas tricky, aber die Interfaces mit denen der User arbeitet 
  sind denk ich wichtiger.



>> 06.12.2005
[CO]
- PLTRendererShaderD3D9 & PLTRendererShaderOpenGL: RecurseProgramParameters(): Ist ein Shader Parameter ungÃ¼ltig oder 
  wird von Cg ausoptimiert da dieser nicht verwendet wird, so wird dieser Parameter nun komplett irgnoriert und eine 
  entsprechende Nachricht wird ins Log geschrieben... ansonnsten zickte Cg herum wenn dieser Parameter trotzdem verwendet 
  wurde. ;-)
  Desweiteren verwenden nun die Shader auch Hash Tables fÃ¼r einen schnelleren Zugriff auf Parameter Ã¼ber ihren Namen.
- Stellte aktuelles PL SDK zusammen, das vorherige ist schon wieder 2 Monate alt.



>> 05.12.2005
[CO]
- Machte PLTSurfaceListener flexibler: Diese Klasse Rendert nun selbst KEINE Informationen wie FPS oder Gui mehr. Genauso 
  wie z.B. das lÃ¶schen des aktuellen Frame Buffers wird das nun Ã¼ber spezielle Scene Nodes geregelt. PLTSurfaceListener 
  selbst verwendet nun NUR noch einen Scene Renderer Query... somit ist das mit dem Scene Rendern nun sauber getrennt 
  von den Surface Listenern. Ein 'Scene Renderer' selbst ist nun ein 'Scene Query' was besser ins Design passt und auch 
  recht nett zu bedienen ist. Diese neue Query-Klasse hat nun also wie gehabt EINEN Scene Container fÃ¼r seine Scene die sie 
  Darstellen soll, jedoch wird hier zwischen 'Root' und 'Scene' Container 'unterschieden'. Hier ein Beispiel wie so ein 
  Root-Container in der Praxis aussieht:
    PLTSceneContainer  (Root Container)
      PLTSNClear
      PLTSceneContainer  (Scene Container mit der eigentlichen 'Szene')
        PLTSNCamera
        PLTSNSky
        PLTSNObject
        ...
      PLTSNGui
      PLTSNEngineInformation
      PLTSNConsole
  Somit kann man das was nacheinander gerendert werden soll also selbst komplett bestimmen. Die 'Unterscheidung' zwischen 
  Root & Scene war nÃ¶tig da es vorkommen kann das die 'eigentliche' Scene fÃ¼r z.B. Reflektionen/Refractionen mehrmals 
  in einem Frame von verschiedenen Perspektiven gerendert werden muss. In diesem Fall ist es aber meistens unpraktisch wenn 
  hier dann auch gleich automatisch die Kamera gesetzt, der Frame Buffer gelÃ¶scht und am Ende noch Dinge wie Gui, Engine 
  Informationen oder gar die Konsole gerendert wird. 'Root' enthÃ¤lt also quasi Pre/In/Post-Order Dinge, wobei 'In' 
  die eigentliche Scene ist.
  Zuerst wollte ich Dinge wie PLTSNClear, PLTSNFog die ja nicht 'wirklich richtige' Elemente der Scene sind zu nicht Scene 
  Nodes machen und es dann so handhaben das PLTSurfaceListener das selbst macht. In diesem Fall hÃ¤tte dieser also noch Dinge 
  wie Frame Buffer lÃ¶schen/Konsole Darstellen direkt selbst gemacht und der User hÃ¤tte spezielle Funktionen in dessen 
  Interface gehabt um diese Dinge Einstellen zu kÃ¶nnen... so ist es Ã¼blich bzw. so machen es die meisten. Jedoch wÃ¤re das 
  ein unschÃ¶ner Style-Bruch gewesen und man hÃ¤tte an FlexibilitÃ¤t verloren, darum die Radikale Variante auch Dinge wie das 
  Ingame Gui gleich Ã¼ber eine Scene Node Darstellen zu lassen.
- Musste PLTSQSceneRenderer noch die Funktion SetRenderTarget() verpassen da es z.B. beim Post Processing nÃ¶tig ist GLEICH 
  am Anfang eine Textur als neues Render Target zu setzen. WÃ¼rde dies erst wie gehabt in 'DrawSceneContainer()' passieren, 
  so wÃ¤re in dieser Textur Schrott und Grafik-Fehler treten auf... 
- Nahm den Scene Manager heraus da dieser Manager Problematisch war. (der haupt PLTSceneContainer konnte hier ja nicht vom 
  RTTI richtig durch die Singleton-Klasse Initialisiert werden)
  DafÃ¼r gibt es nun PL::GetRootSceneContainer() was im Prinzip das gleiche ist, nur das PLTSceneContainer hier vom RTTI 
  erzeugt wird und dadurch auch richtig Initialisiert wird. Eine andere LÃ¶sung fÃ¤llt mir hier nicht ein... aber ich denke 
  das ist ok so - so eine 'Root Node' findet man in vielen Engines. (iiiirrrgendwo muss es ja anfangen ;-)
- PL::GetDefaultSurfaceListener(): Erst wenn diese Funktion zum ersten mal aufgerufen wird, wird der Default Surface 
  Listerner erzeugt - meistens braucht man diesen nicht, nur fÃ¼r kleine Anwendungen ist er praktisch.



>> 04.12.2005
[CO]
- Sobald ein Fragment Shader Texturen verwendet wird es etwas Tricky da man vorher nicht weis in welcher Textur Unit eine 
  Textur von Cg am Ende landet. Daher muss man nach dem setzen des Shader Parameters abfragen in welcher Textur Unit die 
  Textur nun 'sitzt' und den Renderer entsprechend darÃ¼ber Informieren. Wird dies nicht gemacht sind die Infos Ã¼ber die 
  aktuell gesetzen Texturen eventuell falsch was sich dann in falschen Texturen beim Rendern Ã¤uÃert.



>> 02.12.2005
[CO]
PLRenderer:
- Etwas an den Occlusion Queries gefeilt



>> 22.11.2005
[CO]
PLRendererOpenGL:
- Stefan fand heraus das NVIDIA Karten bei Rectangle Texturen keine Kompression mÃ¶gen (zumindestens auf den Karten wo wir 
  es Testen konnten: GeForce 4/5) obwohl es laut Dokumentationen gehen mÃ¼sste...
  Daher erweiterte ich das hochladen der Texturen zur GPU um Anfragen ob gerade Textur Kompression verwendet werden soll und 
  wenn ja, ob das hochladen klappte. Wenn ein Fehler auftrat, so wird automatisch ein Textur Format ohne Kompression als 
  Fallback gewÃ¤hlt.



>> 20.11.2005
[SB]
- Aufrufe von PLTContainer::Add() angepaÃt
- Include <Log.h> eingefÃ¼gt



>> 10.11.2005
[CO]
PLRenderer:
- PLTRendererBuffer: Allocate() kennt nun einen weiteren Parameter welcher angibt ob dieser Buffer 'Managed' ist oder nicht. 
  Ist die Verwendung als PL_USAGE_SOFTWARE Definiert, so hat dieser neue Parameter keine Auswirkung. Im Null Renderer wird 
  dieser Parameter ebenfalls Ignoriert. Im D3D Renderer hingegen wird dann in den Buffern gesagt das D3D diesen Buffer 
  Verwalten soll. Unter OpenGL musste eine eigene LÃ¶sung implementiert werden die eine Kopie des Buffers im Arbeitsspeicher 
  hÃ¤lt. Der Performance Gewinn bei 'Managed-Mode' ist leider nicht wirklich sonderlich groÃ, aber jedes bischn mehr an 
  Performance hilft. Bei Allocate() kann man als letzten Parameter noch angeben ob der aktuelle Buffer Inhalt erhalten 
  bleiben soll oder nicht... meistens braucht man den Inhalt nicht mehr, aber kÃ¶nnte sein das dies mal Praktisch ist.
- PLTRendererBuffer: Wie gestern kurz mit Stefan besprochen, habe ich das Lock/Unlock etwas verÃ¤ndert. Bis jetzt war es so 
  das man nur einmal Lock() aufrufen konnte, war der Buffer bereits gelockt, so wurde NULL zurÃ¼ckgegeben. Wenn es sauber 
  laufen sollte musste man also vorher mit IsLocked() prÃ¼fen und wenn der Buffer bereits gelockt war diesen so direkt 
  verwenden - und nur wenn man ihn selbst gelockt hatte musste man ihn auch selbst wieder freigeben... das war ziemlich 
  FehleranfÃ¤llig und UmstÃ¤ndlich zu bedienen. Nun ist es so, das intern eine art von 'Reference Counter' vorhanden ist. 
  Bei jedem Lock wird um eins erhÃ¶ht, bei jedem Unlock um eins verringert, intern wird der Buffer selbst korrekt gelockt 
  wenn es der erste Lock ist, und wieder freigegeben wenn es das letzte Unlock war. Die Funktion IsLocked() wurde durch 
  GetLockCount() ersetzt. Passte Ã¼berall die Codes entsprechend an... so ists nun viel schÃ¶ner zu Bedienen.
  Einige Funktionen wie Clear() 'erzwingen' intern Unlock(), allerdings lÃ¤sst sich das leider kaum anderst lÃ¶sen... man 
  kÃ¶nnte natÃ¼rlich diese Funktionen wenn der Buffer locked ist 'sperren', aber das kÃ¶nnte gleiche Probleme machen. Der 
  Benutzer muss selbst Lock/Unlock 'gewissenhaft' aufrufen. Also nicht EINMAL Lock und dann sich die Zeiger selbst irgendwo 
  fest speichern und meinen dieser Zeiger wÃ¤re immer gÃ¼ltig selbst wenn der Buffer gekillt wird. ;-)
  (auf diese Dinge wird in den Kommentaren deutlich hingewiesen)



>> 08.11.2005
[CO]
PLRenderer:
- PLTRendererFrame: Neue Funktionen: GetFullscreenAltTab(), SetFullscreenAltTab(): Damit ist es mÃ¶glich unter Windows 
  alt-tab im Vollbild Modus zu unterbinden.
- FÃ¼gte 10 neue Texture Formate hinzu welche es unter OpenGL & Direct3D gibt, es gibt zwar noch viele mehr... aber die 
  jeweils andere API kennt diese Texture Formate nicht. Sollte es spÃ¤ter mal nÃ¶tig sein diese Formate welche NUR die eine 
  oder andere API kennt einzubauen, so kann man dies ja immer noch.
- Verbesserte/erweiterte Shader Support: CreateVertexShader()/CreateFragmentShader() nehmen nun weitere optionale Parameter 
  an. Darunter u.a. zusÃ¤tzliche Definitionen welche dem Shader hinzugefÃ¼gt werden sollen. Dies kann dann Praktisch werden 
  wenn man z.B. bestimmte 'Features' in einem Shader beim erzeugen 'aktivieren/deaktivieren' will. Die OpenGL/D3D Renderer 
  fÃ¼gen diesen Definitionen selbst noch etwas hinzu... z.B. '#define OPENGL'/'#define D3D', so 'weis' man im Shader welche 
  API gerade verwendet wird, z.B. MUSS man bei OpenGL 'texRECT' fÃ¼r Textur Zugriffe verwenden wenn es sich um Rectangle 
  Texturen handelt, unter D3D hingegen ist dieser Befehl unbekannt und es muss hier wie bei normalen 2D Texturen 'tex2D' 
  verwendet werden. Innerhalb der Renderer Backends muss der konkrete Shader also 'zusammenkopiert' werden. Passte die 
  Shader in 'PLPostProcessEffects.pak' entsprechend an so das diese auch unter D3D verwendbar sind.



>> 07.11.2005
[CO]
PLRenderer:
- VertexBuffer: Allocate(): Etwas verfeinert da es zulÃ¤ssig sein soll einen bereits angelegten Vertex Buffer nachtrÃ¤glich zu 
  Ã¤ndern... z.B. die Anzahl der Vertices und/oder die Verwendung. Das hinzufÃ¼gen neuer Vertex Attribute war ja bereits auch 
  nach Allocate() mÃ¶glich... diese Dinge sind zwar nicht wirklich Performant da der Inhalt der Buffer umstÃ¤ndlich 
  herumkopiert werden muss - mÃ¶glich sein soll es aber da es hier und da ganz Praktisch ist.



>> 04.11.2005
[CO]
PLTRendererOpenGL
- Clear(): Wenn der ZBuffer gelÃ¶scht wird, so wird Z Write Enable zur Sicherheit aktiviert - ansonnsten kann es sein das 
  der Z Buffer nicht gelÃ¶scht wird.



>> 29.10.2005
[CO]
PLRenderer:
- Begin2DMode() und End2DMode() Ã¤ndern keine Render States mehr, dies muss der User schon selbst so machen wie er es braucht 
  und es ist eher ungeschickt diese States hier zu Ã¤ndern.



>> 28.10.2005
[CO]
PLRendererOpenGL:
- PLTRendererBackendCg: Man kann nun die automatische Fehler Callback Funktion aktivieren/deaktivieren - beim einladen 
  von Shadern ist diese Callback Funktion z.B. ziemlich unpraktisch, denn nach dem Laden ist es Sinnvoll selbst abzufragen
  ob ein Problem auftrat um dann entsprechend darauf zu reagieren.
- PLTRendererShaderOpenGL machte noch etwas Probleme: In Init() gabs bei cgCreateProgram() auf meiner GeForce4 Ti 4200 
  bei machen Fragement Shader einen merkwÃ¼rdigen Crash wenn das Profile CG_PROFILE_FP20 verwendet wurde. Daher habe ich 
  hier nun einen 'hack' eingebaut der sobald CG_PROFILE_FP20 verwendet werden soll CG_PROFILE_ARBFP1 auswÃ¤hlt welches keinen 
  Crash verursacht - ob der Shader Ã¼berhaupt auf der Karte lÃ¤uft oder nicht kann man ja erst danach feststellen. ;-)
  Bei cgGLLoadProgram() wird die automatische Cg Fehler Callback Funktion nun deaktiviert um auf eventuell aufgetretene 
  Fehler reagieren zu kÃ¶nnen, ansonnsten wurden nicht verwendbare Shader nicht erkannt und verwendet was zu Problemen 
  fÃ¼hren konnte.
- PLTRendererOpenGL::DrawIndexedPrimitives(): glDrawRangeElementsEXT kann nur eine bestimmte Daten Menge verarbeiten, passt 
  man hier nicht auf kann es zu Problemen kommen



>> 27.10.2005
[CO]
PLRenderer:
- Erzeugt man eine Texture in welche man Rendern kann, kann man nun noch optionale Flags mitgeben. Als Standard ist gesetzt 
  das diese Render Targets auch Tiefen & Stencil Buffer haben sollen. Bei z.B. den zwei internen Post Processing Render To 
  Texturen braucht man jedoch keinen Tiefen & Stencil Buffer... und wird kein Stencil Buffer benÃ¶tigt, so versucht der 
  OpenGL Renderer die schnelleren FBO's zu verwenden. (FBO & Stencil Buffer derzeit leider nix gut) Man sollte hier also 
  immer nur das setzen was man auch wirklich benÃ¶tigt so das die jeweiligen Renderer hier intern selbst das Optimalste 
  verwenden kÃ¶nnen. Man MUSS aber nichts genaueres angeben, in dem Fall ist man selbst Schuld wenn die Performance zu 
  wÃ¼nschen Ã¼brig lÃ¤sst. (wenn man nicht genau sagt was man denn gerne hÃ¤tte, bekommt man halt irgendwas das den meisten 
  wohl reicht ;-)
  Ist hier nun also ein brauchbarer Kompromiss so das man im gÃ¼nstigen Fall auf das flotte FBO zurÃ¼ckgreifen kann - was der 
  Post Processing Performance deutlich zugute kommt da hier vorallem bei Effekten wie Bloom extrem hÃ¤uftig Render Targets 
  gewechselt werden mÃ¼ssen was mit pbuffern eine wirklich ziemlich lahme Angelegenheit ist!
  Bei meinen Messungen (PLSampleNewtonCharacterController, 800x600 Fenster, start Ansicht) hatte ich bei aktivem Bloom und 
  mit reinem pbuffer bei aktiven Schatten 28 FPS, ohne Schatten 45. Mit FBO wenn mÃ¶glich, (also wenn kein Stencil Buffer 
  benÃ¶tigt wird was beim Post Processing der Fall ist) hatte ich hingegen bei aktiven Schatten 34 FPS, ohne 60. Beim HDR 
  Test hatte ich bei Standard-Einstellungen statt 16, 17 FPS... man merkt also einen 'minimalen' Performance Gewinn, und je 
  mehr FPS man generell hat desto krasser merkt man einen Unterschied zwischen pbuffer & FBO. :)



>> 06.10.2005
[CO]
PLRenderer:
- Hier kann man nun ein paar weitere States 'fixieren' so das diese nicht mehr geÃ¤ndert werden kÃ¶nnen.



>> 29.09.2005
[CO]
PLRenderer:
- Beim beenden werden die Resourcen & OberflÃ¤chen nun korrekt gelÃ¶scht, desweiteren wird der Vollbild Modus jetzt korrekt in 
  die Konfiguration zurÃ¼ckgeschrieben. Beim beenden wird einfach geprÃ¼ft ob noch ein Fenster im Vollbild Modus ist, wenn ja 
  wird in der Konfiguration 'Fullscreen=1' gesetzt.
PLRendererOpenGL:
- Neue unterstÃ¼tzte Extension: GL_ARB_draw_buffers ist die 'offizielle' neue Variante von GL_ATI_draw_buffers
  Diese sind also vÃ¶llig Identisch - nur halt nen anderer Name. 'NatÃ¼rlich' friert auch hier nach ein paar Sekunden das 
  System einfach ohne erkennbaren Grund ein, darum ist auch diese Extension erstmal aus SicherheitsgrÃ¼nden Deaktiviert.



>> 18.09.2005
[CO]
PLRenderer:
- Neue Funktionen: DrawLines2D(), DrawLines3D(), DrawPoints2D() und DrawLines3D() fÃ¼r das relativ Performante Zeichnen mehrer 
  Linien/Punkte auf einmal.
PLRendererOpenGL:
- PLTRendererSurfaceTextureOpenGL & PLTRendererSurfaceWindowOpenGL: Weiteren Bug behoben: Sobald eine OberflÃ¤che zerstÃ¶rt 
  wird, wird nun versucht die Haupt OberflÃ¤che des OpenGL Renderers zu setzen, erst wenn dies nicht funktioniert wird Null 
  als aktuell gesetzt und OpenGL Befehle haben keine Wirkung mehr. Das machte anderst in PixelLab Probleme: Ich hatte zuerst 
  den Mesh Editor offen, schloss diesen und Ã¶ffnete den Scene Editor - hier viel mir aber dann auf das plÃ¶tzlich Meshs wie 
  die Pfeile bei den Transformern nicht mehr Darsgestellt wurden und fand heraus das die Vertex Buffer nicht erzeugt wurden - 
  das lag daran das beim schlieÃen des Mesh Editors die Fenster beim zerstÃ¶ren Null als Current setzen und die Mesh Buffer 
  erzeugt wurden wÃ¤hrend gerade kein aktueller OpenGL Context gesetzt war. Soetwas ungeschicktes kann nun nicht mehr 
  passieren. :)



>> 16.09.2005
[CO]
PLRenderer:
- PLTRendererSurfaceListener: Im Destruktor trÃ¤gt sich nun dieser Listener wieder bei den Surfaces aus
- Merkte in PLSampleMultiView das es praktisch ist wenn die Fenster nach dem wechsel von Vollbild zu Fenster Modus wieder an 
  ihrer alten Position etc. sind. Daher erweiterte ich PLTRendererFrame entsprechend. So ists mÃ¶glich in PLSampleMultiView 
  bequem ein Fenster nach dem anderen in den Vollbild Modus und wieder zurÃ¼ck zu schalten.
PLRendererOpenGL:
- RestoreDeviceStates() beachtet nun auch das gesetzte Render Flags das setzen von States verhindern kÃ¶nnen - hier wollen 
  wir aber ALLES setzen.



>> 15.09.2005
[CO]
PLRendererOpenGL:
- Wechselt man den Bildschirm Modus werden nun auch die Device States korrekt zurÃ¼ckgesetzt
PLRenderer:
- PLTRendererShaderParameter::SetValueTexture() war noch nicht ok, dadurch bekamen Texturen Handler welche aber nicht wieder 
  korrekt abgemeldet wurden. Auch beim Destructor von PLTRendererShaderParameter musste man noch Texture Handler beachten. 
  Diese zwei Dinge konnten heftige Crashs verursachen.
- PLTRendererSurface hatte auch noch so einige heftige Bugs zu bieten: ClearListeners() Informiert nun auch diese Listener 
  und beim Destructor wird nun ClearListeners() aufgerufen.
- Spendierte PLTRendererSurface BackupDeviceData() und RestoreDeviceData. (wie bei Renderer Resourcen)
  PLTRendererSurfaceTextureOpenGL implementiert diese zwei Funktionen um den pbuffer anzugleichen - ansonnsten konnte es 
  zu Problemen kommen.
- Wechselt ein Fenster in den Vollbild Modus, so wird es nun in PLTRendererFrame::InitWindow() links oben Positioniert. 
  (irgendwie sinnig das ;-) 
--> Ich konnte nun keine Probleme mehr feststellen wenn man zwischen Vollbild und Fenster Modus wechselt, egal wie hÃ¤ufig 
    man das macht - am laufenden Band den Fenster Modus Ã¤ndern ist ein SpaÃ fÃ¼r groÃ und klein. ;-)



>> 14.09.2005
[CO]
PLRenderer:
- Etwas am Direct3D Backend geschraubt. Gibt aber immer noch viele Details zu verbessern. Das Rendern in mehrere Texturen 
  gleichzeitig funktioniert allerdings bereits super - im OpenGL hab ich ja noch diese merkwÃ¼rdigen Crashs.
  Notierte in der PL_API Dokumentation gleich noch diverse Dinge der Renderer Backends wie z.B. nicht UnterstÃ¼tzte 
  Funktionen. Beim erzeugen von Texturen kann man nun noch Flags mitgeben um z.B. Mipmaps Automatisch erzeugen zu lassen 
  oder um eine Texture auch als Color Render Target verwenden zu kÃ¶nnen.
- OpenGL backend: Verwendet man Rectangle Texturen, so wird nun die Texture Matrix so skaliert das der User selbst IMMER 
  mit normalisierten Texture Koordinaten arbeitet. Es hatte mich schon immer genervt das es hier eine so unhandliche 
  Texture Koordinaten unterscheidung gibt. Das einzige wo man hier aufpassen muss ist, wenn man Rectangle Texturen mit 
  Shader verwendet muss man in den Vertex Shadern die Texture Matrixen berÃ¼cksichtigen - ansonnsten stimmen die Texture 
  Koordinaten nicht. (denn die GPU will hier nicht normalisierte haben)
  Zuerst wollte ich diese Texture Matrix Manipulation im D3D Backend machen, denn dieses macht hier keine Unterscheidung - 
  aber dann merkte ich das dies irgendwie anderst herum praktischer ist. ;-)
  U.a. musste ich den Post Process Manager und PLPostProcessEffects.pak umstellen.
- Renderer Statistiken um weitere Werte erweitert
- Post Process Manager: Intern beim Zeichnen einen kleinen Offset hinzugefÃ¼gt der verhindert das z.B. bei Bloom man oben 
  und rechts Farben ins Schwarze ausblenden sieht



>> 03.09.2005
[CO]
PLRenderer:
- Camera & frustum Funktionen aus dem Renderer entfernt, mittlerweile hat das hier nichts mehr zu suchen, das ist Sache des
  Scene Systems :)



>> 27.08.2005
[CO]
PLRenderer:
- Beim erzeugen etc. von Texturen wird nun PLTImage Ã¼bergeben anstatt wie bisher direkt die Daten + Informationen wie groÃ 
  etwas ist etc. Dies hat mehrere Vorteile:
  - Wurde z.B. ein dds Bild eingeladen ist es mÃ¶glich das die Daten bereits in einem bekannten komprimierten Format wie z.B. 
    DXT5 vorliegen und so muss die GPU nicht mehr selbst komprimieren was den Texture erzeugungs Vorgang deutlich 
    beschleunigt. Somit ist auch endlich sauber geregelt welches Interne Texture Format verwendet werden soll - das war bis 
    jetzt ziemlich chaotisch da ich einfach nicht so recht wusste wie ich wo alle verschiedenen Infos Ã¼bergeben soll, dank
    PLTImage kein Problem mehr und alles ist sauber verschnÃ¼rrt.
  - In PLTImage kÃ¶nnen bereits MipMaps liegen, in dem Fall kÃ¶nnen diese direkt an die GPU Ã¼bergeben werden welche diese nicht 
    mehr selbst erzeugen muss. So kann z.B. auch der Grafiker direkt Ã¼ber z.B. das dds Format eigene MipMaps Ã¼bergeben.
    Allerdings funktioniert das mit diesen eigenen Mipmaps anscheinend noch nicht - scheint irgendwie an DevIL zu liegen. 
    Muss das bei Zeiten mal genauer Untersuchen...
  - Generell ist so das Interface dank weniger zu Ã¼bergebende Parameter schicker ;-)
- Neue Funktion: GetTexturePixelFormat() -> Gibt das passende Renderer Texture Format eins Ã¼bergebenen Bildes (PLTImage) 
  zurÃ¼ck



>> 24.08.2005
[CO]
PLRenderer:
- Fand heraus das meine Radion 9600 auch Two Sided Stencil Tests kann, das lÃ¤uft hier nur nicht unter GL_EXT_stencil_two_side 
  sondern unter einer ATI eigenen Extension Names 'ATI_separate_stencil'. Erweiterte den Renderer intern so das er diese 
  Extension nutzen kann - ein Grund mehr fÃ¼r so nen eigenen Renderer, man muss sich nicht mehr drum kÃ¼mmern unter welcher 
  GPU man welche Extensions nutzen muss. ;-)
  Bin mal gespannt ob ich dadurch bei mir bei den Shadow Volumes nen kleinen Performance Gewinn feststellen kann...
PLRendererOpenGL:
- Sortierte Extensions nach WGL, SGIS, EXT, ARB, ATI - so ists nun etwas Ãbersichtlicher
- PLTRendererOpenGLExtensions::Init() in Linux & Win32 cpp Dateien aufgeteilt - so ist es Ã¼bersichtlicher. Hier komplett 
  getrennte Klassen/Ableitungen zu machen schien mir als etwas zu viel Aufwand, denn ifdef muss man so oder so machen, wenn 
  nicht hier dann beim konkreten verwenden einer solch abgeleiteten Klasse.
- Das gleiche bei PLTRendererSurfaceWindowOpenGL, statt abgeleiter Klasse einfach getrennte cpp Dateien - ansonnsten mÃ¼sste 
  man jedesmal wenn man PLTRendererSurfaceWindowOpenGL verwendet casten um z.B. bestimmte Plattform abhÃ¤ngige Dinge zu 
  bekommen. (wÃ¤re ebenfalls nur verschobener Aufwand :)
- Die neue angedachte Plattform Klasse hab ich erstmal weggelassen da mir das momentan als etwas zuviel Aufwand fÃ¼r zuwenig 
  Nutzen erschien - im Prinzip lÃ¤ge dort derzeit eigentlich nur MakeCurrent drinnen welches aber unter Linux mehr Parameter 
  hat als unter Windows und man es daher nicht so ohne weiteres in ein einheitliches Interface quetschen kÃ¶nnte. Generell 
  sind recht wenig Plattform abhÃ¤ngige ifdefs drinen so das dies noch recht Ãbersichtlich ist. Das einzig unÃ¼bersichtliche 
  war eigentlich das mit den Extensions und Window da hier mehr als nur eine Zeile Code je Plattform anderst ist. ;-)



>> 20.08.2005
[CO]
PLRendererOpenGL:
- PLTRendererOpenGL::SetRenderTarget(): Licht & allgemeine OpenGL Einstellungen werden nun ebenfalls korrekt gesetzt wenn 
  PBuffer verwendet werden - damit verschwindet endlich ein nervender 'Grafik Fehler' bei z.B. Post Processing Effekten.



>> 01.08.2005
[CO]
PLRenderer:
- Accumulation Buffer Funktionen hinzugefÃ¼gt welche zumindestens unter OpenGL verwendet werden kÃ¶nnen



>> 18.07.2005
[CO]
PLRenderer:
- Stellte den Renderer auf Cg 1.4 um. Danach traten sehr merkwÃ¼rdige Texture Probleme auf. Als ich der Sache genauer auf 
  den Grund ging stellte ich fest das in PLTRendererShaderParameterOpenGL::SetValueTexture() (und D3D0) noch eine Abfrage
  fÃ¼r PL_RT_TEXTURERECTANGLE fehlte - desweiteren muss man am Ende diesen Sampler noch mit cgGLEnableTextureParameter()
  aktivieren. (aber nur unter OpenGL) Lustig das dies erst ab der neuen Cg Version Probleme bereitete. :)
  PLTMaterialPass::BindShaderParameter() Ã¼bergebe ich Cg nun die aktuelle gesetzte Texture anstatt der Textur des Material
  Passes - denn es kann sein das das Material bestimmte Texturen nicht setzt da diese 'global' vom aktuellen Renderer
  gesetzt werden.
- ATI UnterstÃ¼tzt nun ENDLICH in seinen Treibern FBO! (EXT_framebuffer_object) Ist diese Extension vorhanden, so wird nun 
  diese anstatt des lngsamen und total umstÃ¤ndlichen pbuffers verwendet. Leider machen noch floating point buffer und 
  Rectangle Texturen Ãrger und ich kann einfach nicht herausfinden wieso dies so ist - hoffentlich 'nur' ein Treiber
  Bug dieser neuen Extension. Desweiteren werden Stencil Buffer wie in der Extension Spezifikation angegeben ist noch 
  nicht... schade das es hier noch solche Probleme mit den FBO gib, denn diese sind wirklich eine sehr feine Sache. :)
  Daher hab ich die verwendung von FBO erstmal in PLTRendererOpenGLExtensions::Init() deaktiviert bis das richtig 
  funktioniert.
- Musste OpenGL Header (gl.zip) aktualisieren
- Erweiterte den Renderer um die MÃ¶glichkeit in mehrere Texturen gleichzeitig zu rendern. (GL_ATI_draw_buffers, auch NV) 
  Die aktuelle Implementation ist noch eher Experimentell - im Endeffekt 'mÃ¼sste' man das Rendern in Texturen im Renderer
  nun neu Designen da der FBO sehr universell ist - genauso wie diese Dinge in D3D9. Z.B. kÃ¶nnen sich mehrere Render Targets
  Tiefen und Stencil Buffer 'teilen'... und die neusten Karten kÃ¶nnen gar soweit ich mitbekommen habe in Vertex Buffer 
  'rendern'. Aber fÃ¼rs erste reicht diese Experimentielle Implementation.
  Alles was man machen muss ist, nach dem setzen des Render Targets noch die Texturen als Color Render Targets angeben in 
  die gleichteitig gerendert werden soll. Danach kann man in Fragment Shadern als Ergebniss nicht nur COLOR sondern COLOR0, 
  COLOR1 etc. angeben - jede entspricht dann einer dieser Texturen. Man kann dann also damit in nur einem Render Schritt 
  in einem Shader sehr viel mehr Daten ausgeben als dies mit nur einer Textur mÃ¶glich wÃ¤re. So kann man in einer Textur die 
  normalen Farben ausgeben, in der anderen die Positionen, Normalen etc. Mit diesen Daten kann man dann noch coolere Post
  Processing Effekte wie z.B. TiefenunschÃ¤rfe ohne ZU VIEL AUFWAND Realisieren. Ansonnsten mÃ¼sste man die komplette Szene
  ein paar mal neu Rendern nur in jeweils andere Texturen mit anderen Shadern um die gewÃ¼nschten Informationen in Textur 
  Form zu bekommen die man dann an den Post Process Manager Ã¼bergeben mÃ¼sste.
  Leider funktioniert die FBO Implementation von MRT noch nicht so recht - es gibt keine Fehler/Warnungen... das erwartete
  Ergebniss bleibt einfach aus. Und die PBuffer Implementation ist irgendwie ebenfalls Buggy - bin ich im Debug Modus
  und lasse das Programm bei jedem Frame 'anhalten' so geht alles gut. Lasse ich es aber so laufen friert das gesammte
  System nach ein paar Sekunden ein und der Bildschirm wird ein paar Sekunden spÃ¤ter schwarz so das ich das ich den 
  Rechner neu starten muss. Ein MRT Demo welches ich am laufen hatte und welches im Code anscheinend nichts anderst macht 
  ging jedoch merkwÃ¼rdigerweise - ohman, ich HASSE solche Probleme. Da weis man nie obs nen Treiberbug ist oder ob an 
  iirrrgendeiner Stelle etwas nicht zu 100% Passt - aber dann gleich das ganze System ohne ersichtlichen Grund lamgelegt 
  ist schon hart. :(
  Daher deaktiverte ich MRT erstmal in PLTRendererOpenGLExtensions::Init() - sicher ist sicher. :)



>> 15.07.2005
[CO]
- Ein paar Ordner wie 'lib3ds' oder 'TriStripper' haben nun vorne ein '_'. Steht am Anfang eines Namens ein '_' oder '.' so
  werden diese vom 'CreateSDK.py'-Skript ignoriert



>> 07.07.2005
[SB]
PLRendererOpenGL:
- pbuffer.cpp: Habe <glut.h> aus den Includes entfernt, da wir diese Library nicht benÃ¶tigen
  und sie daher auch nicht bei den libs mit dabei ist. Durch das Einbinden dieser Include-Datei
  jedoch wurden alle GL-Libs automatisch dazugelinkt, inklusive GLUT. Hab auÃerdem das Projekt
  fÃ¼r PLRendererOpenGL angepaÃt, daÃ die GL-Libraries nun im Projekt dazugelinkt werden.



>> 22.06.2005
[CO]
PLRendererOpenGL:
- DrawBox() und SetTexture() etwas Optimiert



>> 14.06.2005
[CO]
- PLRenderer: PN-Triangles (TRUFORM) Support hinzugefÃ¼gt. Gibts zwar nur auf ATI Karten (MUSS desweiteren im Treiber 
  aktiviert sein) und mit GPU Skinned Meshs wirds Probleme geben (da die Matrix Indices nicht Interpoliert werden 
  kÃ¶nnen :) - ist aber trotzdem nen nettes Feature und recht leicht zu verwenden... eigentlich nur aktivieren und 
  Tesselation Level setzen. (Vertex Normalen MÃSSEN vorhanden sein und passen)
  FÃ¼gte entsprechendes PN Triangles Beispiel Programm hinzu.
  Bei Zeiten muss ich mir mal was im Material mit den Render-States etc. Ã¼berlegen - denn mittlerweile haben wir gut
  50 solcher Einstellungen und die jedesmal prÃ¼fen etc. wird sicherlich auf dauer etwas Lam.



>> 11.06.2005
[CO]
PLRendererOpenGL:
- Um WGL_EXT_swap_control erweitert mit dem man unter Windows V-Sync aktivieren/deaktivieren kann



>> 11.05.2005
[CO]
OpenGL Renderer:
- Render To Texture kann nun auch Optional beim PBuffer glCopyTexSubImage2D() verwenden um die Textur zu
  fÃ¼llen falls das direkte FÃ¼llen nicht funktioniert. (ist bei mir z.B. bei Rectangle Textures der Fall)



>> 01.05.2005
[CO]
PLRendererOpenGL:
- Render To Texture Ã¼berarbeitet - es wird nun eine extra PBuffer Klasse verwendet welche einigermaÃen
  handhabbar ist und zumdem auch unter Linux laufen mÃ¼sste. Aber was immer noch ziemlich doof ist, das 
  jeder pbuffer seinen eigenen Context hat... nicht sonderlich Performant und man muss jedesmal beim setzen eines
  Render Targets alle aktuellen Render States Updaten - in PLTRendererOpenGL::SetRenderTarget() fehlte noch das zurÃ¼ck
  setzen der Texturen und Shader... einfach nur Ãrgerlich. (ich brauchte einige Zeit bis ich diesen 'Bug' gefunden hatte)
  Sobald die aktuelle FBO Extension auch von den ATI Treibern unterstÃ¼tzt wird werd ich dann, wenn diese FBO verfÃ¼gbar sind
  diese anstatt pbuffer verwenden.



>> 30.04.2005
[CO]
- PLTRendererShaderOpenGL & PLTRendererShaderD3D9 kÃ¶nnen nun auch Programm Parameter des Typs 
  CG_STRUCT & CG_ARRAY Registrieren



>> 19.04.2005
[CO]
PLRenderer:
- In Cube Maps Rendern mÃ¼sste nun korrekt funktionieren, bis jetzt fehlte bei SetRenderTarget() noch die Optionale
  Cube Map Textur in welche gerendert werden soll. (teste ich die Tage mal aus wenn ich Dynamische Cube Maps
  austeste :)
  Desweiteren implementierte ich noch Support fÃ¼r Rectangle Texturen deren GrÃ¶Ãe kein vielfaches von 2 sein muss.
  DafÃ¼r haben diese Texturen ein paar Nachteile da die GPU's dort diverse Features nicht unterstÃ¼tzen, desweiteren
  sind die Textur Koordinaten dort nicht nomalisiert was die Verwendung leider etwas umstÃ¤ndlich macht. Aber 
  zumindestens fÃ¼r Ingame Guis kann man es sehr gut gebrauchen. :)



>> 06.04.2005
[CO]
PLRenderer:
- PLTRendererSurfaceWindow: FÃ¼gte die Funktionen GetGamma() und SetGamma() hinzu



>> 03.04.2005
[CO]
PLRendererOpenGL:
- PLTRendererOpenGLExtensions spuckt nun noch etwas mehr Informationen Ã¼ber OpenGL aus - hilft beim Auffinden
  von z.B. Shader Problemen wenn man genau weis was die verwendete Hardware so kann. ;-)



>> 29.03.2005
[CO]
PLRenderer:
- PLTRendererBuffer::Allocate() kann nun auch aufgerufen werden wenn der Buffer bereits gefÃ¼llt ist. In diesem Fall wird
  er bei bedarf neu gefÃ¼llt.



>> 22.03.2005
[CO]
- PLRenderer auf neuen Kommentar-Style umgestellt



>> 16.03.2005
[CO]
PLRenderer:
- Stellte auf Cg 1.3 um. In PLRuntime liegen die aktuellen Cg dll's.
- PLeRFlagLockScissorTestStates hinzugefÃ¼gt falls erwÃ¼nscht ist das sich die Scissor Test Render States 
  NICHT Ã¤ndern dÃ¼rfen



>> 04.03.2005
[CO]
PLRenderer:
- Unterhalb der Zeichen-Funktionen ist nun ein Block mit 'Selektions'-Funktionen. Dort sind nun diverse neue
  Funktionen welche es in OpenGL StandardmÃ¤Ãig gibt und einem z.B. das Selektieren enorm erleichtern.
  BuildSelectionPlaneSet() befindet sich nun in PLTPlaneSet::CreateSelectionPlanes() - es stellte sich einfach
  heraus das diese Dinge universell Andwendung finden. Im Renderer selbst sind nur noch die 'luxus' Funktionen
  PickMatrix() und CreateSelectionPlanes() welche aktuelle Viewport, Projection- & View-Matrix Einstellungen 
  verwenden, so spart man sich Schreibarbeit wenn man mit den Standard-Einstellungen arbeiten will.



>> 01.03.2005
[CO]
- Begin2DMode() wenn alle Parameter 0 sind werden die aktuellen Viewport Einstellungen verwendet
- Get2DCoordinate() Ã¼berarbeitet



>> 25.02.2005
[CO]
PLRendererOpenGL:
- DrawTriangle() und DrawQuad() wird nun direkt Ã¼ber OpenGL Befehle gezeichnet anstatt Ã¼ber die allgemeinen
  Vertex Buffer welche unter Direct3D nÃ¶tig sind.



>> 23.02.2005
[CO]
- Musste in PLTRenderStates leider alle Variablen welche vorher auf bool standen auf uint32 umstellen da die
  Typen unterschiedliche grÃ¶Ãen haben und dadurch die Werte nicht korrekt gesetzt wurden... nun hat man im
  ClassView leider nicht automatisch ne ComboBox wo man 'false/true' auswÃ¤hlen kann. Darum sage ich nun 
  ClassView Ã¼ber die Annotations wenn eine Variable als boolean behandelt werden soll.



>> 22.02.2005
[CO]
PLRenderer:
- Verpasste PLTRenderStates, PLTSamplerStates und PLTTextureStageStates nettere Namen was nun ja dank Stefans 
  letzter RTTI Erweiterung mÃ¶glich ist. 'FillMode' liest und schreibt sich netter als 'm_nRS[PL_RS_FILLMODE]'. :)



>> 22.02.2005
[SB]
- Alle Projekte an die neuen RTTI-Makros angepaÃt



>> 20.02.2005
[CO]
PLRenderer:
- FÃ¼gte RTTI Wrapper Klassen fÃ¼r Render-States etc. hinzu. Diese Klassen werden u.a. vom Material verwendet 
  um diese EinstellmÃ¶glichkeiten komfortabler/universeller Handhaben zu kÃ¶nnen.
  (PLTRenderStates, PLTSamplerStates, PLTTextureStageStates)



>> 18.02.2005
[CO]
PLRenderer:
- Entferne PLTMaterialBase und PLTMaterialBaseFactory aus dem Renderer da nun Ã¼berflÃ¼ssig.
- GetStandardMaterial(), SetStandardMaterial(), UseStandardMaterial() entfernt da dafÃ¼r der Material Manager in der ModelLib
  verantwortlich ist.



>> 13.02.2005
[CO]
PLRenderer:
- Da das Mesh Format geÃ¤ndert wurde hab ich gleich PLE_VAS in die bessere Reihenfolge gebracht.



>> 08.02.2005
[CO]
PLRenderer:
- Neue Vertex Attribute Semantics: PL_VAS_BLENDINDICES & PL_VAS_BLENDWEIGHTS -> DarÃ¼ber wird man dann fÃ¼r das
  Hardware Skinning (oder auch Matrix Palette Skinning genannt) die Vertex Weights und Vertex Weight Indices
  Ã¼bergeben. Bei D3D sind diese gleich Definiert, bei OpenGL aber versteckt... darum fand ich erst jetzt heraus
  wie es unter OpenGL geht. Desweiteren noch diverse weitere Semantics eingetagen welche bei D3D so Standard 
  sind und auch bei Cg. Unter OpenGL muss die Extension GL_ARB_vertex_program vorhanden sein damit diese neuen 
  Semantics verwendet werden kÃ¶nnen.
- Die Reihenfolge von PLE_VAS wird, wenn ich das nÃ¤chste mal das Mesh Format Ã¤ndere ebenfalls geÃ¤ndert so wie 
  es Ã¼blich ist. Mit dieser neuen Reihenfolge kommt die GPU angeblich noch besser zurecht da intern nicht 
  so viel im Speicher herumgesprungen werden muss.
- GetVertices() & SetVertices() so erweitert das man nun mehrere Vertex Buffer gleichzeitig verwenden kann. 
  Dies ist Praktisch wenn Beispielsweise die Textur Koordinaten immer gleich bleiben, die Positionen & Normalen 
  aber durch Animation sich stÃ¤ndig Ã¤ndern so das man Position & Normale von Frame 0 und Frame 1 in einem 
  Shader interpolieren muss. Dann von Frame 1 und Frame 2 etc. Da das verwenden mehrer Vertex Buffer nicht so
  performant ist sollte man das wo immer es mÃ¶glich ist vermeiden. Darum war es mir wichtig das sich 
  GetVertices() und SetVertices() weiterhin so einfach wie mÃ¶glich verwenden lassen.
  Nun mÃ¼sste der Renderer alles kÃ¶nnen was man fÃ¼r Hardware Skinning braucht - auch kÃ¶nnte man nun Ã¼ber Vertex
  Shader die GeoMipmaps des Terrains interpolieren lassen so das es kein 'poppen' mehr gibt. :)



>> 05.02.2005
[CO]
PLRenderer:
- BuildSelectionFrustum() in BuildSelectionPlaneSet() umbenannt



>> 26.01.2005
[CO]
- PLTSurfaceListener::PLTSurfaceListener: Da die Kamera dummerweise von PLTRendererCamera angeleitet wird, was man nie machen
  sollte muss man hier per Hand diese Resource dem Renderer hinzufÃ¼gen/entfernen, dann ist der Crash beim beenden wech.
  Bei Zeiten muss ich das mit der Kamera mal komplett Ã¼berarbeiten. :)



>> 18.01.2005
[CO]
- PLTRendererFrame: Von OnMessage() auf OnKeyPressed() umgestellt



>> 11.01.2005
[CO]
- Machte ein paar kleinere Bug-Fixes



>> 09.01.2005
[CO]
- Alles noch an ein paar Ãnderungen angepasst.



>> 26.12.2004
[CO]
- Diverse kleine Bugfixes... die Listen umstellung war wirklich heftig ;-)



>> 25.12.2004
[CO]
- Kleinere Bugs durch das umstellen auf PLContainer in PLRenderer und PLModelLib behoben - nun mÃ¼ssten diese zwei Projekte
  eigentlich wieder soweit funktionieren - auf jedenfall laufen die entsprechenden Test Projekte. ;-)



>> 22.12.2004
[CO]
- PLRenderer an neue Container Klassen angepasst, bei ModelLib auch gleich alles auf das neue FS
  umgestellt damit diese Lib unabhÃ¤ngig von der Engine ist. Da ich es nicht Testen konnte ist es mÃ¶glich das hier 
  und da noch Fehler drin sind, hab mich zwar angestrengt mÃ¶glichst nichts zu Ã¼bersehen, aber das gelingt ja meistens
  nur sehr selten. :(
- Renderer Backends aus dem Renderer Ordner nach PLEngine/Source verschoben



>> 19.12.2004
[CO]
- PLRenderer & Backends: main.cpp an Plugin in Module Makro Umbenennung angepasst



>> 14.12.2004
[SB]
- Plugin-Definitionen der Renderer-Plugins sowie der Sound-Plugins teilweise wiederhergestellt sowie Includes angepaÃt,
  bei den Plugin-Definitionen war wohl einiges durcheinander gekommen
- PLRenderer: Nanu?? Wer behauptet denn, man kÃ¶nne abstrakte Basisklassen nicht korrekt am RTTI registrieren??
              Habe PLRenderer wieder entfernt und statt dessen PLTRenderer korrekt am RTTI registriert sowie
              die abgeleiteten Klassen angepasst :-)



>> 13.12.2004
[CO]
PLRenderer:
- Passte alles an RTTI Ãnderungen an. PLTRenderer wird nun von PLRenderer abgeleitet da PLTRenderer selbst
  eine Abstrakte Klasse ist und es daher nicht mÃ¶glich ist diese Klasse korrekt im RTTI zu regestrieren.
  Entweder lassen wir das so oder wir basteln PLTRenderer so um das die Klasse nicht mehr abstrakt ist - was
  ich aber nicht soo schÃ¶n fÃ¤nde. Hm, andererseits haben wir mehere vergleichbare Klasse die einerseits abstrakt
  sind, andererseits aber als Basis (& Gruppe) dienen sollen. (PLTSceneManager, TPixelLabPlugin in PixelLab etc.)



>> 03.12.2004
[CO]
PLRenderer:
- FÃ¼gte ein Null-Backend hinzu - dieses verhÃ¤lt sich wie ein normales Renderer Backend, nur verwendet es keine
  API wie D3D/OpenGL sondern versucht so viel wie mÃ¶glich selbst zu realsieren, richtig Rendern kann dieses 
  Backend jedoch nicht.
- Renderer Backend Dinge werden nicht mehr direkt in den Renderer eingebunden, somit ist die Renderer Dll selbst
  nun auch unabhÃ¤ngig von Cg - die Codes in diesem Ordner sind ja 'nur' ein Angebot das man als Basis fÃ¼r sein 
  Backend verwenden kann damit man nicht mehr ALLES komplett neu schreiben muss. PLTRendererBackendCg erweitert
  die Grund Klasse um Cg initialisierung etc. SpÃ¤ter werd ich diesen Shader Teil wohl leicht umschreiben so das
  auch problemlos andere Shader Sprachen verwenden kann. (dafÃ¼r muss ich ja nur kleine Teile neu Designen :)



>> 28.11.2004
[CO]
PLRenderer:
- PL::Config wird nun nicht mehr verwendet - stellte alles aus PLTConfig aus PLGeneral um. FÃ¼r das konkrete
  laden/speichern der Einstellungen wird dann wohl die Engine zustÃ¤ndig sein.
  -> Der Renderer ist somit nun komplett unabhÃ¤ngig von der Engine



>> 26.11.2004
[CO]
PLRenderer:
- Passte den Renderer an die von uns in PLGeneral selbst definierten Datentypen an.
  -> PLMaterialPass.h & PLTextureHandler.h in der Engine wurden aktualisiert.



>> 19.11.2004
[CO]
PLRenderer:
- FÃ¼ge BackupDeviceObjects() & RestoreDeviceObjects() Funktionen im Direct3D Backend hinzu, noch nicht komplett implementiert.
- D3D: PLTRendererVertexBufferD3D9 & PLTRendererIndexBufferD3D9 um PL_USAGE_SOFTWARE erweitert - dies Dient nur als Software Speicher
  mit dem NICHT gerendert werden kann sondern nur als Zwischenspeicher oder so dienen kann. Das OpenGL Backend kann zwar damit auch
  Rendern - wird aber nur verwendet wenn die Hardware keine VBOs kann, D3D macht das intern selbst.
- Ãberall PL::Log. in PLTLog::GetInstance()-> geÃ¤ndert



>> 15.11.2004
[CO]
PLRenderer:
- Neue Funktionen: BackupDeviceObjects() & RestoreDeviceObjects() -> Werden z.B. beim wechseln des Fenstermodus verwendet
  um aktuelle Device Objekt Daten zu sichern und wiederherzustellen. Dabei muss jeder Resourcen Typ selbst seine Daten in 
  einen Buffer sichern, bei vielen Daten kÃ¶nnte das zwar dann probleme mit den Datenmengen machen, mir viel jedoch keine
  andere mÃ¶glichkeit ein da man die Daten in Texturen, (beispielsweise dynamisch erzeugte) Vertex Buffern etc. nicht
  einfach wieder nachladen kann. So wie es aussieht klappt das mit dem Bildschirm Modus wechseln + Resourcen aktualsieren
  im OpenGL Backend. Zumindestes bei mir scheint das mit dem Wechsel nun ziemlich gut zu funktionieren, nur in Jens Grabkammer
  Welt scheint noch irgendetwas zu sein was bei Wechsel einen Crash verursacht - der Sache werd ich morgen auf den Grund gehen.



>> 14.11.04
[CO]
PLRenderer:
- Das setzen der Sampler States im OpenGL Backend funktioniert nun besser (z.B. Mipmapping)
- Das wecheln in den Vollbild Modus ist implementiert. PLTRendererSurfaceWindow und dessen Backend implementationen
  machen die Hauptarbeit - dabei bekommt es beim Erzeugen seinen Bildschirm Modus (vollbild oder nicht) und kann diesen
  nicht mehr Ã¤ndern. Dies ist aber kein Problem da es sich bei dieser Renderer OberflÃ¤che ja nicht um das eigentliche
  Fenster sondern 'nur' um einen Ausgabebereich handelt. Im normallfall arbeitet man nur mit PLTRendererWindow und
  PLTRendererFrame wobei das letztere das mit dem Vollbild/nicht Vollbild automatisch implementiert - also NUR Frames
  lassen sich zwischen Vollbild oder Fenster Modus umschalten, kann man spÃ¤ter natÃ¼rlich Ã¤ndern aber ich denke das wÃ¤re
  nicht so sinnig.
  Das eventuelle Aktualisieren von z.B. Texturen ist noch nicht implementiert - wie es scheint muss man selbst den Device
  Context dann neu anlegen, daher klappt das umschalten des Modus noch nicht wirklich.



>> 11.11.04
[CO]
- An das RTTI angepasst



>> 07.11.04
[CO]
PLRendererD3D9:
- Das Direct3D Backend lÃ¤uft nun zu ca. 80% korrekt - Auch die Shader funktionieren bereits. :)



>> 05.11.04
[CO]
PLRendererD3D9:
- Das Direct3D Backend lÃ¤uft nun zu ca. 70% korrekt



>> 20.10.04
[CO]
PLRenderer:
- Neue Texture Formate: PL_TPF_D16, PL_TPF_D24 und PL_TPF_D32 -> NÃ¶tig wenn man nur Tiefenwerte in eine Textur
  rendern will (fÃ¼r z.B. ShadowMapping braucht man eine solche 'Depth Map' :)
  Die Textur selbst lÃ¤sst sich dann wie PL_TPF_L8/PL_TPF_L16 beim Rendern verwenden - also als Textur mit nur einem
  Farbkanal.



>> 05.10.04
[CO]
PLRenderer:
- PLTRendererVertexBufferOpenGL::GetData() -> Scheint nun zu korrekt funktionieren - bei Jens verursachte meine kleine Offset Optimierung
  zuvor lustige Textur Fehler. :)



>> 04.10.04
[CO]
PLRenderer:
- Neue Funktion: DrawPlane() -> Zum Visualisieren einer Ebene was zu Testzwecken recht nÃ¼tzlich sein kann. :)



>> 03.10.04
[CO]
PLRenderer:
- PLTRendererIndexBuffer: Neue Funktionen: GetData() & SetData() zum auslesen und setzen von Indices ohne das man sich um den internen Index Typ
  kÃ¼mmern muss -> Diese Funktionen sollte man nach mÃ¶glichkeit IMMER verwenden!
  Passte gleich alle Codes daran an, nun kann man problemlos auch USHORT verwenden wenn das ausreichend ist - gibt mehr Performance!
- Neue Funktion: PLTRenderer: MakeScreenshot() -> Macht einen Screenshot vom aktuellen Render Target



>> 22.09.04
[CO]
- Behob fehler in PLTSurfaceListener::DrawProfiling()



>> 18.09.04
[CO]
PLRenderer:
- Um zu prÃ¼fen ob Dynamische VBOs extrem langsam sind und ob es nicht schneller ginge wenn man das wie frÃ¼her hochlÃ¤d
  baute ich in PLTRendererIndexBufferOpenGL und PLTRendererVertexBufferOpenGL eigene Buffer ein welche die VBOs Ã¼bernehmen.
  Aber selbst Dynamische VBOs sind dann noch schneller als die 'alte Methode' wenn diese stÃ¤ndig aktualisiert werden.
  Naja, das Experiment hatte den Nebeneffekt das diese Buffer nun auch funktionieren wenn die Karte keine VBOs kann - 
  was aber glaub ich jede Karte mittlerweile unterstÃ¼tzt. ;-)
- Optimierte PLTRendererVertexBufferOpenGL::GetData() etwas durch das vorspeichern der Offsets - das brachte mir
  bei meinem momenten extrem Vertex reichen Wasser Test das doppelte an FPS. (12 statt 6 ;-)
  (hm, beim importieren von 3ds modellen scheint es probleme zu machen... darum erstmal die optimierung rauskommentiert
  bis ich rausgefunden hab wieso das nur dort so ist :)



>> 17.09.04
[CO]
PLRenderer:
- 1D Texturen funktionieren nun richtig



>> 11.09.04
[CO]
PLRendererOpenGL:
- OpenGL Header aktualisiert (siehe gl.zip)
- Neues Feature: UnterstÃ¼tzung von Depth Bounds Test (GL_EXT_depth_bounds_test) welches quasi eine Erweiterung
  der Scissor Tests in 'der Tiefe' ist. Kann mit der Renderer Funktion GetDepthBounds() & SetDepthBounds() abgefragt
  und gesetzt werden. Konnte diese Extension ebenfalls nicht testen aber wenn diese vorhanden ist spart diese beim
  aufwendigen PerPixelLighting & Shadow Volumes nochmal etwas FÃ¼llrate welche bei dieser Technik ja der Flaschenhals
  ist.



>> 10.09.04
[CO]
PLRenderer:
- Two sided stencil tests implementiert - werden bereits wenn verfÃ¼gbar von den Shadow Volumes verwendet. (GL_EXT_stencil_two_side)
  Es sind dafÃ¼r 5 neue Render States hinzugekommen. Konnte dieses Feature zwar nicht selbst testen da es keine meiner
  mittlerweile etwas veralteren Grafikkarten kann - aber auf allen neuen Karten mÃ¼sste es funktionieren. :)
  Stefan, du hast ja ne GeForce5 - wÃ¤re super wenn du mal PLTShadowVolume::DrawZPass() und PLTShadowVolume::DrawZFail()
  testen kÃ¶nntest, im Prinzip siehst du sofort obs geht oder nicht da es normalerweise wenn verfÃ¼gbar Automatisch
  verwendet wird. :)
- Neue Funktion: GetViewportCorners() -> Gibt einen die aktuellen Viewport Ecken zurÃ¼ck - quasi das 'Fenster' durch
  welches man in die Welt schaut. Wird fÃ¼r diverse Dinge immer mal wieder gebraucht, u.a. bei den Shadow Volumes um zu
  prÃ¼fen ob sich die Kamera im Schatten befindet oder nicht.



>> 09.09.04
[CO]
- Neben CalculateBoundingBox() zum berechnen der Bounding Box eines VertexBuffers/Meshs gibt es nun noch
  CalculateBoundingSphere() welche die Bounding Sphere berechnet.
  In PLTObject und dem ODE Ã¤quivalent wird nun der Entity Kollisions Radius mit hilfe dieser neuen Funktion berechnet anstatt den
  Radius der Bounding Box zu nehmen welcher meist grÃ¶Ãer ist.



>> 06.09.04
[CO]
- Neue Funktionen: GetFlags(), SetFlags(), GetCustomFlags(), SetCustomFlags() -> Flags welche z.B. in der Engine
  gesetzt werden wenn gerade etwas spezielles gerendert wird. (ambient(lighting pass, projective texturing etc.)
  Damit kann man unterbinden das Texturen, Shader, spezielle Render States etc. gesetzt werden.
  Mir viel bis jetzt keine bessere LÃ¶sung ein wo man das machen kÃ¶nnte, darum implementierte ich das nun universell
  in den Renderer, und wenn man noch etwas braucht erweitert man es dort halt entsprechend. Zuerst wollte ich mit 
  Hilfe der Custom Render Flage in der Engine vermerken in welchem Render Modus man gerade ist, jedoch stellte sich 
  recht schnell heraus das dies im Chaos und Gehacke geendet hÃ¤tte.
  Im Scene Manager PLTSMPerPixelLighting werden diese Flags bereits recht umfangreich benÃ¶tigt.



>> 28.08.04
[CO]
PLRenderer:
- PLRendererTypes.h -> PLColor3.h und PLColor4.h eingebunden da die Farben nun eigenstÃ¤ndige Klassen sind



>> 12.08.04
[CO]
PLRenderer:
- Neue Funktion:BuildSelectionFrustum() -> Erzeugt einen Frustum dem man zum Selektieren mit hilfe eines Rechtecks
  auf dem Bildschirm verwenden kann.



>> 11.08.04
[CO]
PLRenderer:
- PLTRendererSurfaceListenerHandler eingebaut der in PLTEntityCamera benÃ¶tigt wird... bei Zeiten kÃ¶nnte man all diese Handler
  in einer Basis-Klasse vereinen...



>> 10.08.04
[CO]
- Musste die Fix-Pass Renderer Light Ã¼berarbeiten da man Positionen etc. nicht wirklich gut Ã¼ber DWORD managen kann.
- Neuer Render-State: PL_RS_FIXEDFILLMODE -> Ist dieser Status gesetzt bestimmt er allein den verwendeten FÃ¼ll-Modus,
  damit kann man z.B. immer einen Wireframe Modus erzwingen egal was ein Material fÃ¼r einen FÃ¼llmodus setzt.



>> 07.08.04
[CO]
PLRenderer:
- PLTRendererSurface -> Kann nun aktiviert/deaktiviert werden
- PLTRendererWindow & PLTRendererFrame aktivieren/deaktivieren automatisch ihr Surface
- Stellt auf neues Log in PLGeneral um



>> 03.08.04
[CO]
- PLTRendererOpenGL::Get3DCoordinate() funktioniert nun richtig



>> 02.08.04
[CO]
PLRenderer:
- 3D texturen funktionieren nun korrekt
- UnterstÃ¼tzt nun Point Sprites mit denen z.B. Partikel gezeichnet werden kÃ¶nnen
- SetRenderState() etc. geben nun die alten Werte zurÃ¼ck und -1 bei einem Fehler, so geht das Speichern
  der alten Einstellungen leichter



>> 01.08.04
[CO]
PLRenderer:
- Vertex und Index Buffer kann man nun nur noch Ã¼ber SetVertices()/SetIndices() und nicht mehr direkt Ã¼ber
  MakeCurrent() setzen



>> 27.07.04
[CO]
PLRenderer:
- VertexBuffer: Vertex Element in Vertex Attribute umbenannt um Namensverwechslungen mit der Anzahl an Elementen
  in einem Buffer zu vermeiden. Das zog zwar einige Anpassungen nach sich - nun ist es aber wesentlich einsichtiger
  was gemeint ist.
- Render To Texture System Ã¼berarbeitet so das es nun wesentlich einfacher ist in Texturn zu Rendern. Einfach
  mit z.B. CreateSurfaceTexture2D() eine entsprechende Textur erzeugen. Mit SetRenderTarget() setzen und spÃ¤ter
  kann man die konkrete Textur welche man Ã¼ber PLTRendererSurfaceTexture::GetTexture() wie alle anderen Texturen auch
  verwenden.
- Texture pixel formats (PLE_TPF) erweitert, u.a. gibt es nun auch floating point pixel buffer in welche man z.B.
  Rendern kann. Diese floating point buffer gewinnen immer mehr an Bedeutung da sich damit viele fortschrittliche
  Techniken wie Realtime HDRI realisieren lassen...
PLRendererOpenGL:
- wglext.h in gl.zip aktualisiert -> Muss wie Ã¼blich bei den VC Includes aktualisiert werden



>> 24.07.04
[CO]
PLRenderer:
- Neuen Render State: PL_RS_INVCULLMODE -> Damit kann man den API Cull Mode invertieren, praktisch wenn man
  Reflektionen rendert bei denen durch die Reflection Matrix die Vertex Anordnung vertauscht wird!



>> 20.07.04
[CO]
- Vertex Buffer kÃ¶nnen nun optional bei MakeCurrent oder SetVertices einen Offset haben



>> 08.07.04
[CO]
PLRenderer:
- DrawBitmap, DrawPoint und DrawLine werden nun im OpenGL Backend direkt mit OpenGL Befehlen dargestellt was
  die Performance mehr 4 mal verbesserte da man fÃ¼r einzelne Punkte etc. nicht mehr extra umstÃ¤ndlich einen
  Buffer einstellen muss. (lohne nur wirklich fÃ¼r viele Primitives!)
  Im Direct3D Backend kann man es aber anscheinend nicht anderst machen.
  Somit lassen sich nun auch Ingame GUIs flÃ¼ssig darstellen. (sie PLSampleLarge)
- Neue Funktion: GetOcclusionQuery() -> Damit kann man eine standard Occlusion Query Instance bekommen falls
  es sich nicht lohnt eigene Objekte zu erzeugen - wird erst wirklich nÃ¶tig wenn man mehre Tests gleichzeitig
  machen will.


>> 07.07.04
[CO]
PLRenderer:
- Implementierte eine Occlusion Query Klasse welche z.B. benÃ¶tigt wird um zu prÃ¼fen ob ein Portal derzeit
  komplett verdeckt ist und somit nicht sichtbar ist oder nicht. (komplett Dynamischer zusÃ¤tzlicher Test :)
  Ãber Occulision Tests wird in Zukunft auch geprÃ¼ft ob ein Licht gerade verdeckt ist oder nicht - somit
  braucht man die Funktion ReadDepthComponent() nicht mehr welche unter Direct3D derzeit noch nicht geht...
  (bei Zeiten kÃ¶nnte man diese Funktion vielleicht ganz aus dem Renderer nehmen :)



>> 22.06.04
[CO]
PLRenderer:
- Neue Funktionen zum abfragen der Anzahl der OberflÃ¤chen und Resourcen. Mit PLTRenderer::GetConfigs() erhÃ¤lt
  man die Renderer Einstellungen welche frÃ¼her noch direkt von der Engine abgefragt wurden... ist zwar noch nicht
  die schÃ¶nste LÃ¶sung erfÃ¼llt aber fÃ¼rs erste ihren Zweck bis man sich da was schickes ausgedacht hat. :)
  Desweiteren ist der Renderer nun unabhÃ¤ngig von der Engine - mÃ¼sste die Log zugriffe dafÃ¼r rauskommentieren -
  sollte man wieder reinnehmen sobald das Log in PLGeneral ist.
  Musste bei PLTRendererCamera das Entity binding herausgeben. In der Engine ist nun eine Ableitung davon namens
  PLTCamera welche noch Entity Binding implementiert. Wird die Engine verwendet wird immer nur diese Camera
  verwendet und nicht PLTRendererCamera direkt!
- PLTMaterialBase -> Abstraktes Material Interface fÃ¼r z.B. die Model Lib damit diese von der Engine nichts
  zu wissen braucht. DafÃ¼r gibt es PLTMaterialBaseFactory welche Materialien erzeugen kann.



>> 10.06.04
[CO]
PLRenderer:
- PLTRendererVertexBuffer: Neue Funktion: GetMinMaxPos() -> ermittelt die Bounding Box des Vertex Buffers
  (das wird man sicherlich immer mal wieder brauchen :)



>> 27.05.04
[CO]
- PLTRendererBuffer: Neue Funktion: IsLocked()
- PLTRendererVertexBuffer::AddVertexElement()  funktioniert nun korrekt beim hinzufÃ¼gen von Vertex Elementen
  nach dem anlegen des Buffers



>> 26.05.04
[CO]
- Diverse kleinere Fehler im Renderer etc. behoben so das nun die Shader wieder soweit funktionieren. In PLTests gibts
  nun nen neues Entity welches zum Mesh testen da ist und mit dem sich auch z.B. BumpMapping testen lÃ¤sst.



>> 25.05.04
[CO]
PLRenderer:
- PLTRendererVertexBuffer::AddVertexElement() kann nun auch nachdem ein Buffer bereits angelegt wurde dem Buffer
  neue Vertex Elemente wie z.B. Normalen Daten hinzufÃ¼gen. In diesem Fall muss intern der Buffer umkopiert werden.
  Auf RemoveElement() funktionen werde ich erstmal versichten da mir dies momentan unnÃ¶tig viel Arbeit erscheint
  fÃ¼r etwas was im normalfall niemals gemacht wird.



>> 21.05.04
[CO]
- Vertex und Index Buffer haben nun Copy-Operatoren



>> 20.05.04
[CO]
PLRenderer:
- Bemerkte das ich im Renderer teils bei SRC einen dreher drin hatte und SCR geschrieben hatte -> Behoben



>> 15.05.04
[CO]
PLRenderer:
- SetTextureStageState() -> Diverse Detailverbesserungen



>> 14.05.04
[CO]
- Das Renderer Test Projekt wurde nun gelÃ¶scht da dieses Dinge nun in PLSampleLarge sind.
  (Backup in Backups/TestProjects/PLRendererTest.zip)



>> 13.05.04
[CO]
PLRenderer:
- Neue Funktionen: DrawTriangle(), DrawQuad(), DrawBox(), DrawSphere() -> Diese Funktionen zeichnen ein 
  Dreieck, Rechteck, eine Box und eine Sphere was fÃ¼r Debugging zwecke hilfreich ist da man dann nicht 
  erst umstÃ¤ndlich jedesmal Vertex, Index Buffer etc. erzeugen und einstellen musss
  -> In PLTests ein paar Testfunktionen fÃ¼r diese neuen Renderer Dinge.
- Neue Funktion: ReadDepthComponent() -> Kann aus dem Tiefen Buffer lesen -> vorerst ist die Funktion noch
  nicht komplett durchdacht da ich in z.B. Direct3D keine glReadPixels Ã¤hnliche Funktion finden konnte -
  aber nun kann man z.B. endlich wieder einfach prÃ¼fen ob ein Licht verdeckt wird oder nicht :)
- Neue States: TextureStageState -> Damit lÃ¤sst sich fÃ¼r jede Textureinheit Mischfunktionen und Texture
  Koordinaten erzeugung (z.B. EnvironmentMapping) einstellen.



>> 12.05.04
[CO]
PLRenderer:
- Neue Funktion: Reset() -> Setzt alle Renderer Einstellungen zurÃ¼ck auf Default
- SetTexture() -> Wird als Texture Stage -1 Ã¼bergeben so betrift die Einsellung ALLE Texture Stages.
  Bei SetClipPlaneEnabled() und SetClipPlane() ist es nun genauso.
- Neue Funktionen: GetDefaultRenderStates(), GetDefaultSamplerStates(), GetDefaultLightStates() -> Diese
  Funktionen sind praktisch damit man z.B. in PLTMaterial
  nicht erneut die Standard Einstellungen Definiern muss. :)
- Verbesserte diverse intere Design Dinge im Renderer (u.a. States setzen etc)
- Neue Funktionen: GetPointSize(), SetPointSize(), GetLineWidth(), SetLineWidth() -> zum setzen/abfragen der
  Punkt grÃ¶Ãe und Linien Breite, dieses Funktionen gibt es anscheinend in Direct3D nicht... jedoch sind diese
  fÃ¼r Debug zwecke sehr hilfreich daher entschloss ich mich diese Funktionen im Renderer zu implementieren



>> 11.05.04
[CO]
PLRenderer:
- Neue Funktion: GetCamera() gibt die zuletzt gesetzte Renderer Kamera zurÃ¼ck, manchmal ist es praktisch zu
  wissen mit welchen Daten die aktuelle View Matrix etc. erzeugt wurde - desweiteren muss man hin und wieder zur
  z.B. bestimmung einer Entfernung die Position der Kamera wissen
  PLTRendererCamera ist nun ebenfalls eine Renderer Resource - anderst wÃ¤re es zu umstÃ¤ndlich und meist wird
  sowieso ein Renderer unabhÃ¤ngiges Kamera Entitie verwendet. :)



>> 05.05.04
[CO]
PLRenderer:
- Neue Funktionen: GetColor() & Set Color() -> damit stellt man die aktuelle Farbe von z.B. Text, Linien, Bitmaps
  etc. ein.



>> 04.05.04
[CO]
PLRenderer:
- Neue Funktionen: DrawPoint() und DrawLine()



>> 21.03.04
[SB]
PLRenderer:
- Neue Klassen PLTVertexBuffer und PLTIndexBuffer hinzugefÃ¼gt,
  welche in den neuen Modell-Klassen und im Renderer Verwendung finden werden



>> 15.03.04
[CO]
PLRenderer:
- Neue Funktionen: GetMax3DTextureSize() & GetMaxCubeMapTextureSize() liefert die Maximale Textur grÃ¶Ãe dieser
  Texture Typen zurÃ¼ck - diese werden auch ins Log geschrieben.
- PLTTexture: Neue Funktionen: GetMaxTextureSize() -> liefert die maximale Texture grÃ¶Ãe fÃ¼r den aktuelle Textur Typ



>> 25.02.04
[CO]
PLRenderer:
- PLTTexture::Load -> Wandelt nun intern BGR Texturen in RGB um
PLRendererOpenGL:
- Nun sind alle GL_ARB_multitexture Extension Funktionen verwendbar



>> 20.01.04
[CO]
- PLTRendererHandler lÃ¶scht nicht mehr selbst StandardmÃ¤Ãig den Bildschirm Puffer. Dies sollte im normalfall ein Clear-Entity
  Ã¼bernehmen oder im Fall der Editoren wird der Renderer Handler angewiesen den Bildschirm Puffer selbst zu lÃ¶schen



>> 03.01.04
[CO]
PLRendererOpenGL:
- Neue Extensions werden verwendet: GL_EXT_texture_rectangle & GL_NV_texture_rectangle -> diese machen beide das gleiche
  und werden auch auf die gleiche art verwendet. Damit kann man auch Texturen welche kein vielfaches von 2 (z.B. 465x234)
  verwenden. Ãber das plt-Format kann man in General -> Rectangle=1 eine Textur als Rectangle markieren.
  Diese spezielle Textur Art kann man z.B. hervorragend fÃ¼r MenÃ¼s etc. verwenden da man dann die Orginal Texturen verwenden
  kann was die BildquailtÃ¤t deutlich verbessert. Jedoch hat diese Textur art einige EinschrÃ¤nkungen. Siehe
  http://oss.sgi.com/projects/ogl-sample/registry/NV/texture_rectangle.txt fÃ¼r mehr Informationen.
  -> API Dokumentation im Material Kapitel um einen Textur Teil erweitert.



>> 25.12.03
[CO]
PLRendererOpenGL:
- Neue Extension wird verwendet: GL_EXT_draw_range_elements
- PLTGeometry: Von glDrawElements() auf glDrawRangeElementsEXT() umgestellt da Effektiver.
  Wenn Ã¼ber GetPointer() Geometry Indices verÃ¤ndert wurden MUSS man nun die Funktion UpdateMinMaxIndex()
  aufrufen welche die neuen min/max Indices ermittelt. Entsprechende Stellen in allen Projekt-Codes aktualisiert.
  (war nur bei PLTEntities und ME und in der Engine selbst nÃ¶tig :)
- Nahm Extension NV_vertex_array_range heraus da mittlerweile durch ARB_vertex_buffer_object ersetzt



>> 23.12.03
[CO]
PLRendererOpenGL:
- Warf GL_HP_occlusion_test Ã¼ber Bord und stellte PLTRenderer::OcclusionTest() auf die neue GL_ARB_occlusion_query Extension
  um. Mit dieser neuen Extension welche es erst seit kurzem gibt kann man nun auch herausbekommen wieviele der gezeichneten
  Pixel sichtbar sind
- glext.h um GL_ARB_occlusion_query erweitert, aktuelle Datei wie Ã¼blich im Libs-Ordner (gl.zip)



>> 20.12.03
[CO]
PLRenderer:
- PLTRenderFrame -> GuiFrame Base Funktionen werden nun aufgerufen
- PLTRenderWindow -> GuiWindow Base Funktionen werden nun aufgerufen
- PLTRenderFrame: Neue Funktionen: SetToggleFullscreenMode() & GetToggleFullscreenMode() -> Damit kann man Einstellen ob es
  erlaubt ist den Vollbild-Modus des Fenster Ã¼ber Alt-Return zu wechseln
- PLTRenderFrame: Sobald das Fenster den Fokus verliert wird nun auch dessen Input Handler deaktiviert



>> 13.12.03
[CO]
PLRenderer:
- PLTRenderFrame setzt nun auch Variable PL::Config.m_bFullscreen damit der Fullscreen-Status gespeichert werden kann. Das
  macht zwar nur Sinn wenn man ein Render Frame hat aber wenn man mehere Frames verwendet so laufen diese Ã¼berlicherweise
  immer im Fenster Modus. In 'normalen' Projekten hat man nur einen Render Frame und dann ist es sehr komfortabel wenn der
  Vollbild Modus gespeichert wird.



>> 04.12.03
[CO]
PLRendererOpenGL:
- Renderer: Neue Extension wird verwendet: GL_ARB_texture_mirrored_repeat -> Damit ist ein neuer Texture Wrap Modus mÃ¶glich:
  PL_MIRRORED_REPEAT welcher mit PL_REPEAT vergleichbar ist, die Textur aber zusÃ¤tzlich noch spiegelt
  -> Modell Editor angepasst -> PL User Guide angepasst



>> 29.11.03
[CO]
- In fast allen Projekten gab es durch empfindlichere Compiler Einstellungen diverse Warnungen welche nun behoben sind



/*********************************************************\
 *  EintrÃ¤ge aus altem Diary, damals noch ohne genaue Datum angaben. (oben -> unten = neuer -> Ã¤lter)
\*********************************************************/



[CO] PL::Renderer: Neue Funktion: GetMaxTextureSize() -> gibt die grÃ¶Ãt mÃ¶gliche Texture grÃ¶Ãe zurÃ¼ck
[SB] PLTRenderer: FÃ¼r die 2D Funktionen kann nun angegeben werden, auf welcher Z-Position sie zeichnen sollen. Dieser
     Wert wird durch Set2DZPosition gesetzt und steht normaler Weise auf 0
[SB] PLTFont wurde erweitert, um an eine bestimmte Z-Position zu zeichnen. Dieser Parameter hat einen Default-Wert von
     0 und kann daher ignoriert werden, wenn er nicht explizit verwendet werden soll
[CO] In PLTTexture::LoadData() wird nun Ã¼berprÃ¼ft ob die Texture grÃ¶Ãe ok ist... notfalls wird diese passend gemacht ->
     ansonnsten kann die Textur u.a. nicht von der Grafik-Karte verwendet werden und die Textur bleibt weis (oder andere
     fehler kÃ¶nnten auftreten...)
[CO] Erste Version von PLTRendererStates implementiert (ist bereits ein leichter Performance zuwachs zu bemerken :)
[CO] PLTRenderer: Neue Funktion: OcclusionTest() -> PrÃ¼ft ob eine Bounding Box von etwas anderem komplett verdeckt wird
     oder nicht -> mehr Performance da der Overdraw reduziert wird! :)
[CO] Neue Extension wird verwendet: GL_HP_occlusion_test -> Damit lÃ¤sst sich Hardware mÃ¤Ãig schnell prÃ¼fen ob etwas das
     gerendert werden soll von etwas anderem komplett verdeckt wird oder nicht
[CO] Zum Texturen Laden wird nun DevIL (openil.sourceforge.net) verwendet, dadurch kann man nun sehr viel mehr Textur
     Formate einlesen und speichern -> Datei PLTextureLoad.cpp gelÃ¶scht
[CO] Neue Extension wird verwendet: GL_EXT_texture_edge_clamp -> Ãhnlich wie GL_ARB_texture_border_clamp -> Material
     entsprechend um PL_CLAMP_TO_EDGE erweitert
[CO] PLTTextureHandler um neue Funktion erweitert: GetTexEnvCombineParameters() -> Damit bekommt man zugriff auf diverse
     Combine Parameter mit denen man grÃ¶Ãere Kontrolle darÃ¼ber hat wie die verschiedenen Textur Schichten kombiniert
     werden
[CO] Neue Extension wird verwendet: GL_ARB_texture_border_clamp -> GL_CLAMP_TO_BORDER_ARB ist eine weitere Texture
     Wrapping Funktion neben CLAMP und REPEAT -> Wird im Material mit CLAMP_TO_BORDER gesetzt
[CO] Neue Extension wird verwendet: GL_EXT_texture_lod_bias -> Damit kann man den Textur Filter einstellen und eine Textur
     z.B. verwaschener darstellen -> LÃ¤sst sich im Textur Handler mit der Funktion SetTexLodBias() einstellen -> KÃ¶nnte
     man sogar Animieren und hÃ¤tte damit einen weiteren mÃ¶glichen Textur Effekt! :)  -> PLSamples neues Beispiel Entity:
     EntityTexLodBiasAni -> Test:   EntityTexLodBiasAni m_szModelFilename="farn"  -> sieht nÃ¼sch Ã¼bel aus ;-)
[CO] PLTRenderChild gelÃ¶scht da unnÃ¶tig
[CO] PLTRendererHandler: ShowInfos() -> Informationen kÃ¶nnen StandardmÃ¤Ãig eingeblendet werden. Nur in ausnahmefÃ¤llen
     sind diese nicht ErwÃ¼nscht... wie z.B. bei der Textur Ansicht im Debug Dialog
[CO] PLTRendererHandler -> Ãber Debug-Flags kann man nun einstellen ob die Koordianten Axen, Ebenen usw. eingeblendet
     werden sollen -> lÃ¤sst sich Global Ã¼ber PL::Config und nun auch individuell Einstellen
[SB] Einige kleinere Anpassungen in PlRenderer vorgenommen
[CO] PLTRendererHandler -> LÃ¤sst sich nun Aktivieren oder Deaktivieren, PLTRenderWindow deaktiviert seinen Renderer
     Handler automatisch sobald es unsichbar wird
[CO] PLTRenderWindow: Neue Funktion: GetInputHandler()
[CO] PLTRenderFrame::OnMessage() reagiert auf ALT-RETURN um den Bildschirm Modus umzuschalten (Fenster/Vollbild)
[SB] Fullscreen mode umgeschrieben: Das Schalten in den Vollbildmodus und zurÃ¼ck ist nun Aufgabe von PLTRenderFrame,
     dabei reagiert das Fenster darauf, wann es aktiviert oder deaktiviert wird. Dies ermÃ¶glicht auch mehreren
     Render-Fenstern gleichzeitig, noch korrekt zu funktionieren. Im Moment gibt es jedoch ein Problem mit der
     Farbtiefe, wodurch nach dem Umschalten des Modus evtl. fehlerhafte Grafik dargestellt wird
[SB] Der RendererHandler wurde Ã¼berarbeitet (z.B. Schalten in den Fullscreen-Mode)
[SB] Das unsichtbare Fenster, welches den Device-Kontext erstellt, ist nun vom Typ PLTRenderWindow und wurde auÃerdem
     in m_pRenderWindow umbenannt (um Verwechslungen mit dem Application-Main-Window zu vermeiden)
[SB] Neue Klassen fÃ¼r Render-Fenster eingebaut: PLTRenderWindow als Basis, davon abgeleitet PLTRenderFrame fÃ¼r
     eigenstÃ¤ndige Fenster und PLTRenderChild fÃ¼r eingebettete Render-Fenster
[CO] Verwendung neuer Extension eingebaut: ARB_vertex_buffer_object -> Gibt es erst seit kurzem und daher muss man die
     neusten Treiber haben. Diese Extension wird engeblich von fast allen Karten unterstÃ¼tzt. Kann mit
     NV_vertex_array_range verglichen werden der die Vertex Daten direkt in der Hardware speichert was einen enormen
     Performance gewinn fÃ¼r Statische Dinge bringe. Jedoch muss man sich bei der neuen Extension nicht mehr um einen
     eigenen Vertex Manager bemÃ¼hen da es im gegensatz zu der alten Extension problemlos mÃ¶glich ist viele kleine Vertex
     Arrays zu haben! (das worauf ich schon seit lÃ¤ngerem wartete!! :)
[CO] PLTRendererHandler -> Projective Texturing -> Nur Entities im Licht FOV werden neu gerendert
[CO] PLTRenderer: SetBlendMode() herausgenommen da normalerweise Ã¼ber Material eingestellt, zudem ist die derzeitige
     implementation unzureichend... spÃ¤ter beim Ãberarbeiten des Renderes kann man diese Funktion ja neu implementieren
     (derzeit aber nicht benÃ¶tigt... und vorallem nicht in der Form :)
[CO] PLTExtensions: wglMakeContextCurrentARB & wglGetCurrentReadDCARB wieder herausgenommen da anscheinend nicht mehr
     unterstÃ¼tzt (problem des teilen von Daten zwischen verschiedenen Rendering context lÃ¤sst sich auch mit
     wglShareLists() lÃ¶sen)
[CO] Neue Extensions wird unterstÃ¼tzt: GL_EXT_separate_specular_color -> fÃ¼r besseres Specular highlighting
[CO] Das Rendern in Texturen Ã¼ber den PBuffer klappt nun! -> Im Modell Editor ist eine kleine Demo implementation welche
     zeigt wie man das Rendern in Texturen macht... lÃ¤sst sich genauso verwenden wie das normale Rendern in Fenster :)
[CO] Der RendererHandler kann nun auch in eine Textur Rendern. (Ã¼ber den Hardware PBuffer) Dazu muss man beim
     Initialisieren eines Renderer Handlers statt eines Window Handlers einfach NULL angeben, dann noch die Textur
     einstellen in welche gerendert werden soll et voila ;-)
[CO] Neue Extensions werden verwendet: GL_SGIS_generate_mipmap & WGL_ARB_pbuffer & WGL_ARB_pixel_format &
     WGL_ARB_render_texture, desweiteren PLTRendererExtensions Ã¼bersichtlicher gestaltet
[CO] PLTRenderer: InitOpenGL() & DeInitOpenGL() & ConfigOpenGL() in PLTRendererHandler verschoben
[SB] Get2DCoordinate() berechnet nun selbst die Projektion (ohne GLU), auÃerdem wird durch vorher gespeicherte Matrizen
     ein Auslesen aus OpenGL vermieden, was sowohl Geschwindigkeitsvorteile bringt als auch die FehleranfÃ¤lligkeit
     verringert (Die OpenGl-Matrizen kÃ¶nnen nicht immer gelesen werden und werden auÃerdem durch evtl. Rendering-VorgÃ¤nge
     beeinfluÃt)
[SB] PLTRenderer: Neue Funktion zum Anzeigen einer orientierten Bounding Box (OBB) eingebaut. Die anderen Methoden
     zeigen eine axis-aligned Bounding Box an, welche durch zwei Punkte bestimmt ist. Eine OBB ist jedoch durch zwei
     Punkte nicht eindeutig bestimmt, daher dient diese Methode zum Anzeigen einer OBB.
[CO] PLTRenderer: Der Renderer hat hat nun sein ein eigenes Haupt-Fenster welches quasi als 'Anker' dient. NÃ¶tig falls
     gerade z.B. eine OpenGL Textur angelegt werden soll und kein Fenster vorhanden ist! Jedoch ist dieses
     Renderer-Fenster 'unsichtbar', stÃ¶rt also nicht! :)
[CO] Wird ein Fenster geschlossen so werden nun alle Renderer Handler welche dieses verwendeten de-initialisiert... und beim
     Fenster-Modus umstellen mit dem neuen Fenster Handle wieder neu initialisiert :)  -> War auch ursache fÃ¼r einen
     lÃ¤stigen Crash!! :)
[CO] PLTRendererHandler -> Jeder Renderer Handler hat nun eine PrioritÃ¤t mit welcher man einfluss darauf nehmen kann vor
     welchen anderen Renderer Handlern dieser gerendert werden soll
[CO] PLTRendererHandler::GetSceneManager() liefert nun den standard scene manager zurÃ¼ck falls kein scene manager
     gesetzt wurde
[CO] Der Rendering Contex wird nun bei der Renderer De-Initialisierung und nicht mehr beim beenden eines Renderer
     Handlers aufgelÃ¶st
[CO] PL::Renderer.Clear() Funktion nimmt nun Engine eigene Parameter an
[CO] Windows Struktur DEVMODE in Renderer zum Speichern der BildschirmauflÃ¶sungen durch eigenen Struktur namens
     PLTDisplayMode ersetzt.
[SB] PLTFont: Die Anzeige von Schrift ist nun mit in die Ã¼brigen 2D Funktionen eingebaut und kann damit mit einer beliebigen
     virtuellen AuflÃ¶sung arbeiten
[SB] PLTRenderer: Funktion zum Setzen des Blend Modes eingebaut, die mÃ¶glichen Einstellungen sind Alpha, Additive und Off
[CO] Baute Funktionen PL::Renderer.Get3DCoordinate() & PL::Renderer.Get2DCoordinate() ein
[SB] Baute die Funktionen Begin2DMode() und End2DMode() in den Renderer ein
[SB] Ãnderungen im Fenster/Renderer-Code, es wird nun GetClientRect() verwendet, damit im Fenstermodus das Renderbild komplett
     zu sehen ist und nicht ein Teil von der Titelleiste verdeckt wird
