>> 26.10.2011
[CO]
PLRendererOpenGL:
- "SurfaceWindow": Added Mac OS X implementation of the methods "GetGamma()", "SetGamma()" and "GetSize()"… except for some names, they are identical
  to the Linux implementation



>> 25.10.2011
[CO]
PLRendererOpenGL:
- Removed non public "OpenGL.tar.gz" package within "Windows_x86_32" and "Linux_x86_32" (other targets had no such package).
- "gl.h", "glu.h" and "glx.h" are from MesaLib 7.10
    - License: MIT License (http://mesa3d.org/license.html)
    - Downloaded from: ftp://ftp.freedesktop.org/pub/mesa/7.10/MesaLib-7.10.zip
-> PLRendererOpenGL can now be used without the need to worry about proprietary stuff
PLRendererOpenGLES2:
- Added a CMake option in order to make the non public "OpenGLES2.tar.gz" package only optional... it's only required in case you want to use
  the emulator instead of the native OpenGL ES 2.0 support of your graphics driver



>> 21.10.2011
[CO]
PLRendererOpenGL:
- "ContextMacOSX": Implemented CGL context creation. Not yet tested, don't know whether or not this will work at all, but I have to start somewhere
 (never developed on or used Apple stuff before).
- "Extensions": Implemented Mac OS X part (not yet tested)



>> 20.10.2011
[CO]
PLRendererOpenGL:
- Removed "ExtensionConfig" -> To complicated, to error prone, long winded to maintain, not really useful -> goodbye
  (had been deactivated for several month)
- Extension cleanup: "GL_POINT_SPRITE_ARB" & "GL_COORD_REPLACE_ARB" are within the official "glext.h" from Khronos (years ago, this was not the case,
  there wasn't even such a cool common header :)
- Extension cleanup: Removed "GL_TEXTURE_RECTANGLE_EXT" definition. "GL_TEXTURE_RECTANGLE_EXT" & "GL_TEXTURE_RECTANGLE_NV" and the resulting
  "GL_TEXTURE_RECTANGLE_ARB" have the same value. When I implemented it many years ago, there was no "GL_ARB_texture_rectangle".
- Extension cleanup: Removed "ExtensionDefinitions.h" and added an extension helper macro to make the extension handling easier to maintain
- Extension cleanup: Added "OpenGLExtensions::InitUniversal()" which is called after "OpenGLExtensions::Init()" has done it's job. While "Init()"
  has a platform dependent implementation, "InitUniversal()" has a platform independent implementation. This reduces code which is nearly
  identical across multiple platforms and should make it easier to add support for new platforms. Within "InitUniversal()", I used macros similar
  to the one I used within PLRendererOpenGLES2, this makes the implementation more compact and reusable across multiple platforms.
- Extension cleanup: Renamed the "OpenGLExtensions"-class into "Extensions" (the file itself had already this name)



>> 19.10.2011
[CO]
PLRendererOpenGL:
- All OS dependent implementations are now in subdirectories ("Windows", "Linux" and so on)
- Added empty Mac OS X classes to have something to start with (intentionally no extensions file right now)



>> 17.10.2011
[CO]
- Renamed "VertexBuffer::PSize" into "VertexBuffer::PointSize". There's a Linux definition named "PSize" causing nasty naming conflicts, but here it was
  possible to just "undefine" this namespace wasting definition. On Mac OS X this doesn't seem to work... I didn't research how it's defined because it's
  getting time consuming and stupied with this namespace wasting OS stuff. So, I now just renamed it within PixelLight (but such an action should not be
  enforced by OS headers...).
- PLRendererOpenGL: Kicked the legacy pbuffer implementation. Frame buffers are now commonly supported, even by OpenGL ES 2.0 on mobile devices. There's no
  longer a reason to keep this ugly, frequently breaking and hard to port pbuffer stuff.



>> 28.09.2011
[CO]
PLRendererOpenGLES2:
- Added support for "GL_EXT_Cg_shader" (ftp://download.nvidia.com/developer/GLSL/GLSL%20Release%20Notes%20for%20Release%2060.pdf - page 13)... a REALLY
  cool extension: If this extension is available (on Tegra 2, it is) one can directly feed OpenGL ES 2.0 with Cg shaders!
  This means that in this case, there's no need for the Cg runtime (> 6 MB) - altought there's no Cg runtime for Android anyway. Adding support within
  "PLRendererOpenGL" for this extension would be easy - but there's always the high possibility that this extension is not available (like on AMD GPUs
  as my own :). I'am sure that it's no good idea to use Cg shaders for official released Android apps because one has to assume that this extension is
  not available - but during development I'am also sure that this will become usefull, e.g. for "quick'n'dirty" rapid prototyping using already written
  Cg shaders.
  I noticed two issues with the Cg shaders:
    - When using semantics within Cg attributes, "glGetActiveAttrib()" returns the semantic (e.g. "POSITION") instead of the real attribute name
    - Inverse for matrices required
  ... so, still some minor usage details to figure out for an easy and generic usage... but hey, Cg shaders on a mobile device! :D
- Added support for "GL_OES_texture_3D"
- Added support for "GL_NV_get_tex_image"
- Added support for "GL_OES_mapbuffer"
- Added support for "GL_ARB_draw_buffers", "GL_NV_fbo_color_attachments", "GL_NV_read_buffer", "GL_ANGLE_framebuffer_blit", "GL_ANGLE_framebuffer_multisample",
  "GL_OES_packed_depth_stencil", "GL_OES_depth24" and "GL_OES_depth32"
  -> "FrameBufferObject" has now the same feature set as the OpenGL renderer (and there's still a render to texture refactoring on my list :)
  -> Multi render targets (MRT) is now working on my Tegra 2 smartphone, tested it with 4 render targets, there are up to 8 render targets supported... WOW! :D
    (meaning it's technically possible to also use deferred rendering on Tegra 2 smartphones)



>> 27.09.2011
[CO]
PLRendererOpenGLES2:
- The OpenGL ES 2.0 emulator from ARM can now be used under Linux as well (although it's horrible slow compared to MS Windows, at least on my system)
- Using native OpenGL ES 2.0 on a desktop PC under Linux is now working as well, at least the initalization... right now, when running something there's just a black
  flickering something visible (all EGL and OpenGL ES 2.0 entry points were found, no errors within the log etc.)...
- Linux: "ContextRuntimeLinking::LoadGLESEntryPoints()": When "eglGetProcAddress()" is used to get the OpenGL ES 2.0 function entry points, I see at least something
  (although there's some window flickering from time to time)
- Linux: Ok, it looks like that the "flickering" has something to do with the colormap and that EGL creates an own colormap. When moving around the window, one can clearly
  see that the rendering area stays at the previous position and the window content is black - after stopping the window move around, the render area snaps to the new window
  position. I tried to fix that, but without any luck... maybe someone else can figure out how to solve this?
- Added support for "GL_OES_element_index_uint"
- Added support for "GL_EXT_texture_filter_anisotropic"
- Implemented "Renderer::SetupCapabilities()"
- Added support for "GL_EXT_texture_compression_dxt1" (just a subset of "GL_EXT_texture_compression_s3tc")



>> 25.09.2011
[CO]
- "PLRendererOpenGLES2": Added support for "GL_EXT_texture_compression_s3tc", "GL_EXT_texture_compression_latc" and "GL_AMD_compressed_3DC_texture"



>> 13.09.2011
[CO]
- "PLCore::FrontendConfig" and "PLRenderer::Config" have now the same default size (800x600 still feels quite fine during development)
- "PLRendererOpenGLES2": Implemented render to texture using "PLRendererOpenGL" as base. Please note that this is definitly not optimal and not final... but
  right now I don't want to do the required render to texture refactoring within PLRenderer... the current render to texture design is from the time were one had
  to use e.g. "pbuffer" and the "framebuffer"-extension of OpenGL was not yet existing. So, the current PLRenderer render to texture interface is somewhat out-of-date
  (but for now, it is still usable).



>> 06.09.2011
[CO]
- "PLRendererOpenGLES2": Added Android part to the EGL headers



>> 04.09.2011
[CO]
- Moved the null font manager implementation from "PLRendererNull" into "PLRenderer" backend tools
- "PLRendererOpenGL" & "PLRendererOpenGLES2": It's now possible to disable the font support and by doing so removing the freetype external dependency. Usually
  font support is a nice thing to have - except when you start porting to a new platform and want to see first "proof of concept" results as fast as possible
  before you start to hammer out the details.



>> 01.09.2011
[CO]
- "PLRendererOpenGLES2": The runtime linking approach used in "ContextDesktop" is working really well... time to realize a single source solution working for
  desktop, emulator and mobile device without reconfigurating the CMake file or the source code. This makes it really easier to use the OpenGL GL 2.0 renderer
  and it's now also possible to switch between desktop or emulator by just adding the emulator dlls into the same directory as the renderer dll or removing them
  from this directory. No need to recompile.
  -> Renamed "ContextDesktop" into "ContextRuntimeLinking" and removed "ContextEmulator" and "ContextNative"
- "Renderer": Added "IsInitialized()"-method returning whether or not the renderer instance was initialized successfully within it's constructor
- "RendererContext::CreateInstance()": In case the renderer instance was not initialized successfully within it's constructor, the created instance is destroyed
  and a null pointer will be returned (would be be to dangerous to use a not correctly initialized renderer instance)



>> 31.08.2011
[CO]
- Android port related: "PLRendererOpenGLES2": No X11 when using Android
- Android port related: "PLRendererOpenGLES2" is now compiling as well (when configuring "CMakeFile.txt", this will be changed soon, but one step after another :)



>> 27.08.2011
[CO]
- D'OH! After one hour of experiments it appears that the native OpenGL ES 2.0 support of my ATI desktop driver ("AMD Catalyst 11.8", Windows 7 64 bit,
  "ATI Mobility Radeon HD 4850" with Windows Aero deactivated) can't deal with multiple windows. Until now, the OpenGL renderer implementations
  always created an internal dummy window because OpenGL just needs an OS window to work in the first place... even if your application doesn't
  have a window at all because you're only rendering into background buffers.
  The renderer context is by design window independent, it doesn't even know anything about one or multiple windows (renderer targets). The renderer
  instance is connected with the renderer context. So, the renderer doesn't depend on an OS window as well, but the internal renderer implementation
  may need an OS window. If you have an OS main window which is valid as long as the renderer context instance exists, it's highly recommended to tell
  the renderer context of this main window during creation, else the internal renderer may create it's own invisible dummy window. Most times, there's
  no problem with an invisible dummy window holding a renderer implementation together. Sadly, there are e.g. some OpenGL ES 2.0 implementations which
  just fail when using multiple windows (the internal invisible dummy window and the real visible one => two windows).
  In a nutshell:
  - If you've already got an OS main window which is valid as long as the renderer context instance exists, just tell the renderer
    context about it
  - If you don't have such an OS main window, don't create one just for the renderer context and pass in "NULL_HANDLE", the renderer
    implementation must be able to deal with this situation on it's own
- Bugfix: PLRendererOpenGL & PLRendererOpenGLES2: Automatic texture uncompression was broken ("Passing "empty" images to the GPU no longer creates internal
  image data"-change in PixelLight 0.9.6-R1)
  Bug birth "22.03.2011", but death "27.08.2011": PLRendererOpenGL & PLRendererOpenGLES2: When there's an image without data, e.g. "glTexImage2D()" is
  called with nullptr instead of "ImageBuffer::GetData()" which creates internal image data although it's not required... but only if there's also no
  compressed data available as well! In here, the new "PLGraphics::ImageBuffer::HasAnyData()"-method is now used instead of the
  "PLGraphics::ImageBuffer::HasData()"-method just looking for uncompressed data.
- "PLRendererOpenGLES2" -> "FontManager_GLSL.h": The native OpenGL ES 2.0 support of my ATI desktop driver now eats this shader as well



>> 26.08.2011
[CO]
- PLRendererOpenGLES: Current AMD GPU drivers are (at least in theory) able to provide native OpenGL ES 2.0 support. So, this renderer implementation now
  has three supported use cases:
  - Emulator (for development)
  - Desktop using GPU drivers supporting this (primarily for development)
  - Native (for the mobile devices)
  First, I just saw nothing at all when using the desktop version. No errors, no crashes, but also no graphics. Tested it with "AMD Catalyst 11.8" and Windows
  7 64 bit on a "ATI Mobility Radeon HD 4850" with Windows Aero active. As soon as I disabled Windows Aero all went fine. Good that I tried that after over two
  hours of research and experiments... "(?!$$(!"=$/()=!"$
  Ok, looks like a driver bug or so, but it's really cool that I can now use OpenGL ES 2.0 on my desktop without an emulator! :D
- Renamed PLRendererOpenGLES into PLRendererOpenGLES2 to avoid any future name conflicts



>> 20.08.2011
[CO]
- "FontManager::GetFontTexture()": Font filename comparison should only be done on the absolute paths to be on the safe side



>> 19.08.2011
[CO]
- "RendererApplication" is using the display mode settings from the configuration again



>> 16.08.2011
[CO]
- "RendererContext" destructor was virtual, but it shouldn't be
- Renamed "PLRendererOpenGLCg::ShaderToolsCg" into "PLRendererOpenGLCg::CgContext"



>> 13.08.2011
[CO]
- Removed default font options within the renderer configuration. The font manager itself has now a build in default texture font. In order to remove the default
  texture font or to set another default texture font, just set it during the application initialization.
- Renamed "RendererBackend::GetStatisticsT()" into "RendererBackend::GetWritableStatistics()"



>> 07.08.2011
[CO]
- Renamed "Surface::Update()" into "Surface::Draw()" to make clear that this method is considered to only draw and not e.g. update the complete game logic
- "RendererApplication": Removed "IsFullscreen()" and "SetFullscreen()", this stuff is now part of the frontend-side



>> 06.08.2011
[CO]
- Removed "RendererApplication::Update()"
- "RendererApplication::OnUpdate()" is now an overridden method of "PLCore::AbstractFrontend"
- "RendererBackend::Update()" no longer updates (= redraws) the renderer surfaces
- "RendererApplication::OnDraw()" now only updates the primary frontend renderer surface, while "update" only means "draw"



>> 04.08.2011
[CO]
- Moved "RenderApplication" from "PLEngine" into "PLRenderer". It's now finally possible to use RenderApplication for applications just using PLRenderer... until now
  one had to also include a bunch of other high level components like PLMesh, PLScene, PLEngine... and of course also the big project PLGui...
  It should be possible to write bare minimum applications just using PLRenderer for basic rendering without the need to use any high level components like meshes or
  the scene graph. This should also make it easier to port PixelLight to new platforms - in order to use e.g. the sample application 50RendererTriangle to test
  PLRenderer, one doesn't need to port/compile everything up to PLEngine to do so.
- Renamed "RenderApplication" into "RendererApplication" so that one can guess the name of this class by just knowing the component name it's in



>> 24.05.2011
[CO]
PLRendererOpenGLEs:
- Bugfix: "ShaderLanguageGLSL": "pl_class" and "pl_implement_class(ShaderLanguageGLSL)" was missing
PLRendererOpenGLCg:
- Bugfix: "ShaderLanguageCg": "pl_implement_class(ShaderLanguageCg)" was missing



>> 09.05.2011
[CO]
- Bugfix: "TextureManager::CreateTexture()" set a new instance of "ResourceHandler" which was totally wrong because there were already an instance.
  Thank you "jacky" for pointing this out within the PixelLight forum at http://dev.pixellight.org/forum/viewtopic.php?f=6&t=47
  This whole "m_bShareTextureBuffer" looks somewhat messy, but right now I don't dare to refactor something in here because I'am currently working on totally different
  stuff.



>> 08.05.2011
[CO]
- Added "Capabilities::bTextureBufferNonPowerOfTwo", if it's "true" there are no power of two restrictions for all texture buffer types (yeah! :)
- "Renderer": Added "IsValidTextureBuffer1DSize()" & "IsValidTextureBuffer2DSize()" & "IsValidTextureBufferRectangleSize()" & "IsValidTextureBuffer3DSize()" &
  "IsValidTextureBufferCubeSize()" to make validating a texture buffer size more comfortable. Modern graphics APIs/extensions and GPUs have finally removed nearly all
  limitations from the texture buffers, except for maximum size of course. The renderer interface and PixelLight in general must stay compatible with legacy stuff so
  there are multiple test methods instead of just one for all texture buffer types.
PLRendererOpenGL:
- If "GL_ARB_texture_non_power_of_two" is available "Capabilities::bTextureBufferNonPowerOfTwo" is set to "true"



>> 22.04.2011
[CO]
- Added a version of "DrawHelpers::DrawImage()" with an 3D image position and an object space to clip space matrix as parameters
PLRendererOpenGL:
- "gl_PointSize" in GLSL and "PSIZE" in Cg had no effect because "GL_VERTEX_PROGRAM_POINT_SIZE_ARB" was not enabled
  (see from http://www.opengl.org/registry/specs/ARB/vertex_program.txt -> "(42) How does PointSize work with vertex programs?" for more information)



>> 16.04.2011
[CO]
PLRendererOpenGL:
- Added support for the OpenGL extension "GL_EXT_transform_feedback", currently only used for the binding point of "GL_ARB_uniform_buffer_object"
  (but transform feedback support is planned!)



>> 15.04.2011
[CO]
- "PLRendererOpenGLCg::ProgramCg" was emitting the "EventDirty"-event when the program destructor was called while "PLRendererOpenGL::ProgramGLSL" was not,
  "PLRendererOpenGL::ProgramGLSL" is now emitting this event within the destructor as well
- Added "uniform buffer" (UBO, aka "constant buffer") support



>> 10.04.2011
[CO]
- Added "TextureBuffer::IsDepthFormat()" which returns whether or not a texture buffer format is a depth buffer format
PLRendererOpenGL:
- Ouch! When using a depth buffer texture format (D16, D24, D32) "FrameBufferObject::Initialize()" was also adding a color buffer, fixed that. The interesting
  thing is that my ATI driver never told me "Incomplete attachment frame buffer object" while the NVIDIA sytem, I'am using for testing, told me at once that
  there's something wrong...



>> 08.04.2011
[CO]
- "Parameter::Parameter()" sets the value by default to zero
- Added "ParameterManager::OnParameterChange()" which is called when a parameter has been changed (created, destroyed, value changed)
- Added "ParameterManager::EventParameterChanged"-event which is called when a parameter has been changed (created, destroyed, value changed)
- Added "Material::EventParameterChanged"-event which is called when a parameter has been changed (created, destroyed, value changed)



>> 01.04.2011
[CO]
- Ok, I have enough of this GLSL precision qualifiers issues on NVIDIA systems... now I've receive a "error C1101: ambiguous overloaded function reference
  "clamp(lowp float, float, float)"" while everything works on my AMD/ATI system. I removed the precision qualifiers from all none OpenGL ES 2.0
  runnable shaders, and for those GLSL shaders targeting OpenGL as well as OpenGL ES 2.0, I will remove precision qualifiers from the shader source
  code before passing it to OpenGL. It's just not worth all this issues and it's really sad that there are that many issues with the different
  GPU driver implementations of precision qualifiers (which, as mentioned, on OpenGL have no real effect anyway... at least according to the
  specification... but who cares about specifications anyway, beside me?!).
- Finally removed "PLRenderer::ProgramGenerator::ApplyGLSLHacks()"... again... see diary entries from "07.07.2010", "26.11.2010" and "01.12.2010" for
  more detail (written in German at this time)
- Added "Shader::RemovePrecisionQualifiersFromGLSL()" which is in fact the "PLRenderer::ProgramGenerator::ApplyGLSLHacks()", but this is no longer a
  hack - it's a feature *g*
-> ... cool, it finally looks like that the GLSL shaders are now working properly on my AMD/ATI system as well as the NVIDIA system at my university.
   While the NVIDIA driver is totally fixed on the given GLSL version and blames each and every single wrong set point (this is a good thing!!!),
   the AMD/ATI driver isn't really that interested in the given GLSL version. Sadly, this means when I'am working with GLSL shaders, I can never be sure
   whether or not I missed a GLSL version issue because the AMD/ATI driver probablity won't tell me what I've done wrong according to the selected
   GLSL version. :/



>> 31.03.2011
[CO]
- I was wondering for some time now why on NVIDIA systems there were some issues when using GLSL. Finally I had the possibility and time to check this
  issue in detail using the NVIDIA system at my university. It took me just a few minutes to figure it out that the issue had to do with the "#version"
  directive of GLSL. I was aware that there's such a precompiler definition, and I already put it as comment into the GLSL shader codes as a reminder...
  the reason to don't add a version information was to create one GLSL shader that can be used on e.g. OpenGL and OpenGL ES 2.0 at the same time. On my
  ATI system this approach worked really well, but as mentioned this way was not working the same on NVIDIA systems... and after having a look into the
  OpenGL specification I just noticed that the ATI driver handles this thing "wrong", meaning not according to the specification:
    "The OpenGL¬Æ Shading Language - Language Version: 3.30 - Document Revision: 6 - 11-Mar-2010" Page 14: "Version 1.10 of the language does not require
     shaders to include this directive, and shaders that do not include a #version directive will be treated as targeting version 1.10."
  Ok, this means that one REALLY has to put the GLSL version into the shader source code... but I still try to keep some shaders OpenGL ES 2.0 usable by
  adding the version definition at runtime. I think for the deferred renderer shaders I can but the version directly into the shaders and use more modern
  GLSL language constructs because it will not really run on OpenGL ES 2.0 anyway.
  In GLSL, "#version" must occur before any other statement in the program as stated within:
    "The OpenGL¬Æ Shading Language - Language Version: 3.30 - Document Revision: 6 - 11-Mar-2010" Page 15: "The #version directive must occur in a shader
     before anything else, except for comments and white space."
  ... sadly, this time NVIDIA (driver: "266.58 WHQL") is not implementing the specification in detail and while on AMD/ATI drivers ("AMD Catalyst‚Ñ¢ 11.3")
  you get the error message "error(#105) #version must occur before any other statement in the program" when breaking specification, NVIDIA (driver: "266.58 WHQL")
  just accepts it without any error.
  ... and another one... "Order of Qualification" ...
    "The OpenGL¬Æ Shading Language - Language Version: 3.30 - Document Revision: 6 - 11-Mar-2010" Page 52:
    "4.7 Order of Qualification
     When multiple qualifications are present, they must follow a strict order. This order is as follows.
     invariant-qualifier interpolation-qualifier storage-qualifier precision-qualifier
     storage-qualifier parameter-qualifier precision-qualifier"
  NVIDIA (driver: "266.58 WHQL") did not yell at me when I wrote "in highp vec4 VertexPosition" while the AMD/ATI driver ("AMD Catalyst‚Ñ¢ 11.3") throw a
  "error(#132) Syntax error: 'in' parse error" at me which, according to the specification, was the right action... I changed it yesterday from
  "highp in vec4 VertexPosition" (correct) into "in highp vec4 VertexPosition" (wrong) because the NVIDIA driver gave me a "error C7538: OpenGL does not
  allow 'highp' after 'inout'" (I was not able to find this statement in the GLSL specification!). After looking into the GLSL specification again after all
  this confusion, it looks like that the NVIDIA driver does it "wrong". I know that the precision qualifiers are for OpenGL ES 2.0 compatibilty
  and (currently) have no effect when using OpenGL, but I wanted to use them anyway. Ok, in this situation (in/out/inout) I have no chance to make it working
  using precision qualifiers on both, NVIDIA and AMD/ATI... so I just removed the precision qualifiers for this use cases... :/
  ... such things REALLY make it hard to write shaders running on a broad range of GPU's! As for me, as mentioned, I "just" have an AMD/ATI graphics card and
  no NVIDIA graphics card. At the moment, when I want to test everything on a NVIDIA system, I have to use the NVIDIA system at my university - either directly
  within the university laboratory or via horrible slow remote control. So, I can't test each and every time when making a change within the PixelLight
  codes. If any of you have a NVIDIA system and notice any strange behaviour, please tell me at once so that I can test and fix it!
- Because "PLRenderer::ProgramGenerator" adds "#define" dynamically at runtime at the top of the shader, this is a break of the GLSL specification because
  "#version" needs to be on the very top (see comments above). Therefore, "PLRenderer::ProgramGenerator" is required to also add "#version"... but I don't
  think that's a real problem. For Cg, one already had to provide a "profile"... I extended this to GLSL so that "PLRenderer::ProgramGenerator" adds a GLSL
  version if the current shader language is GLSL and profile, which is this case now contains the GLSL version, if not empty.
- Added some important GLSL comments to "Shader::SetSourceCode()" so that I hopefully never again stumble over this GLSL version issue...



>> 28.03.2011
[CO]
- Added "Renderer::GetTexelToPixelOffset()" returning the pixel origin to texel origin offset, usually (0.0, 0.0) or (-0.5, -0.5).
  OpenGL/D3D10/D3D11 have no offset while D3D9 has an offset of -0.5 (see http://msdn.microsoft.com/en-us/library/bb219690%28VS.85%29.aspx)
  -> The "libRocket"-interface requires this type of renderer API information and this is possibly not the only use case for this offset
     information



>> 25.03.2011
[CO]
- "GeometryShader" input/output primitive type and the number of output vertices can now be set by the user



>> 22.03.2011
[CO]
- PLRendererOpenGL & PLRendererOpenGLES: When there's an image without data, e.g. "glTexImage2D()" is called with nullptr instead of
  "ImageBuffer::GetData()" which creates internal image data although it's not required
PLRendererOpenGLCg:
- "ProgramCg::GetCompiledProgram()": ... when not using "cgIsProgramCompiled()", "cgGetProgramString()" may just crash in case the
  program is not compiled... crashs are never a good thing, so I added a check...
PLRenderer:
- Added "Program::IsValid()"
- Added "Renderer::GetSwapInterval()" and "Renderer::SetSwapInterval()"



>> 18.03.2011
[CO]
PLRendererD3D11:
- Continued the work on the renderer backend, it's now possible to render into multiple windows - clear to color is up and running



>> 15.03.2011
[CO]
PLRendererD3D11:
- After some discussion within the PixelLight forum at http://dev.pixellight.org/forum/viewtopic.php?f=3&t=8 I noticed that there's really interesting
  in an up and running D3D11 renderer backend... and I wanted to have a look at the latest graphics API evolution of OpenGL/D3D11 anyway. I started the
  PLRendererD3D11 project by using PLRendererNull as usual as start point.
- Device and device context creation is now implemented, I really like those feature levels of DirectX 11



>> 08.03.2011
[CO]
PLRendererOpenGL:
- Linux: My OS OpenGL header automatically (!) included "glext.h", which was of course out-of-date... so, I was forced to define "GL_GLEXT_LEGACY" to
  deactivate this include behaviour
- Linux: "ContextLinux::SwapInterval()" was using "glXSwapIntervalSGI" without checking whether or not the extension is actually available
- Linux: Wow, "glXSwapIntervalSGI" was used without been defined or initialized, I wonder why it worked at all...
  ... at least for most people. This bug was found by a user which got an "libPLRendererOpenGL.so: undefined symbol: glXSwapIntervalSGI"
  (PixelLight forum post: http://dev.pixellight.org/forum/viewtopic.php?f=6&t=5)



>> 25.02.2011
[CO]
- Added "PLRenderer::Program::GetCompiledProgram()"
PLRendererOpenGL:
- Added support for "GL_ARB_get_program_binary" - but sadly, "glGetProgramivARB(nOpenGLProgram, GL_PROGRAM_BINARY_LENGTH, &nBinaryLength);" returns
  always 0? (Catalyst 11.2 - there are forum posts reporting similar problems, a driver issue?)
  As a result, I can't implement "load from binary object" because I'am not able to test it right now. :/
  At least the Cg implementation of this new method works, in my test, I received the GLSL codes compiled from the provided Cg shader codes.



>> 19.02.2011
[CO]
PLRendererOpenGL:
- Implemented "RenderState::PointScaleEnable"



>> 28.01.2011
[CO]
- Bugfix: "Texture::Load()": There can be the situation that the image loading was successfully, but there's still no image buffer -
  we really have to deal with this situation properly to avoid a crash



>> 27.12.2010
[CO]
- "PLRenderer::TextureBuffer::GetFormatFromImage": Added L32F support
- "PLRenderer::Texture": For floating point image data: GrayscaleA and RGB data is converted into RGBA internally so it can be used as texture



/*********************************************************\
 *  The entries below are in German only
\*********************************************************/



>> 01.12.2010
[CO]
- Ich hatte heute kurz die Gelegenheit den Dungeon Demo auf einem NVIDIA System an der Hochschule, wo ich derzeit f√ºr meinen
  Master studiere, zu testen... leider bekam ich tausende von Shader Compiler fehler, die √§ltere Version mit GLSL hack ging
  allerdings - verdammt. Hab den Hack erstmal wieder rein und schau zu morgen auf diesem NVIDIA System mal die neusten Treiber
  zu installieren und nochmals zu testen... unglaublich dieses unterschiedliche Treiber verhalten, vorallem wenns laut OpenGL
  Spezifikation gehen sollte (diesmal sich also die ATI Treiber korrekt verhalten)...



>> 26.11.2010
[CO]
- Die am "07.07.2010" (siehe entsprechenden Tagebucheintrag f√ºr mehr Informationen) erstellte Methode "PLRenderer::ProgramGenerator::ApplyGLSLHacks()"
  entfernt da es scheinbar mittlerweile auch ohne geht - hoffentlich wirklich ohne Probleme auf NVIDIA-Karten... denn solche Hacks (nur weil ein GPU-Treiber
  sich nicht an den Standard h√§lt!) sind einfach nur d√§mlich und b√∂se Seiteneffekte sind da nat√ºrlich nicht auszuschlie√üen. W√§re nett wenn jemand mit einer
  NVIDIA-Karte und aktuellen Treibern das nochmals gegentesten k√∂nnte.



>> 08.10.2010
[CO]
- "PLRendererOpenGL::ProgramGLSL" & "PLRendererOpenGLCg::ProgramCg": "RelinkRequired()" wird nur noch in "RestoreDeviceData()" und nicht mehr auch in
  "BackupDeviceData()" aufgerufen, es ist einfach am Geschicktesten wenn das "Dirty"-Event dann kommt, wenn es m√∂glich ist wieder ein neues internes
  Program zu erzeugen (von dem man sich dann z.B. direkte Zeiger auf Attribute/Uniforms speichern kann)



>> 05.10.2010
[CO]
- "DrawHelpersBackend::DrawText": Scale & Bias Parameter wurden nicht verwendet



>> 01.10.2010
[CO]
- "AbstractShader" in "Shader" umbenannt da der Name "Shader" durch das entfernen des alten Shader-Interfaces nun wieder frei ist und es so konsistenter
  zu den anderen PLRenderer Klassennamen ist



>> 28.09.2010
[CO]
- Dank der Umbauten in der letzten Zeit, konnte ich nun endlich Cg-Support von PLRendererOpenGL in ein seperates Plugin Namens PLRendererOpenGLCg
  verschieben. (ein Plugin f√ºr ein Plugin *g*) Cg hat seine Vorteile, hat aber leider genauso auch einige Nachteile - z.B. eher mangelhafter Support
  f√ºr ATI Grafikkarten, ist nicht OpenSource + die Header & Libs darf man nicht weiterverbreiten so das jeder der PL √ºbersetzen will zuerst Cg installieren
  muss... und ganz nebenbei sind die Cg dlls mittlerweile 6,5 MB gro√ü und scheinen mit jedem neuen Release auch weiter zu wachsen. Dies sind also mehr
  als genug Gr√ºnde die daf√ºr sprechen Cg nun komplett Optional zu machen, mit GLSL ist man einfach etwas leichtgewichtiger unterwegs da die Shader-Compiler hier
  direkt in den Grafikkarten-Treibern integriert sind.



>> 27.09.2010
[CO]
- "ShaderLanguage"-Schnittstelle eingef√ºhrt. Da zuk√ºnftig in z.B. PLRendererOpenGL Shader Sprachen √ºber Plugins hinzugef√ºgt werden k√∂nnen sollen
  (z.B. Cg wird rein optional √ºber Plugin), macht eine eigene Schnittstelle denke ich wirklich Sinn. In der "Renderer" Klasse wurden die Methoden
  CreateVertexShader(), CreateGeometryShader(), CreateFragmentShader(), CreateProgram() entfernt - diese Methoden liegen nun in "ShaderLanguage".
  (mittlerweile gibts noch einige weitere neue Shader Typen die wir noch nicht unterst√ºtzen... da w√ºrde es auf die Dauer in "Renderer" auch ziemlich
  voll werden :/)
  √úber z.B. "Renderer::GetShaderLanguage(<Name>)" l√§sst sich eine Instanz einer Shadersprache anfragen.
PLRendererOpenGL:
- ProgramCg::BuildUniformInformation(): Einzelnde Array Elemente k√∂nnen nun z.B. √ºber "MyArray[1]" angesprochen werden
- ProgramCg::BuildAttributeInformation(): Elemente einer Struktur k√∂nnen nun √ºber z.B. "MyStructure.MyPosition" angesprochen werden
- ProgramCg & ProgramGLSL sind nun von der Basisklass Program, und ProgramUniformCg & ProgramUniformGLSL sind nun von der Basisklass ProgramUniform
  abgeleitet, damit fallen an zwei stellen Shadersprachen-Fallunterscheidungen weg



>> 26.09.2010
[CO]
- Effekt-Klassen auf das neue Shader-Interface umgestellt
- Das alte Shader-Interface endlich entfernt :D



>> 17.09.2010
[CO]
PLRendererOpenGL:
- "FixedFunctions::SetVertexBuffer()": Vertex Attribute werden nun nicht mehr in "VertexBuffer::MakeCurrent()" an z.B. "glNormalPointer" f√ºr Fixed Functions
  Rendering √ºbergeben, sondern in "FixedFunctions::SetVertexBuffer()" so das die (grausamen) Fixed Functions Dinge beisammen sind
- "VertexBuffer::MakeCurrent()" durch "BindAndUpdate()" ersetzt - die neue Implementation ist *sehr* schlank, im Grunde nur "glBindBufferARB" und falls n√∂tig
  ein "glBufferSubDataARB" um die VBO Daten auf der GPU zu aktualisieren



>> 07.09.2010
[CO]
PLRendererOpenGL:
- ProgramCg: MakeCurrent()/UnmakeCurrent() d√ºrfen cgGLEnableClientState/cgGLDisableClientState NUR bei Vertex Program Attributen aufrufen
- Renderer::SetProgram(): Bis das alte Shader Interface raus ist, wird hier noch gepr√ºft ob momentan ein Shader √ºber das alte Shader Interface gesetzt wurde,
  wenn ja, wird das hier zur√ºckgesetzt.
- "Renderer::SetProgram(" setzt kein "glUseProgramObjectARB(0)" mehr, das ist Job von "ProgramGLSL::UnmakeCurrent()"... das machte als ich das neue Shader Interface
  implementierte noch Probleme, nun scheint es aber mittlerweile endlich sauber zu laufen :D



>> 06.09.2010
[CO]
PLRendererOpenGL:
- "ATI2N" Support l√§uft (es folgen noch ein paar Arbeitsschritte). Gegen√ºber "DXT5 xGxR" hat man zwar keine Speicherersparnis, die Qualit√§t ist allerdings besser.
  (siehe http://developer.nvidia.com/object/real-time-normal-map-dxt-compression.html und http://www.ozone3d.net/tutorials/bump_map_compression_p4.php)
  Von den Namen her ist das wieder herrlich, ATI f√ºhrte das unter dem Marketingnamen 3DC ein, technisch bezeichnet man das als ATI2N, mittlerweile
  gibts ne universellere OpenGL Extension die auch auf NVIDIA Karten l√§uft und das LATC2 nennt, in DirectX 10 ist es unter BC5 bekannt... *g*
  Ich unterst√ºtze ebenfalls "Alternate XY Swizzle ATI2N", dies ist vergleichbar zu "DXT5 xGxR", beides kann mit "The Compressonator" von ATI erzeugt werden...
  das hat den Vorteil das ich die Shader in den Compositing Schritten NICHT erweitern muss, da bei "ATI2N" der Rest wie bei "DXT5 xGxR" abl√§uft.
  (sprich, 3'te Komponente errechnen)
- "GL_ATI_texture_compression_3dc" scheint am Aussterben zu sein, "GL_EXT_texture_compression_latc" hei√üt der "quasi Nachfolger" der ebenfalls auf NVIDIA Karten l√§uft.
  "ATI2N" in "LATC2" umbenannt (das Format an sich ist das gleiche!) und Support f√ºr "GL_EXT_texture_compression_latc" hinzugef√ºgt das Standardm√§√üig verwendet
  wird, erst wenn diese Erweiterung nicht vorhanden ist, wird nach "GL_ATI_texture_compression_3dc" gesucht. (h√§tte ich RGTC2 gew√§hlt, w√§re das nicht R√ºckw√§rtskompatibel
  zu 3DC und weitere Fallunterscheidungen m√ºssten her, das wollte ich aber vermeiden)
  Ist weder "GL_EXT_texture_compression_latc" noch "GL_ATI_texture_compression_3dc" vorhanden, wird die Texture zu L8A8 auf der CPU dekomprimiert und dann so zur
  GPU gegeben, so das man trotzdem was sehen kann auch wenn dann nat√ºrlich der Speicherverbrauch h√∂her ist.
  -> Da ich keine NVIDIA Karte habe, kann ich das nat√ºrlich nicht gegentesten ob das auch sauber auf NVIDIA Karten l√§uft. Zuk√ºnftig werde ich "LATC2" im Dungeon
     Demo nutzen da dieses Feature mittlerweile eigentlich von allen halbwechs aktuellen GPU's unterst√ºtzt werden sollte, im PL SDK bleibe ich zur Sicherheit auf
     "DXT5 xGxR" da ich hier h√∂chstm√∂gliche Kompatibilit√§t haben will.
- "ATI1N" (zu dem es nicht wirklich Informationen im Netz gibt) in "LATC1" umbenannt und PLRenderer um Support f√ºr dieses Texture Format erweitert. Damit ist es
  endlich auch m√∂glich reine Luminance Texturen (z.B. Height Map) vern√ºmpftig zu komprimieren. Ist "GL_EXT_texture_compression_latc" nicht vorhanden, wird auf der
  CPU dekomprimiert bevor die Daten an die GPU weitergereicht werden. Wie schon bei "LATC2" hat auch "LATC1" *nur* Qualit√§tsvorteile, aber keinen geringeren
  Speicherbedarf gegen√ºber "DXT1".



>> 05.09.2010
[CO]
PLRendererOpenGL:
- ProgramCg::UnmakeCurrent(): Hier sollte cgGLDisableClientState f√ºr alle Attribute aufgerufen werden... macht man das nicht und nutzt
  natives GLSL und Cg gleichzeitig, kann man Probleme bekommen was ich gerade hatte, die Vertex Daten waren dann im Cg Shader kaputt. :/
  (und dann sucht man ertmal Ewig was denn im Shader falsch sein k√∂nnte, obwohl dort alles richtig ist...)



>> 01.09.2010
[CO]
PLRendererOpenGL:
- SurfaceWindow: Gamma wird am Ende nur noch zur√ºckgesetzt, wenn Gamma durch "SetGamma()" ver√§ndert wurde. Sollte das setzen von Gamma
  unerwartet mal Probleme machen, so hat man nun wenigstens keine Probleme, wenn man von der Anwendung aus nie Gamma ver√§ndert :D



>> 20.08.2010
[CO]
PLRendererOpenGL:
- ContextWindows::QueryDisplayModes/ContextLinux::QueryDisplayModes stellen sicher das sich unter keinen Umst√§nden doppelte Eintr√§ge
  in der Liste befinden



>> 17.08.2010
[CO]
PLRendererOpenGL:
- "GL_ARB_texture_float"-Extension wird nun unterst√ºtzt und Vendor-Abh√§ngigen Extensions vorgezogen, so funktionieren nun auch Float-Texturen
  unter Linux und damit auch der Deferred Renderer :D
- Capabilities::bR16G16B16A16 entfernt da mittlerweile irgendwie Witzlos



>> 11.08.2010
[CO]
- PLRendererOpenGL & PLRendererOpenGLES: "FontTexture" speicherte nur den Dateinamen der Font, aber ohne Pfad so das der Font-Manager
  dann nicht mehr wirklich pr√ºfen konnte ob eine Font bereits im Cache ist



>> 10.08.2010
[CO]
- "FontManager::CreateFontTexture(": Hier war noch "Data/Fonts/" fest eingebaut was nat√ºrlich nicht ok war
  (ACHTUNG: am besten alls Configs l√∂schen da dort auch ein Font Dateiname steht...)



>> 07.08.2010
[CO]
- SPDefault √ºberarbeitet. Hier fliegt nun das PixelLight Logo gem√ºtlich durch die Gegend + ein Text erkl√§rt was los ist. Dadurch das nur DrawHelpers
  Dinge verwendet werden, ist das nun auch Shader & Fixed Functions unabh√§ngig.



>> 04.08.2010
[CO]
- "DisplayMode": "nZBufferBits" & "nStencilBits" m√ºssen wie schon die Multisample Einstellung nun einmal beim erzeugen einer Renderer Instanz
  √ºbergeben werden. Hintergrund ist, das diese Einstellungen scheinbar auch "global" f√ºr den gesamten OpenGL Context zu gelten scheinen. Versucht
  man mehrere Fenster in einem OpenGL Context zu erzeugen die z.B. unterschiedliche Stencil-Bits haben, so scheint dies auf ATI Grafikkarten zu
  funktionieren, bei NVIDIA Grafikkarten hingegen sieht man dann absolut nix mehr. Im Internet konnte ich leider keine Informationen dazu finden,
  scheinbar verwendet alle Welt nur ein einziges Fenster zum Rendern, brrr. Da wir nun mehrmals √ºber dieses d√§mliche Problem gestolpert sind,
  und es wohl bei diesen Einstellungen ok ist das diese f√ºr alle Fenster eines Renderers verwendet werden, nun diese kleine √Ñnderung. Da man
  heutzutage meist erstmal in Texturen Rendert und dort wiederum andere Tiefen/Stencil Einstellungen haben kann, f√§llt diese globale Einstellung
  f√ºr das OS Fenster wohl nochmals weniger ins Gewicht.
PLRendererOpenGL:
- Argh, neue Treiber Probleme: Seit der neusten ATI Catalyst Version ging bei mir irgendwie kein Antialiasing mehr... ein Blick in die unterst√ºtzten
  Pixel-Formate zeigte was los ist: 32 Bit Farbtiefe und Antialiasing scheint nicht mehr unterst√ºtzt zu werden. Daher musste ich das suchen eines
  geeigneten Pixel-Formates noch etwas erweitern: Wenn das gew√ºnschte Pixel-Format nicht vorhanden ist, wird die Farbtiefe von 32 Bit auf 24, und dann
  von 24 auf 16 Bit veringert... dadurch steigt die Chance einen Treffer zu haben. brr (ja, da habe ich doppelten Code in zwei unterschiedlichen Klassen,
  das ist mir nun aber zu Riskant hier gr√∂√üere Umbauten zu machen da das praktisch jedesmal zur√ºckschl√§gt und dann auf einem anderen System einen
  totalausfall der Grafik produziert :/)



>> 03.08.2010
[CO]
- "TextureBufferRectangle::GetNumOfBytes": Warum auch immer wurde hier die Anzahl der ben√∂tigten Bytes anderst, und zwar scheinbar falsch, berechnet
  so das es bei mir dann abschmierte sobald ich einen Bildschirm-Modus wechsel vornehmen wollte bei dem die Texturen von der GPU zur√ºckgeladen werden



>> 27.07.2010
[CO]
- DrawHelpers::DrawImage() um Texture Matrize erweitert
- Parameter::GetValueTexture() nutzt nun TextureHandler::GetTexture() statt TextureHandler::GetResource() damit gehen auch Texture Animationen
- Animation um EventStart & EventStop Events erweitert



>> 25.07.2010
[CO]
PLRendererOpenGL:
- Log-Information wie z.B. "[Info]: Extension 'GL_ATI_separate_stencil' not found!" in
  "[Info]: Extension 'GL_ATI_separate_stencil' not found (nothing critical)" ge√§ndert da diese Log-Ausgaben bei PL-Problemen eigentlich immer
  erw√§hnt wurden ob dies das Problem sein k√∂nnte - ist es aber eigentlich nie da die Extensions Optional sind, z.B. fast alle. Dies ist eigentlich
  nur eine Information. (daher auch [Info])



>> 11.07.2010
[CO]
- "Font::Mipmapping" hinzugef√ºgt damit man einstellen kann ob beim Schrift zeichnen Mipmapping verwendet werden soll oder nicht -
  da die Schrift dadurch etwas vermatscht und oder transparenter als sonst r√ºber kommen kann, muss man soetwas von Au√üen einstellen k√∂nnen



>> 07.07.2010
[CO]
- "ProgramGenerator" um einen unsch√∂nen Hack erweitert der auf Wunsch die GLSL Precision Qualifiers im √ºbergebenen
  Shader Quellcode entfernen kann - Hintergrund ist, das auf Stefans Notebook mit NVIDIA GPU der Compiler fehler raushaut
  sobald Precision Qualifiers verwendet werden. Dies ist laut OpenGL Spezifikation allerdings ein Fehlerhaftes
  Verhalten + bei OpenGL ES 2.0 sollte man immer Precision Qualifiers nutzen - ich will aber m√∂glichst nur jeweils
  einen Shader f√ºr alles schreiben. Da so eine Quellcode Modifikation schnell nach hinten gehen kann, habe ich das daher
  nur in "ProgramGenerator" eingebaut. Ebenfalls wird in Vertex Shadern soetwas wie "out vec4 VertexColorVS;"
  durch "varying out vec4 VertexColorVS;" ersetzt.
- ProgramGenerator Konstruktor um Profile Parameter erweitert, die ich bei mir unter Cg immer angeben sollte da
  es sonst vorkommen kann das z.B. "discard" bei mir nicht mit GLSL Profile l√§uft



>> 04.07.2010
[CO]
- Dem Renderer kann man beim Erzeugen im Konstruktor nun noch optional die gew√ºnschte Default Shader Sprache √ºbergeben



>> 03.07.2010
[CO]
PLRendererOpenGL:
- Cg Shader f√ºr Font Rendering hinzugef√ºgt



>> 30.06.2010
[CO]
- "DrawHelpersBackend::DrawText()" stellt die Schrift wieder in der gleichen gr√∂√üe da wie fr√ºher so das erstmal alles wieder ok aussieht. (hoffentlich)
  Die Methode sollte man bei Zeiten nochmal kr√§ftig durchdenken - allerdings sind die Schrift gr√∂√üe relevanten Teile nun zum Gl√ºck nur noch
  in DrawHelpersBackend - die konkreten Renderer Implementationen arbeiten au√üschlie√ülich mit FreeType Schriftgr√∂√üen & Clip Space.
- Fonts: Auch Deutsche Umlaute gehen nun



>> 29.06.2010
[CO]
- MultisampleEnable Render State hinzugef√ºgt. Bei OpenGL (bei OpenGL ES 2.0 nicht) gibt es die M√∂glichkeit Multisample Antialiasing
  beliebig an/aus zu schalten. Bei Image Based Verfahren funktioniert Multisample Antialiasing nicht "automatisch" sondern man muss
  spezielle GLSL Befehle verwenden, die nur die aktuelleren Grafikkarten k√∂nnen. (und Cg/ATI Kombination geht nat√ºrlich schonmal hier
  auch nicht) Resultat ist, dass die Performance total mies ist wenn Multisample Antialiasing aktiv ist wenn der Deferred Scene Renderer
  verwendet wird - ohne das man einen Antialiasing Effekt hat. Daher hier nun diese M√∂glichkeit das gezielt zu deaktivieren - dies
  passiert in der Regel automatisch durch die Surface Klasse so das man sich nicht weiter drum k√ºmmern muss... sondern nur beim
  erzeugen eines Render Targets sagen muss ob man Multisample Antialiasing haben will, oder nicht.



>> 27.06.2010
[CO]
- DrawHelpersBackendShaders nutzt nun ebenfalls ProgramGenerator da der f√ºr "DrawImage()" ben√∂tigte Shader durch zahlreiche
  Features, die ben√∂tigt werden k√∂nnen, oder nicht, schon wieder zu kompliziert wurde
- Standardm√§√üig wird nun DrawHelpersBackendShaders als DrawHelpers Implementation verwendet, Shader sind einfach deutlich Handlicher
  und direkter als Fixed Functions
- CreateTextureBufferRectangle() gibt nun "TextureBuffer" zur√ºck, ob dies dann TextureBufferRectangle oder TextureBuffer2D
  ist h√§ngt von der Implementation ab. Hintergrund ist, das OpenGL ES 2.0 hier keinen Unterschied macht - und nun an zig Stellen in
  allen Codes Fallunterscheidungen zu machen w√§re doof. Das einfachste ist daher Rectangle Texturen in PixelLight weiterhin √ºber
  CreateTextureBufferRectangle() zu erzeugen, also weiterhin als eigenst√§ndige Texture damit es mit anderen API's l√§uft - die Implementation
  kann dann aber auch TextureBuffer2D zur√ºckgeben... und f√ºr den Rest ist es im Grunde eigenltlich immer egal da man den TextureBuffer
  Typ testet. Sollte der Typ dann TextureBuffer2D sein, wird es wie eine normale 2D Texture behandelt, das es intern dann auch mal eine
  none-power-of-two Texture sein kann, ist total wurscht weil weiterhin hier mit normalisierten Texture Koordinaten gearbeitet wird und
  in GLSL weiterhin sampler2D/texture2D verwendet wird. (OpenGL ES 2.0 kenn z.B. auch kein sampler2DRect/texture2DRect)
PLRendererOpenGLES:
- In Texturen Rendern ist noch nicht implementiert, daher sollte hier dann auch immer NULL zur√ºckgeben werden da man sonst z.B.
  durch aktives Shadow Mapping keinerlei Lichter mehr sieht da die Shadow Map nicht wirklich gef√ºllt wurde
- TextureBufferRectangle entfernt, TextureBufferRectangle l√§uft *g*



>> 26.06.2010
[CO]
- DrawHelpers: "DrawPlane()" aktualisiert
- DrawHelpersBackendShaders: Primitive (Punkt, Linie, Dreieck, Quad) lassen sich Darstellen. Somit ist es nun also auch unter
  OpenGL ES 2.0 m√∂glich zahlreiche Debug Visualisierungen zu sehen. :D
- DrawHelpers: "DrawImage()" als Ersatz f√ºr "DrawBitmap()" hinzugef√ºgt, leider mit zahlreichen Parametern - aber ich w√ºsste nicht
  was ich davon weglassen k√∂nnte ohne dann direkt den Nutzen einzuschr√§nken :(



>> 25.06.2010
[CO]
- Resource: Type-Enums umbenannt damit es keine Namenskonflikte mehr mit den dazugeh√∂renden Klassen gibt
- "Shader2" in "AbstractShader" umbenannt damit es keine Namenskonflikte mit der anderen "Shader" Klasse gibt
  die so glaub ich erstmal am besten drinnen bleibt.
- Beim erzeugen einer Renderer Instanz kann nun noch ein "Renderer Modus" eingestellt werden, so das es m√∂glich ist
  die verwendung von Fixed Functions, oder Shadern zu unterbinden - soweit vom Renderer unterst√ºtzt. Damit kann man z.B.
  Fixed Functions Support im OpenGL Renderer abschalten, das hilft beim Testen wie es ohne Fixed Function l√§uft - und
  gibt auch minimal bessere Performance da mit weniger Zust√§nden herumjongliert werden muss.
- DrawHelpersBackend in DrawHelpersBackendFixedFunctions und DrawHelpersBackendShaders unterteilt. Ein paar Dinge k√∂nnen
  direkt in DrawHelpersBackend f√ºr beides Implementiert werden, w√§re umst√§ndlich wenn man komplett alles immer neu Implementieren m√ºsste.
- "FixedFunctions::RenderState::Lighting" ist nun Standardm√§√üig aus... so wie es am h√§ufigsten verwendet wird und √ºbrigens auch
  die Default Einstellung von OpenGL ist
- DrawHelpers: "DrawPoint()", "DrawLine()", "DrawBox()", "DrawTriangle()" und "DrawQuad()" √ºberarbeitet. Wie schon bei Font muss
  auch hier nun die World Space Projection Matrize als Parameter √ºbergeben werden. Dadurch konnte nun an einigen Stellen die Verwendung
  von Fixed Functions entfernt werden und alles wird etwas √úberschaubarer vom Ablauf her.



>> 24.06.2010
[CO]
- Das bisherige PLRenderer Font Interface entfernt, auch "FontManager" im Grundordner + FTGL das wir nun nicht mehr nutzen
- FontManager ist nun ebenfalls Backend-Basierend, daher kann man eine Instanz davon nun √ºber Renderer::GetFontManager() erhalten...
  dabei wird eine Referenz zur√ºckgeben so das man weis das hier immer was g√ºltiges zur√ºckgegben werden muss - ansonnsten w√ºrde
  es in zuvielen unsch√∂nen NULL-Zeiger Abfragen im Code enden.
- Das neue Font Interface habe ich auf Basis dessen entwickelt was ich bereits f√ºr den OpenGL ES 2.0 Renderer in den letzten
  Tagen implementiert habe
- "2D Texte" werden zuk√ºnftig √ºber "DrawHelpers" (derzeitiges 2D Interface) gezeichnet. Font kennt nur frei im Raum platzierbare
  Texte, also das universelle. Ich denke so sind die Aufgaben besser verteilt.
- Die Font Implementation von PLRendererOpenGLES und PLRendererOpenGL ist fast identisch, nur das PLRendererOpenGL auch noch
  zus√§zlich Fixed Functions unterst√ºtzen muss



>> 21.06.2010
[CO]
PLRendererOpenGLES:
- Frei im Raum positionierbare Schriften funktionieren mittlerweile recht gut (was die Grundlage f√ºr alles weitere Darstellt da
  selbst "2D"-Schrift Polygone sind...)
- Auch das Darstellen von 2D Schriften funktioniert nun... als n√§chstes sollte dann das PLRenderer Font Interface neu aufgebaut
  werden da es etwas zugem√ºllt ist. Dies ist allerdings nix Technisches mehr, sondern nur noch eine reine Design-Frage. :D



>> 20.06.2010
[CO]
PLRenderer:
- Program: "EventDirty"-Event hinzugef√ºgt das ausgel√∂st wird wenn Attribute und Uniforms h√∂chstwahrscheinlich ung√ºltig werden.
  "ProgramGenerator" h√∂rt auf dieses Event und zerst√∂rt die Benutzer Daten zu einem erzeugten Program. Somit m√ºssen dann beim
  n√§chsten mal z.B. Uniforms und Attributes von neuem ermittelt werden. (aber immer noch besser als das in jedem Frame x mal
  zu machen! :)
PLRendererOpenGLES:
- Renderer::SetRenderState Implementation komplettiert
PLRendererOpenGL:
- Backup/Restore bei den neuen Shader Implementationen hinzugef√ºgt - damit ist nun auch nach einem Vollbildmodus wechsel noch
  alles da. Bei PLRendererOpenGLES habe ich kein Backup/Restore da ich z.B. keine Texture Daten zur√ºcklesen kann - wenn ganz, oder
  gar nicht, also bei OpenGL ES 2.0 gar nicht.
  Bei der Gelegenheit direkt das Shader Interface noch minimal erweitert.



>> 19.06.2010
[CO]
- ProgramGenerator: Das erzeugte Program wird nun in "GeneratedProgram" zusammen mit Zusatzinformationen gespeichert anstatt direkt
  ein Zeiger auf das erzeugte Program. "GeneratedProgram" hat ebenfalls "pUserData", dadurch kann man einem erzeugten Program noch
  Benutzereigene Informationen hinzuf√ºgen - z.B. etwas das direkte Zeiger auf alle Uniform & Attribute Parameter des Programs h√§lt
  so das man einen performanteren Zugriff darauf hat.
PLRendererOpenGLES:
- Cube Maps Implementiert - ok, das war fast nur ein r√ºberkopieren aus PLRendererOpenGL *g*
PLRendererOpenGL:
- "FrameBufferObject::Initialize()" Multisample Antiasing Support wieder aktiviert da es scheinbar mittlerweile soweit sauber l√§uft
  (hatte am 12.06.2010 ja etwas daran gearbeitet)



>> 17.06.2010
[CO]
- "PLGui::ProgressWindow" Nutzung entfernt. Das sollte, wenn √ºberhaupt, zuk√ºnftig √ºber Events laufen. (die gabs damals noch nicht :)
- "PreviewWindow" von PLRenderer nach PLEngine verschoben
- "WindowConnection", "RenderWindow" und "RenderFrame" von PLRenderer nach PLEngine verschoben
- "Renderer::GetDisplayModes()" entfernt da der "Mehrwert" praktisch nicht vorhanden war
-> PLRenderer und dessen Backends sind nun komplett unabh√§ngig von PLGui, das m√ºsste die Flexibilit√§t und Einsatzm√∂glichkeiten weiter erh√∂hen
PLRendererOpenGL & PLRendererOpenGLES:
- Jedesmal wenn ein Program aktiviert wird, wird nun glEnableVertexAttribArray f√ºr alle Attribute ausgef√ºhrt, wenn ein Program deaktiviert wird,
  wird hingegen glEnableVertexAttribArray ausgef√ºhrt. Wird dies nicht getan, so kann es schnell zu Konflikten mit Fixed Functions kommen.
  (*Kaputte Grafik*)



>> 16.06.2010
[CO]
- Die Renderer Backends nutzen kein PLGui mehr
PLRendererOpenGL:
- Da "OpenGLRenderContext" ein Krampf war, habe ich eine neue "Context" Klassen eingebaut - hatte genau soetwas schon vor Monaten nochmal f√ºr meine
  Bachelor sauber von 0 angefangen. "ContextWindows" f√ºr Windows l√§uft, "ContextLinux" hab ich soviel zusammengeraten wie ich konnte - wird aber
  sicherlich noch nicht laufen... ich hoffe aber das es weniger Arbeit macht das lauff√§hig zu machen als das alte "OpenGLRenderContext". :D



>> 15.06.2010
[CO]
- "ProgramGenerator" aus "PLCompositingShaders" nach "PLRenderer" verschoben, das ist etwas recht allgemeines das mitterweile auch recht ordentlich l√§uft



>> 14.06.2010
[CO]
- Renderer: Altes Shader Interface in einen "Depreciated shader interface" Block geschoben damit das alles √ºbersichtlich beisammen ist was bei
  Zeiten wegkommt
- "GetVertices()" und "SetVertices()" vom Renderer in das FixedFunctions Interface verschoben und in "GetVertexBuffer()" und "SetVertexBuffer()"
  umbenannt. Das zuweisen von Vertex Daten an Shader Attribute l√§uft mittlerweile bei Shadern √ºber ProgramAttribute ab. (was auch viel sch√∂ner
  und universeller ist :D)
- "GetIndices()" und "SetIndices()" in "GetIndexBuffer()" und "SetIndexBuffer()" umbenannt



>> 12.06.2010
[CO]
- Wow, OpenGL ES 2.0 kann sogar Multisample Antialiasing, dass muss nat√ºrlich genutzt werden da es die Bildqualit√§t deutlich steigert.
  (weiche Kanten und generell weniger bis kein Pixelrauschen mehr, insgesamt ein ruhigeres und Angenehmeres Bild :)
  Damit hier eine Initialisierung nicht fehlschl√§gt nur weil man z.B. einen zu gro√üen Samples Wert w√ºnscht, hab ich hier einige Fallbacks
  eingebaut. Im Gegensatz zu OpenGL kann man Multisample allerdings nicht ein/ausschalten wenns erstmal ausgew√§hlt wurde, aber das ist
  nicht wirklich schlimm. Ich hatte auch gepr√ºft ob man das pro Surface einstellen k√∂nnte, sprich, Surfaces mit anderen EGL Config Einstellungen...
  beim internen Dummy Fenster bekam ich einen Crash, und bei normalen Fenstern - sah ich nur M√ºll. Sprich, es darf scheinbar nur eine einzige
  EGL config f√ºr *alles* verwendet werden. (zumindestens beim Emulator) Hm, das macht die Entscheidung etwas einfacher wie man von au√üen
  Multisample Antialiasing Einstellt - und zwar beim PLRenderer initialisieren!
- Aufgrund der gemachten Multisample Antialiasing Erfahrungen in OpenGL ES 2.0 habe ich mich dazu entschlossen das Multisample Antialiasing
  Samples am besten als Parameter bei "RendererContext::CreateInstance()" √ºbergeben wird
- Auch bei OpenGL ist das so das wenn man einmal ein Fenster mit Multisample nutzt, alle anderen Fenster ebenfalls Multisample nutzen m√ºssen -
  hm, h√§tte schw√∂ren k√∂nnen das w√§re auch mal anderst gegangen. Ok, "DisplayMode::AntiAliasing" entfernt da witzos - Multisample Antialiasing
  wird nun also einmal beim Renderer Instanz erzeugen definiert, und dann wird das √ºberall so verwendet.
- Renderer: "Init()" und "DeInit()" -> unn√∂tig und gef√§hliche Methoden entfernt



>> 09.06.2010
[CO]
PLRendererOpenGLES:
- Sampler States eingebaut
- OpenGL ES 2.0 hat keinen Support f√ºr Occlusion Queries
- "Renderer::MakeScreenshot()" implementiert. Zuerst freute ich mich das dies ein 1:1 kopieren aus dem OpenGL Backend war... bis ich
  merkte, das glReadPixels nur einen Fehler zur√ºckgab. Unter OpenGL ES 2.0 unterst√ºtzt glReadPixels kein GL_RGB was ich bisher verwendete,
  daher √§nderte ich das in GL_RGBA, und auch im OpenGL Backend - speichert man das als png hat man nun also auch noch eine Alpha Maske was
  ja auch mal von Vorteil sein kann. Mache ich einen Screenshot von "Mipmaps.scene", welches einen "leeren" Hintergrund hat, so hab ich im
  png hier nun eine Transparenz - nett. Sollte das jemand mal nicht wollen, kann man den Alpha Kanal nachtr√§glich entfernen lassen.



>> 08.06.2010
[CO]
- Bis auf "Shader2": Die "2" aus den Namen des neuen Shader-Interfaces rausgenommen da es keine Konflikte gibt und es nun langsam an die
  Abschlussarbeiten geht... und es mehr Arbeit w√§re nun alles umzustellen, und dann sp√§ter nochmal die Namen anzupassen. :D
- Sampler Uniforms bekommen nun wie in Cg eine Texture Unit fest zugeteilt, so das man eine Texture nur einem Uniform zuweisen muss und
  der Rest intern automatisch gehandhabt wird. Das hat sich in der Vergangenheit als sehr Praktisch herausgestellt, die konkrete Texture
  Unit wird wie gehabt von der entsprechenden Methode als Parameter zur√ºckgegeben oder kann durch "GetTextureUnit()" ermittelt werden.
- ProgramUniform um etliche Methoden erweitert
- Etwas mit den OpenGL Shader Language Versionen auseinandergesetzt, dazu werden im Log nun vom Renderer die jeweiligen Versionen rausgeschrieben.
  OpenGL ES 2.0 unterst√ºtzt nur "#version 100", das aktuelle OpenGL unterst√ºtzt NICHT "#version 100". Laut OpenGL GLSL Spezifikation sollte
  man die Version immer dazuschreiben, im Internet findet man eigentlich dann auch fast nur GLSL Codes wo die Version immer dabei steht -
  das dumme ist hier allerdings das ich nicht zwanghaft zwei GLSL Shader Code Versionen machen will "nur" weil halt die Version ne andere ist.
  Solange es auch ohne Versionsangabe dann auf OpenGL ES 2.0 und mit OpenGL l√§uft, machen wir es so. Dazu schreibe ich aber immer ein entsprechendes
  Kommentar in die GLSL Codes so das man nicht sp√§ter mal denkt "huch, da sollte aber ne Versionsinfo" rein, sich dann freut das man sich nun
  an die Spefizikation h√§lt, und dann irgendwann sp√§ter erst merkt das nun bei der anderen OpenGL Version nun gar nix mehr geht. Mal schaun
  wann dann bei den Scene Renderer Schritten der Punkt kommt wo ich unterschiedliche GLSL Codes schreiben muss da ich Features nutzen will/m√ºsste
  die erst die neueren Sprachen haben. Da muss ich mir dann wohl jeden Punkt anschaun - z.B. glaub ich nicht das es dann lohnen w√ºrde z.B. f√ºr
  SSAO Shader OpenGL ES 2.0 Versionen zu schreiben... denn damit w√§ren die kleinen Maschienchen eh total √ºberfordert + k√∂nnen auch kein MRT was
  ich f√ºr Deferred Rendering aber nutze, und z.B. SSAO nutze ich auch nur beim Deferred Renderer. Da muss man dann wohl immer Ordentliche
  Kommentare verfassen damit klar ist wie was. :D
  Ich hoffe das l√§uft so dann ohne Versionsangaben auch direkt z.B. auf dem Nokia N900, nicht das der Emulator hier zu nett zu mir ist. *g*
- Die abgeleiteten Renderer-Klassen hei√üen nun ebenfalls "Renderer", das macht deren Verwendung etwas angenehmer da man nicht immer
  "PLRendererOpenGLES::RendererOpenGLES" und "PLRendererOpenGL::RendererOpenGL" schreiben muss sondern nur noch z.B.
  "PLRendererOpenGLES::Renderer" - damit kann man etwas komforabler √ºber z.B. die Konfigurations-Datei den Renderer wechseln ohne immer darauf
  achten zu m√ºssen das man alles anpasst. Damit ist das nun konsistent zu den anderen Backend-Klassen - fr√ºher ging das leider nicht anderst
  da das alte RTTI keine Namespaces unterst√ºtzte. :D
  -> ACHTUNG: Sicherheitshalber die "cfg" Dateien l√∂schen damit nun kein ung√ºltiger Renderer angegeben wird.
  -> Die anderen Backend-Systeme sollten am besten genauso angepasst werden, das mit der Namespace nutzung ist einfach viel sch√∂ner und
     Handlicher :D



>> 07.06.2010
[CO]
- Die Geometry-Shader Implementation ist korrekt, die Nutzung im Beispiel war falsch... nat√ºrlich muss man auch hier schaun das die Daten
  sauber von der Vorstufe aufgenommen, und an die Nachstufe weitergegeben werden.
- "ShaderToolsGLSL::WriteProgramInformationIntoLog" war nicht ok... hm, das kommt eher selten vor das sich Dinge die fr√ºher Extensions waren
  und dann in den Kern √ºbernommen wurden sich anderst verhalten und andere Funktionen da sind :/
- Wird der Shader Quellcode mit "SetSourceCode" gesetzt, so kann man nun ebenfalls das Profile als String √ºbergeben - eigentlich nur f√ºr Cg
  relevant! Als Standard Profile nutzte ich bei Cg die GLSL Profile da ich so auch auf meiner ATI Karte ordentliche Shader schreiben kann -
  denn ansonnsten kann ich nur die ersten primitiven Shader Generationen auf meiner ATI Karte nutzen - der Rest geht *nat√ºrlich* nur auf
  NVIDIA Karten. Das war noch ein weiterer Grund wieso ich Cg nicht mehr als Hauptshadersprache haben will - als ATI Nutzer f√ºhle ich mich
  da etwas ver√§ppelt. *g*
  Mittlerweile l√§uft auch "glslv" korrekt... der Trick bestand darin "cgCombinePrograms2" zu nutzen was in Cg 1.5 eingef√ºhrt wurde... sprich,
  die einzelnden Cg Programme werden zu einem Cg Program zusammengematscht - Cg intern wohl u.a. wegen GLSL das nur ein gemeinsames Programm
  kennt. Nett. Das fand ich nun eher per Zufall. Sprich, das aktuelle PL Shader-Interface ist sehr gut so - da man einfach ein gesamt Programm
  braucht wenn es auf sovielen APIs wie m√∂glich laufen soll.
  Cg ist irgendwie Horror, ich habe nun etliche Stunden damit verbracht zu Analysieren wie sich was verh√§lt, denn die Cg-Dokus sind eher schwach
  und im Internet gibts meist auch keine Antworten auf meine speziellen Fragen. Sobald GLSL Profile verwendet werden, bricht in Cg die H√∂lle aus
  und einiges verh√§lt sich schlichtweg anderst! Ich habe mir nun selbst zusammengereihmt das die Fau√üregel ist "Ein Shader mit GLSL, alles GLSL!".
  Ich habe entsprechende Log Fehlernachrichten eingebaut wenn man versucht Shader Profile zu mischen so das man nicht wie ich nun Stundenlang braucht
  um Fehlerquellen zu finden! Wenn man also nun ein GLSL Program hat, ein "Cg Combined Program", kann man z.B. mit "cgGLIsProgramLoaded" direkt
  testen ob alles geklappt hat. Verwendet man aber nicht GLSL, so geht "cgGLIsProgramLoaded" intersanterweise nicht, und man muss dann die Unterprogramme
  aus dennen sich das "Cg Combined Program" zusammensetzt einzelnd abtesten.
  Weitere Stunden gingen f√ºr den Cg Shader von SPTriangleShaders drauf - denn sobalg GLSL Profile genutzt werden, lassen sich auf einmal die Shader
  nicht mehr √ºbersetzen wenn man nicht unversch√§mt strickte Regeln einh√§lt. Z.B. d√ºrfen Attribute wie Vertex Positionen dann nicht mehr frei mit
  z.B. "ATTR0" gekennzeichnet werden, nein, dann MUSS die Semantic auf einmal "POSITION", "COLOR" etc. sein. Das Spielchen mit den Semantics geht
  an anderen Stellen so weiter - so das hier wieder alles etwas Altbacken wirkt da man scheinbar mit Festverl√∂teten Daten-Bedeutungen arbeitet.
  Hat ja alles vor und Nachteile mit den Semantics, z.B. muss Cg ja wissen wie die einzelnden Daten Pipelines zusammengest√∂ppelt werden, ist aber einfach
  ein zu GLSL anderer Ansatz wo man sich Gedanklich dann immer Umstellen muss.
  Das ist im naiven GLSL, also nicht Cg, alles viel sch√∂ner, da GLSL Attributen keine feste Bedeutung unterstellt - das einzige was "fest" ist, ist
  die Vertex-Position... denn die Vertex Position wird dazu verwendet um ein Dreieck zu Rasterisieren... hier muss die Hardware also wissen wo die
  Vertex Positionen zu finden sind. Alle anderen Datenstr√∂me braucht die GPU nicht zu interessieren!
  Gefreut habe ich mich dar√ºber das es Funktionen wie "cgGetProfileProperty(m_pCgProfile, CG_IS_VERTEX_PROFILE)" gibt mit denen man Pr√ºfen kann ob
  der Benutzer f√ºr einen Vertex Shader ein Profil angibt das nicht f√ºr Vertex Shader ist... geflucht hab ich als ich merkte das sobald "CG_IS_OPENGL_PROFILE"
  ja sagt, "CG_IS_VERTEX_PROFILE" etc. nicht gesetz sind so ich per Hand auf z.B. "CG_PROFILE_GLSLV" hin pr√ºfen muss. Na also wirklich brauchbar
  sind diese Eigenschaften ja dann doch irgendwie nicht wann man am Ende dann wieder individuelle Profile in die Hand nehmen muss. (von dennen es in Cg
  so einige gibt und regelm√§√üig neue hinzukommen...)
  Geometry-Shader in Cg zum laufen zu bringen war nat√ºrlich genauso wenig lustig... umso mehr froh bin ich das nun scheinbar alles soweit l√§uft und
  das PL Shader-Interface einiges vom Cg Horror intern verbergen kann. Z.B. hab ich nirgends eine wirkliche Dokumentation f√ºr die Geometry-Shader
  gefunden. "emitVertex" sieht man oft, aber dann kam die Frage auf wie man denn nun ein neues Primitive anf√§ngt, √ºber Umwege fand ich dann
  "restartStrip". Dann wollte ich es wissen und durchsuchte nochmal das Cg-SDK... da liegt ein Dokument "Cg-2.0.pdf" bei, das sind Folien einer
  Pr√§sentation, "restartStrip" taucht dort als Randnotiz auf einer Folie auf. Also offen gesagt, das ist schlichtweg Unprofessionel, das kann man
  doch nicht bringen f√ºr soetwas wie Cg eine derart schlampige Dokumentation zu haben. *gruml*
- Wird der Shader Quellcode mit "SetSourceCode" gesetzt, so kann man nun auch den Einstiegspunkt als String √ºbergeben. GLSL kennt soetwas
  nicht, Cg aber schon. Standard ist "main".



>> 06.06.2010
[CO]
- Geometry Shader hinzugef√ºgt, das ist etwas was heute umbedingt da sein sollte - damit hatte ich schon w√§hrend meiner Bachelorarbeit etwas
  herumgespielt. Irgendwie schl√§gt aber momentan das Program linken ganz ohne Fehlermeldung fehl sobald ich einen Geometry Shader nutzen will,
  hm, das muss ich mir genauer anschaun. Aber f√ºr's erste sind schonmal die Geometry Shader Klassen drinnen.
PLRendererOpenGL:
- GLSL Implementation f√ºr das neue Shader-Interface hinzugef√ºgt. Im Grunde musste ich nur das was ich f√ºr OpenGL ES 2.0 machte r√ºberkopieren,
  und dann die OpenGL Funktionen anpassen da hier GL_ARB_shader_objects & GL_ARB_vertex_shader verwendet wird. Uff, GL_ARB_shader_objects war
  einiges an Flei√üarbeit bis alle Funktionen eingebunden waren. Schade das man hier in verschiedenen Projekten fast identsichen Code hat, aber
  mit Kopieren arbeiten muss damit das kein Chaos gibt. :/
  Die SDK Demos PLDemoRendererTriangle und PLDemoMeshTeapot laufen nun auch mit PLRendererOpenGL unter GLSL. Hier also absolut keinen Unterschied
  ob gerade OpenGL ES 2.0 oder OpenGL verwendet wird, GLSL ist GLSL. Das ist wohl ein weiteres Argument daf√ºr das GLSL zuk√ºnftig unsere
  Hauptshaderprache wird.
- Cg Implementation f√ºr das neue Shader-Interface hinzugef√ºgt



>> 05.06.2010
[CO]
PLRendererOpenGLES:
- TextureBuffer2D implementiert, ist fast genauso wie beim OpenGL Backend, nur das man Texturen nicht mehr von der GPU herunterladen kann
  und es keine DXT Kompressions Formate gibt (... daf√ºr ein anderes Kompressions Format...)



>> 04.06.2010
[CO]
PLRendererOpenGLES:
- Leider braucht auch OpenGL ES immer ein gesetztes Fenster, sonst gehen Anfragen ins Leere (auch wenn diese eigentlich im Context
  gespeichert werden...)



>> 03.06.2010
[CO]
- Schnittstellen ProgramAttribute & ProgramUniform hinzugef√ºgt, das erstere um Vertex Eingabestreams setzen zu k√∂nnen, das zweite
  f√ºr die Program Parameter. Auch hier orientierte ich mich wieder an OpenGL & GLSL, das m√ºsste sich dann recht einfach auf Cg
  und sicherlich auch HLSL √ºbertragen lassen und z.B. auch bei Cg werden Program Parameter im Shader Code mit "uniform" gekennzeichnet -
  von der Terminology her ist das also stimmig. :D



>> 02.06.2010
[CO]
- Neue Funktion "VertexBuffer::GetVertexAttribute" die ein Vertex Attribute anhand Semantic zur√ºckgibt
- Mit dem neuen Shader-Interface begonnen, ich nenne alles erstmal "VertexShader2" und so weiter. Beim Design und den Namen versuche
  ich mich soweit wie m√∂glich an GLSL zu halten da dies wohl unsere Hauptshadersprache wird - und z.B. Cg kennt kein "Program" Objekt
  in dem Sinne wie GLSL, von daher wird am Ende z.B. Cg wohl einfacher zu implementieren sein da das "Program" Objekt dort dann im
  grunde nur eine Vertex & Fragment Shader Sammlung ist, aber ohne das das "Program" noch "gelinkt" werden m√ºsste. Die Methode
  "Renderer::SetVertices" wird es Zuk√ºnftig wohl nicht mehr geben, bzw. nicht mehr im Hauptinterface. (f√ºr Fixed Function wohl schon
  noch) Mittlerweile ist das alles viel offener und Dynamischer und z.B. "Vertex Shader Attribut" und "Vertex Buffer Attribut" werden
  nur "verlinkt". Ich mache diesmal auch direkt "VertexShader" etc. Klassen damit das sauberer ist als vorher wo alles √ºber eine
  gemeinsame "Shader" Klasse lief. Insgesamt versuche ich die Shader Interfaces & Implementationen so direkt und leichtgewichtig wie
  m√∂glich zu machen - das ist sehr Grundliegend, und ich denke gerade bei Mobilen Ger√§ten sollte man darauf achten nicht unn√∂tig viel
  Overhead einzubauen wenn sich das auch umgehen l√§sst.



>> 31.05.2010
[CO]
- "RendererBackend" und "DrawHelpersBackend" liegen nun direkt in PLRenderer



>> 30.05.2010
[CO]
- Nutzung von "glGetError" entfernt, das sollte im Allgemeinen nur f√ºr konkretes Debugging verwendet werden und in den meisten F√§llen
  war die Verwendung von "glGetError" ohnehin nicht korrekt da wenn ein Fehler gefunden wurde, keine weiteren Fehler registiert werden
  bis der Fehler abgefragt wurde.



>> 29.05.2010
[CO]
- IndexBuffer: UByte wird als Index Datentyp nun ebenfalls unterst√ºtzt. UInt wird von OpenGL ES 2.0 nicht unterst√ºtzt,
  daf√ºr wird UByte von DirectX 9 nicht unterst√ºtzt - UShort scheint das Format zu sein, das auf allen bisher unterst√ºtzten
  Grafik-API's l√§uft. Daher ist UInt nun nicht mehr der Default-Wert, sondern UShort damit es m√∂glichst immer sofort l√§uft
  wenn man das mal von Hand f√ºllt. (was in der Praxis eigentlich eher seltener vorkommt)
PLRendererOpenGLES:
- Mit der konkreten OpenGL ES 2.0 Implementation begonnen
- (Fensterloser) Context wird erzeugt und zerst√∂rt. Das geht mit der OpenGL ES API viel angenehmer als mit der alten OpenGL API. :D
- Renderer: SetViewport, SetScissorRect, SetColorMask, Clear, SetIndices und SetVertices implementiert, diese sind fast komplett
  identisch zu den OpenGL Implementationen
- Renderer: DrawPrimitives und DrawIndexedPrimitives implementiert. Prinzipiell identisch mit den OpenGL Implementationen, nur das es
  bei OpenGL ES 2.0 viel weniger 'Draw'-Varianten gibt, so das der Code zwanghaft kompakt bleiben muss.
- IndexBuffer implementiert. Praktisch identisch zu OpenGL, nur das Index Buffer in OpenGL ES 2.0 so direkt implementiert sind und
  man daher nicht √ºber Extensions gehen muss. "MapBuffer" l√§uft weiterhin √ºber Extensions, wird aber eher selten bis gar nicht genutzt
  da wir normalerweise dann direkt den Buffer Inhalt Host Seitig Buffern.
- VertexBuffer implementiert. Der Kern ist praktisch identisch zu OpenGL, nur das Vertex Buffer in OpenGL ES 2.0 so direkt implementiert
  sind und man daher nicht √ºber Extensions gehen muss. "MapBuffer" l√§uft weiterhin √ºber Extensions, wird aber eher selten bis gar nicht
  genutzt da wir normalerweise dann direkt den Buffer Inhalt Host Seitig Buffern. Ein zuweisen der Vertex Daten an Shader Attribute l√§uft
  nat√ºrlich etwas anderst ab als fr√ºher bei Fixed Functions - aber dieser Code stand ohnehin schon l√§nger auf meiner Refactoring Liste und
  jetzt hab ich nen Grund das endlich mal zu √ºberarbeiten damit es besser zu den modernen Grafik-API's passt. (und trotzdem auch noch mit
  Fixed Function l√§uft)



>> 03.05.2010
[SB]
- TextureBuffer::FixNANValues(): Da die Umwandlung von float in half noch nicht funktioniert, kan der √ºbergebene
  Farbwert nat√ºrlich nicht konvertiert werden, hier kommt also immer 0 heraus. Das macht diese Funktion noch ziemlich
  nutzlos, denn "schwarz" anstelle von "schwarz" ist, naja, ... Habe darum erstmal hier feste Werte eingebaut, die
  Rot ergeben sollten. Neim Setzen der Farbe gab es auch noch einige kleine Fehler. Allerdings scheint die Methode dennoch
  nicht zu funktionieren, es ist jedenfalls nichts zu sehen, wenn ich das aufrufe (vermute, dass das eher daran liegt,
  dass die Textur nicht geupdatet wird, als am Farbwert).



>> 01.05.2010
[CO]
- TextureBuffer: Statische Funktionen GetComponentsPerPixel(), GetBytesPerPixelComponent() und GetBytesPerPixel() hinzugef√ºgt. Damit sich
  das genauso verwenden l√§sst wie PLGraphics::ImageBuffer bleibt "Pixel" hier im Namen - eine Unterscheidung in Texel/Voxel w√§re eine
  unn√∂tige verkomplizierung.
- TextureBuffer::GetNumOfComponents() in TextureBuffer::GetComponentsPerPixel() umbenannt und weitere Funktionen GetBytesPerPixelComponent()
  und GetBytesPerPixel() hinzugef√ºgt damit sich das genauso verwenden l√§sst wie PLGraphics::ImageBuffer
- TextureBuffer::IsCompressedFormat(), TextureBuffer::GetUncompressedFormat() und TextureBuffer::IsFloatingPointFormat() hinzugef√ºgt
- Renderer::IsTextureBufferPixelFormatCompressed() entfernt, daf√ºr gibts nun TextureBuffer::IsCompressedFormat()
- Renderer::GetTextureBufferPixelFormat() nach TextureBuffer verschoben und in GetFormatFromImage() umbenannt
- Neue Funktion TextureBuffer::GetNumOfFaces()
- Neue Funktion TextureBuffer::GetNumOfNANValues(): F√ºr Flie√ükommezahlen Formate kann man hiermit die Anzahl der NANs in der Texture zusammenz√§hlen
  lassen. Funktioniert im Augenblick noch nicht f√ºr 16 Bit Flie√ükommazahlen (half)... daher f√ºr den DOF Bug Test im "Begin" Render Schritt ein 32 Bit
  Flie√ükommazahlen Ziel einstellen. (ist unabh√§ngig von "Float32" in "SRPDeferredGBuffer")
- TextureBuffer::GetNumOfNANValues() nutzt die neue PLMath::Half-Hilfsklasse, nun funktioniert auch der Test bei 16 Bit Flie√ükommazahlen Texturen
- TextureBuffer::FixNANValues() hinzugef√ºgt, ist √§hnlich zu TextureBuffer::GetNumOfNANValues(), ersetzt gefundene Pixel die irgendwo ein NAN haben
  jedoch direkt durch eine √ºbergebene Farbe und l√§d am Ende den "geflickten" Buffer wieder hoch. Damit w√ºsste man zumindestens das nach einem Aufruf
  dieser Funktion der Buffer nur g√ºltige Werte hat - k√∂nnte helfen NAN Fehler weiter einzugrenzen da weniger Ungewissheiten.



>> 18.04.2010
[CO]
- WindowConnection, RenderFrame, RenderWindow, PreviewWindow, SPDefault und SPDefault vom "Renderer"-Verzeichnis in den Grundordner von PLRenderer
  verschoben. Im "Renderer"-Verzeichnis sollten eigentlich nur Backend-Relevante Dinge liegen, also der Technische Kern. Die verschobenen Klassen
  sind hingegen bereits Klassen die auf dem System aufsetzen um es noch einen Tick einfacher nutzbar zu machen. Alles was man also braucht um sich
  einen "Renderer" zu erzeugen liegt nun im Grundverzeichnis.
- WindowConnection::SetToggleFullscreenMode() k√ºmmert sich nun um die Registrierung der Hot-Keys
- WindowConnection-Konstruktor: Da ein PLGui Content-Window die Nachrichten nur an sein Parent weiterleitet, muss man leider im Falle von PLGui::Frame
  die Ereignisse von PLGui::Frame und nicht vom Content-Window abgreifen :/
- WindowConnection: Da ich gerade schon wieder dar√ºber gestolpert bin, speichert WindowConnection nun selbst den aktuellen Vollbild-Modus so das man
  das interne Surface l√∂schen kann, aber immer noch korrekte verwendete Einstellungen ermitteln kann.



>> 17.04.2010
[CO]
- Das meiste aus RenderFrame liegt nun in der neuen Klasse WindowConnection. RenderFrame und RenderWindow sind beide davon abgeleitet, dadurch sind
  beide Klassen nun fast leer was aber auch gut so ist. Diese zwei Klassen sollten nur "erweiterte" GUI Elements sein die man nutzen *kann* um
  direkt ein GUI Element Instanzieren zu k√∂nnen in das was gerendert wird. Auch ist endlich der Code nicht mehr doppelt was mich nun schon einige
  male etwas St√∂rte - das bedeutet aber, das man Prinzipiell auch ein RenderWindow in einen Vollbild-Modus versetzen kann. Dies finde ich aber ok
  denn das k√∂nnte durchaus mal ben√∂tigt werden. (z.B. um ein Render-Fenster in einem Editor in den Vollbild-Modus zu schalten wie wir es vor langer
  laaaaaannger Zeit mal in PixelLab hatten :)
  WindowConnection m√ºsste es nun auch etwas Einfacher machen ein PixelLight Render Fenster in eine andere Anwendung einzubetten... den Nativen OS
  Fenster Handle verpackt man dann wie gehabt in NativeWindow, und √ºbergibt dieses dann WindowConnection. Ein weiteres GUI-Fenster wird also intern
  nicht mehr zwangsl√§ufig erzeugt. Daher war ein Design-Ziel von WindowConnection auch, das es m√∂glichst GUI unabh√§ngig ist und wenn irgend m√∂glich
  nichts am √ºbergebenen GUI Fenster manipuliert. Wenn beispielsweise in den Vollbild-Modus geschaltet wird, ist es der Job von beispielsweise
  RenderFrame sich darum zu k√ºmmern das das GUI Fenster links oben plaziert und auf die richtige gr√∂√üe gesetzt wird. Auch ob der Fensterrahmen
  sichtbar sein soll oder nicht ist nicht Job von WindowConnection.
- RenderFrame: "sTitle"-Parameter aus dem Konstuktor entfernt, das bringt hier nicht wirklich viel an Mehrnutzen und bl√§ht das Interface nur
  unn√∂tig auf
- PLRendererOpenGL: Bugfix: Wenn Mipmaps nicht bis 1x1 Definiert sind, werden die restlichen Mipmaps automatisch erzeugt da dies n√∂tig ist... allerdings
  wurde m_nTotalNumOfBytes nicht aktualisiert
- TextureBuffer3D & TextureBuffer2D: GetSize(): Autsch, die kleinste Mipmap wurde nicht richtig zur√ºckgegeben und konnte auch mal 0x1 oder so sein
  was ja nicht sein kann -> Der Fehler ist am 05.04.2010 reingekommen wo ich auf PLMath::Vector2i umgestellt habe.



>> 14.04.2010
[CO]
PLRendererOpenGL:
- FrameBufferObject: Depth&Stencil Support l√§uft, zumindestens √ºber die GL_EXT_packed_depth_stencil-Erweiterung die man nutzen kann wenn man
  mit 24 Bit Tiefenbuffer und 8 Bit Stencilbuffer auskommt. Interessanterweise ging ein *seperater* Stencilbuffer immer noch nicht und ich konnte
  im Netz auch kein einziges laufendes Beispiel sehen das GL_EXT_packed_depth_stencil nicht nutzt.



>> 13.04.2010
[CO]
- Transform State √Ñnderungen von gestern komplettiert... hui, das zog wirklich einige (kleine und immer gleiche :) Anpassungen in anderen Projekten
  nach sich da an vielen Stellen wo etwas gezeichnet wird derzeit direkt Fixed Function Zeug genutzt wird. Durch die Entfernung der Semantics aus
  Effect gehen derzeit ein paar Effekte wie z.B. "Volumetric Line" nicht. Daher werd ich heute mal schaun wo/wie ich Fixed Functions Nutzung
  einschr√§nken kann bzw. es so zu √§ndern das es mit und ohne Fixed Functions l√§uft. (vorher macht es auch weniger Sinn z.B. sofort mit OpenGL ES
  anzufangen)
  Wie man am besten *bekannte* Effekt Shader Parameter setzt werd ich mir auch anschaun. Wird wohl darauf hinauslaufen das Scene Renderer das machen
  und Stellen die direkt zeichnen ohne √ºber Scene Renderer zu gehen - aber in PLRenderer selbst sollte soetwas nicht mehr fest eingebaut sein, das
  ist einfach zu Chaotisch. :D



>> 12.04.2010
[CO]
- RenderState::ShadeMode nach FixedFunctions verschoben
- In OpenGL 3 und DirectX 10 wurden Clip Planes durch einfachere Clip Distances ersetzt die zumal anderst Verwendet werden. IsClipPlaneEnabled(),
  SetClipPlaneEnabled(), GetClipPlane() und SetClipPlane() daher nach FixedFunctions verschoben. Clip Distances bau ich aber erstmal nicht ein
  da wir das derzeit nicht ben√∂tigen.
- Ok, "Alpha-Test" scheint es bei den modernen Grafik-APIs ebenfalls nicht mehr zu geben. Hm, ok, dann geht das wohl zuk√ºnftig *nur* noch dar√ºber das
  man in seinem Fragment-Shader selbst einen Alpha-Test realisiert und dann √ºber "discard" (texkill) Fragmente verwirft. Gut, dann ist die Frage ob man
  lieber Alpha-Test oder "discard" verwendet gekl√§rt. *g*
  Alpha-Test durch "discard" sollte weiterhin sparsam Eingesetzt werden da es laut diverser Quellen Tiefenbuffer Optimierungen deaktiviert.
  (z.B. laut http://developer.amd.com/media/gpu_assets/Depth_in-depth.pdf Early-Z... aber nur wenn man gerade auch in den Tiefen-Buffer schreibt)
  RenderStates AlphaTestEnable, AlphaFunc und AlphaRef nach FixedFunctions verschoben und die letzten zwei States in AlphaTestFunction und
  AlphaTestReference umbenannt damit das vom Namen her klar ist wozu das geh√∂rt.
- VertexBuffer: GetColor() und SetColor() arbeiten nun mit PLGraphics::Color4
- TextureBuffer: GetPriority(), SetPriority() entfernt da scheinbar bei allen aktuellen Grafik-APIs (OpenGL 3, OpenGL ES, DirextX 10>) Depricated
  oder bereits weg - selbst genutzt hatten wir das eigentlich nie
- GetColor() und SetColor() nach FixedFunctions verschoben und auf PLGraphics::Color4 umgestellt
- Renderer: ModifyProjectionMatrix() entfernt, nutzten wir schon seit einer Weile nicht mehr und soetwas sollte zuk√ºnftig nicht mehr direkt
  in PLRenderer sein
- Renderer: ResetTransformStates(), GetTransformState() und SetTransformState() nach FixedFunctions verschoben
- ShaderProgramCgBackend: BindSemanticParameters() und RefreshSemanticParameter() entfernt, das zog nochmal eine ganze Reihe von √Ñnderungen nach sich.
  Auch wenn das fr√ºher mal ganz nett war, passt dies nun einfach soetwas von √ºberhaupt nicht mehr ins Konzept. Es machte in PLRenderer vieles zu
  kompliziert und inperformant... PLRenderer muss zuk√ºnftig "Leichtgewichtiger" sein wenn wir auch soetwas wie OpenGL ES unterst√ºtzen wollen.
  Das mit den "Benutzer Shader √ºber Effekte" klappt mit dem Scene Renderer Konzept ohnehin nicht mehr so richtig dolle, da muss ich mir bei Zeiten
  wohl was neues ausdenken, falls dies wirklich n√∂tig werden sollte. (was ich zumindestens derzeit nicht sehen kann)



>> 10.04.2010
[CO]
- Renderer: Begin2DMode(), Is2DMode(), Get2DMode(), End2DMode(), Get2DZValue(), Set2DZValue() und DrawBitmap() nach DrawHelpers verschoben. Bisher war
  das ja irgendwie nett mit einem "2D-Modus", aber jetzt mit Shadern wirkt das irgendwie nur noch Umst√§ndlich. Das hab ich gerade in den letzten
  Wochen gemerkt als ich viel im "Image-Space" gearbeitet habe - da ist es einfacher wenn man auf all die World, View, Projektion und so weiter
  Matrizen verzichtet und *direkt* Clip-Space Koordinaten √ºbergibt ohne wenn und aber. Zuk√ºnftig sollte man das also h√∂chstens noch f√ºr
  "mal schnell was ausprobieren" nutzen, ansonnsten sollte man das entweder selbst richtig machen, oder √ºber Hilfs-Klassen wie "PLScene::FullscreenQuad"
  die im Grunde fast schon die "DrawBitmap()"-Funktionalit√§t ist... aber auf einer h√∂heren Ebene und mit deutlich mehr Einflussm√∂glichkeiten.
  Wie auch bei den anderen DrawHelpers-Funktionen wird das allerdings derzeit noch hier und da ersthaft genutzt und ich habe alles nur soweit
  angepasst das es noch √ºbersetzbar ist und l√§uft. Die Stellen muss ich mir dann im einzelnden anschaun und aktualsieren - so das am Ende dann
  auch *alles* l√§uft wenn das "FixedFunctions"-Interface nicht vorhanden ist. (sprich, auch alles sauber unter OpenGL ES l√§uft!)
- Renderer: GetLineWidth() und SetLineWidth() zu RenderState gemacht (hey, und das ist sogar noch Bestandteil von OpenGL 3>=!... auch wenn es bereits
  auf der Abschussliste steht *g*)
- DrawHelper-Funktionen haben nun Farbe als Parameter da hier SetColor() ohnehin schon ohne Wirkung war und man SetColor() nur noch wirklich f√ºr reine
  Fixed-Function Draw-Calls nutzen sollte
- Font::Draw() muss man nun die Farbe √ºbergeben



>> 09.04.2010
[CO]
- DrawPoints2D(), DrawPoints3D(), DrawLines2D() und DrawLines3D() entfernt, diese Funktionen sind einfach nur daneben da totaler Overkill und
  umst√§ndlich. Will man viele Punkte und Linien zeichen, sollte man wirklich wirklich einen Vertex Buffer anlegen, das ist nicht sooo viel
  Arbeit und deutlich sauberer und Effizienter. DrawPoint() und DrawLine() hingegen sind noch ok, wenn man f√ºr Debugging mal schnell was kleines
  anzeigen will. (aber wirklich nur f√ºr Debugging bzw. Debugging Visualisierung, ein Draw-Call pro Element, das geht einfach nicht :)
- Neues Interface "DrawHelpers". DrawPoint(), DrawLine(), DrawTriangle(), DrawQuad(), DrawBox() und DrawPlane() hierhin verschoben. Das sind alles
  Dinge die man eigentlich nur "mal schnell was ausprobieren" oder "kleine schnell realisierte Debug-Visualisierung" nutzen solle, aber NIEMALS
  ernsthaft f√ºr richtige Grafik. (auch wenn das derzeit noch an wenigen Stellen so ist) Daf√ºr ist es schlichtweg zu Ineffektiv einzelnde Elemente
  zu zeichen + auch viel zu Einschr√§nkend da man keine Texture Koordinate, Vertex Farben und und und und angeben kann. (w√§re auch der totale Overkill
  wenn man das alles in den Funktionen bieten wollte :)
  Auch hier heist die Diverse: Lieber einen kleinen eigenen Vertex Buffer anlegen, mit Daten f√ºllen und dann auf einen Schlag zeichnen lassen.
  Im Renderer-Interface kommt man √ºber die Funktion "GetDrawHelper()" an dieses Helper-Interface... hier wird eine Referenz zur√ºckgegen da das
  Objekt *immer* g√ºltig sein sollte, es w√§re etwas am "schnell und einfach was ausprobieren"-Sinn vorbei wenn man erst Pr√ºfen m√ºsste ob der
  Zeiger √ºberhaupt g√ºltig ist.



>> 08.04.2010
[CO]
- "FixedFunctions"-Schnittstelle begonnen - hierhin werde ich nun Schrittweise alle Funktionalit√§ten verschieben die fr√ºher in Grafik-APIs und GPUs
  fest Verdrahtet waren, heute aber universell und frei √ºber Shader realisiert werden. Dinge die es in DirectX 10 nicht mehr gibt, und in OpenGL 3.0
  Depreciated sind. Renderer Backends sind nicht gezwungen das Interface zu Implementieren - z.B. PLRendererOpenGLES wird es nicht implementieren.
- GetDefaultMaterialState(), ResetMaterialStates(), GetMaterialState(), SetMaterialState() nach FixedFunctions verschoben
- ShaderProgramCgBackend: Die "Verdrahtung" von Fixed-Function Render States und Shadern werd ich nun ebenfalls Schrittweise rausnehmen, das ist aus
  heutiger Sicht einfach nur noch d√§mlich und umst√§ndlich und viel zu Einschr√§nkend. (haben wir eh nie ernsthaft genutzt) Entweder nutzt man Fixed-Function,
  oder gleich saubere Shader basierende Konzepte.
- GetDefaultLightSettings(), ResetLights(), IsLightEnabled(), SetLightEnabled(), GetLight(), SetLight() nach FixedFunctions verschoben
- Lighting, Ambient, NormalizeNormals von "RenderState" nach "FixedFunctions::RenderState" verschoben
- FogEnable, FogColor, FogDensity, FogStart, FogEnd, FogMode von "RenderState" nach "FixedFunctions::RenderState" verschoben
-> Achtung: In plfx-Dateien muss nun z.B. "Lighting" in "FixedFunctionsRenderStates" und nicht mehr "RenderStates" stehen
   (das ist schon OK das diese Namen nun l√§nger sind - denn man sollte es NICHT mehr nutzen weils immer mehr Hardware gibt wo das einfach nicht mehr l√§uft *g*)
- Renderer-Flags BindNoTextures, BindNoShaders, LockModeStates, LockZBufferStates, LockAlphaStates, LockBlendStates, LockStencilStates, LockPointStates,
  LockTessellationStates, LockScissorTestStates entfernt... soetwas war noch nie sch√∂n und das ist mit dem Scene Renderer Konzept eh nun √ºberfl√ºssig.
  (und wer das nicht nutzt, muss sich eh um alles selbst k√ºmmern)
- Renderer: GetFlags() und SetFlags() entfernt, das einzige Argument daf√ºr war das von eine Zeile weiter oben
- Accumulation Buffer Support entfernt, das stand schon lange auf meiner Abschussliste. Zum einen gibs das nur f√ºr OpenGL, in OpenGL 3.0 scheint das auch
  Depriciated zu sein und ich w√ºsste auch nicht wof√ºr man das noch br√§uchte - denn mittlerweile kann man daf√ºr genauso gut FBO nutzen das weit mehr bietet.
  (Flie√ükommazahlen, Blend Funktionen und und und) Tiefenunsch√§rfe, Motion Blur - alles was man immer liest das dies so toll mit Accumulation Buffer geht,
  geht heute mit FBO und Shadern noch viel besser und Universeller. :D
- Renderer: ReadDepthComponent() entfernt... obwohl ich das ja eigentlich erst vor 6 Jahren eingebaut habe! *g*
  F√ºr die Performance ist das *zur√ºcklesen* von Werten √ºber die traditionellen OpenGL Funktionen t√∂tlich, unter DirectX gibts soetwas n√ºsch. Entweder kann
  man Occlusion Queries nutzen um zu ermitteln ob was verdeckt ist, oder man nutzt Render To Texture und holt sich dann die Texture Daten zur√ºck.
  (das meiste wird eh mittlerweile direkt in Texturen gerendert so das man genauso gut "TextureBuffer::Download()" nutzen kann, es aber nat√ºrlich wegen
  mieser Performance nicht sollte) Wurde auch nirgends mehr verwendet.
- GetDefaultTextureStageState(), ResetTextureStageStates(), GetTextureStageState(), SetTextureStageState() nach "FixedFunctions::RenderState" verschoben
- "TextureStageStates"-Klasse in "FixedFunctionsTextureStageStates" umbenannt
-> Achtung: In plfx-Dateien muss nun z.B. "TexGen" in "FixedFunctionsTextureStageStates" und nicht mehr "TextureStageStates" stehen



>> 07.04.2010
[CO]
- GL_ATI_pn_triangles ("PNTriangles" = "TruForm") durch GL_AMD_vertex_shader_tessellator ersetzt. ATI hat GL_ATI_pn_triangles mittlerweile aus den Treibern
  entfernt und NVIDIA hat das leider nie unterst√ºtzt. F√ºr Tessellation wird auf ATI Karten seit der HD2000 GL_AMD_vertex_shader_tessellator verwendet, unter
  OpenGL 4 und DirectX 11 ist das dann sogar "Standardisiert" und NVIDIA hat dort ebenfalls Tessellation. Da ich leider keine entsprechende GPU habe, ist das
  f√ºr mich derzeit uninteressant - da aber GL_AMD_vertex_shader_tessellator geht kann ich damit erste Tessellation und Displacement Mapping gehversuche machen.
  Displacement Mapping l√§uft bei den *modernen Tessellation Verfahren* ja genauso ab so das man dann die Daten weiternutzen kann.
  GL_AMD_vertex_shader_tessellator wird √ºber GLSL "angesteuert", da wir derzeit nur Cg als Shader Sprache unterst√ºtzen konnte ich das noch nicht ausprobieren.
  (ein Grund f√ºr mich mehr auch GLSL direkt zu unterst√ºtzen *g*)
  Im grunde wollte ich Haupts√§chlich erstmal GL_ATI_pn_triangles drau√üen haben, war aber einfacher das direkt durch GL_AMD_vertex_shader_tessellator zu ersetzen
  als das erstmal ganz rauszunehmen, und sp√§ter wieder einzubauen.



>> 05.04.2010
[CO]
- Dort wo angebracht wird nun PLMath::Vector2i & PLMath::Vector3i anstatt GetWidth(), GetHeight() und GetDepth() verwendet



>> 04.04.2010
[CO]
- "Renderer::Clear()": Die Farbe √ºbergibt man nun als PLGraphics::Color4 und nicht mehr als PLGeneral::uint32. Zum einen war das Umst√§ndlich, aber noch
  viel wichtiger - nun ist es auch m√∂glich z.B. einen Buffer mit der Farbe "2 2 2 2" zu l√∂schen, etwas was man u.B. bei Flie√ükommazahlen Render Targets
  brauchen kann!
RendererOpenGL:
- Die Extension "GL_ARB_color_buffer_float" wird nun unterst√ºtzt, damit kann man beeinflussen ob wo Automatisch Zahlen auf den Bereich [0, 1] beschr√§nkt werden



>> 02.04.2010
[CO]
RendererOpenGL:
- "RendererOpenGL::SetColor()" setzt nun sofort die Farbe mit "glColor4f()", damit passiert das nur noch an einer Stelle - aber viel wichtiger ist,
  das "glColor4f()" im Zusammenspiel mit Shadern nix bringt und bisher in "RendererOpenGL::DrawPrimitives()" dann Overhead drinnen war.
- "RendererOpenGL::m_bWorldMatrixChanged" entfernt. Die Lazy-Evaluation ist zwar f√ºr Fixed-Function Rendering ganz nett, aber bei Shadern ist
  "glLoadMatrixf()" witzlos sofern man die States nicht √ºber GLSL ausliest, was ich aber nicht mache und nicht machen werde. Noch ein Overhead
  bei verwendung von Shadern weniger.
- "RendererOpenGL::SetRenderTarget()": Vertex & Fragment Shader werden nicht mehr zur√ºckgesetzt, das ist wirklich ziemlich st√∂rend - hab alles
  durchgetestet, geht alles noch.



>> 01.04.2010
[CO]
- Neue Funktion "SurfaceTextureBuffer::TakeDepthBufferFromSurfaceTextureBuffer()", damit kann eine Render Texture einer anderen den Tiefen Buffer
  Stehlen... oder freundlicher ausgedr√ºckt: Der Tiefenbuffer wird Freundschaftlich herumgereicht, wie die Fackel bei der Er√∂ffnung der Olympischen
  Spiele. *g*
  Ich weis noch nicht ob das final so bleibt, aber momentan will ich hier noch keine zu gro√üen Umbauten machen. "PLScene::SRPDeferred" Implementationen
  nutzen das bereits und es klappt zumindestens recht gut.



>> 29.03.2010
[CO]
- Material: DetailNormalMap, HorizonMap, DiffuseRampMap, SpecularRampMap und EdgeRampMap Strings entfernt da schon viel zu sepeziell



>> 27.03.2010
[CO]
- Parameters: Integer, Integer2, Integer3, Integer4 und float3x3 Typen hinzugef√ºgt... alles Typen die ich nun schon mehrmals nutzen
  wollte und mich jedesmal etwas √Ñrgerte als die nicht Existierten und es dadurch Umst√§ndlicher wurde



>> 25.03.2010
[CO]
- Material: "AmbientOcclusionMap"-String hinzugef√ºgt - da wir diesen Map-Typ mittlerweile unter dem Namen "LightMap" bereits f√ºr
  viele Projekte verwendet haben, und laut Jens auch superduper wichtig ist und bleibt, ist das wohl gerechtfertigt das zu einem
  "bekannten Standard Parameter" zu machen.



>> 20.03.2010
[CO]
- Neue Funktion "SurfaceTextureBuffer::SetMaxColorTargets()"
-> Das "Render To Texture"-System muss ich umbedingt mal komplett √ºberarbeiten... seit ich das System Implementiere hatte, hat sich enorm
   viel getan und es ist viel neues hinzugekommen. Das Rendern in Texturen ist heute √ºber FBO in OpenGL aber sehr sch√∂n und einfach zu realisieren
   und verdammt m√§chtig. Das aktuelle PLRenderer-Interface beschr√§nkt die M√∂glichkeiten derzeit noch und es ist ein viel zu gro√üer interner Overhead
   vorhanden. Zuk√ºnftig muss FBO und Render Texturen getrennt werden, denn ein FBO kann man f√ºr sehr viele Dinge direkt so wiederverwenden und
   braucht nicht jedesmal wenn man in eine Texture Rendern will dazu ein neues FBO. Anhand des Deferred Scene Renderers kann man sch√∂n sehen
   wie das Render To Texture heute normalerweise eingesetzt wird.
- "RendererOpenGL::GetOpenGLFormat()": Ich bin hier gerade wieder √ºber etwas gestolpert das mir bei meiner Bachelorarbeit, wo ich u.a. kr√§ftig mit
  OpenGL 3.2 herumspielte, aufgefallen ist. Will ich in Texturen Rendern die nur eine Komponente haben, muss man bei z.B. glTexImage2D
  GL_RED als Format angeben und nicht GL_LUMINANCE oder GL_INTENSITY. Alles andere geht nicht. Ich hab noch irgends wirklich Literatur gefunden die dieses
  Verhalten erkl√§rt... na hoffentlich gehts so auch auf NVIDIA Karten. (zumindestens auf dem FH System mit NVIDIA Karte ging das damals in meiner Bachelorarbeit)



>> 17.03.2010
[CO]
- RendererOpenGL: Multi-Render-Targets Support l√§uft, in "FrameBufferObject::Finish()" fehlte nur ein "glDrawBuffer(GL_NONE);". Man bin
  ich froh das dies endlich l√§uft... vor einigen Jahren ging das ja gar nicht so richtig, Crashte etc. - das lag glaub ich aber an meiner
  damaligen Hardware. Im PLSample "PLSampleRTT" kann man testen ob alles l√§uft, da m√ºssten nun einige Teapots mit Grundfarben sein.
  GL_COLOR_ATTACHMENT0_EXT - GL_COLOR_ATTACHMENT15_EXT sind definiert, daher werden nun in diesem Renderer Backend 16 Render Targets
  Unterst√ºtzt... meine GPU hat beispielsweise 8 davon.



>> 15.03.2010
[CO]
- "nBitsPerPel" in "nColorBits" umbenannt da es so an anderen Stellen geschrieben wird und besser lesbar ist
- "RenderWindow": Neue Funktionen: "GetDisplayMode()" und "SetDisplayMode()", damit ist das Interface √§hnlich zu "RenderFrame"



>> 14.03.2010
[CO]
- An die √Ñnderungen des Konfigurations-Systems angepasst
- Texture-Manager: Neue Funktionen: "GetTextureQuality()" und "SetTextureQuality()"
- Texture-Manager: Neue Funktionen: "AreTextureMipmapsAllowed()" und "SetTextureMipmapsAllowed()"
- Texture-Manager: Neue Funktionen: "IsTextureCompressionAllowed()" und "SetTextureCompressionAllowed()"
- "RenderFrame"-Konstruktor √ºberarbeitet. Wenn ein Fenster sofort im Vollbild-Modus erzeugt werden soll, so muss man nun
  noch weitere Einstellungen √ºber "DisplayMode" √ºbergeben. (wurde bisher fest verdrahtet √ºber eine globale Konfiguration ausgelesen)
  Das m√ºsste alles etwas Flexibler machen.
- "RenderFrame": Neue Funktionen: "GetDisplayMode()" und "SetDisplayMode()"
- "RenderFrame": Neues Event: "EventDisplayMode"
- "Renderer::CreateFrame()" entfernt da nicht wirklich n√∂tig
- "Config" nach "PLEngine" verschoben und in "RendererConfigGroup" umbenannt
- "DisplayMode" um "nZBufferBits", "nStencilBits", "nAccumBits" und "nAntiAliasing" erweitert, diese Informationen werden ebenfalls
  ben√∂tigt wenn ein Fenster zum Rendern eingerichtet werden soll (wurde bisher fest verdrahtet √ºber eine globale Konfiguration ausgelesen)
- "RenderWindow"-Konstruktor √ºberarbeitet
- "Renderer::GetConfigs()" entfernt da nicht mehr ben√∂tigt. Dort war bisher eh nur eine "DisplayMode"-Instanz enthalten, was noch aus den
  Anfangszeiten stammt... mittlerweile kanns ja mehrere Fenster geben, und im Grunde eigentlich Prinzipiell auch mehrere Vollbild-Fenster -
  darum macht eine DisplayMode Information pro Renderer keinen Sinn. Diese Information ist pro Render-Fenster. Andere Renderer Einstellm√∂glichkeiten
  gehen direkt √ºber das Renderer-Interface.
- "RendererBackend::UpdateCurrentDisplayModeInformation()" entfernt da unn√∂tig



>> 10.09.2009
[CO]
- "Texture::Load()" nutzt das neue "PLGraphics::ImageEffects::RemovePalette()" um Paletten aufzul√∂sen da Texturen mit
  Paletten nicht unterst√ºtzt werden



>> 02.08.2009
[CO]
- "EventListener" entfernt -> ein √úberbleibsel aus unserer "Listener Zeit". :D
  Stattdessen gibts nun in "Animation" ein neues "EventSpecialFrame"-Event.
  Die Funktionen "GetNumOfEventListeners()", "IsEventListener()", "AddEventListener()", "RemoveEventListener()" und
  "ClearEventListeners()" in den Ruhestand geschickt.



>> 07.07.2009
[CO]
PLRendererOpenGL:
- "RendererOpenGL::MakeScreenshot()": Da bei OpenGL der Bildmittelpunkt links unten ist, m√ºssen wir das erhaltene
  Bild um die Y Achse Spiegeln (die alte Image Klasse machte das Automatisch)
- "RendererOpenGL::MakeScreenshot()": Falls gerade ein FBO verwendet wird, wird "SurfaceTextureBuffer:::Finish()"
  aufgerufen damit im Falle von Multisample der Inhalt aktualisiert wird... macht man das nicht, bekommt man nur
  einen schwarzen Inhalt zu sehen



>> 11.06.2009
[SB]
PLRendererOpenGL:
- Linux-Implementation an neue OpenGL-Extensions angepasst und einige √úbertragungsfehler behoben.
- Das Projekt l√§sst sich nun auch wieder fehlerfrei unter Linux/gcc √ºbersetzen. 



>> 04.06.2009
[CO]
PLRendererOpenGL:
- "TextureBuffer2D::RestoreDeviceData()": Wenn es eine Tiefentexture ist m√ºssen auch entsprechende Einstellungen
  wie in "TextureBuffer2D::TextureBuffer2D()" gemacht werden da ansonnsten z.B. Shadow Maps nach einem Bildschirm
  Modus wechsel nicht mehr sichtbar sind.



>> 31.05.2009
[CO]
PLRendererOpenGL:
- "GL_ARB_multisample" OpenGL Extension wird nun unterst√ºtzt f√ºr Anti-Aliasing
- "GL_EXT_framebuffer_multisample" & "GL_EXT_framebuffer_blit" OpenGL Extensions werden nun unterst√ºtzt f√ºr
  Anti-Aliasing w√§hrend in Texturen gerendert wird
- "FrameBufferObject" & "SurfaceWindow" um Multisample Support erweitert
- In der Renderer-Config (z.B. "PLRendererOpenGL.cfg") gibts die neue Option "AntiAliasing" f√ºr Anti-Aliasing.
  Standardm√§√üig ist das 0, also aus, da das nat√ºrlich etwas an Leistung kostet. (sieht aber schick aus :)
  Typische Werte sind: 2, 4, 8...
- "SurfaceTextureBuffer": Neues Flag "NoAntiAliasing": Damit l√§sst sich Anti-Aliasing unterdr√ºcken - das ist z.B.
  beim Shadow Map rendern n√ºtzlich da der Qualit√§tsunterschied hier praktisch nicht sichtbar ist... aber der Leistungs
  unterschied schon!



>> 29.05.2009
[CO]
- "Texture::Load()": Ich entschloss mich dazu CubeMaps √ºber 'plt'-Dateien und dann entsprechende Dateinamen f√ºr die
  anderen CubeMap Seiten komplett herauszunehmen. Das ist einfach zu kompliziert und auch fehleranf√§llig da sehr
  schnell dann mal CubeMap Seiten nicht den Anforderungen entsprechen. Das zusammenfummeln der CubeMap √ºber die
  'plt'-Datei und Dateinamen war auch nicht sonderlich Benutzerfreundlich. CubeMaps kann man wirklich sehr sch√∂n √ºber
  das 'dds'-Dateiformat einladen und es gibt auch sehr einfach zu bedienende Tools wie z.B.
  http://ati.amd.com/developer/cubemapgen/index.html um "mal schnell" eine dds CubeMap zu erzeugen. Mir viel kein
  einziger Grund ein der daf√ºr sprach das noch drinnen zu lassen.
- "Renderer::CreateTextureBufferCube()" bekommt nun nur noch ein Image-Objekt und kein Feld aus Image-Objekten
  mehr. Damit kann man CubeMaps dem Renderer also NUR noch √ºber ein Image-Objekt das aus verschiedenen Teilen
  besteht √ºbergeben - aber das ist dank der neuen Image-Klasse ja absolut kein Problem mehr. :D



>> 28.05.2009
[CO]
- "PLRendererOpenGL": "TextureBufferRectangle::TextureBufferRectangle()": Komprimierte Rectangle Texturen scheinen
  mittlerweile auch ganz wunderbar zu funktionieren



>> 26.05.2009
[CO]
- "Texture::Load()": "gamma correction" rausgenommen da hier nicht wirklich umbedingt n√∂tig



>> 21.05.2009
[CO]
- "Renderer::DrawBitmap()" schaltet nicht mehr automatisch in einen "2D Modus" da dies einfach nur unpraktisch ist
  und es nicht mehr m√∂glich ist z.B. eine Bitmap "frei" im 3D Raum zu zeichnen. "Renderer::DrawPoint()" schalteten
  ebenfalls nicht automatisch in einen "2D Modus" und von der Seite aus war das zus√§zlich sogar noch inkonsequent.
  Durch diese kleine √Ñnderung/Vereinfachung ist "Renderer::DrawBitmap()" nun vielseitiger einsetzbar.



>> 20.05.2009
[CO]
- "Font": "Draw()"-Funktion ohne Positionsangabe √ºberarbeitet und die hinteren Parameter entfernt. Diese Funktion
  zeichnet nun "nur" noch Text ohne noch zig Render States zu ver√§ndern. Dadurch wird der Text z.B. nicht automatisch
  auf "2D" ausgerichtet - was immer mal wieder gew√ºnscht ist um den "flachen" Text frei in einer 3D Szene plazieren
  zu k√∂nnen.



>> 19.05.2009
[CO]
- "PLRendererOpenGL": "Font2D" & "Font3D": "Draw()": Die aktuelle OpenGL-Farbe braucht nicht weggespeichert und
  wiederhergestellt werden



>> 10.05.2009
[CO]
- "OpenGLRenderContext" etwas aufger√§umt



>> 06.05.2009
[CO]
- "Animation": "EventFrameChange"-Event hinzugef√ºgt damit man von au√üen mitbekommen kann wenn sich etwas √§nderte
  und dann z.B. ein Mesh aktualisieren kann... oder auch nur ein Flag das notiert das ein Mesh Update n√∂tig ist :)
- "AnimationManager"-Klasse hinzugef√ºgt
- "AnimationManager" besitzt nun ein "EventAnimationFrameChange"-Event das eine "Sammelstelle" f√ºr "EventFrameChange"-
  Events darstellt, das vereinfacht die Arbeit wenn man auf alle "EventFrameChange" h√∂ren will
- "Surface": Um "EventPaintBegin", "EventPaint" und "EventPaintEnd" Events erweitert damit man z.B. Texturen
  aktualisieren kann bevor das Zeichen beginnt



>> 29.04.2009
[CO]
- "RendererContext" hat nun ein "EventUpdate"-Event das in der neuen "Update()"-Funktion ausgel√∂st wird
- "TextureHandler" hat keine "Update()"-Funktion mehr. "TextureHandler::AnimationState()" h√§ngt sich
  in das neue "EventUpdate"-Event von "RendererContext" ein. Dadurch folgen nun einige vereinfachungen
  die dazu f√ºhren das viele "Update"-Funktionen wegfallen und dadurch pro Frame weniger Arbeit direkt f√ºr
  die Tonne anf√§llt. :D
- "ShaderManager" hat keine "Update()"-Funktion mehr, die war eh praktisch leer
- "TextureManager" hat keine "Update()"-Funktion mehr, die war eh praktisch leer
- "Material" und "MaterialHandler" haben keine "Update()"-Funktionen mehr, dienten nur zum "TextureHandler"-Update
- "Mesh::UpdateMaterials()" entfernt
- "Effect::Update()" macht kein "TextureHandler"-Update mehr, "derzeit" noch drinnen wegen "m_fTimer"
- ... in auf PLRenderer aufbauenden Projekten konnten nun ebenfalls einige "Update"-Funktionen √ºber den Jordan
  gehen. Wie man sehen kann zog das "Texture Animation"-Feature bis jetzt einen heftigen Rattenschwanz quer
  durch alle Projekte "nur" damit "falls eventuell vorhanden" Texture Animationen aktualsiert wurden. Dort gabs
  dann auch noch "Update"-Konflikte so das z.B. eine Animation pro Frame mehrmals an verschiedenen Stellen
  aktualisiert wurde und dadurch die Animation einmal schneller, einmal langsamer abspielte. Das war mir schon
  sehr lange ein Dort im Auge - und √ºber die Events lies sich das nun denke ich recht einfach und ordentlich l√∂sen.
- Bugfix: "RendererOpenGL::SetLight()": Directionale Lichter setzen war nicht ok, den Richtungsvektor setzt man
  lustigerweise √ºber die "Position"



>> 26.04.2009
[CO]
- Hoffnunglos veralteten "Selection Buffer" vom Renderer entfernt. Folgende Funktionen gibt es also im
  "Renderer"-Interface nicht mehr: "GetSelectionBuffer()", "SetSelectionBuffer()", "GetRenderMode()",
  "SetRenderMode()", "InitNames()", "PushName()", "PopName()" und "LoadName()"
  In den anderen Projekten musste ledeglich  "PLSampleSceneNodes::SNSampleSelection" angepasst werden,
  ansonnsten wurde das nirgends genutzt da eher umst√§ndlich und eingeschr√§nkt in der Nutzung.
  "Selection Buffer" gab es nur "fr√ºher" in OpenGL, in DirectX gab es soetwas nie - und ab OpenGL
  3.1 wurde dieses Feature entfernt. So wie es aussieht war das schon in den alten OpenGL Versionen immer
  nur eine "halbe" Sache und wurde in der CPU ausgef√ºhrt. Sobald VBO dazu kam ging es schon nicht mehr
  richtig und die Performance lag im einstelligen FPS Bereich... auf meinem aktuellen Notebook scheint es
  sogar √ºberhaupt nicht mehr zu funktionieren. H√∂chste Zeit also uns komplett davon zu trennen - vorallem
  da man es eh nie wirklich nutzen konnte da es soetwas von √ºberhaupt nicht in das PixelLight Scene Renderer
  Konzept passt. :D
- "RenderApplication" von PLRenderer nach PLEngine verschoben
- PLRendererOpenGL: Upsala, "GL_INDEX_ARRAY"/"glIndexPointer()" hat nix mit "Vertex Indices" zu tun sondern
  dies ist f√ºr "Color Index Arrays"
- "GetOcclusionQuery()" aus dem "Renderer"-Interface entfernt da dies nicht wirklich n√∂tig ist und wohl schnell
  Probleme macht wenn von mehreren Stellen dieser Occlusion Query gleichzeitig genutzt werden w√ºrde. Es musste
  nichts weiter angepasst werden da diese Funktion nirgends verwendet wurde. *√ºberbleibsel aus vergangenen Zeiten*



>> 22.04.2009
[CO]
- "ShaderLoaderCg::Load()": Implementation Optimiert: Falls die √ºbergebene Datei bereits im Speicher liegt
  und am Ende eine "\0" ist, so wird die Datei nicht nochmals "Zwischengespeichert" sondern das bereits
  im Speicher liegende kann direkt so genutzt werden.



>> 15.04.2009
[CO]
- "ShaderManager": "Load()"-Funktion hinzugef√ºgt der man direkt ein "File"-Objekt √ºbergeben kann
- "ShaderManager" hat keinen "Default Shader" mehr da dieser nicht wirklich einen Sinn hat (Shader
  sind einfach speziell und lassen sich nicht einfach produktiv √ºberall drauf klatschen wie z.B.
  das bei Texturen m√∂glich ist) und nur dazu f√ºhrt das ein total nutzloser Shader immer am Anfang
  eingeladen wird was dann dazu f√ºhrt das "Cg" Initialisiert wird auch wenn man in einem Projekt
  √ºberhaupt keine Shader nutzt.
- "EffectManager": "Default.plfx" wird nicht mehr geladen sondern dynamisch erzeugt damit man nicht
  immer gezwungen ist "Standard.zip" auszuliefern



>> 11.04.2009
[SB]
- PLRendererOpenGL: Habe versucht, die √Ñnderungen mit dem OpenGLRendererContext auf Linux anzupassen. Leider
  sind mir so so beim dr√ºberschauen, ohne die √Ñnderungen selbst gemacht zu haben, nicht wirklich alle
  Zusammenh√§nge klar, weshalb dieses Unterfangen nicht gerade leicht ist. Deshalb w√§re es wirklich gut,
  wenn gerade bei solchen Struktur√§nderungen auch *immer* die Linux-Variante mit angepasst wird, damit
  das nicht sp√§ter immer schwieriger wird, das ganze noch anzupassen. Ich weiss, dass das etwas bl√∂d ist,
  wenn man selbst nicht unter Linux arbeitet und dazu der Linux-Port noch gar nicht funktionsf√§hig ist. Aber
  f√ºr mich wird es auch immer schwieriger, das System unter Linux zu warten, wenn ich st√§ndig 
  hinterherarbeiten muss, weil nach ein paar Wochen grunds√§tzlich irgend eine √Ñnderung dazu gef√ºhrt hat,
  dass das Projekt sich unter Linux nicht einmal mehr √ºbersetzen l√§sst. Also bitte in Zukunft mal mehr
  darauf achten, insbesondere bei solchen √Ñnderungen, wo dann sogar eine wgl-Funktion aus dem #ifdef
  herausgezogen wurde. Dann kann ich zumindest weiter unter Linux arbeiten und das System bleibt einiger
  Massen aktuell auch unter Linux. Und dann kann ich in der n√§chsten Zeit endlich den Linux-Port komplett
  neu aufsetzen, dann wird das ganze auch sinnvoller zu warten, wenn es auch endlich mal funktioniert :-)
  Aber bis dahin w√§re es nett, wenn ich zumindest nicht st√§ndig damit k√§mpfen m√ºsste, dass es sich mal
  wieder nicht einmal mehr √ºbersetzen l√§sst.



>> 08.04.2009
[CO]
- "RendererBackend::GetOcclusionQuery()" erzeugt die interne Instanz erst wenn diese zum ersten mal ben√∂tigt wird



>> 05.04.2009
[CO]
- "RendererOpenGL::Font2D" & "RendererOpenGL::Font3D": Die Fonts werden intern erst dann erzeugt wenn diese zum
  ersten mal ben√∂tigt werden (falls dies √ºberhaupt mal der Fall ist... :)



>> 01.04.2009
[CO]
- "OpenGLRenderContext" hinzugef√ºgt damit diese Dinge zuk√ºnfig √ºberschaubar beisammen sind
- "RendererOpenGL::GetRenderingContext()" in "RendererOpenGL::GetOpenGLRenderContext()" umbenannt, gibt nun
  "OpenGLRenderContext" zur√ºck
- "RendererOpenGL::BackupDeviceObjects()" & "RendererOpenGL::RestoreDeviceObjects()": Der OpenGL Rendering Context
  muss hier NICHT zerst√∂rt und wieder erzeugt werden
- "RendererOpenGL::CreateContext()" & "RendererOpenGL::DeleteContext()" entfernt, der OpenGL Render Context
  wird nun direkt in "RendererOpenGL::Init()" & "RendererOpenGL::DeInit()" erzeugt und zerst√∂rt
- Die OpenGL-Extensions werden nun im "OpenGLRenderContext"-Konstruktor initialisiert und nicht mehr in
  "SurfaceWindow::Init()" bzw. "SurfaceLinux::Init()"



>> 08.03.2009
[CO]
- "Material::Load()"-Implementation √ºberarbeitet. Wenn man im Material eine "einfache Texture" einladen wollte MUSSTE diese immer eine
  bekannte Dateiendung haben oder das Laden schlug fehlt. Da man aber durchaus auch z.B. Dynamische Texturen haben kann die irgendeinen beliebigen
  Namen mit oder ohne "bekannte Dateiendung" haben sollte man hier keinen Namenscheck machen sondern einfach den Namen der zu verwendenden
  Texture "durchreichen".
- "Texture::Load()": Beim skalieren aufgrund von veringerter Qualit√§t wurden Warnungen rausgeschrieben das die Texture gr√∂√üe nicht passt...
  das sollte nat√ºrlich nicht sein und die "NUR die Original" gr√∂√üe sollte auf passende Dimensionen hin gepr√ºft werden und nicht die errechnete
  verkleinerte Dimension!
- "Texture::Load()": Beim skalieren wird nun auch noch ins Log geschrieben wie gro√ü die Texture urspr√ºnglich war



>> 07.02.2009
[CO]
- 'RendererBackend::UpdateCurrentDisplayModeInformation()': Wird die 'gegebene' Aufl√∂sung nicht gefunden, so wird nun zuerst versucht eine
  Aufl√∂sung zu finden 'die nah dran ist' - erst wenn auch das fehlschl√§gt wird die erstbeste Aufl√∂sung genommen
- 'Parameters': 'GetParameterTexture()' & 'SetParameterTexture()' hinzugef√ºgt so das man nicht zwanghaft direkt √ºber 'TextureBuffer' gehen muss.
  ('Texture' kann als eine art 'TextureBuffer Handler' angesehen werden)
- 'Parameters': 'GetParameterString()' in 'GetParameterString()' und 'SetParameterString()' in 'SetParameterString()' umbenannt damit konsistent
  zu den anderen Funktionen



>> 06.02.2009
[CO]
- 'RendererOpenGL::Init()': 'PLRendererOpenGL.cfg' wurde zwar geladen aber intern gibts derzeit noch ein
  'm_sConfigs.sDisplayMode' das nicht auf die gelesenen Werte gesetzt wurde



>> 05.02.2009
[SB]
- Animation: Wenn man eine Animation z.B. von Frame 0 - 50 abspielen l√§√üt, sprang diese am Ende wieder auf
  Frame 0 zur√ºck, da bei Stop() automatisch Reset() aufgerufen wurde. Habe dies nun ge√§ndert und in Stop()
  nur noch das aktuelle Abspielen beendet, nicht aber die gesamte Animation zur√ºckgesetzt. Bitte mal in den
  aktuellen Projekten pr√ºfen, ob irgendwo das alte Verhalten vorausgesetzt wurde.



>> 04.02.2009
[SB]
- Projekt auf Basis von RendererNull begonnen. Dies soll ein OpenGL ES 2.0 kompatibler Renderer f√ºr PixelLight werden.
  Zun√§chst implementieren wir dies anhand des OpenGL ES Emulator SDKs und dessen Samples.
- SurfaceWindow implementiert. Es kann erfolgreich ein Fenster mit diesem Renderer ge√∂ffnet und ein Kontext erzeugt werden.
  Testweise rendere ich in Present() ein simples Dreieck (√ºbernommen aus dem Sample), damit man schonmal was sieht :-)  



>> 04.02.2009
[CO]
- 'RendererOpenGL' & 'RendererD3D9': 'QueryDisplayModes()' filtert nicht mehr k√ºnstlich ohne das man dies von au√üen
  beeinflussen k√∂nnte
- 'Renderer': Neue Funktion: 'GetDisplayModes()': Kann eine Liste 'sicherer' Bildschirm-Modi zur√ºckgeben, man sollte
  wenn m√∂glich immer diese Funktion nutzen um auf der halbwechs sicheren Seite zu sein
- 'RendererBackend::UpdateCurrentDisplayModeInformation()' nutzt nun als Fallback die erste gefundene 'sichere'
  Bildschirmaufl√∂sung
- 'RendererBackend::UpdateCurrentDisplayModeInformation()': Hier MUSS man derzeit auch noch die Einstellungen in der
  Konfiguration aktualisieren



>> 01.02.2009
[CO]
- 'Font': Derzeit gibts hier ein kleines Problem mit der 'virtuellen Bildschirmgr√∂√üe'... 'Renderer::Begin2DMode()' hat als Default eine
  'normalisierte Bildschirmgr√∂√üe', sprich, Breite und H√∂he sind immer 1... das bei√üt sich allerdings wenn man Font gr√∂√üe in Pixel angeben will.
  Wir m√ºssen uns das hier nochmal ganz genau anschaun und uns √ºberlegen was wir hier machen wollen. Das einfachste w√§re wenn man keine
  'normalisierte Bildschirmgr√∂√üe' unterst√ºtzen w√ºrde, allerdings h√§tte das den Nachteil das man dann immer wissen muss was gerade die
  Bildschirmgr√∂√üe (virtuell oder nicht) ist. Damit das nach au√üen hin erstmal wie gehabt funktioniert baute ich einen Hack ein.



>> 31.01.2009
[CO]
- 'ParameterManager::SetParameterTextureBuffer()': Wenn die interne Texture nur durch einen Texture Handler genutzt wird ist es relativ sicher
  einfach der Texture einen neuen Texture Buffer zu geben - dadurch werden nicht mehr so oft dynamisch Texturen erzeugt und wieder zerst√∂rt.
  (viel mir bei 'SCMirror' auf)



>> 30.01.2009
[CO]
- 'Font': Die 'Draw()'-Funktionen nutzen nun standardm√§√üig die 'virtuelle Bildschirmgr√∂√üe' anstatt die gerade im Viewport eingestellte gr√∂√üe...
  dadurch passt sich die Schrift der Fensterskalierung "automatisch" an. Will man das 'alte' Verhalten, also Schriftgr√∂√üe unabh√§ngig von Viewport
  gr√∂√üe, so kann man dies √ºber einen optionalen Parameter einstellen.
  Gleiche √§nderung bei 'GetWidthRelative()' und 'GetHeightRelative()'.



>> 29.01.2009
[CO]
- 'RenderApplication::Update()': Auch bei gesetzten 'bForceUpdate' MUSS nat√ºrlich 'Timing::GetInstance()->Update()'
  aufgerufen werden



>> 25.01.2009
[CO]
- 'Renderer': 'GetVendor()' hinzugef√ºgt damit man z.B. rausfinden kann ob man gerade eine ATI oder NVIDIA GPU vor sich hat



>> 21.01.2009
[CO]
- 'RenderStates': 'DstBlendFunc' hat nun als Default-Einstellung 'InvSrcAlpha' statt 'One' da dies g√§ngiger und viel n√ºtzlicher ist und
  wir selbst auch 'meistens' nutzen
- 'Animation': 'GetStartFrame()' & 'GetEndFrame()' & 'GetNumOfFrames()' hinzugef√ºgt



>> 20.01.2009
[CO]
- 'ShaderManager::Load()': Diese Funktion unterscheidet nun zwischen 'Dateiname' und 'Name'... denn aus einer
  Shader Datei k√∂nnen √ºber Defines eine vielzahl spezieller Shader erzeugt werden.



>> 10.01.2009
[CO]
- 'RenderFrame': Neben 'Alt-Return' kann man nun auch 'AltGr-Return' zum Vollbildmodus wechseln nutzen, das scheint so g√§ngig zu sein
  (und ist auch viel 'bequemer' da man das auf normalen Tastaturen mit nur einer Hand machen kann *g*)



>> 09.01.2009
[CO]
- 'RenderApplication': 'IsFullscreen()' & 'SetFullscreen()' & 'OnFullscreenMode()' hinzugef√ºgt
- 'RenderFrame': 'SetFullscreenMode()' in 'SetFullscreen()' umbenannt damit konsistent zu den anderen √§hnlichen
  Funktions Namen
- 'SurfaceWindow::Init()': Der OS Mauszeiger wird nicht mehr sichtbar/unsichtbar gemacht - auch im Vollbild
  Modus kann der OS Mauszeiger scheinbar korrekt angezeigt werden... auf jedenfall auf den bis jetzt getesteten
  Systemen - meine mich erinnern zu k√∂nnen das dies vor Jahren mal Probleme machte - so wie es jetzt ist ist's
  jedenfalls viel besser.



>> 03.01.2009
[CO]
- 'Parameters' um 'String'-Typ erweitert den man f√ºr alles nutzen kann das nicht so recht in die anderen Typen passen mag. Nun hat
  man auch in 'ParameterManager::SetParameterString()' keine Probleme mehr 'automatisch' einen entsprechenden Parameter hinzuzuf√ºgen.
 (kein Sonderfall mehr :) Dummerweise muss man nun 'PLGeneral::String' in dieser + davon abgeleiteten Klassen schreiben da sonst der
 Compiler nicht weis was man nun meint... aber ich h√§tte es noch weniger sch√∂n gefunden den 'String'-Typ irgendwie anderst zu nennen.



>> 01.01.2009
[CO]
- 'SurfacePainter' etwas umgebaut. Diese Objekte werden nun statt √ºber 'Surface::CreatePainter()' mit 'Renderer::CreateSurfacePainter()'
  erzeugt und wie gehabt √ºber 'Surface::SetPainter()' gesetzt. 'SurfacePainter' sind nur noch von 'Renderer' zu 100% abh√§ngig, das aktuelle
  'Surface' wird bei den 'Paint'-Funktionen als Parameter √ºbergeben. So kann man nun sehr einfach einen SurfacePainter gleichzeitig f√ºr
  verschiedene Surfaces nutzen.



>> 31.12.2008
[CO]
- 'RenderApplication::Update()': √úbernimmt nun den 'Timing' Test so das dies nicht in verschiedenen 'OnUpdate()' Implementationen immer
  wieder aufs neue implementiert werden muss. √úber 'Update(true)' kann man ein Update erzwingen auch wenn es ein FPS Limit gibt und es
  eigentlich noch gar nicht Zeit f√ºr ein Update ist.



>> 03.12.2008
[SB]
- RenderApplication: Neue Methode Update(), die intern OnUpdate() aufruft. In der Mainloop wird nun Update() statt OnUpdate() aufgerufen,
  ausserdem wurde das Abfragen der Gui-Nachrichten aus OnUpdate() entfernt und in die Gui-Mainloop verschoben, damit dies auch wirklich nur
  bei Run() passiert, nicht aber bei eingebetteten Aufrufen. Die Methode Update() muss von aussen aufgerufen werden, wenn nicht per Run()
  eine einige Mainloop ausgef√ºhrt wird, sondern die Applikation beispielsweise irgendwo eingebettet wurde.
- RenderApplication: Es wurde bisher nur RenderFrame als Fenster akzeptiert, nicht aber RenderWindow. Es muss aber immer beides beachtet werden,
  damit nicht nur eigenst√§ndige Fenster sondern auch eingebettete Fenster mit 3D-Kontext benutzt werden k√∂nnen. Also bitte das RenderWindow
  in Zukunft nicht weiter so vernachl√§ssigen, wie bisher ;-)
- RenderApplication: In OnCreateMainWindow() wird jetzt √ºberpr√ºft, ob die Applikation eingebettet werden soll, oder nicht, und je
  nachdem wird entweder ein RenderWindow oder ein RenderFrame instanziiert. Das bekommt man vielleicht noch allgemeiner hin, aber
  erstmal sollte es so in Ordnung sein.



>> 12.10.2008
[CO]
- RenderApplication: Wie besprochen geben 'OnCreateRendererContext()' & 'OnCreatePainter()' nix mehr zur√ºck sondern
  setzen 'direkt' in diesen Funktionen



>> 06.10.2008
[CO]
- RendererApplication von PLEngine nach PLRenderer verschoben
- SPDefault: von PLEngine in PLRenderer verschoben



>> 27.09.2008
[CO]
PLRendererOpenGL:
- Nachdem ich gerade ein Grafikkarten-Treiber Update gemacht habe (Catalyst 8.9) Crashten auf einmal viele PL-Szenen....
  Konnte das Problem auf Tiefen Texturen zur√ºckf√ºhren:
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  Nach dem erzeugen der Texture ausf√ºhren und schon war der Treiber-Crash weg...



>> 12.09.2008
[CO]
PLRendererOpenGL:
- RendererOpenGL::SetupCapabilities(): Merkte gerade das auf meinem benntec-Computer 'nMaxTextureUnits' auf 4 stand, das aber h√§tte
  32 sein m√ºssen. Schaute mir das hier also mal an... so wie es aussieht gabs bei GL_ARB_multitexture eine √Ñnderung bzw. wie man
  mit 'Texture Units' umgeht. "http://developer.nvidia.com/object/General_FAQ.html" hier steht auch etwas dar√ºber. Machte erstmal
  ein Kommentar in den Code - das muss ich mir nun genauer anschaun und √ºberlegen wie ich das korrekt Umbauen kann.
  Wird wohl Zeit das PLRenderer Refactoring langsam mal in Angriff zu nehmen...



>> 04.09.2008
[CO]
- Renderer::GetDescription() in Renderer::GetAPI() umbenannt das z.B. 'OpenGL' oder 'Direct3D' zur√ºck gibt... das bringt mehr
  als eine 'Beschreibung' da man dann einfach testen kann welche API gerade genutzt wird. Desweiteren kann man √ºber diese Funktion
  auf Wunsch auch die 'Version' bekommen - wobei diese API abh√§ngig ist.
PLRendererOpenGL:
- VertexBuffer::Allocate: Wenn kein VBO verf√ºgbar ist wird die Software-Implementation genutzt
- IndexBuffer::Allocate: Wenn kein VBO verf√ºgbar ist wird die Software-Implementation genutzt
- VertexBuffer::MakeCurrent(): Das 'return' beim setzen der Vertex Daten war definitiv KEINE gute Idee von mir... denn sobald
  'GL_ARB_vertex_program' nicht vorhanden war sah man dann gar nix mehr. Jetzt sieht man selbst dann bei 'Basic.sr'
  noch etwas wenn man seinen Grafikkarten-Treiber Deinstalliert - hatte n√§mlich heute hier den Fall das jemand keinen
  OpenGL Treiber Installiert hatte und der sich dann wunderte das nix ging...



>> 27.08.2008
[CO]
- 'Window' zu 'RenderWindow' und 'Frame' zu 'RenderFrame' gemacht damit man ohne Namespace keine Namenskonflikte mit den
  gleichnamigen PLGui Klassen bekommt was schon ziemlich st√∂rend war
- 'RenderWindow' und 'RenderFrame' ans RTTI angest√∂ppelt damit man f√ºr 'sicheres Casting' 'IsInstanceOf()' nutzen kann



>> 24.08.2008
[CO]
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da f√ºr 32 Bit als auch f√ºr 64 Bit



>> 20.08.2008
[SB]
- Font2D: Texte k√∂nnen nun auch transparent gerendert werden, zuvor wurde der Alpha-Wert der Farbe ignoriert.



>> 17.08.2008
[CO]
- Frame: Registriert 'Hot Key' f√ºr 'Alt-Return' zum Vollbild-Modus wechseln was eine recht g√§ngige Kombination ist.
  Durch die kleine PLGui Erweiterung von heute muss man endlich nicht mehr 'Strg-Alt-Return' dr√ºcken (sonst konnte man das nicht
  abfragen) was umst√§ndlich war und auf das man auch nicht wirklich von selbst kam.
- Frame: 'EventFullscreenMode'-Event hinzugef√ºgt das ausgel√∂st wird nachdem sich der Vollbild-Modus ver√§ndert hat



>> 08.08.2008
[CO]
- Wie von Stefan gew√ºnscht erzeugt ParameterManager nun automatisch 'fehlende' Parameter wenn man z.B. "SetParameter3f()" nutzt.
  "SetParameterString()" ist jedoch nicht in der lage automatisch Parameter zu generieren, denn diese Funktion bekommt nur einen
  String, zum Parameter erzeugen muss aber bekannt sein von welchem Typ dieser Parameter ist. Einen 'String' Typ gibts nicht, der
  w√ºrde nicht wirklich sinn hier machen + wenn man floats als String √ºbergibt bekommt man sicherlich nicht das als Ergebniss was
  man wollte, z.B. einen Float3-Parameter. Man k√∂nnte aufw√§ndig Parsen und 'raten' was der User wollte, aber das w√§re denke ich
  nicht gut da fehleranf√§llig. Man k√∂nnte irgendwie versuchen das gesammte 'Parameter System' noch universeller und flexibler zu
  machen, sehe aber momentan keinen Anlass daf√ºr wichitgere Arbeiten fallen zu lassen um mich wieder was neuem zuzuwenden. :D



>> 06.08.2008
[CO]
PLRendererOpenGL:
- Mipmaps m√ºssen bis 1x1 runter definitert werden. √úbergibt man die Mipmaps direkt √ºber ein 'Image', so wurde bis jetzt 'nur' im
  Log gewarnt wenn die kleinste Mipmap nicht 1x1 ist. Es ergab sich nun allerdings 'wieder einmal' (!) die Situation das wir
  'dds'-Bilder bekamen die zwar Mipmaps hatten, aber z.B. nur bis 2x2. Das Resultat verdutzte mich diese mal etwas, denn 'per'
  Zufall 'verschwanden' immer mal wieder, je nach Blickwinkel etc. (= 'scheinbar Zuf√§llig' *g*) Lightmaps die genutzt wurden.
  Zuerst konnte ich nicht sofort das 'Problem' auf die fehlenden Mipmaps zur√ºckf√ºhren, tests zeigten das "scheinbar" die Texture
  Koordinaten nach 'links unten sprangen'. (f√§rbte hierzu eine Test-Texture entsprechend)
  Nachdem ich dann auf die Idee kam erstmal alle "Mipmaps m√ºssen bis 1x1 definiert werden"-Warnungen im Log zu beseitigen stellte
  ich fest das das 'Problem' verschwunden war. Wie man anhand dieser Situation sehen kann, k√∂nnen die Auswirkungen ziemlich
  happig werden und man erkennt eventuell nicht 'sofort' was das Problem ist. Ich entschloss mich daher die fehlenden Mipmaps
  nun automatisch zu erzeugen - einfach √ºber einen 'wei√üen'-Buffer. Die Textur aufw√§ndig runterzuskalieren war mir offen gesagt
  zu d√§mlich, denn die Log Warnung sagt hier 'Du hast hier noch was zu tun!' und ich will offen gesagt 'schlamperei' nicht
  unterst√ºtzen... vorallem da dies sich auch etwas auf die Ladezeit auswirkt wenn man Daten 'selbst erzeugen muss' die 'eigentlich'
  h√§tten mitgeliefert 'werden m√ºssen'. Wenn nur die 1x1 Mipmap fehlt, f√§llt das mit 'weis' nicht wirklich auf - sieht dann h√∂chstens
  wie ein kleiner Pixel-Fehler aus, aber dabei bleibts dann wenigstens und l√∂st keine Lawine der merkw√ºrdigsten Grafig-Bugs aus.



>> 22.07.2008
[SB]
- Font, Font2D, Font3D: Die Methoden, um die Gr√∂√üe eines Strings auf dem Bildschirm zu messen, geben anscheinend die tats√§chliche
Gr√∂√üe auf dem Bildschirm, also abh√§ngig von der gew√§hlten Aufl√∂sung, zur√ºck. Das mag in vielen F√§llen die gew√ºnschte Information
sein, ist jedoch unbrauchbar, wenn es z.B. um Gr√∂√üen von Strings innerhalb der Ingame-GUI geht. Hier hat man eine virtuelle
Aufl√∂sung (z.B. 1024x768), daher mu√ü das Ergebnis hier auch auf diese virtuelle Gr√∂√üe bezogen werden. Das kann jedoch hier nicht
mehr vern√ºnftig gemacht werden, weil man dazu z.B. die Gr√∂√üe des Fensters wissen m√º√üte, in dem die Scene gerendert wird in der
die Ingame-GUI angezeigt wird, da die Schrift entsprechend der Fenstergr√∂√üe ja auch noch skaliert wird ... :-) An diese
Informationen kommt man aber nicht mehr heran und das w√§re auch nicht gut und nicht w√ºnschenswert, da ein Element in z.B. der
Ingame-Gui nicht mehr wissen muss, auf was f√ºr einem Surface mit was f√ºr einer Gr√∂√üe etc. es gerendert wird. Daher habe ich
zus√§tzliche Methoden hinzugef√ºgt, um die Schriftgr√∂√üe auf einer virtuellen Skala von 0.0 - 1.0 zu messen. Die Font-Klasse
von GuiPL nutzt dann diese Methode, und rechnet das Ergebnis wiederum auf die virtuelle Gui-Gr√∂√üe um. Damit d√ºrften nun die
Gr√∂√üen-Messungen von Texten auch innerhalb der Ingame-Gui korrekt funktionieren, was bisher immer fehlerhaft war.



>> 17.07.2008
[CO]
- TextureAniLoaderPL & MaterialLoaderPL & EffectLoaderPL & Texture (plt): Um Format Versions Informationen erweitert



>> 11.07.2008
[CO]
- Texture::Load(): Tests auf 'm_nCompressionHint' etc. sollten erst 'nach' dem eventuellen Skalieren der Texture
  gemacht werden... denn dadurch kann es sein das die vorhandene Kompression verworfen werden muss.



>> 24.05.2008
[CO]
PLRendererOpenGL:
- Texturen: 'm_nSamplerState' wurde nicht initialisiert + in RendererOpenGL::RestoreDeviceStates() sollten diese Werte zur√ºckgesetzt werden.
  Da OpenGL diese Einstellungen 'pro Texture' und nicht wie D3D (und bei uns im Renderer Interface) 'pro Stage' eingestellt ist dies
  eine Performance Optimierung da wir vergleichen k√∂nnen ob es n√∂tig ist einen OpenGL API Call (die man so gering wie m√∂glich halten sollte) zu
  machen oder ob die aktuellen Einstellungen noch immer passen.
- TextureBuffer1D::TextureBuffer1D(): Und nochmal ein Hack der √ºblen Sorte: Das hochladen komprimierter 1D Texturen scheint zu klappen, aber wenn
  ich dann die Daten wieder von der GPU hole und wieder hochlade (nach Bildschirm wechsel) habe ich irgendwie Schrott in den H√§nden. Wollte zuerst
  das wie in TextureBufferRectangle::BackupDeviceData() machen, also erst hier dann auch nicht Komprimiert schalten, aber sogar das funktionierte
  nicht richtig. Darum habe ich hier nun erstmal intern Texture Kompression f√ºr 1D Texturen komplett deaktiviert bis bekannt ist warum da was nicht
  geht und wie man es beheben kann. (Treiber Bug oder wieder etwas das mir einfach nur unbekannt ist?)
  Nicht sch√∂n, aber noch weniger sch√∂n ist es in z.B. der 'Cartoon'-Demo Szene nach einem Bildschirm Modus wechsel kaputte Grafik zu haben...



>> 23.05.2008
[CO]
PLRendererOpenGL:
- TextureBufferRectangle::BackupDeviceData(): Baute hier einen doofen Hack ein weil ich momentan keine Ahnung habe was hier los ist und es so herum
  immer noch besser ist als... Hat man eine 'RGB Rectangle Texture' klappt irgendwie das herunterladen der Daten von der GPU nicht so richtig, man
  bekommt die Daten leicht verschoben und wenn man das paar mal macht hat man nur noch Schrott in der Texture. (im schlimmsten Fall kann es sogar
  zu einem Crash im Treiber kommen...) Ist bei meinen ATI und NVIDIA Systemen der Fall wie meine Tests zeigten... mit RGBA gehts, darum stelle ich
  dann hier auf RGBA um. Entweder haben beide Hersteller hier einen Treiber-Bug oder es gibt iiirrgendetwas das man noch beachten muss - aber nicht
  wirklich offensichtlich Dokumentiert wurde. (generell scheint mir RGB eher schlecht denn recht Supported zu sein und irgendwie eher RGBA bevorzugt
  wird, hat wohl was mit der 32 Bit Speicherausrichtung zu tun)



>> 17.05.2008
[CO]
PLRenderer:
- 'Get2DCoordinate() 'und 'Get3DCoordinate()' herausgenommen da dies API unabh√§ngige Mathematische Funktionen sind bzw. 'zu sein haben'. In
  'PLMath::Vector3' finden sich daf√ºr nun zwei neue Funktionen Namens 'To2DCoordinate()' und 'To3DCoordinate()' die genau diese Aufgabe √ºbernehmen.
- 'Renderer::PickMatrix()' entfernt da 'PLMath::Matrix4x4::RestrictedProjection()' ausreichend ist
- 'Renderer::CreateSelectionPlanes()' entfernt da 'PLMath::PlaneSet::CreateSelectionPlanes()' ausreichend ist



>> 16.05.2008
[CO]
- Neue Klasse: PreviewWindow: Implementiert eine einfache Kamera-Steuerung, das ist recht n√ºtzlich und wird bereits an verschiedenen Stellen genutzt
- "EffectLoaderFX" Effect Loader in neues "PLDefaultFileFormats"-Projekt verschoben
PLRendererOpenGL:
- RendererOpenGL::InitWrappers(): 'PLRenderer::TextureBuffer::D16' etc. mappen nun auf 'GL_DEPTH_COMPONENT16' etc. statt alle auf 'GL_DEPTH_COMPONENT'
  da dies nun korrekt zu funktionierten scheint - fr√ºher ging das mal nicht richtig mit diesen Einstellungen, so herum ist es aber korrekt.



>> 14.05.2008
[CO]
- RendererBackend::Get2DCoordinate() Implementation vereinfacht



>> 12.05.2008
[CO]
PLRendererOpenGL:
- RendererOpenGL::Accum(): Da es warum auch immer bei mir zum Crash kommen 'konnte' (war z.B. in 'PLSampleInGameGui' der Fall) wenn ein 'glAccum'
  Befehl aufgerufen wird w√§hrend man gerade in eine Texture Rendert habe ich das erstmal so gel√∂st das Accumulation Buffer NUR f√ºr nicht Texture
  Render Targets genutzt wird... auf dauer wird diese Funktionalit√§t dann sowieso in ein 'Legacy'-Interface verschoben darum machte ich mir nun
  nicht die M√ºhe mich Stundenlang hinzusetzen und rauszubekommen warum das probleme machen kann.



>> 10.05.2008
[CO]
- Material::Load(): Wird nur eine einfache Texture als Material √ºbergeben so wird nun kein 'Standard Effekt' mehr gesetzt da sich das in der
  Praxis als "sehr" ungeschickt und umst√§ndlich herausstellte. Am besten f√§hrt man wirklich wenn man wo immer m√∂glich nur 'DiffuseMap' etc.
  Material Parameter setzt und den Rest komplett einem Scene Renderer √ºberl√§sst. "Effekte" sollte man nach m√∂glichkeit nur gaaanz selten
  nutzen da diese nat√ºrlich nicht mit 'Uniform Lighting and Shadowing' Harmonieren k√∂nnen + nicht sonderlich Performant sind weil sich einfach
  jeder Render State potentiell unkontrolliert ver√§ndern kann. Und wenn man sp√§ter mal einen 'Raytrace Scene Renderer' haben sollte geht das
  schonmal √ºberhaupt nicht mehr mit 'Custom Effects' in dieser Art.



>> 01.05.2008
[CO]
PLRendererOpenGL:
- Ich fand gerade heraus wieso z.B. der 'Bloom' Post Processing Effekt so grausam 'blockig' aussah... RendererOpenGL::GetCombinedMinMipFilter()...
  die Kommentare waren richtig, aber dann wurde statt 'GL_LINEAR' einfach 'GL_NEAREST' genommen. *gruml* Auf jedenfall passt das nun wieder
  und 'Bloom' etc. sieht endlich wieder wie 'Bloom' aus.



>> 27.04.2008
[CO]
PLRendererOpenGL:
- RendererOpenGL::RestoreDeviceStates(): Hier sollten nat√ºrlich auch die Texture Matrizen zur√ºckgesetzt werden... und schon sieht man z.B. in der
  Cartoon-Szene wieder den Himmel...



>> 25.04.2008
[CO]
- Copy-Operators und Copy-Constructors hinzugef√ºgt
- Renderer: Font-Funktionen DrawText(), DrawText3D(), GetFontSize(), SetFontSize(), GetFont2D(), SetFont2D(), GetFont3D() und SetFont3D()
  heraus genommen. Die 'Font'-Klasse hat daf√ºr nun Draw()-Funktionen... so herum ist es das einfacher zu nutzen und die √ºbergewichtige
  'Renderer'-Klasse ist minimal schlanker geworden.
  -> Passte alle Projekte daran an
- Renderer Context um einen einfachen Font Manager erweitert



>> 19.04.2008
[CO]
- Renderer::Clear(): 'nColor' als Default auf '0' gestellt da 'Color4::Black' bei Alpha 1 hat, (da es eine 'Farbe' ist) es aber g√§ngig ist Alpha
  als Default ebenfalls auf 0 zu haben
- Renderer::CreateFont2D() muss man nun noch die Schrift gr√∂√üe als Parameter mitgeben
- Font Interface etwas erweitert
- 'Renderer::CreateFont2D()' mit Texture Handler entfernt da ich nicht wirklich einen Grund finden konnte wieso man das mal noch brauchen k√∂nnte +
  die Implementation wird dadurch gleich viel √úbersichtlicher
PLRendererOpenGL:
- Font2D Implementation komplett √ºberarbeitet. Wie von Stefan vorgeschlagen wird intern nun FreeType genutzt. Da die Implementation allerdings wieder
  immer un√ºbersichtlicher und aufw√§ndiger wurde entschloss ich mich dazu FTGL zu nutzen welches eine 'FreeType->OpenGL'-Schnittstelle darstellt. Damit
  war es bis auf zwei Stellen vergleichsweise einfach bessers Schriften zu realisieren. Das Einladen der Schrift 'direkt aus Speicher' war erstmal
  ungewohnt da das was aus der Datei gelesen wurde erhalten bleiben muss w√§hrend die Schrift verwendet wird. Momentan wird intern wie fr√ºher auch
  eine 'Texture Font' genutzt da dies einfach die beste Performance hat - allerdings war die Schrift anfangst dann immer 'schwarz' da FTGL die Schrift
  in einer 'GL_ALPHA'-Texture h√§lt. Gestern machte ich recht lange herum, kam aber auf keine L√∂sung wie man auch Schriften damit eine Farbe verpassen kann...
  Nachde ich eine Nacht √ºber das Problem geschlafen hatte gelang mir das heute morgen sehr schnell eine saubere L√∂sung zu finden: √úber 'glTexEnvi'
  wird der Alpha-Wert in der Schrift Texture zusammen mit der aktuell √ºber 'glColor' eingestellten Farbe kombiniet - et voila, es sind wieder Farbige
  Texture Schriften m√∂glich! :D
  Die aktuelle Implementation ist noch nicht vollst√§ndig, aber soviel wie fr√ºher geht allemal und es sieht dazu noch besser aus + man kann komfortabel
  Schriften wie 'ttf' oder 'otf' nutzen. F√ºr PL sollten wir selbst immer 'otf', also 'OpenType' nutzen da es 'aktueller' ist und die Schrift Dateien
  normalerweise deutlich kompakter sind. (au√üer jemand hat einen guten Grund wieso wie das Format nicht nutzten sollten :)
  -> Passte alle Projekte an diese √Ñnderungen an. Als Default-Schrift wird derzeit "Standard.pak/Data/Fonts/LinLibertine_Re-2.7.9.9.otf" genommen. Diese
     Schrift ist ganz ok und kann frei genutzt werden. 'Gefunden' habe ich diese Schrift hier: http://linuxlibertine.sourceforge.net/



>> 13.04.2008
[CO]
- 'RendererContext'-Klasse eingef√ºhrt. Diese verwaltet bereits 'Renderer', 'TextureManager', 'ShaderManager', 'EffectManager', 'MaterialManager'
  -> Passte alle Projekte entsprechend an
- Renderer API Wrapper Klassen in 'Renderer'-Unterordner verschoben
  -> Passte alle Projekte entsprechend an



>> 12.04.2008
[CO]
PLRendererOpenGL:
- Versuchte nochmals ein paar Minuten lang GLSL √ºber Cg zu nutzen um Shader 3.0 auf meiner ATI Karte ('nat√ºrlich' unterst√ºtzt Cg NUR NVIDIA Extensions
  f√ºr mehr als Shader 2.0!"$=!"$=!") nutzen zu k√∂nnen - auf Dauer kommen wir da nicht drum herum. Allerdings waren die Ergebnisse nicht sonderlich
  prall und bis auf supereinfache Shader ging im Grunde nix richtig + man ben√∂tigt einen Hack der Shader wieder korrekt Deaktiviert, Cg scheint das
  n√§mlich bei GLSL Profilen nicht selbst automatisch zu machen. Schade. Habe das mit Shader unter GLSL korrekt deaktivieren eingebaut, kann das aber
  Zeitlich erstmal nicht weiterverfolgen da noch anderes zu machen ist.



>> 06.04.2008
[CO]
- 'PLRenderer::Texture' in 'PLRenderer::TextureBuffer' umbenannt, das gleiche f√ºr die konkreten Typen, so gibt es keinen Namenskonflikt mehr mit
  'PLMesh::Texture'. Passte alle Projekte entsprechend an so das alles wieder lauff√§hig ist. Allerdings muss man die Verwendung in den anderen
   Projekten nochmal genauer durchschaun und pr√ºfen ob das nun 'Texture' oder 'TextureBuffer' ist damit das sauber getrennt ist.
- Alle Renderer-Backends haben nun ihren eigenen Namespace so wie es mittlerweile auch bei den anderen √§hnlichen Projekten der Fall ist. Das ist
  so herum einfach viel √ºberschaubarer was wo liegt + man muss nicht mehr k√ºnstlich neue Namen wie z.B. 'TextureBuffer1DOpenGL' generieren.
- 'PLRenderer::Shader' in 'PLRenderer::ShaderProgram' umbenannt, so gibt es keinen Namenskonflikt mehr mit 'PLMesh::Shader'. Passte alle Projekte
  entsprechend an so das alles wieder lauff√§hig ist.
- 'Texture', 'Shader', 'Effect', 'Material' + ein paar Animations-Klassen (da von 'Texture' ben√∂tigt) von PLMesh nach PLRenderer verschoben. Passte
  alle Projekte entsprechend an so das alles wieder lauff√§hig ist.



>> 05.04.2008
[SB]
- Surface: So ge√§ndert, dass der SurfacePainter von aussen gesetzt werden kann. F√ºr das neue Application-Framework sollte
  das m√∂glich sein, da nun alles im Rahmen einer Application-Instanz erzeugt und verwaltet werden sollt. Ich denke, die alte
  Methode √ºber den Namen kann dann ganz gel√∂scht werden. Aber erst, wenn das Framework steht :-)



>> 31.12.2007
[CO]
PLRendererD3D9:
- Konstruktoren der Texture Implementationen noch etwas aufger√§umt so das man hier im Fehlerfall kein 'return' mehr hat +
  die Daten korrekt zur√ºck gesetzt werden.
- ShaderD3D9::SetParameterTexture(): Die Funktion liefert nun die korrekte Texture Stage zur√ºck an die die Textur gebunden wurde.
  Leider gab es keine 'direkte' M√∂glichkeit an diese Information zu kommen, darum musste ich hier etwas Tricksen. :D
- Texturen: Upsala, Image::Mode_DXTCDataFormat != Image::Mode_DXTCFormat ich sollte anfangen meine eigenen Kommentare zu lesen *g*



>> 28.12.2007
[CO]
PLRendererD3D9:
- Auf das "November 2007"-DirectX SDK umgestellt + alle unn√∂tigen Libs und Header entfernt (wir nutzen ja wirklich NUR das grundliegenste :)
- Shader gehen wieder soweit, musste daf√ºr 'nur' etwas mit ein paar Cg Features herumspielen. Merkw√ºrdig ist u.a. das Vertex und Fragment Shader 3.0
  irgendwie fast immer "Unkown error" produzieren. Aber im gro√üen und ganzen gehts so nun erstmal. (was nicht hei√üt das √ºberall alles ok aussieht, da
  spielen noch andere Dinge mit rein :)



>> 27.12.2007
[CO]
PLRendererD3D9:
- Texture::R8G8B8 Kommentar erweitert da man NICHT davon ausgehen kann das es bei jeder Implementation intern wirklich 24-Bit sind. Unter D3D9
  muss ich z.B. D3DFMT_X8R8G8B8 anstatt D3DFMT_R8G8B8 nutzen da das letztere nicht sonderlich weit vom Hardware-Support her verbreitet zu sein
  scheint. (... egal welche API, immer das gleiche da die Hardware soetwas von unterschiedlich ist...)
- Das 'hochladen' von Textur Daten mit ber√ºcksichtigung von Kompression und Mipmaps m√ºsste nun klappen (konnte jedenfalls keine Probleme
  feststellen)



>> 25.12.2007
[CO]
PLRendererOpenGL:
- Es fehlten Sicherheits-Abfragen f√ºr 'glActiveTextureARB' und 'glClientActiveTextureARB'... hab hier zum Testen gerade 'GDI Generic' als Renderer
  laufen, also das was bei Windows beiliegt - und das kann nat√ºrlich praktisch nix und ich bekam immer sofort einen Crash wenn ich etwas laufen
  lassen wollte.



>> 24.12.2007
[CO]
PLRendererD3D9:
- Man 'sieht' wieder etwas, bei einer der xxx Anpassungen hatte ich die Matrizen falsch √ºbergeben



>> 22.12.2007
[CO]
PLRenderer:
- Auf "Cg 2.0 December 2007" umgestellt (keine PL Code √Ñnderungen)



>> 21.12.2007
[CO]
PLRendererOpenGL:
- Fand gerade heraus wieso auf meinem neuem Notebook "scheinbar" 'Rectangle Texturen' nicht gehen - stellte sich heraus das auch
  im z.B. Texture Debug Dialog 'normale' Texturen nicht korrekt (bzw. gar nicht) angezeigt wurden... als ich etwas herum probierte
  landete ich am Ende in "RendererOpenGL::DrawBitmap()", genauer gesagt bei der Verwendung von "glMultiTexCoord2f()". Als ich zum
  Testen dort "glTexCoord2f()" einsetzte ging auf einmal alles wie auf dem alten Notebook!
  Googelte etc. etwas, fand aber nix was das erkl√§ren k√∂nnte... DAS kann eigentlich nur ein Treiber Bug von ATI sein, denn nicht
  nur in PL tritt das bei mir auf. Z.B. sehe ich beim "Starship Troopers"-Spiel (und noch bei anderen Dingen) das gleiche einfarbige
  flackern wie wenn ich in PL Post Processing an habe. √ÑRGERLICH!
  Da mir das nun zu bl√∂de wurde nahm ich die spezielle OpenGL "DrawBitmap()" von uns heraus so das immer mit Vertex Buffern gearbeitet
  wird. "glBegin()" etc. wird in OpenGL 3.0 nicht mehr dabei sein da es total veraltet ist und nicht mehr wirklich ins Konzept passt
  und alles nur umst√§ndlich und langsam macht. (die OpenGL Treiber Entwicklung ist angeblich mittlerweile Horror da alles in zig
  m√∂glichkeiten ausartet wovon viele noch aus Zeigen stammen als es keine GPU's gab)
  √úberlegte mir schon mehrmals ob ich "glBegin()" etc. komplett aus unserem OpenGL Renderer rausnehmen sollte... nun hab ich zumindestens
  einen Grund das an der Stelle rauszuhauen. :D



>> 23.10.2007
[CO]
PLRenderer:
- 'Types.h': Die verschiedenen Konstanten sind nun in Klassen anstatt Namespaces 'verpackt'. So herum sieht das in der
  von Doxygen erzeugten Dokumentation um einiges besser aus da die einzelnen Render-Definitionen nicht mehr als Namespaces
  auftauchen.



>> 20.09.2007
[CO]
PLRenderer:
- IndexBuffer: Neue Funktion namens 'SetElementTypeByMaximumIndex()' hinzugef√ºgt die 'automatisch' anhand eines √ºbergebenen
  maximalen Vertex Index einen passenden Element Typ setzt. Mir viel vor kurzem auf das wir h√§ufige dieses Zeilen in den
  Codes stehen hatten:
    if (nVertices <= IndexBuffer::MaxVertexIndexUShort)
        pIndexBuffer->SetElementType(IndexBuffer::UShort);
    else pIndexBuffer->SetElementType(IndexBuffer::UInt);
  ... daher denke ich das diese neue Funktion recht Praktisch ist da man nun nur noch
      pIndexBuffer->SetElementTypeByMaximumIndex(nVertices-1);
  schreiben muss was viel √ºberschaubarer ist + ganz nebenbei muss man sich keine Gedanken mehr machen ob das nun nur '<'
  oder '<=' ist. *g*



>> 17.09.2007
[CO]
- Alle Projekte von PLBool auf bool zur√ºckgestellt (siehe PLBase Diary-Entrag von heute)



>> 08.09.2007
[CO]
PLRendererOpenGL:
- SurfaceWindowOpenGL::GetGamma(): Der verwendete Buffer liegt nun direkt auf dem Runtime-Stack, in der Funktion konnte
  es sogar ein Speicherleck geben wenn GetDeviceGammaRamp() fehlschlug!
- SurfaceWindowOpenGL::SetGamma(): Der verwendete Buffer liegt nun direkt auf dem Runtime-Stack
PLRendererD3D9:
- TextureCubeD3D9-Konstruktor: Zeiger auf die 6 CubeMap-Seiten liegen nun direkt auf dem Runtime-Stack



>> 06.09.2007
[CO]
PLRenderer:
- Auf "Cg 1.5 August 2007" umgestellt (war nur header, libs und dlls austauschen)
- cgSetAutoCompile() auf CG_COMPILE_LAZY gestellt damit die Shader erst dann √ºbersetzt werden wenn diese wirklich ben√∂tigt
  werden



>> 22.08.2007
[CO]
PLRenderer:
- RendererOpenGL::GeneralSettings(): Nahm [TODO] heraus... wir lassen einfach die Default Einstellungen, diese Dinge machen
  heute sowieso nicht mehr sonderlich viel aus :)
- Nahm die Funktion "DrawSphere()" aus der Renderer-Klasse heraus da dies etwas zuviel des guten ist und das unter D3D
  nicht sonderlich schnell implementiert w√§re + man unter OpenGL nicht ohne weiteres rausbekommt wieviele Vertices denn nun
  rausgehauen wurden. Macht also mehr √Ñrger als es Wert ist. Will man ne Sphere haben, kann man sich schnell so nen Mesh
  √ºber einen Mesh-Creator erzeugen lassen, das ist kein Beinbruch. (wurde zudem auch nur in PLEngine::SceneNode::DrawDebug()
  verwendet)
  DrawTriangle() etc. lass ich mal drinnen da dies recht einfache Dinge sind und gerade DrawBox() etwas nettes ist.
RendererBackend:
- DrawPoints2D() & DrawPoints3D() & DrawLines2D() & DrawLines3D(): Nahm das [TODO] 'Implement more performant technique...
  (using m_pTempVertexBuffer)' heraus da soetwas nicht ganz unproblematisch w√§re da man nicht w√ºsste wie gro√ü dieser
  Zwischenbuffer sein m√ºsste. Das g√§be eine ziemlich Chaotische Implementation zu versuchen da soetwas einzubauen... entweder
  wenn n√∂tig vergr√∂√üern, dann h√§tte man eventuell pl√∂tzlich einen 20 MB Vertex Buffer oder so und m√ºsste wieder schaun wann
  man den wie wieder dynamisch verkleinern kann. Das lohnt alles irgendwie nicht, zudem ist diese Angebotene Implementation
  so oder so immer Eingeschr√§nkt da man nie ALLES bieten k√∂nnen wird was man in jeder m√∂glichen Situation mal brauchen
  k√∂nnte. (z.B. Vertex Farben, Textur Koordinaten etc) Wenn man VIELE solcher Elemente zeichnen will, muss man sich nen
  Vertex Buffer schnell selbst anlegen und f√ºllen - oft hat man ja diesen Buffer bereits. Das w√§re also viel mehr Aufwand
  soetwas zu implementieren als es nutzen bringen w√ºrde. :)



>> 07.08.2007
[CO]
PLRenderer:
- SurfacePainter::OnPaintBegin() liefert nun einen Fehlerwert zur√ºck



>> 03.08.2007
[CO]
PLRenderer:
- TextureRectangle::GetNumOfBytes(): F√ºr komprimierte Texturen eine andere Formel eingebaut, das m√ºsste so passen da dies
  so in der DirectX Dokumentation steht.



>> 06.07.2007
[CO]
PLRenderer + Backends:
- Wo m√∂glich/sinnig von Zeiger auf Referenzen umgestellt



>> 02.06.2007
[CO]
PLRenderer:
- Texture: Neue Funktionen: GetPriority() & SetPriority(): Damit l√§sst sich die GPU Textur Speicherverwaltung etwas beeinflussen.
  OpenGL kennt auch noch 'glAreTexturesResident' wor√ºber man rausfinden kann ob eine Textur gerade im Textur-Speicher ist oder
  nicht - bei D3D konnte ich so eine Funktion bis jetzt noch nicht finden und f√ºgte daher erstmal keine solche Funktion
  ins Textur Interface ein.
PLRendererOpenGL:
- Ein paar unn√∂tige 'glClientActiveTextureARB' herausgenommen
- Sampler State Changes minimiert indem jede Textur noch ihre aktuellen States speichert und nur wenn n√∂tig etwas angeglichen
  wird... In OpenGL werden diese zust√§nde pro Textur, in D3D pro Stage gespeichert - f√ºr PL entschied ich mich damals f√ºr
  die D3D Methode. :)
  Performance m√§√üig konnte ich keine √Ñnderung feststellen, allerdings sind die API Aufrufe hier nun meistens um den Faktor
  10 weniger - das sah im Profiling schon etwas merkw√ºrdig aus wenn da immer z.B. '1000' Sampler State Changes stand obwohl
  nicht viel auf dem Bildschirm zu sehen war.



>> 21.05.2007
[CO]
PLMesh: Effekt-Komponente:
- Ein paar 'const' eingef√ºgt
- Ein paar Konstruktoren & Destruktoren hinzugef√ºgt, ein paar Dinge 'private' gemacht + sichergestellt das in den Konstruktoren
  auch ohne RTTI alle Variablen korrekt Initialisiert werden
- Ein paar Zeiger zu Referenzen gemacht damit man den 'NULL'-Fall wo √ºberhaupt nicht m√∂glich auch nicht ber√ºcksichigen muss
- EffectPass-Interface aufger√§umt
-> Uh, merkte gerade das durch diese s√§uberungen in der Beispiel-Szene 'PhysicsPlayground.scene' der merkw√ºrdige Grafik-Bug
   mit teils falsch gesetzten States verschwunden ist sobald das Wasser sichtbar wurde... das zeigt mal wieder deutlich das
   es sich definitiv lohnt immer mal wieder klar Schiff zu machen. *g*



>> 19.05.2007
[CO]
PLRenderer:
- SurfacePainter + davon abgeleitete Klassen durchgeschaut und wo n√∂tig Destruktoren hinzugef√ºgt + bestimmte Dinge 'protected'
  oder gar 'private' (wo z.B. nicht weiter abgeleitet werden k√∂nnen soll) gemacht so das die Sichtbarkeit soweit korrekt ist
- GetCustomFlags() & SetCustomFlags() aus dem Renderer-Interface herausgenommen da dies nicht sonderlich universell und
  nur sehr eingeschr√§nkt nutzbar ist (wurde bis heute auch noch nie wirklich verwendet :)



>> 10.05.2007
[CO]
- Sortierte ins Diary so richtig alte Eintr√§ge aus "PLSDK/internal/old_diaries.zip" ein



>> 09.05.2007
[CO]
- Alte Diary Eintr√§ge von ab "21.03.04" einsortiert



>> 06.05.2007
[CO]
RendererOpenGL:
- RendererOpenGL::GetCombinedMinMipFilter() pr√ºft anfangs ob Mipmaps vorhanden sind, wenn nicht, so wird 'GL_NEAREST' als
  Fallback zur√ºckgegeben damit OpenGL trotzdem noch etwas korrekt ausf√ºhren kann
- RendererOpenGL::SetSamplerState() pr√ºft ob √ºberhaupt eine Textur gesetzt ist, ist dem nicht so, so wird der interne Status
  nicht ge√§ndert + f√ºgte noch ein paar glGetError()-Abfragen ein damit man Informiert wird wenn etwas nicht klappte



>> 10.04.2007
[CO]
PLRenderer + Backends:
- Einige 'return' entfernt



>> 24.03.2007
[CO]
- PLRendererD3D9 Backend etwas aufger√§umt



>> 21.03.2007
[CO]
- PLRenderer Backends etwas aufger√§umt



>> 17.03.2007
[CO]
PLRenderer:
- Header & Namespace √Ñnderungen wie in z.B. PLBase



>> 03.03.2007
[CO]
PLRendererOpenGL:
- FrameBufferObject: Hat nun ein weiteres Flag Namens 'Color'. Ist dieses nicht vorhanden, handelt es sich um einen reinen
  Tiefenbuffer und es darf KEIN eigener Tiefenbuffer hinzugef√ºgt werden - sonst gibts (zumindestens bei mir) einen √ºblen
  Treiber Crash :(



>> 21.02.2007
[CO]
PLRenderer:
- ShaderCgBackend::BackupDeviceData(): Statt 'strcpy' wird hier nun memcpy genutzt, wunderbar keine Compiler-Warnung mehr
  (memcpy scheint Sicherer zu sein *g*)
PLRendererOpenGL:
- OpenGLExtensions::CheckExtension() etwas vereinfacht und √ºbersichtlicher gemacht



>> 11.02.2007
[CO]
- Auf VC 2005 umgestellt
PLRendererD3D9:
- Da man hier 'd3dx9.h' einbindet bekam ich zuerst folgende Fehlermeldungen:
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(222) : error C2146: Syntaxfehler: Fehlendes ';' vor Bezeichner 'PVOID64'
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(222) : error C4430: Fehlender Typspezifizierer - int wird angenommen. Hinweis: "default-int" wird von C++ nicht unterst√ºtzt.
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(5940) : error C2146: Syntaxfehler: Fehlendes ';' vor Bezeichner 'Buffer'
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(5940) : error C4430: Fehlender Typspezifizierer - int wird angenommen. Hinweis: "default-int" wird von C++ nicht unterst√ºtzt.
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(5940) : error C4430: Fehlender Typspezifizierer - int wird angenommen. Hinweis: "default-int" wird von C++ nicht unterst√ºtzt.
  -> Fand aber zum Gl√ºck recht schnell raus was probleme machte bzw. wie man das 'l√∂st':
  Bei den 'zus√§tzlichen Include Verzeichnissen' MUSS man
    '$(VCInstallDir)PlatformSDK/include'
  VOR
    'external/win32/dx_9/Include/'
  einf√ºgen, dann gehts. (ich erspare mir weitere MS-Kommentare *g*)



>> 28.01.2007
[CO]
- VC Projekt-Dateien wie besprochen in die jeweiligen Grundordner verschoben



>> 27.01.2007
[SB]
- CMake Projektdateien f√ºr alle PLEngine-Projekte hinzugef√ºgt 



>> 11.01.2007
[CO]
PLRendererOpenGL:
- Bugfix: Falls eine Renderer Textur aus einem gegebenen Bild erzeugt werden sollte, konnte es noch zu Format Problemen
  kommen wenn in dieser √ºbergebenen Textur z.B. Level-0 Daten Komprimiert waren, aber die anderen Mipmap Levels nicht. Nun
  kann man frei kombinieren.



>> 22.12.2006
[CO]
Allgemein:
- An ein paar Stellen wurde der Element Typ von Index Buffern nicht korrekt gesetzt da die Anzahl der Indices, und nicht
  die Anzahl der Vertices verwendet wurde... aber der Typ gibt nat√ºrlich den gr√∂√üten speicherbaren Vertex Index an. :)
- Nahm einige Code Umformungen vor (haupts√§chlich bei for-Schleifen) um die Lesbarkeit zu erh√∂hen



>> 17.12.2006
[CO]
PLRenderer + Backends:
- In den BackupDeviceData() Funktionen der verschiedenen Resourcen wird das Backup auf NULL gesetzt wenn kein Backup vorhanden
  ist
PLRendererOpenGL:
- Texture3DOpenGL: 'm_nTotalNumOfBytes' wurde bei automatisch erzeugten Mipmaps nicht gesetzt



>> 16.12.2006
[CO]
PLRenderer:
- TextureStageStates.h, RenderStates.h, SamplerStates.h -> Hier wurde 'Config.h' aus PLGeneral includiert obwohl das
  √ºberhaupt nicht n√∂tig ist. Durch das entfernen musste man nun an verschiedenen Stellen z.B. 'Log.h' aus PLGeneral
  includieren was aber durchaus korrekt ist.



>> 01.12.2006
[CO]
PLRenderer + Backends:
- Gleiche √Ñnderung wie in PLPhysics



>> 11.11.2006
[SW]
PLRendererOpenGL:
- in den Funktionene RendererOpenGL::BeginScene() und RendererOpenGL::EndScene() unter linux den aufruf von
  glXWaitX(in BeginScene) und glXWaitGL(in EndScene) hinzugef√ºgt. Diese Funktionen sorgen daf√ºr, das alle vor dem aufruf der Funktion
  entstandenen XEvents(glXWaitX) bzw. OpenGL Events(glXWaitGL) durchgef√ºhrt werden.
  Das ganze verbessert etwas das verhalten beim Verschieben/ver√§ndern der Gr√∂√üe des Fensters unter Linux.
- PLRenderer: fehlenden Constructor hinzugef√ºgt, hatte zu einem undefined reference beim laden der lib gef√ºhrt, trat aber nur im debug-build auf.
- In SurfaceWindowLinux das setzen und auslesen der Gamma werte und die Behandlung f√ºr die 32bit Farbtiefe eingef√ºgt.



>> 09.11.2006
[CO]
RendererOpenGL:
- SetShaderTexture(): Bugfix: Hier fehlte das aktivieren von Textur-Typen. (z.B. glEnable(GL_TEXTURE_2D)) Lief es mal
  richtig dumm, war eine Textur zwar gesetzt, aber nicht aktiviert. (in z.B. 'plfx_Effects.scene' konnte es dadurch zu
  'Grafik Bugs' kommen)



>> 04.11.2006
[CO]
PLRenderer:
- SurfaceTexture: Neues Flag: Mipmaps: Ist dieses Flag gesetzt, so werden von der GPU Mipmaps 'on the fly' erzeugt.
  (nat√ºrlich nur falls dies auch unterst√ºtzt wird) Das kostet zwar etwas mehr Performance, jedoch 'pixeln' diese Texturen
  dann nicht mehr wenn diese 'etwas weiter' weg Dargestellt werden. Derzeit klappt das jedoch leider nur f√ºr FBO korrekt.
PLRendererOpenGL:
- FrameBufferObject::Initialize(): Tiefen Buffer crasht auf dem neuen Catalyst Treiber 6.10 nicht mehr :)



>> 31.10.2006
[CO]
PLRendererOpenGL:
- TextureCubeOpenGL::TextureCubeOpenGL(Renderer *pRenderer, uint32 nSize, EPixelFormat nFormat, uint32 nFlags):
  Anzahl der Bytes darf hier nat√ºrlich nicht durch 6 geteilt werden. :)



>> 20.10.2006
[CO]
PLRendererOpenGL:
- Beim hochladen bereits komprimierter Bilder muss man (neuerdings??) auch pr√ºfen ob wirklich komprimierte Daten vorliegen -
  denn Mipmaps scheinen nicht mehr in komprimierter Form vorzuliegen, auch denn das Hauptbild dieses tut. Sicherlich mal
  wieder so ne DevIL '√§nderung', das war zwar nicht fatal da es vom Renderer 'kompensiert' wurde - aber nicht wirklich
  optimal. :(
- RendererOpenGL::ChooseFormats(): Liegt eine Textur bereits Komprimiert vor, es soll aber gerade keine Textur Kompression
  verwendet werden, so wird diese Komprimierung einfach ignoriert.



>> 19.10.2006
[CO]
PLRenderer:
- Renderer: GetLightEnabled() in IsLightEnabled() umbenannt
- Surface: GetSwapY() in IsSwapY() umbenannt
- Surface: GetAPISwapY() in IsAPISwapY() umbenannt
- Surface: GetActive() in IsActive() umbenannt
- Surface: GetWidth() & GetHeight() 'const' eingef√ºgt
- Renderer: GetClipPlaneEnabled() in IsClipPlaneEnabled() umbenannt



>> 14.10.2006
[SW]
Alle Projekte: finale version f√ºr das visibility attribute feature vom gcc.



>> 11.10.2006
[SB]
Wieder diverse Anpassungen:
- √úberbleibsel aus einem alten Merge-Error aus dieser Datei entfernt
- Unn√∂tigen [DEBUG]-Kommentar entfernt
- PLLOCAL entfernt - dieses Makro nutzen wir nicht!
- Eingef√ºgte Konstruktoren und Destruktoren mit Kommentaren versehen und in die richtige Reihenfolge gebracht



>> 11.10.2006
[SW]
Alle Projekte: Die projekte verwenden das neue visibility feature vom gcc, wenn vorhanden.
- PLRenderer: den Klassen Frame und Window den virtuellen dtor hinzugef√ºgt,
  damit werden die probleme mit dem visibility-feature vom gcc behoben



>> 04.10.2006
[CO]
- An ein paar Stellen (ColorX & VectorX) "String::Format(" durch ".ToString()" ersetzt



>> 28.09.2006
[SW]
- Linux-port Folgende Project an √Ñnderungen von PLBase angepasst: PLRenderer, PLMesh, PLRendererOpenGL
PLRendererNull:
- Linux projekt dateien hinzugef√ºgt.



>> 24.09.2006
[CO]
- PLRenderer + Backends: Fand noch ein paar auf PLBool umzustellende Stellen



>> 22.09.2006
[CO]
- PLRenderer + Backends auf PLBool umgestellt + die anderen Projekte wo es n√∂tig wurde angepasst



>> 14.09.2006
[CO]
- Beseitige Warnungen die erscheinen wenn der Compiler auf Warnungs-Level 4 gestellt wird



>> 13.09.2006
[CO]
- Dort wo PLRenderer::Buffer::Lock verwendet wird sollte immer mit angegeben werden was f√ºr Operationen auf dem Buffer stattfinden
  werden so das der Renderer intern das m√∂glichst geschickt handhaben kann. F√ºgte dort wo das noch nicht der Fall war jeweils
  einen entsprechenden Lock-Typ ein... der jedoch wirklich nur als 'Verwendung-Hinweis' zu verstehen ist. Gibt man 'Read' an
  kann man trotzdem noch Schreiben, aber eventuell nicht mehr ganz sooo Performant - das h√§ngt von einigen Faktoren ab. :)



>> 23.08.2006
[CO]
PLRenderer:
- Frame::SetFullscreenMode(): Nach dem wechsel des Bildschim-Modus wurde die neue Oberfl√§che des Painers nicht aktualisiert.



>> 09.08.2006
[CO]
PLRendererOpenGL:
- ShaderOpenGL::Init(): Konnte den kleinen GeForce4 Hack entfernen da es bei den neuen Cg Versionen korrekt geht... diesmal
  war es sogar so, das dieser Hack auf meiner GeForce4 einen Crash in cgGLLoadProgram verursachte. :)



>> 08.08.2006
[CO]
PLRendererOpenGL:
- SurfaceTextureOpenGL: Uh, durch irgendeine Umstellung kam hier etwas √ºbel durcheinander... eine kleine Klammer war falsch
  gesetzt, dadurch wurde aber der PBuffer intern als 'not managed' angesehen und der Speicher wurde am Ende nicht freigegeben...



>> 28.07.2006
[CO]
PLRenderer:
- RendererBackend::CheckTextureCube(): Sind die Seiten als einzelnde Bilder √ºbergeben worden, so wird zus√§tzlich noch gepr√ºft
  ob alle Bilder gleich gro√ü sind und das gleiche Format haben - ansonnsten klappt das nicht.
- Die TextureCube Implementationen erkennen nun ob direkt das erste Image eine Cube Map ist, ist dies der Fall, werden eventuell
  √ºbergebene weitere Images ignoriert.



>> 25.07.2006
[CO]
Renderer:
- Capabilities: Es wird nun zwischen nMaxTextureSize und nMaxRectangleTextureSize unterschieden da diese Werte unterschiedlich
  sein *k√∂nnen*
RendererOpenGL:
- CreateTexture3D() & CreateTextureCube(): Hier fehlte noch eine kleine Abfrage ob dieser Textur Typ unterst√ºtzt wird.
- Neben GL_ARB_texture_cube_map wird nun auch GL_EXT_texture_cube_map gepr√ºft, zwar wurde diese Extension scheinbar ziemlich
  schnell zum 'Standard', aber sicher ist sicher.
- Neben GL_ARB_occlusion_query wird nun auch GL_NV_occlusion_query unterst√ºzt das praktisch identisch ist - nur f√ºr alle F√§lle.
- Ist GL_ARB_vertex_program nicht verf√ºgbar, wird in VertexBufferOpenGL::MakeCurrent() das gute alte glFogCoordPointerEXT verwendet,
  aber nur wenn GL_EXT_fog_coord vorhanden ist.
- Es wird gepr√ºft ob GL_EXT_secondary_color vorhanden ist
- Schrieb dazu das dies ein OpenGL 1.1 (aus dem Jahre 1992 :) Renderer ist und alles weitere √ºber Extensions reinkommt, so sind wir
  vom Renderer so Abw√§rtskompatibel wie irgend m√∂glich. So muss man auch keinem erkl√§ren wieso man das eine Testen sollte und
  das andere nicht. Noch gibt es jedoch einiges an entsprechenden Abfragen und Fallbacks einzubauen damit das auf so vielen (alten) Karten
  wie m√∂glich l√§uft. Und dann m√ºsste man sich soetwas wie eine 'Versions-Nummer' ausdenken, wohl D3D9 vergleichbar so das ich als
  User auf einen Schlag pr√ºfen kann auf welcher GPU Generation das hier gerade l√§uft - um z.B. dann schon gleich beim Programmstart
  abbrechen zu k√∂nnen wenn das die aaalererste GPU Generation ist, ich aber mindestens die dritte erwarte da alles andere keinen
  Sinn machen w√ºrde.
- Nahm GL_EXT_polygon_offset heraus da dies bereits in OpenGL 1.1 vorhanden ist, und bei heutigen Karten scheint das √ºberhaupt
  nicht mehr in der Extension Liste aufzutauchen. (Stephan und ich konnten es auf unseren mittlerweile betagten Rechnern nicht finden :)



>> 24.07.2006
[CO]
PLRendererOpenGL:
- Neben GL_EXT_texture_rectangle und GL_NV_texture_rectangle gibts noch GL_ARB_texture_rectangle (jipi, es lebe die Freiheit!)
  welches das gleiche ist, und nur einen anderen Namen hat. Baute noch einen Test auf diese Extension ein damit das wirklich
  sicher erkannt wird ob das Feature verf√ºgbar ist oder nicht.



>> 21.07.2006
[CO]
RendererOpenGL:
- Das mit den OS-abh√§ngigen Funktionen etwas aufger√§umt, so m√ºsste das nun etwas √ºbersichtlicher sein.



>> 09.07.2006
[CO]
PLRenderer:
- √Ñnderte die Funktionen GetDefaultRenderStates() zu GetDefaultRenderState(), GetDefaultSamplerStates() zu GetDefaultSamplerState(),
  GetDefaultTextureStageStates() zu GetDefaultTextureStageState() und GetDefaultMaterialStates() zu GetDefaultMaterialState().
  Statt einen Array mit den Default Werten zu f√ºllen, fragt man nun einzelnde Default Werte ab. Zum einen ist das etwas sicherer
  da es wenn ein Array zu klein war nat√ºrlich zu Problemen kam, zum anderen ist man meistens an einzelnen Default Werten interessiert
  und da ist es einfach Handlicher wenn man diese einzelnd anstatt als ganzen Brocken bekommen kann.



>> 07.07.2006
[CO]
PLRenderer:
- Frame: SetFullscreenMode() an die SurfacePainter √Ñnderung angepasst: Hier muss der Surface Painter etwas unsch√∂n 'weggespeichert'
  werden da ein zerst√∂ren & neu erzeugen hier 'etwas' viel Aufwand f√ºr nix w√§re.



>> 03.07.2006
[CO]
PLRenderer:
- Nahm wie gestern mit Stefan besprochen den Surface Listener heraus. F√ºgte SurfacePainter hinzu. Surface um GetPainter() und
  CreatePainter() erweitert. Sobald eine 'Oberfl√§che' aktualsiert wird, wird der SurfacePainter dieser Oberfl√§che aufgerufen
  der f√ºr das 'Zeichnen' verantwortlich ist. Da diese Klasse an das RTTI gekoppelt ist, ist das die Entwicklung neuer
  'Surface Renderer' recht einfach und universell.



>> 30.06.2006
[CO]
PLRenderer:
- SetViewport() & SetScissorRect(); (0, 0) liegt nun wieder links-oben. Das passt zwar nicht mit unserem 3D Koordinatensystem
  zusammen, allerdings ist rechts-unten an vielen Stellen noch unhandlicher als das umrechnen von y an ein paar Stellen...
  gerade beim ingame gui h√§tte man viel herumwurschteln m√ºssen und das platzieren von 2D Texten w√§re anderst gewesen als das
  platzieren von Gui Texten was eher verwirrend als hilfreich gewesen w√§re.



>> 27.06.2006
[CO]
PLRenderer:
- GetViewport(), SetViewport(), GetScissorRect(), SetScissorRect() Arbeiten nun mit der neuen Klasse PLMath::Rectangle. Dadurch
  l√§sst sich das nun um einiges netter Bedienen. Desweiteren ist der Punkt (0, 0) nun links unten anstatt links oben wie bisher
  -> so passt das auch mit unseren Koordinaten System (rechte Hand) zusammen.



>> 16.06.2006
[CO]
PLRendererOpenGL:
- Wenn die Extension GL_SGIS_generate_mipmap vorhanden ist, so muss man wenn man Texturen hochl√§d nicht z.B. gluBuild2DMipmaps()
  verwenden um Mipmaps zu erzeugen sondern kann dies der GPU √ºberlassen. Dann kann man sogar eine eventuelle Kompression
  direkt √ºbernehmen... ich hoffe das wir so laangsam mal alles Textur m√§√üig m√∂gliche & Sinnige drinnen haben...
- Bugfixing: In Parameters::Semantic mussten die Enums noch angepasst werden. Damit Shadow Mapping funktioniert mussten
  ein paar kleine Einstellungen ge√§ndert werden.



>> 15.06.2006
[CO]
PLRenderer:
- Parameters: SetParameterTexture(): Der nStage Parameter durfte gehen da er hier √ºberfl√ºssig ist. Cg bindet die Textur selbst
  an eine geeignete Texture Stage welche man dann abfragen muss um die PL Renderer States korrekt zu setzen. In PLMesh::ParameterManager
  konnte man mit dieser Information sowieso nichts anfangen und daher ich bin froh das man diesen Parameter komplett entfernen
  konnte damit alles einheitlich ist. :)
  Da man wenn man Shader verwendet sowieso keine Kontrolle dar√ºber hat wo welche Textur landet, und im Prinzip auch gar keine
  haben muss da es bei Cg-Shadern egal ist, nahm ich die Texture<index>-Semantics heraus... im Effekt wurden diese sowieso
  nicht mehr verwendet da eine Textur in verschiedenen P√§ssen/Schichten verwendet werden kann und man daher keine feste
  Texture Stage angeben konnte. Die TextureMatrix<index>-Semantic macht dadurch ebenfalls keinen Sinn mehr. Will man Textur
  Matrizen setzen um z.B. eine Textur durch verschieben zu 'animieren', so muss sich der Szene Renderer darum k√ºmmern das
  die Infos korrekt an die Shader weitergegeben werden... falls diese √ºberhaupt Textur Matrizen unterst√ºzen. :)



>> 13.06.2006
[CO]
PLRendererOpenGL
- RendererOpenGL::Init(): Ighh, kann mich gar nicht dran erinnern hier m_sCapabilities.nMaxClipPlanes auf 5 gesetzt zu haben.
  Das ist nat√ºrlich totaler unf√ºg... hatte mich gerade schon gewundert wieso ich nur 5 Clipping Planes habe... :)
- TextureCubeOpenGL: Da GetNumOfBytes() den Speicherbedarf f√ºr ALLE Seiten zusammen f√ºr diese Mipmap Stufe zur√ºckgibt, muss
  man an diversen Stellen durch 6 Teilen.



>> 10.06.2006
[CO]
PLRenderer:
- Renderer: CreateVertexShader(), CreateFragmentShader() Funktionen um Parameter f√ºr den Programm Einstiegspunkt erweitert -
  falls dieser mal nicht 'main' hei√üen sollte.... :)
- Stellte auf die aktuellste Cg Version um... da ich mich gerade mit diesem Gebiet befasse sollte das alles so aktuell wie
  m√∂glich sein.



>> 09.06.2006
[CO]
PLRenderer:
- RenderStates & TextureStageStates & SamplerStates: Enumerations werden nun gro√ü/klein geschrieben. Zum einen ist das besser
  Lesbar, aber noch viel wichtiger, diese Namen stimmen nun genau mit den Renderer Einstellungen √ºberein so das man sich den Namen
  nur einmal merken muss. In den Default Einstellungen werden ebenfalls die Enumeration Namen anstatt der Nummer verwendet.



>> 07.06.2006
[CO]
PLRendererOpenGL:
- Bei den Upload/Download Funktionen fehlte nat√ºrlich noch das Bind-Textur. Ganz Gl√ºcklich bin ich noch nicht mit diesem
  'aktuelle Textur holen, eigene Textur setzen, Operation durchf√ºhren und alte Textur wieder herstellen'. Zum einen kann das
  superschnell in supervielen Texture State Changes ausarten wenn man z.B. sich nacheinander alle Mipmaps einer zur√ºckgeben
  l√§sst, und zum anderen weis ich nicht obs so wie es momentan ist wirklich funktioniert... was, wenn z.B. gerade eine 2D
  Textur gesetzt ist, ich aber momentan mir eine 1D Textur wegsichere - keine Ahnung ob das funkt. :)
  Da werd ich wohl bei Zeiten noch etwas anderes ausprobieren m√ºssen, aber f√ºrs erste kann man es wohl lassen.
  (gibt derzeit wichtigeres zu tun :)



>> 06.06.2006
[CO]
PLRenderer:
- In der Renderer Textur Basisklasse Upload() & Download() hinzugef√ºgt damit man Textur Daten hoch/runterladen kann. GetNumOfBytes()
  um einen Optionalen Parameter erweitert damit es m√∂glich ist sich auch f√ºr ein anderes Format den ben√∂tigten Speicher zur√ºckgeben
  zu lassen.



>> 02.06.2006
[CO]
PLRenderer:
- Shader um Parameter Typen erweitert. Derzeit gibts nur diese Typ Definitionen + Funktionen um den Typen von seinem String zu
  ermitteln oder den Typen in einen String 'umzuwandeln'.
- Shader: GetSemanticParameter() Funktion hinzugef√ºgt um den Namen des Parameters zu ermitteln der die angebene Semantic hat.
  Eine Semantic kann NUR von einem Parameter verwendet werden, alles andere w√ºrde keinen Sinn machen und es zudem nur unn√∂tig
  komplizierter machen.



>> 01.06.2006
[CO]
PLRenderer:
- Arbeite an der Shader Semantic Implementation weiter. Innerhalb der Shader Backend Implementation passiert Semantic m√§√üig im
  Prinzip nichts, die Basis Klasse selbst √ºbernimmt die gesammte Arbeit. Innerhalb der konkreten Renderer Implementationen
  muss jedesmal wenn sich an einem Render State der auch als Shader Parameter Semantic bekannt ist etwas √§ndert, so
  muss Shader::RefreshSemanticParameter() aufgerufen werden was intern nur ein 'is Dirty'-Flag setzt. Vor konkreten Zeichen
  Operationen muss intern dann Shader::BindSemanticParameters() aufgerufen werden - alle 'Schmutzigen' Shader Parameter mit
  bekannter Semantic werden dann auf aktuelle Render States gesetzt. Eine 'sch√∂nere' Implementation viel mir hier einfach
  nicht ein, man muss einfach die Shader Parameter 'synchronisieren' und das geht wohl kaum besser. :(
  W√§hrend das Shader Interface recht √ºbersichtlich ist und auch das mit der Semantic sehr einfach zu verwenden ist, ist die
  Implementation leider etwas weniger 'sch√∂n' da ich mit vielen Bit-Operationen, Callback-Funktionen und Maps arbeite damit
  alles so flott wie irgend m√∂glich von dannen geht. Die Shader Parameter mit Semantic werden z.B. erst dann wenn wirklich
  ben√∂tigt aktualsiert. Also bitte nicht 'aufschreien' das dies doch kein Mensch lesen oder gar verstehen k√∂nnte, wenn jemand
  das besser Implementieren kann OHNE einen totalen Performance Overkill zu produzieren soll er mir einfach bescheit geben. ;-)
  Da Shader mittlerweile sehr wichtig/unverzichtbar geworden sind, MUSS das einfach so flott wie irgend m√∂glich gehen auch
  wenn das dann auf kosten der Lesbarkeit der Implementation geht - an diesen internen Codes haben sowieso keine Fremden
  herumzudoktern, und jemand der dazu berechtig ist, wird wohl sicherlich kein Newbie Coder mehr sein. Die RTTI Codes sind
  f√ºr 'Au√üenstehende' ja auch nicht so ohne weiteres zu durchschauen. ;-)
  Aber dieser Aufwand lohnt definitv, in der Beispiel Szene 'NormalMapping.scene' kann man bereits sehen wie 'm√§chtig' dieses
  System ist... nun haben endlich die Lichter der Szene einen Einfluss auf die Shader, zumindestens das 'Prim√§re' Licht, denn
  mit mehrern Lichtern herumzujonglieren ist definitiv der Job eines entsprechenden Szene Renderers. Als n√§chstes m√ºssen die
  Material Parameter etwas √ºberarbeitet werden, wobei im Material weitere Shader Parameter Semantics hinzukommen werden f√ºr z.B.
  Timing, also etwas speziellere Dinge welche im Renderer selbst einfach nix zu suchen haben.
- Lies alle Projekte nach h√§ufigen Englisch Fehlern durchsuchen auf die mich Stefan vor geraumer Zeit hinwies, haupts√§chlich
  'kown', 'were' und 'byself'.
- Schaute alle Stellen bei denen in Interfaces '-1' vorkommt durch und dort wo m√∂glich √§nderte ich es (sammt Implementation)
  in <0 damit das etwas/allgemeiner Sicherer ist.



>> 31.05.2006
[CO]
PLRenderer:
- √úberarbeite die Shader im Renderer da die aktuelle Implementation viel zu aufw√§ndig war. Nahm dabei die Shader Parameter
  Klasse heraus da dies totaler Overhead war, also das 'Managen' der Uniform Shader Parameters innerhalb der Shader Klasse
  und das zwischenspeichern ('shadowing') der Einstellungen innerhalb der Shader Parameter Klasse. Die Shader API's bieten
  Funktionen an um einen gesetzten Wert auch wieder auszulesen, und die meisten API's bieten auch 'Shadowing' der Parameter
  an so das man dies wirklich nicht selbst zu machen braucht, zumindestens NICHT direkt im Shader Wrapper - im Renderer selbst
  sollte das so einfach wie irgend m√∂glich sein. Unser Material in PLMesh macht ja genau das gleiche, und so war das am
  Ende auch doppelt gemoppelt. Desweiteren war das auch in der Bedienung nicht so sch√∂n da man sich zuerst einen Parameter
  zur√ºckgeben lassen musste um ihn dann setzen/lesen zu k√∂nnen.
  Shader m√§√üig gibts nun nur noch eine Klasse im Renderer. Diese bietet u.a. Funktionen wie SetParameter2f() um direkt Shader
  Parameter zu setzen oder auszulesen. '2f' etc. am Ende des Namens ist eine g√§ngige Namensgebung und daher machte ich es genauso,
  denn es gibt verschiedene Funktionen f√ºr die Shader Parameter, je nachdem um welchen Typ es sich handelt. Im Null Renderer
  gibts keine Shader Implementation. Passte alle Projekte an diese √Ñnderung an. (waren nur minimale Anpassungen n√∂tig :)
- In den PLMesh Materialen kann man ja bereits seit langem Shader Parametern eine 'Semantic' zuweisen so das sobald ein
  Shader gesetzt wird z.B. die aktuelle World Matrix des Renderers einem Shader Parameter √ºbergeben wird so das man quasi
  'automatische Parameter' hat die immer einen aktuellen Wert haben was sich als relativ praktisch herausgestellt hat. Aber
  dieses System war leider nicht so m√§chtig wie es sein k√∂nnte da es erst in PLMesh implementiert wurde und viele Dinge
  wie Nebel oder noch viel wichtiger Licht Einstellungen konnte man nicht so sch√∂n dem Shader automatisch √ºbergeben lassen. Und
  da diese 'automatischen Parameter' NUR beim setzen/aktivieren eines Material Passes gesetzt wurden, waren diese Werte nat√ºrlich
  nicht mehr korrekt wenn man z.B. die Welt Matrix des Renderer √§nderte, und dann musste man nochmal selbst schaun das korrekte
  Werte gesetzt waren. Das st√∂rte mich gewaltig da hierdurch z.B. der Normal Mapping Shader des Soldaten immer etwas 'au√üerhalb'
  stand, z.B. war es schlichtweg unm√∂glich ohne aufwand die Shader Parameter f√ºr das Licht einzustellen. Es war auch nicht
  m√∂glich eine kleine Szene zu machen in der nur der Shader Soldat und eine Licht Scene Node waren wobei das Licht auch wirklich
  den Shader Soldaten 'beeinflusste' - denn da es komplett getrennte Systeme waren, konnten diese Dinge auch nicht automatisch
  miteinander Arbeiten. Die einfache L√∂sung des Problems bestand darin, die 'Parameter Semantic' von PLMesh direkt in die Renderer
  Shader zu verschieben, zumindestens die welche was mit dem Renderer zu tun hatten. Bei D3D 10 gibt es viele Render States
  wie z.B. f√ºr Nebel, Licht, Material NICHT mehr, es MUSS also komplett √ºber Shader selbst implementiert werden. Und generell
  ist's ja so das diese Einstellungen auch nur 'verwendet' werden wenn gerade kein Shader aktiv ist - also Fixed Pipeline Render
  States... wobei es soetwas wie 'Fixed Pipeline' heute ja in den GPU's nicht mehr wirklich gibt. In der Renderer Shader Klasse
  kann man nun also wie gehabt 'per Hand' Parameter einstellen, oder ihnen eine Semantic zuweisen wodurch diese dann automatisch
  gesteuert werden - sprich, Set-Funktionen werden ignoriert, Get-Funktionen liefern die aktuellen Render States zur√ºck. Sobald
  man einem Parameter eine Semantic zuweist, hat man also 'richtige' automatische Parameter die automatisch intern mit den aktuellen
  Renderer Einstellungen 'angeglichen' werden. √Ñndere ich z.B. die Welt Matrix des Renderers, so hat AUTOMATISCH auch gleich
  ein gerade aktiver Shader die aktuelle Welt Matrix als Shader Parameter gesetzt wenn dieser die entsprechende Semantic hat.
  Nun hat man ein m√§chtiges System welches zudem noch recht Nat√ºrlich & Logisch zu bedienen ist. Stell ich nun z.B. in einem
  PLMesh Material eine Parameter Semantic ein, wird intern dieser Parameter mit dem Renderer 'zusammengeschlossen' - und nun haben
  automatisch aktuelle Renderer Einstellungen wie z.B. f√ºr Licht 'einfluss' auf den Shader. Im Falle der Szene mit dem Shader
  Soldaten und einem Licht (siehe PLSamples: NormalMapping.scene) 'beeinflusst' diese Licht Scene Node nun tats√§chlich wie man
  es auch erwarten w√ºrde den Soldaten. Bei mehreren Lichtern muss man auch mehrere Lichter dem Shader √ºbergeben, aber das
  ist wohl selbsterkl√§rend. ;-)
  Shader bietet zwei Statische Hilfsfunktionen Namens SemanticFromString() und SemanticToString() mit denen sich superflott
  ein Semantic String in eine Nummer 'umwandeln' l√§sst und umgekehrt. Das kann man haupts√§chlich beim Laden & Speichern brauchen.
  Renderer Shader kennen derzeit 45 Semantics, das sollte f√ºr's erste reichen.
  Dieses System m√ºsste nun auch relativ Zukunftssicher sein, also wenn man sp√§ter z.B. noch ein D3D 10 Backend schreibt. In dem
  Fall MUSS man halt Shader f√ºr z.B. Beleuchtung schreiben, aber es sollte wohl Problemlos m√∂glich sein das IM Renderer Backend
  dann entsprechende Default Shader verwendet werden so das sich alles wie auch bei OpenGL oder D3D 9 bedienen l√§sst. Und bedient
  wird es immer gleich, es 'sieht' also f√ºr den User so aus als obs weiterhin Nebel Einstellungen im Renderer g√§be, ok, es gibt
  diese ja auch, nur werden diese dann im Renderer Backend selbst gemacht anstatt von fertigen API/GPU Funktionen.
  Da das mit den 'nicht automatischen' Shader Parametern nun viel direkter und einfacher zu Bedienen ist, sollte es auch
  viel einfacher als vorher sein einen netten Shader Beleuchtungs Szene Renderer zu schreiben - wo man also direkt im Code diverse
  Shader Parameter einstellt.
  Jipi, durch diesen Eintrag ist das PLEngine Tagebuch nun 300 KB gro√ü - das was ich in diesem Monat erreichen wollte. H√§tte nicht
  gedacht das ich heute noch die verbleibenden 5 KB f√ºllen k√∂nnte - aber das mit der Renderer Shader √Ñnderung bot ja genug Stoff zum
  Labern. ;-)



>> 30.05.2006
[CO]
PLRenderer:
- RendererBackendCg entfernt, die Dinge welche dort gemacht wurden passieren nun direkt in den konkreten Shader Implementationen.
PLRendererOpenGL
- Codes etwas herausgeputzt: Leerzeichen/Tabs verbessert, √ºberfl√ºssige Includes entfernt, √ºberfl√ºssige 'using namespace'
  entfernt, String Anpassungen, diverse Konstruktoren protected gemacht, ein paar Kommentare verbessert
- Extensions Klasse: Neue Funktion: WriteExtensionStringIntoLog() schreibt einen Extensions String ins Log - da dies
  mittlerweile an mehreren Stellen mit verschiedenen Extensions Strings geschieht, war eine entsprechende Funktion sinnig. :)
- OpenGLExtensions: ShowGeneralOpenGLInformation() & ShowOpenGLShaderInformation() verbessert so das nun immer korrekte
  Informationen im Log stehen.



>> 29.05.2006
[CO]
PLRenderer & PLRendererNull & PLRendererD3D9:
- Codes etwas herausgeputzt: Leerzeichen/Tabs verbessert, √ºberfl√ºssige Includes entfernt, √ºberfl√ºssige 'using namespace'
  entfernt, String Anpassungen, diverse Konstruktoren protected gemacht, ein paar Kommentare verbessert



>> 23.05.2006
[CO]
PLRendererOpenGL:
- BackupDeviceData()/RestoreDeviceData() Implementationen der Texturen √ºberarbeitet. Nun werden auch Mipmaps sammt Kompression
  von der GPU heruntergeladen und danach wieder herauf was sogar ziemlich flott und stabil geht. :)



>> 22.05.2006
[CO]
- Stellen wo Tokenizer::Start() verwendet wird angepasst



>> 21.05.2006
[SB]
- Projekte an FS-√Ñnderungen angepa√üt



>> 21.05.2006
[CO]
PLRenderer:
- Texturen um Funktionen erweitert welche zur√ºckgeben wieviele Mipmaps eine Textur hat und wieviel Bytes the Textur zusammem
  mit allen Mipmaps und unter ber√ºcksichtung des verwendeten internen Formats (sammt Kompression) ben√∂tigt.
  GetNumOfBytes() sowie den Funktionen zum ermitteln der z.B. Textur Breite kann man nun noch die gew√ºnschte Mipmap als
  Parameter √ºbergeben.
- In den Renderer Statistiken steht nun auch wieviele Texturen derzeit auf der GPU sind und wieviel Speicher diese dort
  beanspruchen. Gerade bei gro√üen Szenen ist diese Information wohl ziemlich wichtig damit man absch√§tzen kann ob gerade
  einfach zuviele & zugro√üe Texturen verwendet werden oder ob man noch massig Spielraum hat. :)
  Da z.B. OpenGL keine M√∂glichkeit bietet abzufragen wieviel GPU Speicher gerade belegt ist/noch frei ist, ist es unumg√§nglich
  selbst diese Infos zu Managen. Ich kann mir sehr gut vorstellen das diese Informationen bei gr√∂√üeren Projekten welche
  Dynamisch Texturen laden und entladen m√ºssen wichtig ist um zu entscheiden ob es nun n√∂tig ist weniger wichtige
  Texturen/gerade nicht verwendete Texturen wieder zu entladen oder nicht.



>> 20.05.2006
[CO]
PLRenderer:
- Texture:EPixelFormat: Neues Texture Kompressions Format 'ATI2N' hinzugef√ºgt. 3Dc ist f√ºr Normal Map Kompression 
  gedacht wobei es sich um ein Format mit 2 Farbkomponenten handelt. Es gibt auch noch 'ATI1N' f√ºr nur Luminance,
  z.B. f√ºr BumpMaps, jedoch gibt es dieses Format unter OpenGL noch nicht und daher f√ºgte ich es nicht hinzu. Testen konnte
  ich 3Dc leider nicht da meine Karte es nicht kann, allerdings 'm√ºsste' es funktionieren. :)
  √Ñnderte DXT1 von RGBA in ein RGB Format, unter OpenGL kann man zwar beides Ausw√§hlen, aber normalerweise versteht man unter
  DXT1 ein RGB Format. Musste 'glext.h' um GL_ATI_texture_compression_3dc erweitern.
- Da das √ºbergebene Bild bereits Komprimiert sein kann, kann der Renderer das komprimierte Bild direkt so √ºbernehmen -
  vorausgesetzt nat√ºrlich das Kompressions-Format wird unterst√ºtzt. Unterst√ºtzt der Renderer das Format jedoch nicht, so
  muss 'er' bevor das Bild der GPU √ºbergeben wird das Bild dekomprimieren... sprich, der Renderer KANN beim erzeugen einer
  Texture aus einem gegebenen Bild dieses Bild manipulieren, konkret, es dekomprimieren. Zwar wollte ich es vermeiden das
  der Renderer selbst so ein Bild √§ndert, aber gerade unter OpenGL bestimmen mehrere Faktoren dar√ºber OB die das komprimierte
  Bild direkt so √ºbernommen werden kann oder nicht... und ich denke das w√§re unzumutbar/umst√§ndlich die Renderer Capabilities
  so um die entsprechenden Detail Infos zu erweitern so das z.B. PLMesh::Texture dann pr√ºfen kann ob dekomprimiert werden
  muss oder nicht. Wobei, da derzeit im DevIL Bild leider IMMER beim einladen automatisch auch eine Dekomprimierte Version
  angelegt wird, √§ndert der Renderer ja derzeit nicht wirklich was am Bild. ;-)
- Texture::IsFormatCompressed() entfernt und im Renderer als IsTexturePixelFormatCompressed() eingebaut, so ist das universeller
- Renderer: GetTexturePixelFormat(): √úber einen Parameter kann man nun noch bestimmen ob komprimierte Formate erw√ºnscht sind
- Texture: Neues Flag: Compression -> Ist dieses Flag gesetzt, so wird soweit m√∂glich die Textur intern komprimiert auf der GPU
  abgelegt. W√ºnscht der User beim erzeugen der Textur ein bestimmtes Format, so wird dieses Flag ignoriert.
- Erweiterte in Renderer::CreateTexture1D() die Anmerkungen
PLRendererOpenGL:
- Passte die Textur Klassen an das √ºbernehmen von Image bereitgestellter Mipmaps & Kompression an. Werden die Mipmaps nicht
  bis zu 1x1 herunter Definiert, so ist das ein Fehler und sobald man versucht eine solche Textur mit entsprechendem Filter zu
  verwenden, so bekommt man unter OpenGL normalerweise nur eine wei√üe Textur zu Gesicht. Dies kann man sch√∂n Testen wenn man
  einer dds Textur Mipmaps verpasst die nicht bis 1x1 heruntergehen... baute hier daher gleich eine entsprechende Log Warnung
  ein. BackupDeviceData() und RestoreDeviceData() m√ºssen noch angepasst werden.
- Da das Ausw√§hlen der konkret verwendeten Formate nun von einigen Parametern abh√§ngt und das bei jedem Textur Typ ben√∂tigt wird,
  f√ºgte ich in RendererOpenGL::ChooseFormats() eine entsprechende 'Auswahl'-Funktion hinzu.



>> 19.05.2006
[CO]
PLRendererOpenGL:
- Durch die kleine Verbesserung in PLGeneral::Image ist es nun m√∂glich die von z.B. einem dds Bild eingeladenen Mipmaps
  direkt an die GPU zu √ºbergeben. (siehe z.B. Texture2DOpenGL)
  Zum einen spart das etwas Zeit beim hochladen der Textur da die Mipmaps nicht noch extra erzeugt werden m√ºssen, aber viel
  wichtiger ist, das nun die Grafiker direkte Kontrolle √ºber diese Mipmaps haben... also diese selbst so anlegen k√∂nnen das
  diese immer Optimal aussehen... oder man kann damit auch einfach nur etwas Umfug treiben so das mit der 'Entfernung' sich
  das Bild der Textur √§ndert. ;-)
  Hat man z.B. in jeder Mipmap eine andere Farbe, so kann man sehr sch√∂n sehen wie die GPU mit der Entfernung verschiedene
  Mipmaps ausw√§hlt und filtert.



>> 18.05.2006
[SW]
PLRendererOpenGL:
- Abfragen f√ºr die Extension ARB_multisample, ATI_pixel_format_float und NV_float_buffer
  unter Linux hinzugef√ºgt. Zus√§tzlich habe ich OpenGLExtensions::CheckExtension
  leicht modifiziert, damit auch alle verf√ºgbaren Extension-Strings f√ºr die Pr√ºfung
  verwendet werden. Denn unter Linux(GLX) gibt es 2 zus√§tzlich funktionen,
  neben glGetString(GL_EXTENSIONS), um die vorhandenen Extensions als String zu bekommen.
- Multi Render Target support auch unter Linux deaktiviert, da es zu sporadischen abst√ºrzen f√ºhrt



>> 16.05.2006
[CO]
- An PLGeneral √Ñnderungen angepa√üt



>> 15.05.2006
[CO]
PLRenderer:
- Fehlerhafte -1 zuweisungen verbessert
- ~ShaderParameter() etwas umgebaut damit der gcc Compiler keine Warnung mehr ausspuckt (warning: deleting `void*' is undefined)
PLRendererOpenGL:
- IndexBufferOpenGL: L√∂schen des Buffers etwas umgebaut damit der gcc Compiler keine Warnung mehr ausspuckt
  (warning: deleting `void*' is undefined)
- Fehlerhafte -1 zuweisungen verbessert



>> 14.05.2006
[SW]
PLRendererOpenGL:
- einen fehler in linux part gefixed, welcher nen abst√ºrtz auf ATI karten gef√ºhrt hat.
  man sollte halt den RenderContext zum testen der vorhandenen OpenGL Extension nach gebrauch wieder freigeben.



>> 14.05.2006
[SB]
- An PLGeneral √Ñnderungen angepa√üt



>> 11.05.2006
[SB]
- An PLGeneral √Ñnderungen angepa√üt (DEFINE_GROUP entfernt, GetClasses())



>> 09.05.2006
[SB]
- Externe Libraries nach "external" verschoben und die Projekte entsprechend angepa√üt



>> 03.05.2006
[CO]
PLRenderer:
- SetSamplerState(): Wird 'Sampler::MipFilter' gesetzt und hat die gerade aktivie Textur KEINE Mipmaps, so wird automatisch
  als Wert 'TextureFiltering::None' angenommen so das die Texture korrekt Darstellt wird und man nicht selbst einen entsprechenden
  Wert setzen muss wenn eine Textur keine Mipmaps hat.
  Diese √Ñnderung der Einstellung ist jedoch rein intern, wenn der User GetSamplerState() aufruft, so bekommt er seinen gesetzten
  Wert zur√ºck. Sobald eine andere Textur gesetzt wird welche Mipmaps hat und daher die User einstellung g√ºltig ist, wird diese
  automatisch verwendet. Nun wird die Textur immer korrekt Dargestellt, auch wenn man mal 'vergessen' hat einen anderen Filter 
  Modus zu w√§hlen wenn die verwendete Textur keine Mipmaps hat... oder sich darum einfach nicht k√ºmmern wollte. ;-)



>> 23.04.2006
[CO]
PLRenderer:
- F√ºgte eine SetTransformState() Funktion f√ºr eine 3x4 Matrize hinzu damit man seine 3x4 Matrizen direkt so an den Renderer
  √ºbergeben kann. Intern wird dann aber trotzdem eine 4x4 Matrize verwendet und es gibt auch nur eine GetTransformState()
  Funktion welche eine 4x4 Matrize zur√ºckgibt. Aber entsprechende Zuweisungen sind ja in den Matrizen Klassen implementiert.
  Ich wollte hier nur vermeiden das eine extra 4x4 Temp Matrize erzeugt wird wenn man z.B. seine 3x4 Welt Matrize dem
  Renderer √ºbergeben will.



>> 14.04.2006
[CO]
PLRenderer:
- RendererBackend::Get2DCoordinate(): Hier muss noch die World Matrix ber√ºcksichtigt werden



>> 08.04.2006
[CO]
PLRenderer:
- Stellte auf 'Cg 1.5 Beta 1' um



>> 31.03.2006
[CO]
PLRenderer:
- Surface: Neue Funktionen: GetSwapY() & SetSwapY(): Da man bei D3D beim Rendern in Texturen die y Achse vertauschen muss, 
  entschloss ich mich dazu das gleich universell zu machen falls mal jemand sein Bild verdreht rendern will. :)
  Intern gibts noch eine virtuelle API abh√§ngige Funktion namens 'GetAPISwapY()', der Renderer selbst verwendet nur diese 
  Funktion. Hier kann man unter z.B. D3D zur√ºckgeben wie 'verdreht' werden soll. Wird verdreht, so muss der Renderer intern 
  auch entsprechend den Cull Mode anpassen.
PLRendererD3D9:
- Wird Reflection Mapping verwendet, so wird die Texture Matrix genauso wie im OpenGL Renderer ver√§ndert
- TextureRectangleD3D9: Wird Textur Kompression verwendet, so ist der Inhalt der Texture immer Schrott - noch habe ich 
  nicht herausgefunden wieso das so ist und wie man es besser machen k√∂nnte. :(



>> 30.03.2006
[CO]
PLRendererOpenGL:
- SurfaceTextureOpenGL: Implementation etwas √ºbersichtlicher gemacht. Die erzeugung von FBO/PBuffer findet nun in jeweils
  eigenen Funktionen statt, der Rest wie z.B. MakeCurrent() bleibt in einer Funktion. Auch wenn kein FBO und kein PBuffer 
  vorhanden sind kann nun immer noch in eine 'Textur gerendert' werden... √ºber einfaches glCopyTexSubImage2D(). Hier wird 
  zwar der aktuelle Framebuffer Inhalt immer √ºberschrieben und man ist auf die Bildschirmgr√∂√üe beschr√§nkt, aber besser 
  als n√ºschts. Allerdings ist dann die Verwendbarkeit sssehr eingeschr√§nkt, nur das RTT Beispiel lief dann korrekt bei mir, 
  bei den anderen Beispielen wurde nat√ºrlich immer der aktuelle Bildschirminhalt √ºberzeichnet da man hier nicht wirklich 
  die Reihenfolge wie etwas gerendert wird beeinflussen kann.
PLRendererD3D9:
- Bei Texturen wurde der letzte Pixel nicht korrekt von dem √ºbergebenen Bild √ºbernommen
PLRenderer:
- Neuer Render State: Ambient: (gleicher Name wie bei den beiden API's g√§ngig) Als ich damit anfing den Renderer zu 
  schreiben, hatte ich diesen State ignoriert da er mir √ºberfl√ºssig vorkam... ist er ja auch irgendwie. ;-)
  Jedoch merkte ich, das D3D 9 und OpenGL jeweils andere Voreinstellungen hierf√ºr haben, bei D3D ist alles schwarz wenn 
  kein Licht in der Szene ist, so wie man es eigentlich auch erwartet. Bei OpenGL hinwegen hat die Szene als Voreinstellung 
  etwas Ambient so das selbst wenn kein Licht in der Szene ist man was sehen kann. Damit das aber jeder selbst so einstellen 
  kann wie er will nahm ich diesen Render State nun doch mit auf. Voreinstellung ist bei uns wie bei D3D schwarz.



>> 29.03.2006
[CO]
PLRendererD3D9:
- In Rectangle Texturen rendern funktioniert nun
- In Cube Texturen rendern funktioniert nun
PLRenderer
- RenderState::SlopeScaleDepthBias & RenderState::DepthBias sollte man nach m√∂glichkeit nie verwenden... als ich im D3D 
  Backend etwas nachging das f√ºr mich so aussah als ob der Tiefenbuffer Test deaktiviert ist, merkte ich das OpenGL & D3D
  diese 'Polygon Offset' Werte jeweils etwas anderst Interpretiert. Als ich etwas im Netz nachforschte las ich, das sogar 
  sich das Verhalten dieser Werte von GPU zu GPU unterscheidet, es gibt hier scheinbar keine feste Definition wie das zu 
  Handhaben ist... dadurch werden diese zwei Render States praktisch witzlos. Ich denke/hoffe das erkl√§rt wieso bei Jens 
  unberechenbarerweise beim PerPixelLighting Lichter 'flackerten/verschwanden'. Da das 'anheben' von Tiefenbuffer Werten 
  jedoch vorallem dann wenn etwas in meheren Schritten gerendert wird sehr wichtig ist um 'z-fighting' zu verhindern, 
  musste eine Alternative her. Daher f√ºgte ich einen neuen Render State Namens 'RenderState::ZBias' hinzu. Ist hier ein 
  Wert ungleich null gesetzt, manipuliert der Renderer automatisch etwas die Perspective Matrix. Laut diverser Foren hat 
  man so ein Ergebniss das in etwa auf jeder GPU & API gleich ist, und zumindestens bekam ich so nun bei OpenGL & D3D in 
  etwa gleiche Ergebnisse. :)
  Dokumentierte das auch gleich bei diesen Render State Kommentaren. Die 'anderen' zwei States lies ich jedoch drinnen 
  falls jemand diese aus welchem Grund auch immer verwenden will.



>> 28.03.2006
[CO]
- Renderer + Backends: Verbesserte ein paar Tab/Leerzeichen + schaute das √ºberall wo man einen Zeiger auf Zeiger hat 
  auch 'pp' im Variable Name steht.
PLRendererOpenGL:
- Wenn das hochladen komprimierter Texturen nicht funktioniert, muss im Fallback nat√ºrlich ein korrektes anderes Format 
  ausgew√§hlt werden...
PLRendererD3D9:
- Dieses Backend unterst√ºtzt nun ebenfalls Vertex Streaming. Vor jedem Draw Call wird gepr√ºft ob sich etwas an den Vertex 
  Daten ge√§ndert hat. Ist nur ein Vertex Stream aktiv, so wird die Vertex Declaration direkt von diesem Buffer √ºbernommen.
  Sind jedoch mehrere Streams aktiv, so muss eine Vertex Declaration dynamisch erzeugt werden.



>> 21.03.2006
[CO]
PLRenderer:
- TextureCube: Klassen Beschreibung um 2 ASCII Zeichnungen erweitert so das wirklich klar ist welche Cub Map Textur Seite 
  wo ist.
PLRenderer:
- Renderer::SetVertices(): Die Dokumentation von nOffset war nicht korrekt, der Index ist NICHT in Bytes sondern einfach 
  ein Vertex Index. Eine Bytes Angabe so wie es die API's selbst verlangen w√§re hier sowieso gef√§hrlich, denn wenn man das 
  nur um ein Byte verschieben w√ºrde stimmen die ganzen Vertex Daten ja nicht mehr! Diesen Doku Fehler merkte ich erst als 
  das Terrain unter D3D 9 nicht korrekt Dargestellt wurde, denn im Gegensatz zum OpenGL Backend wurde dieser Vertex Index 
  direkt an die API weitergeleitet ohne ihn erst mit der Vertex gr√∂√üe zu multiplizieren.
- Renderer::GetTransformState(): Standardm√§√üig wird nun die Matrize zur√ºckgegeben welche man dem Renderer so √ºbergeben 
  hatte, denn normalerweise braucht man sich nicht um die Innereien scheren. Weglassen kann man diesen optionalen Parameter 
  allerdings nicht, PLMesh::MaterialPass::BindShaderParameter() verwendet diesen um Shader Parameter zu f√ºllen, und die 
  brauchen die konkreten API Matrizen!
PLRendererOpenGL:
- Unnnd ein weiterer Sonderfall den unser OpenGL Renderer automatisch behandeln muss: Ist die automatische Textur Generation 
  auf 'reflection map' gesetzt, so muss die Textur Matrix mit der inversen der View Matrix multipliziert werden - macht man 
  dies nicht, so hat man keine Kamera abh√§ngigen Reflektionen! In dem einen PL Beispiel in dem die Umgebung dynamisch √ºber 
  Cube Maps reflektiert wird hatte ich bis jetzt einen Shader f√ºr die Reflektion verwendet, dies ist hier nun unn√∂tig und 
  kompakter. :)
  Da es mittlerweile 2 Dinge sind (rectangle textures, reflection map) welche einfluss auf die Textur Matrizen haben,
  packte ich das alles gleich sauber in eine extra Funktion Namens UpdateCurrentOpenGLTextureMatrix().
PLRendererD3D9:
- VertexBufferD3D9 & IndexBufferD3D9: D3DUSAGE_DYNAMIC und D3DPOOL_MANAGED sind lustigerweise NICHT Kompatibel und wenn 
  man es trotzdem versucht, so geht gar nix mehr - wow, was f√ºr eine interne D3D Implementation! :)



>> 18.03.2006
[CO]
RendererOpenGL:
- Get3DCoordinate() war noch nicht ok da die abgefragte View Matrix eventuell gerade nicht aktuell war - daher verwende ich nun 
  die in unserem Renderer gespeicherten Matrizen direkt anstatt mir diese von OpenGL zur√ºckgeben zu lassen. Das werd ich 
  wohl sp√§ter nochmal etwas umbauen da derzeit diese Funktion auch beim Null & D3D Backend nicht richtig implementiert ist.
  Aber f√ºr jetzt erstmal nur soweit das das unter OpenGL sauber funktioniert.



>> 12.03.2006
[SW]
PLRenderer(OpenGL):
- nun wieder √ºbersetzbar unter Linux, plus ein paar wgl* aufrufe im linuxteil entfernt(b√∂ser Chris ;)).



>> 10.03.2006
[CO]
PLRendererOpenGL:
- Fing damit an Sicherheits-Abfragen einzubauen falls eine Extension nicht vorhanden ist
- RendererOpenGL: DrawPrimitives() und DrawIndexedPrimitives() verwenden nun, wenn der verwendete Vertex Buffer im 
  Software Modus ist und falls die entsprechende Extension vorhanden ist, glLockArraysEXT() und glUnlockArraysEXT() was in 
  diesem Fall die Performance deutlich verbessert... aber insgesammt ist die Performance im Software Modus nat√ºrlich 
  langsamer als die VBO Variante.



>> 09.03.2006
[CO]
PLRenderer:
- SetRenderState(), SetSamplerState(), SetTextureStageState(), SetMaterialState(): Haben nun wie besprochen boolsche 
  R√ºckgabewerte
- WrappersBackend.inl etc. gibt es nicht mehr, das wird nun direkt in z.B. SetRenderState() gepr√ºft - dadurch m√ºsste man 
  besser auf Fehleingaben reagieren k√∂nnen.
- Resource: BackupDeviceData() & RestoreDeviceData() bekommen nun einen Zeiger auf einen Zeiger auf 
  PLGeneral::uint8 als Parameter. Hier k√∂nnen/sollten alle Resourcen ihre Backups anlegen und dann in RestoreDeviceData() 
  auch wieder freigeben. Zum einen muss dadurch nicht mehr ein Zeiger pro Resource auf ein eventuelles Backup gespeichert 
  werden (jipi, wir sparen 4 Byte :), aber der viel gr√∂√üere Vorteil ist, das es nun relativ leicht zu realisieren sein 
  sollte w√§hrend der Laufzeit von einem Renderer zu einem anderen zu wechseln. (z.B. von Direct3D zu OpenGL) In dem Fall 
  werden einfach die Daten aller Resourcen 'weggespeichert' und dann dem neuen Renderer zum 'Restore' √ºbergeben. WIE genau 
  die jeweiligen Resource Typen ihre Daten wegspeichern ist dabei diesen Resourcen selbst √ºberlassen. Aber f√ºrs erste 
  ist dies wirklich nur zum einfachen Wiederherstellen der Daten nach z.B. dem wechsel des Bildschirm Modus.
- Die einzelnen Texturen haben nun nur noch GetNumOfBytes() anstatt AllocateMemory() Funktionen, diese Funktion gibt nur 
  zur√ºck wie gro√ü ein Buffer sein muss um diese Texture zu speichern und belegt nicht gleich Speicher. Mipmaps oder Texture 
  Kompression werden hier nicht ber√ºcksichtigt.



>> 03.03.2006
[CO]
PLRenderer:
- IndexBuffer: MaxVertexIndexUShort (=65536) Konstante hinzugef√ºgt. Hat ein Vertex Buffer weniger als 65536 Vertices, so 
  kann man beim Index Buffer den Typ UShort nehmen.
- 'Renderer Flags'-Definitionen (PLERFlags) in die 'Renderer'-Klasse verschoben
- 'PL_MAX_PIPELINE_CHANNELS'-Definition in die 'VertexBuffer'-Klasse verschoben
- Nahm an einigen stellen wie z.B. 'RendererBackend::GetMaterialState()' unn√∂tige 'Sicherheit-Abfragen' raus... wenn solche 
  Werte kommen, dann l√§uft gerade wirklich etwas total schief... ;-)
- Renderer Definitionen Umstellungen fertiggestellt, ob die Namen der diversen Namespaces so ok sind, wird sich noch zeigen
- Passte alle Projekte an diese Renderer √Ñnderungen an



>> 02.03.2006
[CO]
- Dort wo m√∂glich werden nun die statischen Objekte von z.B. Quaternion verwendet statt neue Tempor√§re Objekte zu erzeugen
PLRenderer:
- 'Vertex Attribute Semantic'-Definitionen verschob ich direkt in die 'VertexBuffer'-Klasse da es nur hier verwendet wird
- 'Vertex Attribute Type'-Defintionen direkt in die 'VertexBuffer'-Klasse verschoben. Das alte 'PL_VAT_COLOR' musste ich in 
  'RGBA' umbennen da bereits die Semantic eine 'Color'-Definition hat.
- Die 'Vertex Attribute'-Struktur verschob ich ebenfalls direkt in die 'VertexBuffer'-Klasse
- 'Vertex index type'-Definitionen direkt in 'IndexBuffer'-Klasse verschoben
- 'Resource Types'-Definitionen (PLE_RT) in 'Resource'-Klasse verschoben... man k√∂nnte hier Theoretisch diese Resourcen 
  Klassen mit dem RTTI Verwalten, das w√§re hier aber meines erachtens unn√∂tiger Overhead. Auch k√∂nnte man diese 
  Typ-Definitionen abstrakter halten und z.B. nur 'Buffer' als Resourcen Typ angeben und dann in Buffer weiter zwischen 
  'Index Buffer' etc. unterscheiden, aber auch das w√§re ziemlich umst√§ndlich. :)
- 'Texture Pixel Formats'-Definitionen (PLE_TPF) in die 'Texture'-Klasse verschoben
- 'Texture Flags'-Definitionen (PLE_TEXTUREFLAGS) in die 'Texture'-Klasse verschoben
- 'Surface Types'-Definitionen (PLE_ST) in die 'Surface'-Klasse verschoben
- 'Shader Parmeter Types'-Definitionen (PLE_SPT) in die 'ShaderParameter'-Klasse verschoben
- 'Texture Surface Flags'-Definitionen (PLETSFlags) in die 'SurfaceTexture'-Klasse verschoben
- Schaute die Header durch um nur n√∂tige Header einzubinden und √ºberall korrekte Predefinitions zu machen
- Passte alle Projekte an diese Renderer √Ñnderungen an
... einige Renderer Definitionen m√ºssen noch umgestellt werden, ist aber wirklich zuviel um alles auf einmal zu machen ;-)



>> 01.03.2006
[CO]
- √Ñnderte wie besprochen im Renderer (Types.h) die Definitionen zu Namespace & Enum Kombinationen so das man alles besser  
  lesen kann. Ein paar g√§ngige Abk√ºrzungen lies ich drinnen wie z.B. 'InvSrcColor' in 'BlendFunc' - hier jedesmal 
  'BlendFunction::InversedSourceColor' zu schreiben w√§re heftig. (vorallem wenn Coder Stundenm√§√üig viel Kohle kosten. ;-)
  Da ich auch gleich wie √ºblich alle Projekte an diese √Ñnderungen anpasse, wurde ich heute mit dieser Umstellung nicht 
  ganz fertig.



>> 28.02.2006
[CO]
- Ein paar Leerzeichen/Tabs verbessert



>> 25.02.2006
[CO]
- Alles an Quaternion √Ñnderungen angepasst



>> 25.02.2006
[SB]
- Alles an PLGeneral √Ñnderungen angepasst



>> 24.02.2006
[CO]
- Alles an PLGui √Ñnderungen angepasst
- Stellte wie dort wo m√∂glich/sinnig von globalen Definitionen auf Klassen abh√§ngige enum Definitionen um. Beim Renderer 
  hab ich erstmal nichts gemacht da diese Umstellung dort eine gr√∂√üere Sache wird.



>> 23.02.2006
[CO]
- Alles an PLGeneral √Ñnderungen angepasst



>> 22.02.2006
[CO]
- Die Haupt-Header der Projekte haben nun am Anfang des Namens wieder ein PL
- Doxygen Makefiles angepasst
- Alles an PLMath √Ñnderungen angepasst



>> 21.02.2006
[CO]
- Alles an aktuelle PLMath √Ñnderungen angepasst (ein paar Dinge sind noch nicht ganz ok)



>> 10.02.2006
[CO]
- Alles an Stack & PLMath √Ñnderungen angepasst



>> 06.02.2006
[CO]
- Alles auf String::Format() umgestellt + dort wo m√∂glich von %f auf %g umgestellt da dadurch nur das n√∂tigste ausgegeben wird



>> 25.01.2006
[CO]
- PLRenderer auf Namespace umgestellt



>> 23.01.2006
[CO]
- An uint32 √Ñnderungen angepasst



>> 19.01.1006
[CO]
- Alles an PLMath & PLGui √Ñnderungen angepasst



>> 18.01.2006
[CO]
- Alles an PLGeneral √Ñnderungen angepasst



>> 13.01.2006
[CO]
- Stellte alle Projekte '√ºber' PLGui auf die neue String Klasse um - nur an den stellen wo String Variablen vom RTTI genutzt 
  werden wird noch die alte Klasse verwendet.



>> 01.01.2006
[CO]
- Passte √ºberall das aktuelle Jahr an, also von 2002-2006
PLRendererOpenGL:
- FrameBufferObject::CheckFrameBufferStatus(): Arbeitet nun korrekt - hier muss man zuerst den Draw & Read Buffer auf Null 
  setzen, ansonnsten gibt 'glCheckFramebufferStatusEXT' IMMER einen Fehler zur√ºck.
- Rendern in Cube Texturen funktioniert nun



>> 30.12.2005
[CO]
- Fand in den verschiedenen Projekten noch ein paar Stellen wo nun PLTString verwendet werden kann, und stellte entsprechend 
  um



>> 29.12.2005
[CO]
PLRenderer:
- Verschob ein paar Funktionen der Renderer Backends in die Backend Klasse
- Machte diverse Funktionen der Renderer Resourcen protected - somit sind die Interfaces etwas sauberer und der User 
  MUSS die entsprechenden Renderer Funktionen verwenden anstatt direkt die Resource Funktionen. Das machte zwar die 
  Implementation in den konkreten Renderer Backends teils etwas tricky, aber die Interfaces mit denen der User arbeitet 
  sind denk ich wichtiger.



>> 06.12.2005
[CO]
- PLTRendererShaderD3D9 & PLTRendererShaderOpenGL: RecurseProgramParameters(): Ist ein Shader Parameter ung√ºltig oder 
  wird von Cg ausoptimiert da dieser nicht verwendet wird, so wird dieser Parameter nun komplett irgnoriert und eine 
  entsprechende Nachricht wird ins Log geschrieben... ansonnsten zickte Cg herum wenn dieser Parameter trotzdem verwendet 
  wurde. ;-)
  Desweiteren verwenden nun die Shader auch Hash Tables f√ºr einen schnelleren Zugriff auf Parameter √ºber ihren Namen.
- Stellte aktuelles PL SDK zusammen, das vorherige ist schon wieder 2 Monate alt.



>> 05.12.2005
[CO]
- Machte PLTSurfaceListener flexibler: Diese Klasse Rendert nun selbst KEINE Informationen wie FPS oder Gui mehr. Genauso 
  wie z.B. das l√∂schen des aktuellen Frame Buffers wird das nun √ºber spezielle Scene Nodes geregelt. PLTSurfaceListener 
  selbst verwendet nun NUR noch einen Scene Renderer Query... somit ist das mit dem Scene Rendern nun sauber getrennt 
  von den Surface Listenern. Ein 'Scene Renderer' selbst ist nun ein 'Scene Query' was besser ins Design passt und auch 
  recht nett zu bedienen ist. Diese neue Query-Klasse hat nun also wie gehabt EINEN Scene Container f√ºr seine Scene die sie 
  Darstellen soll, jedoch wird hier zwischen 'Root' und 'Scene' Container 'unterschieden'. Hier ein Beispiel wie so ein 
  Root-Container in der Praxis aussieht:
    PLTSceneContainer  (Root Container)
      PLTSNClear
      PLTSceneContainer  (Scene Container mit der eigentlichen 'Szene')
        PLTSNCamera
        PLTSNSky
        PLTSNObject
        ...
      PLTSNGui
      PLTSNEngineInformation
      PLTSNConsole
  Somit kann man das was nacheinander gerendert werden soll also selbst komplett bestimmen. Die 'Unterscheidung' zwischen 
  Root & Scene war n√∂tig da es vorkommen kann das die 'eigentliche' Scene f√ºr z.B. Reflektionen/Refractionen mehrmals 
  in einem Frame von verschiedenen Perspektiven gerendert werden muss. In diesem Fall ist es aber meistens unpraktisch wenn 
  hier dann auch gleich automatisch die Kamera gesetzt, der Frame Buffer gel√∂scht und am Ende noch Dinge wie Gui, Engine 
  Informationen oder gar die Konsole gerendert wird. 'Root' enth√§lt also quasi Pre/In/Post-Order Dinge, wobei 'In' 
  die eigentliche Scene ist.
  Zuerst wollte ich Dinge wie PLTSNClear, PLTSNFog die ja nicht 'wirklich richtige' Elemente der Scene sind zu nicht Scene 
  Nodes machen und es dann so handhaben das PLTSurfaceListener das selbst macht. In diesem Fall h√§tte dieser also noch Dinge 
  wie Frame Buffer l√∂schen/Konsole Darstellen direkt selbst gemacht und der User h√§tte spezielle Funktionen in dessen 
  Interface gehabt um diese Dinge Einstellen zu k√∂nnen... so ist es √ºblich bzw. so machen es die meisten. Jedoch w√§re das 
  ein unsch√∂ner Style-Bruch gewesen und man h√§tte an Flexibilit√§t verloren, darum die Radikale Variante auch Dinge wie das 
  Ingame Gui gleich √ºber eine Scene Node Darstellen zu lassen.
- Musste PLTSQSceneRenderer noch die Funktion SetRenderTarget() verpassen da es z.B. beim Post Processing n√∂tig ist GLEICH 
  am Anfang eine Textur als neues Render Target zu setzen. W√ºrde dies erst wie gehabt in 'DrawSceneContainer()' passieren, 
  so w√§re in dieser Textur Schrott und Grafik-Fehler treten auf... 
- Nahm den Scene Manager heraus da dieser Manager Problematisch war. (der haupt PLTSceneContainer konnte hier ja nicht vom 
  RTTI richtig durch die Singleton-Klasse Initialisiert werden)
  Daf√ºr gibt es nun PL::GetRootSceneContainer() was im Prinzip das gleiche ist, nur das PLTSceneContainer hier vom RTTI 
  erzeugt wird und dadurch auch richtig Initialisiert wird. Eine andere L√∂sung f√§llt mir hier nicht ein... aber ich denke 
  das ist ok so - so eine 'Root Node' findet man in vielen Engines. (iiiirrrgendwo muss es ja anfangen ;-)
- PL::GetDefaultSurfaceListener(): Erst wenn diese Funktion zum ersten mal aufgerufen wird, wird der Default Surface 
  Listerner erzeugt - meistens braucht man diesen nicht, nur f√ºr kleine Anwendungen ist er praktisch.



>> 04.12.2005
[CO]
- Sobald ein Fragment Shader Texturen verwendet wird es etwas Tricky da man vorher nicht weis in welcher Textur Unit eine 
  Textur von Cg am Ende landet. Daher muss man nach dem setzen des Shader Parameters abfragen in welcher Textur Unit die 
  Textur nun 'sitzt' und den Renderer entsprechend dar√ºber Informieren. Wird dies nicht gemacht sind die Infos √ºber die 
  aktuell gesetzen Texturen eventuell falsch was sich dann in falschen Texturen beim Rendern √§u√üert.



>> 02.12.2005
[CO]
PLRenderer:
- Etwas an den Occlusion Queries gefeilt



>> 22.11.2005
[CO]
PLRendererOpenGL:
- Stefan fand heraus das NVIDIA Karten bei Rectangle Texturen keine Kompression m√∂gen (zumindestens auf den Karten wo wir 
  es Testen konnten: GeForce 4/5) obwohl es laut Dokumentationen gehen m√ºsste...
  Daher erweiterte ich das hochladen der Texturen zur GPU um Anfragen ob gerade Textur Kompression verwendet werden soll und 
  wenn ja, ob das hochladen klappte. Wenn ein Fehler auftrat, so wird automatisch ein Textur Format ohne Kompression als 
  Fallback gew√§hlt.



>> 20.11.2005
[SB]
- Aufrufe von PLTContainer::Add() angepa√üt
- Include <Log.h> eingef√ºgt



>> 10.11.2005
[CO]
PLRenderer:
- PLTRendererBuffer: Allocate() kennt nun einen weiteren Parameter welcher angibt ob dieser Buffer 'Managed' ist oder nicht. 
  Ist die Verwendung als PL_USAGE_SOFTWARE Definiert, so hat dieser neue Parameter keine Auswirkung. Im Null Renderer wird 
  dieser Parameter ebenfalls Ignoriert. Im D3D Renderer hingegen wird dann in den Buffern gesagt das D3D diesen Buffer 
  Verwalten soll. Unter OpenGL musste eine eigene L√∂sung implementiert werden die eine Kopie des Buffers im Arbeitsspeicher 
  h√§lt. Der Performance Gewinn bei 'Managed-Mode' ist leider nicht wirklich sonderlich gro√ü, aber jedes bischn mehr an 
  Performance hilft. Bei Allocate() kann man als letzten Parameter noch angeben ob der aktuelle Buffer Inhalt erhalten 
  bleiben soll oder nicht... meistens braucht man den Inhalt nicht mehr, aber k√∂nnte sein das dies mal Praktisch ist.
- PLTRendererBuffer: Wie gestern kurz mit Stefan besprochen, habe ich das Lock/Unlock etwas ver√§ndert. Bis jetzt war es so 
  das man nur einmal Lock() aufrufen konnte, war der Buffer bereits gelockt, so wurde NULL zur√ºckgegeben. Wenn es sauber 
  laufen sollte musste man also vorher mit IsLocked() pr√ºfen und wenn der Buffer bereits gelockt war diesen so direkt 
  verwenden - und nur wenn man ihn selbst gelockt hatte musste man ihn auch selbst wieder freigeben... das war ziemlich 
  Fehleranf√§llig und Umst√§ndlich zu bedienen. Nun ist es so, das intern eine art von 'Reference Counter' vorhanden ist. 
  Bei jedem Lock wird um eins erh√∂ht, bei jedem Unlock um eins verringert, intern wird der Buffer selbst korrekt gelockt 
  wenn es der erste Lock ist, und wieder freigegeben wenn es das letzte Unlock war. Die Funktion IsLocked() wurde durch 
  GetLockCount() ersetzt. Passte √ºberall die Codes entsprechend an... so ists nun viel sch√∂ner zu Bedienen.
  Einige Funktionen wie Clear() 'erzwingen' intern Unlock(), allerdings l√§sst sich das leider kaum anderst l√∂sen... man 
  k√∂nnte nat√ºrlich diese Funktionen wenn der Buffer locked ist 'sperren', aber das k√∂nnte gleiche Probleme machen. Der 
  Benutzer muss selbst Lock/Unlock 'gewissenhaft' aufrufen. Also nicht EINMAL Lock und dann sich die Zeiger selbst irgendwo 
  fest speichern und meinen dieser Zeiger w√§re immer g√ºltig selbst wenn der Buffer gekillt wird. ;-)
  (auf diese Dinge wird in den Kommentaren deutlich hingewiesen)



>> 08.11.2005
[CO]
PLRenderer:
- PLTRendererFrame: Neue Funktionen: GetFullscreenAltTab(), SetFullscreenAltTab(): Damit ist es m√∂glich unter Windows 
  alt-tab im Vollbild Modus zu unterbinden.
- F√ºgte 10 neue Texture Formate hinzu welche es unter OpenGL & Direct3D gibt, es gibt zwar noch viele mehr... aber die 
  jeweils andere API kennt diese Texture Formate nicht. Sollte es sp√§ter mal n√∂tig sein diese Formate welche NUR die eine 
  oder andere API kennt einzubauen, so kann man dies ja immer noch.
- Verbesserte/erweiterte Shader Support: CreateVertexShader()/CreateFragmentShader() nehmen nun weitere optionale Parameter 
  an. Darunter u.a. zus√§tzliche Definitionen welche dem Shader hinzugef√ºgt werden sollen. Dies kann dann Praktisch werden 
  wenn man z.B. bestimmte 'Features' in einem Shader beim erzeugen 'aktivieren/deaktivieren' will. Die OpenGL/D3D Renderer 
  f√ºgen diesen Definitionen selbst noch etwas hinzu... z.B. '#define OPENGL'/'#define D3D', so 'weis' man im Shader welche 
  API gerade verwendet wird, z.B. MUSS man bei OpenGL 'texRECT' f√ºr Textur Zugriffe verwenden wenn es sich um Rectangle 
  Texturen handelt, unter D3D hingegen ist dieser Befehl unbekannt und es muss hier wie bei normalen 2D Texturen 'tex2D' 
  verwendet werden. Innerhalb der Renderer Backends muss der konkrete Shader also 'zusammenkopiert' werden. Passte die 
  Shader in 'PLPostProcessEffects.pak' entsprechend an so das diese auch unter D3D verwendbar sind.



>> 07.11.2005
[CO]
PLRenderer:
- VertexBuffer: Allocate(): Etwas verfeinert da es zul√§ssig sein soll einen bereits angelegten Vertex Buffer nachtr√§glich zu 
  √§ndern... z.B. die Anzahl der Vertices und/oder die Verwendung. Das hinzuf√ºgen neuer Vertex Attribute war ja bereits auch 
  nach Allocate() m√∂glich... diese Dinge sind zwar nicht wirklich Performant da der Inhalt der Buffer umst√§ndlich 
  herumkopiert werden muss - m√∂glich sein soll es aber da es hier und da ganz Praktisch ist.



>> 04.11.2005
[CO]
PLTRendererOpenGL
- Clear(): Wenn der ZBuffer gel√∂scht wird, so wird Z Write Enable zur Sicherheit aktiviert - ansonnsten kann es sein das 
  der Z Buffer nicht gel√∂scht wird.



>> 29.10.2005
[CO]
PLRenderer:
- Begin2DMode() und End2DMode() √§ndern keine Render States mehr, dies muss der User schon selbst so machen wie er es braucht 
  und es ist eher ungeschickt diese States hier zu √§ndern.



>> 28.10.2005
[CO]
PLRendererOpenGL:
- PLTRendererBackendCg: Man kann nun die automatische Fehler Callback Funktion aktivieren/deaktivieren - beim einladen 
  von Shadern ist diese Callback Funktion z.B. ziemlich unpraktisch, denn nach dem Laden ist es Sinnvoll selbst abzufragen
  ob ein Problem auftrat um dann entsprechend darauf zu reagieren.
- PLTRendererShaderOpenGL machte noch etwas Probleme: In Init() gabs bei cgCreateProgram() auf meiner GeForce4 Ti 4200 
  bei machen Fragement Shader einen merkw√ºrdigen Crash wenn das Profile CG_PROFILE_FP20 verwendet wurde. Daher habe ich 
  hier nun einen 'hack' eingebaut der sobald CG_PROFILE_FP20 verwendet werden soll CG_PROFILE_ARBFP1 ausw√§hlt welches keinen 
  Crash verursacht - ob der Shader √ºberhaupt auf der Karte l√§uft oder nicht kann man ja erst danach feststellen. ;-)
  Bei cgGLLoadProgram() wird die automatische Cg Fehler Callback Funktion nun deaktiviert um auf eventuell aufgetretene 
  Fehler reagieren zu k√∂nnen, ansonnsten wurden nicht verwendbare Shader nicht erkannt und verwendet was zu Problemen 
  f√ºhren konnte.
- PLTRendererOpenGL::DrawIndexedPrimitives(): glDrawRangeElementsEXT kann nur eine bestimmte Daten Menge verarbeiten, passt 
  man hier nicht auf kann es zu Problemen kommen



>> 27.10.2005
[CO]
PLRenderer:
- Erzeugt man eine Texture in welche man Rendern kann, kann man nun noch optionale Flags mitgeben. Als Standard ist gesetzt 
  das diese Render Targets auch Tiefen & Stencil Buffer haben sollen. Bei z.B. den zwei internen Post Processing Render To 
  Texturen braucht man jedoch keinen Tiefen & Stencil Buffer... und wird kein Stencil Buffer ben√∂tigt, so versucht der 
  OpenGL Renderer die schnelleren FBO's zu verwenden. (FBO & Stencil Buffer derzeit leider nix gut) Man sollte hier also 
  immer nur das setzen was man auch wirklich ben√∂tigt so das die jeweiligen Renderer hier intern selbst das Optimalste 
  verwenden k√∂nnen. Man MUSS aber nichts genaueres angeben, in dem Fall ist man selbst Schuld wenn die Performance zu 
  w√ºnschen √ºbrig l√§sst. (wenn man nicht genau sagt was man denn gerne h√§tte, bekommt man halt irgendwas das den meisten 
  wohl reicht ;-)
  Ist hier nun also ein brauchbarer Kompromiss so das man im g√ºnstigen Fall auf das flotte FBO zur√ºckgreifen kann - was der 
  Post Processing Performance deutlich zugute kommt da hier vorallem bei Effekten wie Bloom extrem h√§uftig Render Targets 
  gewechselt werden m√ºssen was mit pbuffern eine wirklich ziemlich lahme Angelegenheit ist!
  Bei meinen Messungen (PLSampleNewtonCharacterController, 800x600 Fenster, start Ansicht) hatte ich bei aktivem Bloom und 
  mit reinem pbuffer bei aktiven Schatten 28 FPS, ohne Schatten 45. Mit FBO wenn m√∂glich, (also wenn kein Stencil Buffer 
  ben√∂tigt wird was beim Post Processing der Fall ist) hatte ich hingegen bei aktiven Schatten 34 FPS, ohne 60. Beim HDR 
  Test hatte ich bei Standard-Einstellungen statt 16, 17 FPS... man merkt also einen 'minimalen' Performance Gewinn, und je 
  mehr FPS man generell hat desto krasser merkt man einen Unterschied zwischen pbuffer & FBO. :)



>> 06.10.2005
[CO]
PLRenderer:
- Hier kann man nun ein paar weitere States 'fixieren' so das diese nicht mehr ge√§ndert werden k√∂nnen.



>> 29.09.2005
[CO]
PLRenderer:
- Beim beenden werden die Resourcen & Oberfl√§chen nun korrekt gel√∂scht, desweiteren wird der Vollbild Modus jetzt korrekt in 
  die Konfiguration zur√ºckgeschrieben. Beim beenden wird einfach gepr√ºft ob noch ein Fenster im Vollbild Modus ist, wenn ja 
  wird in der Konfiguration 'Fullscreen=1' gesetzt.
PLRendererOpenGL:
- Neue unterst√ºtzte Extension: GL_ARB_draw_buffers ist die 'offizielle' neue Variante von GL_ATI_draw_buffers
  Diese sind also v√∂llig Identisch - nur halt nen anderer Name. 'Nat√ºrlich' friert auch hier nach ein paar Sekunden das 
  System einfach ohne erkennbaren Grund ein, darum ist auch diese Extension erstmal aus Sicherheitsgr√ºnden Deaktiviert.



>> 18.09.2005
[CO]
PLRenderer:
- Neue Funktionen: DrawLines2D(), DrawLines3D(), DrawPoints2D() und DrawLines3D() f√ºr das relativ Performante Zeichnen mehrer 
  Linien/Punkte auf einmal.
PLRendererOpenGL:
- PLTRendererSurfaceTextureOpenGL & PLTRendererSurfaceWindowOpenGL: Weiteren Bug behoben: Sobald eine Oberfl√§che zerst√∂rt 
  wird, wird nun versucht die Haupt Oberfl√§che des OpenGL Renderers zu setzen, erst wenn dies nicht funktioniert wird Null 
  als aktuell gesetzt und OpenGL Befehle haben keine Wirkung mehr. Das machte anderst in PixelLab Probleme: Ich hatte zuerst 
  den Mesh Editor offen, schloss diesen und √∂ffnete den Scene Editor - hier viel mir aber dann auf das pl√∂tzlich Meshs wie 
  die Pfeile bei den Transformern nicht mehr Darsgestellt wurden und fand heraus das die Vertex Buffer nicht erzeugt wurden - 
  das lag daran das beim schlie√üen des Mesh Editors die Fenster beim zerst√∂ren Null als Current setzen und die Mesh Buffer 
  erzeugt wurden w√§hrend gerade kein aktueller OpenGL Context gesetzt war. Soetwas ungeschicktes kann nun nicht mehr 
  passieren. :)



>> 16.09.2005
[CO]
PLRenderer:
- PLTRendererSurfaceListener: Im Destruktor tr√§gt sich nun dieser Listener wieder bei den Surfaces aus
- Merkte in PLSampleMultiView das es praktisch ist wenn die Fenster nach dem wechsel von Vollbild zu Fenster Modus wieder an 
  ihrer alten Position etc. sind. Daher erweiterte ich PLTRendererFrame entsprechend. So ists m√∂glich in PLSampleMultiView 
  bequem ein Fenster nach dem anderen in den Vollbild Modus und wieder zur√ºck zu schalten.
PLRendererOpenGL:
- RestoreDeviceStates() beachtet nun auch das gesetzte Render Flags das setzen von States verhindern k√∂nnen - hier wollen 
  wir aber ALLES setzen.



>> 15.09.2005
[CO]
PLRendererOpenGL:
- Wechselt man den Bildschirm Modus werden nun auch die Device States korrekt zur√ºckgesetzt
PLRenderer:
- PLTRendererShaderParameter::SetValueTexture() war noch nicht ok, dadurch bekamen Texturen Handler welche aber nicht wieder 
  korrekt abgemeldet wurden. Auch beim Destructor von PLTRendererShaderParameter musste man noch Texture Handler beachten. 
  Diese zwei Dinge konnten heftige Crashs verursachen.
- PLTRendererSurface hatte auch noch so einige heftige Bugs zu bieten: ClearListeners() Informiert nun auch diese Listener 
  und beim Destructor wird nun ClearListeners() aufgerufen.
- Spendierte PLTRendererSurface BackupDeviceData() und RestoreDeviceData. (wie bei Renderer Resourcen)
  PLTRendererSurfaceTextureOpenGL implementiert diese zwei Funktionen um den pbuffer anzugleichen - ansonnsten konnte es 
  zu Problemen kommen.
- Wechselt ein Fenster in den Vollbild Modus, so wird es nun in PLTRendererFrame::InitWindow() links oben Positioniert. 
  (irgendwie sinnig das ;-) 
--> Ich konnte nun keine Probleme mehr feststellen wenn man zwischen Vollbild und Fenster Modus wechselt, egal wie h√§ufig 
    man das macht - am laufenden Band den Fenster Modus √§ndern ist ein Spa√ü f√ºr gro√ü und klein. ;-)



>> 14.09.2005
[CO]
PLRenderer:
- Etwas am Direct3D Backend geschraubt. Gibt aber immer noch viele Details zu verbessern. Das Rendern in mehrere Texturen 
  gleichzeitig funktioniert allerdings bereits super - im OpenGL hab ich ja noch diese merkw√ºrdigen Crashs.
  Notierte in der PL_API Dokumentation gleich noch diverse Dinge der Renderer Backends wie z.B. nicht Unterst√ºtzte 
  Funktionen. Beim erzeugen von Texturen kann man nun noch Flags mitgeben um z.B. Mipmaps Automatisch erzeugen zu lassen 
  oder um eine Texture auch als Color Render Target verwenden zu k√∂nnen.
- OpenGL backend: Verwendet man Rectangle Texturen, so wird nun die Texture Matrix so skaliert das der User selbst IMMER 
  mit normalisierten Texture Koordinaten arbeitet. Es hatte mich schon immer genervt das es hier eine so unhandliche 
  Texture Koordinaten unterscheidung gibt. Das einzige wo man hier aufpassen muss ist, wenn man Rectangle Texturen mit 
  Shader verwendet muss man in den Vertex Shadern die Texture Matrixen ber√ºcksichtigen - ansonnsten stimmen die Texture 
  Koordinaten nicht. (denn die GPU will hier nicht normalisierte haben)
  Zuerst wollte ich diese Texture Matrix Manipulation im D3D Backend machen, denn dieses macht hier keine Unterscheidung - 
  aber dann merkte ich das dies irgendwie anderst herum praktischer ist. ;-)
  U.a. musste ich den Post Process Manager und PLPostProcessEffects.pak umstellen.
- Renderer Statistiken um weitere Werte erweitert
- Post Process Manager: Intern beim Zeichnen einen kleinen Offset hinzugef√ºgt der verhindert das z.B. bei Bloom man oben 
  und rechts Farben ins Schwarze ausblenden sieht



>> 03.09.2005
[CO]
PLRenderer:
- Camera & frustum Funktionen aus dem Renderer entfernt, mittlerweile hat das hier nichts mehr zu suchen, das ist Sache des
  Scene Systems :)



>> 27.08.2005
[CO]
PLRenderer:
- Beim erzeugen etc. von Texturen wird nun PLTImage √ºbergeben anstatt wie bisher direkt die Daten + Informationen wie gro√ü 
  etwas ist etc. Dies hat mehrere Vorteile:
  - Wurde z.B. ein dds Bild eingeladen ist es m√∂glich das die Daten bereits in einem bekannten komprimierten Format wie z.B. 
    DXT5 vorliegen und so muss die GPU nicht mehr selbst komprimieren was den Texture erzeugungs Vorgang deutlich 
    beschleunigt. Somit ist auch endlich sauber geregelt welches Interne Texture Format verwendet werden soll - das war bis 
    jetzt ziemlich chaotisch da ich einfach nicht so recht wusste wie ich wo alle verschiedenen Infos √ºbergeben soll, dank
    PLTImage kein Problem mehr und alles ist sauber verschn√ºrrt.
  - In PLTImage k√∂nnen bereits MipMaps liegen, in dem Fall k√∂nnen diese direkt an die GPU √ºbergeben werden welche diese nicht 
    mehr selbst erzeugen muss. So kann z.B. auch der Grafiker direkt √ºber z.B. das dds Format eigene MipMaps √ºbergeben.
    Allerdings funktioniert das mit diesen eigenen Mipmaps anscheinend noch nicht - scheint irgendwie an DevIL zu liegen. 
    Muss das bei Zeiten mal genauer Untersuchen...
  - Generell ist so das Interface dank weniger zu √ºbergebende Parameter schicker ;-)
- Neue Funktion: GetTexturePixelFormat() -> Gibt das passende Renderer Texture Format eins √ºbergebenen Bildes (PLTImage) 
  zur√ºck



>> 24.08.2005
[CO]
PLRenderer:
- Fand heraus das meine Radion 9600 auch Two Sided Stencil Tests kann, das l√§uft hier nur nicht unter GL_EXT_stencil_two_side 
  sondern unter einer ATI eigenen Extension Names 'ATI_separate_stencil'. Erweiterte den Renderer intern so das er diese 
  Extension nutzen kann - ein Grund mehr f√ºr so nen eigenen Renderer, man muss sich nicht mehr drum k√ºmmern unter welcher 
  GPU man welche Extensions nutzen muss. ;-)
  Bin mal gespannt ob ich dadurch bei mir bei den Shadow Volumes nen kleinen Performance Gewinn feststellen kann...
PLRendererOpenGL:
- Sortierte Extensions nach WGL, SGIS, EXT, ARB, ATI - so ists nun etwas √úbersichtlicher
- PLTRendererOpenGLExtensions::Init() in Linux & Win32 cpp Dateien aufgeteilt - so ist es √ºbersichtlicher. Hier komplett 
  getrennte Klassen/Ableitungen zu machen schien mir als etwas zu viel Aufwand, denn ifdef muss man so oder so machen, wenn 
  nicht hier dann beim konkreten verwenden einer solch abgeleiteten Klasse.
- Das gleiche bei PLTRendererSurfaceWindowOpenGL, statt abgeleiter Klasse einfach getrennte cpp Dateien - ansonnsten m√ºsste 
  man jedesmal wenn man PLTRendererSurfaceWindowOpenGL verwendet casten um z.B. bestimmte Plattform abh√§ngige Dinge zu 
  bekommen. (w√§re ebenfalls nur verschobener Aufwand :)
- Die neue angedachte Plattform Klasse hab ich erstmal weggelassen da mir das momentan als etwas zuviel Aufwand f√ºr zuwenig 
  Nutzen erschien - im Prinzip l√§ge dort derzeit eigentlich nur MakeCurrent drinnen welches aber unter Linux mehr Parameter 
  hat als unter Windows und man es daher nicht so ohne weiteres in ein einheitliches Interface quetschen k√∂nnte. Generell 
  sind recht wenig Plattform abh√§ngige ifdefs drinen so das dies noch recht √úbersichtlich ist. Das einzig un√ºbersichtliche 
  war eigentlich das mit den Extensions und Window da hier mehr als nur eine Zeile Code je Plattform anderst ist. ;-)



>> 20.08.2005
[CO]
PLRendererOpenGL:
- PLTRendererOpenGL::SetRenderTarget(): Licht & allgemeine OpenGL Einstellungen werden nun ebenfalls korrekt gesetzt wenn 
  PBuffer verwendet werden - damit verschwindet endlich ein nervender 'Grafik Fehler' bei z.B. Post Processing Effekten.



>> 01.08.2005
[CO]
PLRenderer:
- Accumulation Buffer Funktionen hinzugef√ºgt welche zumindestens unter OpenGL verwendet werden k√∂nnen



>> 18.07.2005
[CO]
PLRenderer:
- Stellte den Renderer auf Cg 1.4 um. Danach traten sehr merkw√ºrdige Texture Probleme auf. Als ich der Sache genauer auf 
  den Grund ging stellte ich fest das in PLTRendererShaderParameterOpenGL::SetValueTexture() (und D3D0) noch eine Abfrage
  f√ºr PL_RT_TEXTURERECTANGLE fehlte - desweiteren muss man am Ende diesen Sampler noch mit cgGLEnableTextureParameter()
  aktivieren. (aber nur unter OpenGL) Lustig das dies erst ab der neuen Cg Version Probleme bereitete. :)
  PLTMaterialPass::BindShaderParameter() √ºbergebe ich Cg nun die aktuelle gesetzte Texture anstatt der Textur des Material
  Passes - denn es kann sein das das Material bestimmte Texturen nicht setzt da diese 'global' vom aktuellen Renderer
  gesetzt werden.
- ATI Unterst√ºtzt nun ENDLICH in seinen Treibern FBO! (EXT_framebuffer_object) Ist diese Extension vorhanden, so wird nun 
  diese anstatt des lngsamen und total umst√§ndlichen pbuffers verwendet. Leider machen noch floating point buffer und 
  Rectangle Texturen √Ñrger und ich kann einfach nicht herausfinden wieso dies so ist - hoffentlich 'nur' ein Treiber
  Bug dieser neuen Extension. Desweiteren werden Stencil Buffer wie in der Extension Spezifikation angegeben ist noch 
  nicht... schade das es hier noch solche Probleme mit den FBO gib, denn diese sind wirklich eine sehr feine Sache. :)
  Daher hab ich die verwendung von FBO erstmal in PLTRendererOpenGLExtensions::Init() deaktiviert bis das richtig 
  funktioniert.
- Musste OpenGL Header (gl.zip) aktualisieren
- Erweiterte den Renderer um die M√∂glichkeit in mehrere Texturen gleichzeitig zu rendern. (GL_ATI_draw_buffers, auch NV) 
  Die aktuelle Implementation ist noch eher Experimentell - im Endeffekt 'm√ºsste' man das Rendern in Texturen im Renderer
  nun neu Designen da der FBO sehr universell ist - genauso wie diese Dinge in D3D9. Z.B. k√∂nnen sich mehrere Render Targets
  Tiefen und Stencil Buffer 'teilen'... und die neusten Karten k√∂nnen gar soweit ich mitbekommen habe in Vertex Buffer 
  'rendern'. Aber f√ºrs erste reicht diese Experimentielle Implementation.
  Alles was man machen muss ist, nach dem setzen des Render Targets noch die Texturen als Color Render Targets angeben in 
  die gleichteitig gerendert werden soll. Danach kann man in Fragment Shadern als Ergebniss nicht nur COLOR sondern COLOR0, 
  COLOR1 etc. angeben - jede entspricht dann einer dieser Texturen. Man kann dann also damit in nur einem Render Schritt 
  in einem Shader sehr viel mehr Daten ausgeben als dies mit nur einer Textur m√∂glich w√§re. So kann man in einer Textur die 
  normalen Farben ausgeben, in der anderen die Positionen, Normalen etc. Mit diesen Daten kann man dann noch coolere Post
  Processing Effekte wie z.B. Tiefenunsch√§rfe ohne ZU VIEL AUFWAND Realisieren. Ansonnsten m√ºsste man die komplette Szene
  ein paar mal neu Rendern nur in jeweils andere Texturen mit anderen Shadern um die gew√ºnschten Informationen in Textur 
  Form zu bekommen die man dann an den Post Process Manager √ºbergeben m√ºsste.
  Leider funktioniert die FBO Implementation von MRT noch nicht so recht - es gibt keine Fehler/Warnungen... das erwartete
  Ergebniss bleibt einfach aus. Und die PBuffer Implementation ist irgendwie ebenfalls Buggy - bin ich im Debug Modus
  und lasse das Programm bei jedem Frame 'anhalten' so geht alles gut. Lasse ich es aber so laufen friert das gesammte
  System nach ein paar Sekunden ein und der Bildschirm wird ein paar Sekunden sp√§ter schwarz so das ich das ich den 
  Rechner neu starten muss. Ein MRT Demo welches ich am laufen hatte und welches im Code anscheinend nichts anderst macht 
  ging jedoch merkw√ºrdigerweise - ohman, ich HASSE solche Probleme. Da weis man nie obs nen Treiberbug ist oder ob an 
  iirrrgendeiner Stelle etwas nicht zu 100% Passt - aber dann gleich das ganze System ohne ersichtlichen Grund lamgelegt 
  ist schon hart. :(
  Daher deaktiverte ich MRT erstmal in PLTRendererOpenGLExtensions::Init() - sicher ist sicher. :)



>> 15.07.2005
[CO]
- Ein paar Ordner wie 'lib3ds' oder 'TriStripper' haben nun vorne ein '_'. Steht am Anfang eines Namens ein '_' oder '.' so
  werden diese vom 'CreateSDK.py'-Skript ignoriert



>> 07.07.2005
[SB]
PLRendererOpenGL:
- pbuffer.cpp: Habe <glut.h> aus den Includes entfernt, da wir diese Library nicht ben√∂tigen
  und sie daher auch nicht bei den libs mit dabei ist. Durch das Einbinden dieser Include-Datei
  jedoch wurden alle GL-Libs automatisch dazugelinkt, inklusive GLUT. Hab au√üerdem das Projekt
  f√ºr PLRendererOpenGL angepa√üt, da√ü die GL-Libraries nun im Projekt dazugelinkt werden.



>> 22.06.2005
[CO]
PLRendererOpenGL:
- DrawBox() und SetTexture() etwas Optimiert



>> 14.06.2005
[CO]
- PLRenderer: PN-Triangles (TRUFORM) Support hinzugef√ºgt. Gibts zwar nur auf ATI Karten (MUSS desweiteren im Treiber 
  aktiviert sein) und mit GPU Skinned Meshs wirds Probleme geben (da die Matrix Indices nicht Interpoliert werden 
  k√∂nnen :) - ist aber trotzdem nen nettes Feature und recht leicht zu verwenden... eigentlich nur aktivieren und 
  Tesselation Level setzen. (Vertex Normalen M√úSSEN vorhanden sein und passen)
  F√ºgte entsprechendes PN Triangles Beispiel Programm hinzu.
  Bei Zeiten muss ich mir mal was im Material mit den Render-States etc. √ºberlegen - denn mittlerweile haben wir gut
  50 solcher Einstellungen und die jedesmal pr√ºfen etc. wird sicherlich auf dauer etwas Lam.



>> 11.06.2005
[CO]
PLRendererOpenGL:
- Um WGL_EXT_swap_control erweitert mit dem man unter Windows V-Sync aktivieren/deaktivieren kann



>> 11.05.2005
[CO]
OpenGL Renderer:
- Render To Texture kann nun auch Optional beim PBuffer glCopyTexSubImage2D() verwenden um die Textur zu
  f√ºllen falls das direkte F√ºllen nicht funktioniert. (ist bei mir z.B. bei Rectangle Textures der Fall)



>> 01.05.2005
[CO]
PLRendererOpenGL:
- Render To Texture √ºberarbeitet - es wird nun eine extra PBuffer Klasse verwendet welche einigerma√üen
  handhabbar ist und zumdem auch unter Linux laufen m√ºsste. Aber was immer noch ziemlich doof ist, das 
  jeder pbuffer seinen eigenen Context hat... nicht sonderlich Performant und man muss jedesmal beim setzen eines
  Render Targets alle aktuellen Render States Updaten - in PLTRendererOpenGL::SetRenderTarget() fehlte noch das zur√ºck
  setzen der Texturen und Shader... einfach nur √Ñrgerlich. (ich brauchte einige Zeit bis ich diesen 'Bug' gefunden hatte)
  Sobald die aktuelle FBO Extension auch von den ATI Treibern unterst√ºtzt wird werd ich dann, wenn diese FBO verf√ºgbar sind
  diese anstatt pbuffer verwenden.



>> 30.04.2005
[CO]
- PLTRendererShaderOpenGL & PLTRendererShaderD3D9 k√∂nnen nun auch Programm Parameter des Typs 
  CG_STRUCT & CG_ARRAY Registrieren



>> 19.04.2005
[CO]
PLRenderer:
- In Cube Maps Rendern m√ºsste nun korrekt funktionieren, bis jetzt fehlte bei SetRenderTarget() noch die Optionale
  Cube Map Textur in welche gerendert werden soll. (teste ich die Tage mal aus wenn ich Dynamische Cube Maps
  austeste :)
  Desweiteren implementierte ich noch Support f√ºr Rectangle Texturen deren Gr√∂√üe kein vielfaches von 2 sein muss.
  Daf√ºr haben diese Texturen ein paar Nachteile da die GPU's dort diverse Features nicht unterst√ºtzen, desweiteren
  sind die Textur Koordinaten dort nicht nomalisiert was die Verwendung leider etwas umst√§ndlich macht. Aber 
  zumindestens f√ºr Ingame Guis kann man es sehr gut gebrauchen. :)



>> 06.04.2005
[CO]
PLRenderer:
- PLTRendererSurfaceWindow: F√ºgte die Funktionen GetGamma() und SetGamma() hinzu



>> 03.04.2005
[CO]
PLRendererOpenGL:
- PLTRendererOpenGLExtensions spuckt nun noch etwas mehr Informationen √ºber OpenGL aus - hilft beim Auffinden
  von z.B. Shader Problemen wenn man genau weis was die verwendete Hardware so kann. ;-)



>> 29.03.2005
[CO]
PLRenderer:
- PLTRendererBuffer::Allocate() kann nun auch aufgerufen werden wenn der Buffer bereits gef√ºllt ist. In diesem Fall wird
  er bei bedarf neu gef√ºllt.



>> 22.03.2005
[CO]
- PLRenderer auf neuen Kommentar-Style umgestellt



>> 16.03.2005
[CO]
PLRenderer:
- Stellte auf Cg 1.3 um. In PLRuntime liegen die aktuellen Cg dll's.
- PLeRFlagLockScissorTestStates hinzugef√ºgt falls erw√ºnscht ist das sich die Scissor Test Render States 
  NICHT √§ndern d√ºrfen



>> 04.03.2005
[CO]
PLRenderer:
- Unterhalb der Zeichen-Funktionen ist nun ein Block mit 'Selektions'-Funktionen. Dort sind nun diverse neue
  Funktionen welche es in OpenGL Standardm√§√üig gibt und einem z.B. das Selektieren enorm erleichtern.
  BuildSelectionPlaneSet() befindet sich nun in PLTPlaneSet::CreateSelectionPlanes() - es stellte sich einfach
  heraus das diese Dinge universell Andwendung finden. Im Renderer selbst sind nur noch die 'luxus' Funktionen
  PickMatrix() und CreateSelectionPlanes() welche aktuelle Viewport, Projection- & View-Matrix Einstellungen 
  verwenden, so spart man sich Schreibarbeit wenn man mit den Standard-Einstellungen arbeiten will.



>> 01.03.2005
[CO]
- Begin2DMode() wenn alle Parameter 0 sind werden die aktuellen Viewport Einstellungen verwendet
- Get2DCoordinate() √ºberarbeitet



>> 25.02.2005
[CO]
PLRendererOpenGL:
- DrawTriangle() und DrawQuad() wird nun direkt √ºber OpenGL Befehle gezeichnet anstatt √ºber die allgemeinen
  Vertex Buffer welche unter Direct3D n√∂tig sind.



>> 23.02.2005
[CO]
- Musste in PLTRenderStates leider alle Variablen welche vorher auf bool standen auf uint32 umstellen da die
  Typen unterschiedliche gr√∂√üen haben und dadurch die Werte nicht korrekt gesetzt wurden... nun hat man im
  ClassView leider nicht automatisch ne ComboBox wo man 'false/true' ausw√§hlen kann. Darum sage ich nun 
  ClassView √ºber die Annotations wenn eine Variable als boolean behandelt werden soll.



>> 22.02.2005
[CO]
PLRenderer:
- Verpasste PLTRenderStates, PLTSamplerStates und PLTTextureStageStates nettere Namen was nun ja dank Stefans 
  letzter RTTI Erweiterung m√∂glich ist. 'FillMode' liest und schreibt sich netter als 'm_nRS[PL_RS_FILLMODE]'. :)



>> 22.02.2005
[SB]
- Alle Projekte an die neuen RTTI-Makros angepa√üt



>> 20.02.2005
[CO]
PLRenderer:
- F√ºgte RTTI Wrapper Klassen f√ºr Render-States etc. hinzu. Diese Klassen werden u.a. vom Material verwendet 
  um diese Einstellm√∂glichkeiten komfortabler/universeller Handhaben zu k√∂nnen.
  (PLTRenderStates, PLTSamplerStates, PLTTextureStageStates)



>> 18.02.2005
[CO]
PLRenderer:
- Entferne PLTMaterialBase und PLTMaterialBaseFactory aus dem Renderer da nun √ºberfl√ºssig.
- GetStandardMaterial(), SetStandardMaterial(), UseStandardMaterial() entfernt da daf√ºr der Material Manager in der ModelLib
  verantwortlich ist.



>> 13.02.2005
[CO]
PLRenderer:
- Da das Mesh Format ge√§ndert wurde hab ich gleich PLE_VAS in die bessere Reihenfolge gebracht.



>> 08.02.2005
[CO]
PLRenderer:
- Neue Vertex Attribute Semantics: PL_VAS_BLENDINDICES & PL_VAS_BLENDWEIGHTS -> Dar√ºber wird man dann f√ºr das
  Hardware Skinning (oder auch Matrix Palette Skinning genannt) die Vertex Weights und Vertex Weight Indices
  √ºbergeben. Bei D3D sind diese gleich Definiert, bei OpenGL aber versteckt... darum fand ich erst jetzt heraus
  wie es unter OpenGL geht. Desweiteren noch diverse weitere Semantics eingetagen welche bei D3D so Standard 
  sind und auch bei Cg. Unter OpenGL muss die Extension GL_ARB_vertex_program vorhanden sein damit diese neuen 
  Semantics verwendet werden k√∂nnen.
- Die Reihenfolge von PLE_VAS wird, wenn ich das n√§chste mal das Mesh Format √§ndere ebenfalls ge√§ndert so wie 
  es √ºblich ist. Mit dieser neuen Reihenfolge kommt die GPU angeblich noch besser zurecht da intern nicht 
  so viel im Speicher herumgesprungen werden muss.
- GetVertices() & SetVertices() so erweitert das man nun mehrere Vertex Buffer gleichzeitig verwenden kann. 
  Dies ist Praktisch wenn Beispielsweise die Textur Koordinaten immer gleich bleiben, die Positionen & Normalen 
  aber durch Animation sich st√§ndig √§ndern so das man Position & Normale von Frame 0 und Frame 1 in einem 
  Shader interpolieren muss. Dann von Frame 1 und Frame 2 etc. Da das verwenden mehrer Vertex Buffer nicht so
  performant ist sollte man das wo immer es m√∂glich ist vermeiden. Darum war es mir wichtig das sich 
  GetVertices() und SetVertices() weiterhin so einfach wie m√∂glich verwenden lassen.
  Nun m√ºsste der Renderer alles k√∂nnen was man f√ºr Hardware Skinning braucht - auch k√∂nnte man nun √ºber Vertex
  Shader die GeoMipmaps des Terrains interpolieren lassen so das es kein 'poppen' mehr gibt. :)



>> 05.02.2005
[CO]
PLRenderer:
- BuildSelectionFrustum() in BuildSelectionPlaneSet() umbenannt



>> 26.01.2005
[CO]
- PLTSurfaceListener::PLTSurfaceListener: Da die Kamera dummerweise von PLTRendererCamera angeleitet wird, was man nie machen
  sollte muss man hier per Hand diese Resource dem Renderer hinzuf√ºgen/entfernen, dann ist der Crash beim beenden wech.
  Bei Zeiten muss ich das mit der Kamera mal komplett √ºberarbeiten. :)



>> 18.01.2005
[CO]
- PLTRendererFrame: Von OnMessage() auf OnKeyPressed() umgestellt



>> 11.01.2005
[CO]
- Machte ein paar kleinere Bug-Fixes



>> 09.01.2005
[CO]
- Alles noch an ein paar √Ñnderungen angepasst.



>> 26.12.2004
[CO]
- Diverse kleine Bugfixes... die Listen umstellung war wirklich heftig ;-)



>> 25.12.2004
[CO]
- Kleinere Bugs durch das umstellen auf PLContainer in PLRenderer und PLModelLib behoben - nun m√ºssten diese zwei Projekte
  eigentlich wieder soweit funktionieren - auf jedenfall laufen die entsprechenden Test Projekte. ;-)



>> 22.12.2004
[CO]
- PLRenderer an neue Container Klassen angepasst, bei ModelLib auch gleich alles auf das neue FS
  umgestellt damit diese Lib unabh√§ngig von der Engine ist. Da ich es nicht Testen konnte ist es m√∂glich das hier 
  und da noch Fehler drin sind, hab mich zwar angestrengt m√∂glichst nichts zu √ºbersehen, aber das gelingt ja meistens
  nur sehr selten. :(
- Renderer Backends aus dem Renderer Ordner nach PLEngine/Source verschoben



>> 19.12.2004
[CO]
- PLRenderer & Backends: main.cpp an Plugin in Module Makro Umbenennung angepasst



>> 14.12.2004
[SB]
- Plugin-Definitionen der Renderer-Plugins sowie der Sound-Plugins teilweise wiederhergestellt sowie Includes angepa√üt,
  bei den Plugin-Definitionen war wohl einiges durcheinander gekommen
- PLRenderer: Nanu?? Wer behauptet denn, man k√∂nne abstrakte Basisklassen nicht korrekt am RTTI registrieren??
              Habe PLRenderer wieder entfernt und statt dessen PLTRenderer korrekt am RTTI registriert sowie
              die abgeleiteten Klassen angepasst :-)



>> 13.12.2004
[CO]
PLRenderer:
- Passte alles an RTTI √Ñnderungen an. PLTRenderer wird nun von PLRenderer abgeleitet da PLTRenderer selbst
  eine Abstrakte Klasse ist und es daher nicht m√∂glich ist diese Klasse korrekt im RTTI zu regestrieren.
  Entweder lassen wir das so oder wir basteln PLTRenderer so um das die Klasse nicht mehr abstrakt ist - was
  ich aber nicht soo sch√∂n f√§nde. Hm, andererseits haben wir mehere vergleichbare Klasse die einerseits abstrakt
  sind, andererseits aber als Basis (& Gruppe) dienen sollen. (PLTSceneManager, TPixelLabPlugin in PixelLab etc.)



>> 03.12.2004
[CO]
PLRenderer:
- F√ºgte ein Null-Backend hinzu - dieses verh√§lt sich wie ein normales Renderer Backend, nur verwendet es keine
  API wie D3D/OpenGL sondern versucht so viel wie m√∂glich selbst zu realsieren, richtig Rendern kann dieses 
  Backend jedoch nicht.
- Renderer Backend Dinge werden nicht mehr direkt in den Renderer eingebunden, somit ist die Renderer Dll selbst
  nun auch unabh√§ngig von Cg - die Codes in diesem Ordner sind ja 'nur' ein Angebot das man als Basis f√ºr sein 
  Backend verwenden kann damit man nicht mehr ALLES komplett neu schreiben muss. PLTRendererBackendCg erweitert
  die Grund Klasse um Cg initialisierung etc. Sp√§ter werd ich diesen Shader Teil wohl leicht umschreiben so das
  auch problemlos andere Shader Sprachen verwenden kann. (daf√ºr muss ich ja nur kleine Teile neu Designen :)



>> 28.11.2004
[CO]
PLRenderer:
- PL::Config wird nun nicht mehr verwendet - stellte alles aus PLTConfig aus PLGeneral um. F√ºr das konkrete
  laden/speichern der Einstellungen wird dann wohl die Engine zust√§ndig sein.
  -> Der Renderer ist somit nun komplett unabh√§ngig von der Engine



>> 26.11.2004
[CO]
PLRenderer:
- Passte den Renderer an die von uns in PLGeneral selbst definierten Datentypen an.
  -> PLMaterialPass.h & PLTextureHandler.h in der Engine wurden aktualisiert.



>> 19.11.2004
[CO]
PLRenderer:
- F√ºge BackupDeviceObjects() & RestoreDeviceObjects() Funktionen im Direct3D Backend hinzu, noch nicht komplett implementiert.
- D3D: PLTRendererVertexBufferD3D9 & PLTRendererIndexBufferD3D9 um PL_USAGE_SOFTWARE erweitert - dies Dient nur als Software Speicher
  mit dem NICHT gerendert werden kann sondern nur als Zwischenspeicher oder so dienen kann. Das OpenGL Backend kann zwar damit auch
  Rendern - wird aber nur verwendet wenn die Hardware keine VBOs kann, D3D macht das intern selbst.
- √úberall PL::Log. in PLTLog::GetInstance()-> ge√§ndert



>> 15.11.2004
[CO]
PLRenderer:
- Neue Funktionen: BackupDeviceObjects() & RestoreDeviceObjects() -> Werden z.B. beim wechseln des Fenstermodus verwendet
  um aktuelle Device Objekt Daten zu sichern und wiederherzustellen. Dabei muss jeder Resourcen Typ selbst seine Daten in 
  einen Buffer sichern, bei vielen Daten k√∂nnte das zwar dann probleme mit den Datenmengen machen, mir viel jedoch keine
  andere m√∂glichkeit ein da man die Daten in Texturen, (beispielsweise dynamisch erzeugte) Vertex Buffern etc. nicht
  einfach wieder nachladen kann. So wie es aussieht klappt das mit dem Bildschirm Modus wechseln + Resourcen aktualsieren
  im OpenGL Backend. Zumindestes bei mir scheint das mit dem Wechsel nun ziemlich gut zu funktionieren, nur in Jens Grabkammer
  Welt scheint noch irgendetwas zu sein was bei Wechsel einen Crash verursacht - der Sache werd ich morgen auf den Grund gehen.



>> 14.11.04
[CO]
PLRenderer:
- Das setzen der Sampler States im OpenGL Backend funktioniert nun besser (z.B. Mipmapping)
- Das wecheln in den Vollbild Modus ist implementiert. PLTRendererSurfaceWindow und dessen Backend implementationen
  machen die Hauptarbeit - dabei bekommt es beim Erzeugen seinen Bildschirm Modus (vollbild oder nicht) und kann diesen
  nicht mehr √§ndern. Dies ist aber kein Problem da es sich bei dieser Renderer Oberfl√§che ja nicht um das eigentliche
  Fenster sondern 'nur' um einen Ausgabebereich handelt. Im normallfall arbeitet man nur mit PLTRendererWindow und
  PLTRendererFrame wobei das letztere das mit dem Vollbild/nicht Vollbild automatisch implementiert - also NUR Frames
  lassen sich zwischen Vollbild oder Fenster Modus umschalten, kann man sp√§ter nat√ºrlich √§ndern aber ich denke das w√§re
  nicht so sinnig.
  Das eventuelle Aktualisieren von z.B. Texturen ist noch nicht implementiert - wie es scheint muss man selbst den Device
  Context dann neu anlegen, daher klappt das umschalten des Modus noch nicht wirklich.



>> 11.11.04
[CO]
- An das RTTI angepasst



>> 07.11.04
[CO]
PLRendererD3D9:
- Das Direct3D Backend l√§uft nun zu ca. 80% korrekt - Auch die Shader funktionieren bereits. :)



>> 05.11.04
[CO]
PLRendererD3D9:
- Das Direct3D Backend l√§uft nun zu ca. 70% korrekt



>> 20.10.04
[CO]
PLRenderer:
- Neue Texture Formate: PL_TPF_D16, PL_TPF_D24 und PL_TPF_D32 -> N√∂tig wenn man nur Tiefenwerte in eine Textur
  rendern will (f√ºr z.B. ShadowMapping braucht man eine solche 'Depth Map' :)
  Die Textur selbst l√§sst sich dann wie PL_TPF_L8/PL_TPF_L16 beim Rendern verwenden - also als Textur mit nur einem
  Farbkanal.



>> 05.10.04
[CO]
PLRenderer:
- PLTRendererVertexBufferOpenGL::GetData() -> Scheint nun zu korrekt funktionieren - bei Jens verursachte meine kleine Offset Optimierung
  zuvor lustige Textur Fehler. :)



>> 04.10.04
[CO]
PLRenderer:
- Neue Funktion: DrawPlane() -> Zum Visualisieren einer Ebene was zu Testzwecken recht n√ºtzlich sein kann. :)



>> 03.10.04
[CO]
PLRenderer:
- PLTRendererIndexBuffer: Neue Funktionen: GetData() & SetData() zum auslesen und setzen von Indices ohne das man sich um den internen Index Typ
  k√ºmmern muss -> Diese Funktionen sollte man nach m√∂glichkeit IMMER verwenden!
  Passte gleich alle Codes daran an, nun kann man problemlos auch USHORT verwenden wenn das ausreichend ist - gibt mehr Performance!
- Neue Funktion: PLTRenderer: MakeScreenshot() -> Macht einen Screenshot vom aktuellen Render Target



>> 22.09.04
[CO]
- Behob fehler in PLTSurfaceListener::DrawProfiling()



>> 18.09.04
[CO]
PLRenderer:
- Um zu pr√ºfen ob Dynamische VBOs extrem langsam sind und ob es nicht schneller ginge wenn man das wie fr√ºher hochl√§d
  baute ich in PLTRendererIndexBufferOpenGL und PLTRendererVertexBufferOpenGL eigene Buffer ein welche die VBOs √ºbernehmen.
  Aber selbst Dynamische VBOs sind dann noch schneller als die 'alte Methode' wenn diese st√§ndig aktualisiert werden.
  Naja, das Experiment hatte den Nebeneffekt das diese Buffer nun auch funktionieren wenn die Karte keine VBOs kann - 
  was aber glaub ich jede Karte mittlerweile unterst√ºtzt. ;-)
- Optimierte PLTRendererVertexBufferOpenGL::GetData() etwas durch das vorspeichern der Offsets - das brachte mir
  bei meinem momenten extrem Vertex reichen Wasser Test das doppelte an FPS. (12 statt 6 ;-)
  (hm, beim importieren von 3ds modellen scheint es probleme zu machen... darum erstmal die optimierung rauskommentiert
  bis ich rausgefunden hab wieso das nur dort so ist :)



>> 17.09.04
[CO]
PLRenderer:
- 1D Texturen funktionieren nun richtig



>> 11.09.04
[CO]
PLRendererOpenGL:
- OpenGL Header aktualisiert (siehe gl.zip)
- Neues Feature: Unterst√ºtzung von Depth Bounds Test (GL_EXT_depth_bounds_test) welches quasi eine Erweiterung
  der Scissor Tests in 'der Tiefe' ist. Kann mit der Renderer Funktion GetDepthBounds() & SetDepthBounds() abgefragt
  und gesetzt werden. Konnte diese Extension ebenfalls nicht testen aber wenn diese vorhanden ist spart diese beim
  aufwendigen PerPixelLighting & Shadow Volumes nochmal etwas F√ºllrate welche bei dieser Technik ja der Flaschenhals
  ist.



>> 10.09.04
[CO]
PLRenderer:
- Two sided stencil tests implementiert - werden bereits wenn verf√ºgbar von den Shadow Volumes verwendet. (GL_EXT_stencil_two_side)
  Es sind daf√ºr 5 neue Render States hinzugekommen. Konnte dieses Feature zwar nicht selbst testen da es keine meiner
  mittlerweile etwas veralteren Grafikkarten kann - aber auf allen neuen Karten m√ºsste es funktionieren. :)
  Stefan, du hast ja ne GeForce5 - w√§re super wenn du mal PLTShadowVolume::DrawZPass() und PLTShadowVolume::DrawZFail()
  testen k√∂nntest, im Prinzip siehst du sofort obs geht oder nicht da es normalerweise wenn verf√ºgbar Automatisch
  verwendet wird. :)
- Neue Funktion: GetViewportCorners() -> Gibt einen die aktuellen Viewport Ecken zur√ºck - quasi das 'Fenster' durch
  welches man in die Welt schaut. Wird f√ºr diverse Dinge immer mal wieder gebraucht, u.a. bei den Shadow Volumes um zu
  pr√ºfen ob sich die Kamera im Schatten befindet oder nicht.



>> 09.09.04
[CO]
- Neben CalculateBoundingBox() zum berechnen der Bounding Box eines VertexBuffers/Meshs gibt es nun noch
  CalculateBoundingSphere() welche die Bounding Sphere berechnet.
  In PLTObject und dem ODE √§quivalent wird nun der Entity Kollisions Radius mit hilfe dieser neuen Funktion berechnet anstatt den
  Radius der Bounding Box zu nehmen welcher meist gr√∂√üer ist.



>> 06.09.04
[CO]
- Neue Funktionen: GetFlags(), SetFlags(), GetCustomFlags(), SetCustomFlags() -> Flags welche z.B. in der Engine
  gesetzt werden wenn gerade etwas spezielles gerendert wird. (ambient(lighting pass, projective texturing etc.)
  Damit kann man unterbinden das Texturen, Shader, spezielle Render States etc. gesetzt werden.
  Mir viel bis jetzt keine bessere L√∂sung ein wo man das machen k√∂nnte, darum implementierte ich das nun universell
  in den Renderer, und wenn man noch etwas braucht erweitert man es dort halt entsprechend. Zuerst wollte ich mit 
  Hilfe der Custom Render Flage in der Engine vermerken in welchem Render Modus man gerade ist, jedoch stellte sich 
  recht schnell heraus das dies im Chaos und Gehacke geendet h√§tte.
  Im Scene Manager PLTSMPerPixelLighting werden diese Flags bereits recht umfangreich ben√∂tigt.



>> 28.08.04
[CO]
PLRenderer:
- PLRendererTypes.h -> PLColor3.h und PLColor4.h eingebunden da die Farben nun eigenst√§ndige Klassen sind



>> 12.08.04
[CO]
PLRenderer:
- Neue Funktion:BuildSelectionFrustum() -> Erzeugt einen Frustum dem man zum Selektieren mit hilfe eines Rechtecks
  auf dem Bildschirm verwenden kann.



>> 11.08.04
[CO]
PLRenderer:
- PLTRendererSurfaceListenerHandler eingebaut der in PLTEntityCamera ben√∂tigt wird... bei Zeiten k√∂nnte man all diese Handler
  in einer Basis-Klasse vereinen...



>> 10.08.04
[CO]
- Musste die Fix-Pass Renderer Light √ºberarbeiten da man Positionen etc. nicht wirklich gut √ºber DWORD managen kann.
- Neuer Render-State: PL_RS_FIXEDFILLMODE -> Ist dieser Status gesetzt bestimmt er allein den verwendeten F√ºll-Modus,
  damit kann man z.B. immer einen Wireframe Modus erzwingen egal was ein Material f√ºr einen F√ºllmodus setzt.



>> 07.08.04
[CO]
PLRenderer:
- PLTRendererSurface -> Kann nun aktiviert/deaktiviert werden
- PLTRendererWindow & PLTRendererFrame aktivieren/deaktivieren automatisch ihr Surface
- Stellt auf neues Log in PLGeneral um



>> 03.08.04
[CO]
- PLTRendererOpenGL::Get3DCoordinate() funktioniert nun richtig



>> 02.08.04
[CO]
PLRenderer:
- 3D texturen funktionieren nun korrekt
- Unterst√ºtzt nun Point Sprites mit denen z.B. Partikel gezeichnet werden k√∂nnen
- SetRenderState() etc. geben nun die alten Werte zur√ºck und -1 bei einem Fehler, so geht das Speichern
  der alten Einstellungen leichter



>> 01.08.04
[CO]
PLRenderer:
- Vertex und Index Buffer kann man nun nur noch √ºber SetVertices()/SetIndices() und nicht mehr direkt √ºber
  MakeCurrent() setzen



>> 27.07.04
[CO]
PLRenderer:
- VertexBuffer: Vertex Element in Vertex Attribute umbenannt um Namensverwechslungen mit der Anzahl an Elementen
  in einem Buffer zu vermeiden. Das zog zwar einige Anpassungen nach sich - nun ist es aber wesentlich einsichtiger
  was gemeint ist.
- Render To Texture System √ºberarbeitet so das es nun wesentlich einfacher ist in Texturn zu Rendern. Einfach
  mit z.B. CreateSurfaceTexture2D() eine entsprechende Textur erzeugen. Mit SetRenderTarget() setzen und sp√§ter
  kann man die konkrete Textur welche man √ºber PLTRendererSurfaceTexture::GetTexture() wie alle anderen Texturen auch
  verwenden.
- Texture pixel formats (PLE_TPF) erweitert, u.a. gibt es nun auch floating point pixel buffer in welche man z.B.
  Rendern kann. Diese floating point buffer gewinnen immer mehr an Bedeutung da sich damit viele fortschrittliche
  Techniken wie Realtime HDRI realisieren lassen...
PLRendererOpenGL:
- wglext.h in gl.zip aktualisiert -> Muss wie √ºblich bei den VC Includes aktualisiert werden



>> 24.07.04
[CO]
PLRenderer:
- Neuen Render State: PL_RS_INVCULLMODE -> Damit kann man den API Cull Mode invertieren, praktisch wenn man
  Reflektionen rendert bei denen durch die Reflection Matrix die Vertex Anordnung vertauscht wird!



>> 20.07.04
[CO]
- Vertex Buffer k√∂nnen nun optional bei MakeCurrent oder SetVertices einen Offset haben



>> 08.07.04
[CO]
PLRenderer:
- DrawBitmap, DrawPoint und DrawLine werden nun im OpenGL Backend direkt mit OpenGL Befehlen dargestellt was
  die Performance mehr 4 mal verbesserte da man f√ºr einzelne Punkte etc. nicht mehr extra umst√§ndlich einen
  Buffer einstellen muss. (lohne nur wirklich f√ºr viele Primitives!)
  Im Direct3D Backend kann man es aber anscheinend nicht anderst machen.
  Somit lassen sich nun auch Ingame GUIs fl√ºssig darstellen. (sie PLSampleLarge)
- Neue Funktion: GetOcclusionQuery() -> Damit kann man eine standard Occlusion Query Instance bekommen falls
  es sich nicht lohnt eigene Objekte zu erzeugen - wird erst wirklich n√∂tig wenn man mehre Tests gleichzeitig
  machen will.


>> 07.07.04
[CO]
PLRenderer:
- Implementierte eine Occlusion Query Klasse welche z.B. ben√∂tigt wird um zu pr√ºfen ob ein Portal derzeit
  komplett verdeckt ist und somit nicht sichtbar ist oder nicht. (komplett Dynamischer zus√§tzlicher Test :)
  √úber Occulision Tests wird in Zukunft auch gepr√ºft ob ein Licht gerade verdeckt ist oder nicht - somit
  braucht man die Funktion ReadDepthComponent() nicht mehr welche unter Direct3D derzeit noch nicht geht...
  (bei Zeiten k√∂nnte man diese Funktion vielleicht ganz aus dem Renderer nehmen :)



>> 22.06.04
[CO]
PLRenderer:
- Neue Funktionen zum abfragen der Anzahl der Oberfl√§chen und Resourcen. Mit PLTRenderer::GetConfigs() erh√§lt
  man die Renderer Einstellungen welche fr√ºher noch direkt von der Engine abgefragt wurden... ist zwar noch nicht
  die sch√∂nste L√∂sung erf√ºllt aber f√ºrs erste ihren Zweck bis man sich da was schickes ausgedacht hat. :)
  Desweiteren ist der Renderer nun unabh√§ngig von der Engine - m√ºsste die Log zugriffe daf√ºr rauskommentieren -
  sollte man wieder reinnehmen sobald das Log in PLGeneral ist.
  Musste bei PLTRendererCamera das Entity binding herausgeben. In der Engine ist nun eine Ableitung davon namens
  PLTCamera welche noch Entity Binding implementiert. Wird die Engine verwendet wird immer nur diese Camera
  verwendet und nicht PLTRendererCamera direkt!
- PLTMaterialBase -> Abstraktes Material Interface f√ºr z.B. die Model Lib damit diese von der Engine nichts
  zu wissen braucht. Daf√ºr gibt es PLTMaterialBaseFactory welche Materialien erzeugen kann.



>> 10.06.04
[CO]
PLRenderer:
- PLTRendererVertexBuffer: Neue Funktion: GetMinMaxPos() -> ermittelt die Bounding Box des Vertex Buffers
  (das wird man sicherlich immer mal wieder brauchen :)



>> 27.05.04
[CO]
- PLTRendererBuffer: Neue Funktion: IsLocked()
- PLTRendererVertexBuffer::AddVertexElement()  funktioniert nun korrekt beim hinzuf√ºgen von Vertex Elementen
  nach dem anlegen des Buffers



>> 26.05.04
[CO]
- Diverse kleinere Fehler im Renderer etc. behoben so das nun die Shader wieder soweit funktionieren. In PLTests gibts
  nun nen neues Entity welches zum Mesh testen da ist und mit dem sich auch z.B. BumpMapping testen l√§sst.



>> 25.05.04
[CO]
PLRenderer:
- PLTRendererVertexBuffer::AddVertexElement() kann nun auch nachdem ein Buffer bereits angelegt wurde dem Buffer
  neue Vertex Elemente wie z.B. Normalen Daten hinzuf√ºgen. In diesem Fall muss intern der Buffer umkopiert werden.
  Auf RemoveElement() funktionen werde ich erstmal versichten da mir dies momentan unn√∂tig viel Arbeit erscheint
  f√ºr etwas was im normalfall niemals gemacht wird.



>> 21.05.04
[CO]
- Vertex und Index Buffer haben nun Copy-Operatoren



>> 20.05.04
[CO]
PLRenderer:
- Bemerkte das ich im Renderer teils bei SRC einen dreher drin hatte und SCR geschrieben hatte -> Behoben



>> 15.05.04
[CO]
PLRenderer:
- SetTextureStageState() -> Diverse Detailverbesserungen



>> 14.05.04
[CO]
- Das Renderer Test Projekt wurde nun gel√∂scht da dieses Dinge nun in PLSampleLarge sind.
  (Backup in Backups/TestProjects/PLRendererTest.zip)



>> 13.05.04
[CO]
PLRenderer:
- Neue Funktionen: DrawTriangle(), DrawQuad(), DrawBox(), DrawSphere() -> Diese Funktionen zeichnen ein 
  Dreieck, Rechteck, eine Box und eine Sphere was f√ºr Debugging zwecke hilfreich ist da man dann nicht 
  erst umst√§ndlich jedesmal Vertex, Index Buffer etc. erzeugen und einstellen musss
  -> In PLTests ein paar Testfunktionen f√ºr diese neuen Renderer Dinge.
- Neue Funktion: ReadDepthComponent() -> Kann aus dem Tiefen Buffer lesen -> vorerst ist die Funktion noch
  nicht komplett durchdacht da ich in z.B. Direct3D keine glReadPixels √§hnliche Funktion finden konnte -
  aber nun kann man z.B. endlich wieder einfach pr√ºfen ob ein Licht verdeckt wird oder nicht :)
- Neue States: TextureStageState -> Damit l√§sst sich f√ºr jede Textureinheit Mischfunktionen und Texture
  Koordinaten erzeugung (z.B. EnvironmentMapping) einstellen.



>> 12.05.04
[CO]
PLRenderer:
- Neue Funktion: Reset() -> Setzt alle Renderer Einstellungen zur√ºck auf Default
- SetTexture() -> Wird als Texture Stage -1 √ºbergeben so betrift die Einsellung ALLE Texture Stages.
  Bei SetClipPlaneEnabled() und SetClipPlane() ist es nun genauso.
- Neue Funktionen: GetDefaultRenderStates(), GetDefaultSamplerStates(), GetDefaultLightStates() -> Diese
  Funktionen sind praktisch damit man z.B. in PLTMaterial
  nicht erneut die Standard Einstellungen Definiern muss. :)
- Verbesserte diverse intere Design Dinge im Renderer (u.a. States setzen etc)
- Neue Funktionen: GetPointSize(), SetPointSize(), GetLineWidth(), SetLineWidth() -> zum setzen/abfragen der
  Punkt gr√∂√üe und Linien Breite, dieses Funktionen gibt es anscheinend in Direct3D nicht... jedoch sind diese
  f√ºr Debug zwecke sehr hilfreich daher entschloss ich mich diese Funktionen im Renderer zu implementieren



>> 11.05.04
[CO]
PLRenderer:
- Neue Funktion: GetCamera() gibt die zuletzt gesetzte Renderer Kamera zur√ºck, manchmal ist es praktisch zu
  wissen mit welchen Daten die aktuelle View Matrix etc. erzeugt wurde - desweiteren muss man hin und wieder zur
  z.B. bestimmung einer Entfernung die Position der Kamera wissen
  PLTRendererCamera ist nun ebenfalls eine Renderer Resource - anderst w√§re es zu umst√§ndlich und meist wird
  sowieso ein Renderer unabh√§ngiges Kamera Entitie verwendet. :)



>> 05.05.04
[CO]
PLRenderer:
- Neue Funktionen: GetColor() & Set Color() -> damit stellt man die aktuelle Farbe von z.B. Text, Linien, Bitmaps
  etc. ein.



>> 04.05.04
[CO]
PLRenderer:
- Neue Funktionen: DrawPoint() und DrawLine()



>> 21.03.04
[SB]
PLRenderer:
- Neue Klassen PLTVertexBuffer und PLTIndexBuffer hinzugef√ºgt,
  welche in den neuen Modell-Klassen und im Renderer Verwendung finden werden



>> 15.03.04
[CO]
PLRenderer:
- Neue Funktionen: GetMax3DTextureSize() & GetMaxCubeMapTextureSize() liefert die Maximale Textur gr√∂√üe dieser
  Texture Typen zur√ºck - diese werden auch ins Log geschrieben.
- PLTTexture: Neue Funktionen: GetMaxTextureSize() -> liefert die maximale Texture gr√∂√üe f√ºr den aktuelle Textur Typ



>> 25.02.04
[CO]
PLRenderer:
- PLTTexture::Load -> Wandelt nun intern BGR Texturen in RGB um
PLRendererOpenGL:
- Nun sind alle GL_ARB_multitexture Extension Funktionen verwendbar



>> 20.01.04
[CO]
- PLTRendererHandler l√∂scht nicht mehr selbst Standardm√§√üig den Bildschirm Puffer. Dies sollte im normalfall ein Clear-Entity
  √ºbernehmen oder im Fall der Editoren wird der Renderer Handler angewiesen den Bildschirm Puffer selbst zu l√∂schen



>> 03.01.04
[CO]
PLRendererOpenGL:
- Neue Extensions werden verwendet: GL_EXT_texture_rectangle & GL_NV_texture_rectangle -> diese machen beide das gleiche
  und werden auch auf die gleiche art verwendet. Damit kann man auch Texturen welche kein vielfaches von 2 (z.B. 465x234)
  verwenden. √úber das plt-Format kann man in General -> Rectangle=1 eine Textur als Rectangle markieren.
  Diese spezielle Textur Art kann man z.B. hervorragend f√ºr Men√ºs etc. verwenden da man dann die Orginal Texturen verwenden
  kann was die Bildquailt√§t deutlich verbessert. Jedoch hat diese Textur art einige Einschr√§nkungen. Siehe
  http://oss.sgi.com/projects/ogl-sample/registry/NV/texture_rectangle.txt f√ºr mehr Informationen.
  -> API Dokumentation im Material Kapitel um einen Textur Teil erweitert.



>> 25.12.03
[CO]
PLRendererOpenGL:
- Neue Extension wird verwendet: GL_EXT_draw_range_elements
- PLTGeometry: Von glDrawElements() auf glDrawRangeElementsEXT() umgestellt da Effektiver.
  Wenn √ºber GetPointer() Geometry Indices ver√§ndert wurden MUSS man nun die Funktion UpdateMinMaxIndex()
  aufrufen welche die neuen min/max Indices ermittelt. Entsprechende Stellen in allen Projekt-Codes aktualisiert.
  (war nur bei PLTEntities und ME und in der Engine selbst n√∂tig :)
- Nahm Extension NV_vertex_array_range heraus da mittlerweile durch ARB_vertex_buffer_object ersetzt



>> 23.12.03
[CO]
PLRendererOpenGL:
- Warf GL_HP_occlusion_test √ºber Bord und stellte PLTRenderer::OcclusionTest() auf die neue GL_ARB_occlusion_query Extension
  um. Mit dieser neuen Extension welche es erst seit kurzem gibt kann man nun auch herausbekommen wieviele der gezeichneten
  Pixel sichtbar sind
- glext.h um GL_ARB_occlusion_query erweitert, aktuelle Datei wie √ºblich im Libs-Ordner (gl.zip)



>> 20.12.03
[CO]
PLRenderer:
- PLTRenderFrame -> GuiFrame Base Funktionen werden nun aufgerufen
- PLTRenderWindow -> GuiWindow Base Funktionen werden nun aufgerufen
- PLTRenderFrame: Neue Funktionen: SetToggleFullscreenMode() & GetToggleFullscreenMode() -> Damit kann man Einstellen ob es
  erlaubt ist den Vollbild-Modus des Fenster √ºber Alt-Return zu wechseln
- PLTRenderFrame: Sobald das Fenster den Fokus verliert wird nun auch dessen Input Handler deaktiviert



>> 13.12.03
[CO]
PLRenderer:
- PLTRenderFrame setzt nun auch Variable PL::Config.m_bFullscreen damit der Fullscreen-Status gespeichert werden kann. Das
  macht zwar nur Sinn wenn man ein Render Frame hat aber wenn man mehere Frames verwendet so laufen diese √ºberlicherweise
  immer im Fenster Modus. In 'normalen' Projekten hat man nur einen Render Frame und dann ist es sehr komfortabel wenn der
  Vollbild Modus gespeichert wird.



>> 04.12.03
[CO]
PLRendererOpenGL:
- Renderer: Neue Extension wird verwendet: GL_ARB_texture_mirrored_repeat -> Damit ist ein neuer Texture Wrap Modus m√∂glich:
  PL_MIRRORED_REPEAT welcher mit PL_REPEAT vergleichbar ist, die Textur aber zus√§tzlich noch spiegelt
  -> Modell Editor angepasst -> PL User Guide angepasst



>> 29.11.03
[CO]
- In fast allen Projekten gab es durch empfindlichere Compiler Einstellungen diverse Warnungen welche nun behoben sind



/*********************************************************\
 *  Eintr√§ge aus altem Diary, damals noch ohne genaue Datum angaben. (oben -> unten = neuer -> √§lter)
\*********************************************************/



[CO] PL::Renderer: Neue Funktion: GetMaxTextureSize() -> gibt die gr√∂√üt m√∂gliche Texture gr√∂√üe zur√ºck
[SB] PLTRenderer: F√ºr die 2D Funktionen kann nun angegeben werden, auf welcher Z-Position sie zeichnen sollen. Dieser
     Wert wird durch Set2DZPosition gesetzt und steht normaler Weise auf 0
[SB] PLTFont wurde erweitert, um an eine bestimmte Z-Position zu zeichnen. Dieser Parameter hat einen Default-Wert von
     0 und kann daher ignoriert werden, wenn er nicht explizit verwendet werden soll
[CO] In PLTTexture::LoadData() wird nun √ºberpr√ºft ob die Texture gr√∂√üe ok ist... notfalls wird diese passend gemacht ->
     ansonnsten kann die Textur u.a. nicht von der Grafik-Karte verwendet werden und die Textur bleibt weis (oder andere
     fehler k√∂nnten auftreten...)
[CO] Erste Version von PLTRendererStates implementiert (ist bereits ein leichter Performance zuwachs zu bemerken :)
[CO] PLTRenderer: Neue Funktion: OcclusionTest() -> Pr√ºft ob eine Bounding Box von etwas anderem komplett verdeckt wird
     oder nicht -> mehr Performance da der Overdraw reduziert wird! :)
[CO] Neue Extension wird verwendet: GL_HP_occlusion_test -> Damit l√§sst sich Hardware m√§√üig schnell pr√ºfen ob etwas das
     gerendert werden soll von etwas anderem komplett verdeckt wird oder nicht
[CO] Zum Texturen Laden wird nun DevIL (openil.sourceforge.net) verwendet, dadurch kann man nun sehr viel mehr Textur
     Formate einlesen und speichern -> Datei PLTextureLoad.cpp gel√∂scht
[CO] Neue Extension wird verwendet: GL_EXT_texture_edge_clamp -> √Ñhnlich wie GL_ARB_texture_border_clamp -> Material
     entsprechend um PL_CLAMP_TO_EDGE erweitert
[CO] PLTTextureHandler um neue Funktion erweitert: GetTexEnvCombineParameters() -> Damit bekommt man zugriff auf diverse
     Combine Parameter mit denen man gr√∂√üere Kontrolle dar√ºber hat wie die verschiedenen Textur Schichten kombiniert
     werden
[CO] Neue Extension wird verwendet: GL_ARB_texture_border_clamp -> GL_CLAMP_TO_BORDER_ARB ist eine weitere Texture
     Wrapping Funktion neben CLAMP und REPEAT -> Wird im Material mit CLAMP_TO_BORDER gesetzt
[CO] Neue Extension wird verwendet: GL_EXT_texture_lod_bias -> Damit kann man den Textur Filter einstellen und eine Textur
     z.B. verwaschener darstellen -> L√§sst sich im Textur Handler mit der Funktion SetTexLodBias() einstellen -> K√∂nnte
     man sogar Animieren und h√§tte damit einen weiteren m√∂glichen Textur Effekt! :)  -> PLSamples neues Beispiel Entity:
     EntityTexLodBiasAni -> Test:   EntityTexLodBiasAni m_szModelFilename="farn"  -> sieht n√ºsch √ºbel aus ;-)
[CO] PLTRenderChild gel√∂scht da unn√∂tig
[CO] PLTRendererHandler: ShowInfos() -> Informationen k√∂nnen Standardm√§√üig eingeblendet werden. Nur in ausnahmef√§llen
     sind diese nicht Erw√ºnscht... wie z.B. bei der Textur Ansicht im Debug Dialog
[CO] PLTRendererHandler -> √úber Debug-Flags kann man nun einstellen ob die Koordianten Axen, Ebenen usw. eingeblendet
     werden sollen -> l√§sst sich Global √ºber PL::Config und nun auch individuell Einstellen
[SB] Einige kleinere Anpassungen in PlRenderer vorgenommen
[CO] PLTRendererHandler -> L√§sst sich nun Aktivieren oder Deaktivieren, PLTRenderWindow deaktiviert seinen Renderer
     Handler automatisch sobald es unsichbar wird
[CO] PLTRenderWindow: Neue Funktion: GetInputHandler()
[CO] PLTRenderFrame::OnMessage() reagiert auf ALT-RETURN um den Bildschirm Modus umzuschalten (Fenster/Vollbild)
[SB] Fullscreen mode umgeschrieben: Das Schalten in den Vollbildmodus und zur√ºck ist nun Aufgabe von PLTRenderFrame,
     dabei reagiert das Fenster darauf, wann es aktiviert oder deaktiviert wird. Dies erm√∂glicht auch mehreren
     Render-Fenstern gleichzeitig, noch korrekt zu funktionieren. Im Moment gibt es jedoch ein Problem mit der
     Farbtiefe, wodurch nach dem Umschalten des Modus evtl. fehlerhafte Grafik dargestellt wird
[SB] Der RendererHandler wurde √ºberarbeitet (z.B. Schalten in den Fullscreen-Mode)
[SB] Das unsichtbare Fenster, welches den Device-Kontext erstellt, ist nun vom Typ PLTRenderWindow und wurde au√üerdem
     in m_pRenderWindow umbenannt (um Verwechslungen mit dem Application-Main-Window zu vermeiden)
[SB] Neue Klassen f√ºr Render-Fenster eingebaut: PLTRenderWindow als Basis, davon abgeleitet PLTRenderFrame f√ºr
     eigenst√§ndige Fenster und PLTRenderChild f√ºr eingebettete Render-Fenster
[CO] Verwendung neuer Extension eingebaut: ARB_vertex_buffer_object -> Gibt es erst seit kurzem und daher muss man die
     neusten Treiber haben. Diese Extension wird engeblich von fast allen Karten unterst√ºtzt. Kann mit
     NV_vertex_array_range verglichen werden der die Vertex Daten direkt in der Hardware speichert was einen enormen
     Performance gewinn f√ºr Statische Dinge bringe. Jedoch muss man sich bei der neuen Extension nicht mehr um einen
     eigenen Vertex Manager bem√ºhen da es im gegensatz zu der alten Extension problemlos m√∂glich ist viele kleine Vertex
     Arrays zu haben! (das worauf ich schon seit l√§ngerem wartete!! :)
[CO] PLTRendererHandler -> Projective Texturing -> Nur Entities im Licht FOV werden neu gerendert
[CO] PLTRenderer: SetBlendMode() herausgenommen da normalerweise √ºber Material eingestellt, zudem ist die derzeitige
     implementation unzureichend... sp√§ter beim √úberarbeiten des Renderes kann man diese Funktion ja neu implementieren
     (derzeit aber nicht ben√∂tigt... und vorallem nicht in der Form :)
[CO] PLTExtensions: wglMakeContextCurrentARB & wglGetCurrentReadDCARB wieder herausgenommen da anscheinend nicht mehr
     unterst√ºtzt (problem des teilen von Daten zwischen verschiedenen Rendering context l√§sst sich auch mit
     wglShareLists() l√∂sen)
[CO] Neue Extensions wird unterst√ºtzt: GL_EXT_separate_specular_color -> f√ºr besseres Specular highlighting
[CO] Das Rendern in Texturen √ºber den PBuffer klappt nun! -> Im Modell Editor ist eine kleine Demo implementation welche
     zeigt wie man das Rendern in Texturen macht... l√§sst sich genauso verwenden wie das normale Rendern in Fenster :)
[CO] Der RendererHandler kann nun auch in eine Textur Rendern. (√ºber den Hardware PBuffer) Dazu muss man beim
     Initialisieren eines Renderer Handlers statt eines Window Handlers einfach NULL angeben, dann noch die Textur
     einstellen in welche gerendert werden soll et voila ;-)
[CO] Neue Extensions werden verwendet: GL_SGIS_generate_mipmap & WGL_ARB_pbuffer & WGL_ARB_pixel_format &
     WGL_ARB_render_texture, desweiteren PLTRendererExtensions √ºbersichtlicher gestaltet
[CO] PLTRenderer: InitOpenGL() & DeInitOpenGL() & ConfigOpenGL() in PLTRendererHandler verschoben
[SB] Get2DCoordinate() berechnet nun selbst die Projektion (ohne GLU), au√üerdem wird durch vorher gespeicherte Matrizen
     ein Auslesen aus OpenGL vermieden, was sowohl Geschwindigkeitsvorteile bringt als auch die Fehleranf√§lligkeit
     verringert (Die OpenGl-Matrizen k√∂nnen nicht immer gelesen werden und werden au√üerdem durch evtl. Rendering-Vorg√§nge
     beeinflu√üt)
[SB] PLTRenderer: Neue Funktion zum Anzeigen einer orientierten Bounding Box (OBB) eingebaut. Die anderen Methoden
     zeigen eine axis-aligned Bounding Box an, welche durch zwei Punkte bestimmt ist. Eine OBB ist jedoch durch zwei
     Punkte nicht eindeutig bestimmt, daher dient diese Methode zum Anzeigen einer OBB.
[CO] PLTRenderer: Der Renderer hat hat nun sein ein eigenes Haupt-Fenster welches quasi als 'Anker' dient. N√∂tig falls
     gerade z.B. eine OpenGL Textur angelegt werden soll und kein Fenster vorhanden ist! Jedoch ist dieses
     Renderer-Fenster 'unsichtbar', st√∂rt also nicht! :)
[CO] Wird ein Fenster geschlossen so werden nun alle Renderer Handler welche dieses verwendeten de-initialisiert... und beim
     Fenster-Modus umstellen mit dem neuen Fenster Handle wieder neu initialisiert :)  -> War auch ursache f√ºr einen
     l√§stigen Crash!! :)
[CO] PLTRendererHandler -> Jeder Renderer Handler hat nun eine Priorit√§t mit welcher man einfluss darauf nehmen kann vor
     welchen anderen Renderer Handlern dieser gerendert werden soll
[CO] PLTRendererHandler::GetSceneManager() liefert nun den standard scene manager zur√ºck falls kein scene manager
     gesetzt wurde
[CO] Der Rendering Contex wird nun bei der Renderer De-Initialisierung und nicht mehr beim beenden eines Renderer
     Handlers aufgel√∂st
[CO] PL::Renderer.Clear() Funktion nimmt nun Engine eigene Parameter an
[CO] Windows Struktur DEVMODE in Renderer zum Speichern der Bildschirmaufl√∂sungen durch eigenen Struktur namens
     PLTDisplayMode ersetzt.
[SB] PLTFont: Die Anzeige von Schrift ist nun mit in die √ºbrigen 2D Funktionen eingebaut und kann damit mit einer beliebigen
     virtuellen Aufl√∂sung arbeiten
[SB] PLTRenderer: Funktion zum Setzen des Blend Modes eingebaut, die m√∂glichen Einstellungen sind Alpha, Additive und Off
[CO] Baute Funktionen PL::Renderer.Get3DCoordinate() & PL::Renderer.Get2DCoordinate() ein
[SB] Baute die Funktionen Begin2DMode() und End2DMode() in den Renderer ein
[SB] √Ñnderungen im Fenster/Renderer-Code, es wird nun GetClientRect() verwendet, damit im Fenstermodus das Renderbild komplett
     zu sehen ist und nicht ein Teil von der Titelleiste verdeckt wird
